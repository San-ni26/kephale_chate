
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserInvitation
 * 
 */
export type UserInvitation = $Result.DefaultSelection<Prisma.$UserInvitationPayload>
/**
 * Model InvitationGuest
 * 
 */
export type InvitationGuest = $Result.DefaultSelection<Prisma.$InvitationGuestPayload>
/**
 * Model Follow
 * 
 */
export type Follow = $Result.DefaultSelection<Prisma.$FollowPayload>
/**
 * Model Organization
 * 
 */
export type Organization = $Result.DefaultSelection<Prisma.$OrganizationPayload>
/**
 * Model OrganizationMember
 * 
 */
export type OrganizationMember = $Result.DefaultSelection<Prisma.$OrganizationMemberPayload>
/**
 * Model Department
 * 
 */
export type Department = $Result.DefaultSelection<Prisma.$DepartmentPayload>
/**
 * Model DepartmentDocument
 * 
 */
export type DepartmentDocument = $Result.DefaultSelection<Prisma.$DepartmentDocumentPayload>
/**
 * Model DepartmentGoal
 * 
 */
export type DepartmentGoal = $Result.DefaultSelection<Prisma.$DepartmentGoalPayload>
/**
 * Model DepartmentMeeting
 * 
 */
export type DepartmentMeeting = $Result.DefaultSelection<Prisma.$DepartmentMeetingPayload>
/**
 * Model DepartmentPoll
 * 
 */
export type DepartmentPoll = $Result.DefaultSelection<Prisma.$DepartmentPollPayload>
/**
 * Model PollVote
 * 
 */
export type PollVote = $Result.DefaultSelection<Prisma.$PollVotePayload>
/**
 * Model TeamDecision
 * 
 */
export type TeamDecision = $Result.DefaultSelection<Prisma.$TeamDecisionPayload>
/**
 * Model DecisionVote
 * 
 */
export type DecisionVote = $Result.DefaultSelection<Prisma.$DecisionVotePayload>
/**
 * Model DepartmentMember
 * 
 */
export type DepartmentMember = $Result.DefaultSelection<Prisma.$DepartmentMemberPayload>
/**
 * Model Group
 * 
 */
export type Group = $Result.DefaultSelection<Prisma.$GroupPayload>
/**
 * Model GroupDocument
 * 
 */
export type GroupDocument = $Result.DefaultSelection<Prisma.$GroupDocumentPayload>
/**
 * Model GroupNote
 * 
 */
export type GroupNote = $Result.DefaultSelection<Prisma.$GroupNotePayload>
/**
 * Model GroupMember
 * 
 */
export type GroupMember = $Result.DefaultSelection<Prisma.$GroupMemberPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model Attachment
 * 
 */
export type Attachment = $Result.DefaultSelection<Prisma.$AttachmentPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Announcement
 * 
 */
export type Announcement = $Result.DefaultSelection<Prisma.$AnnouncementPayload>
/**
 * Model AnnouncementRead
 * 
 */
export type AnnouncementRead = $Result.DefaultSelection<Prisma.$AnnouncementReadPayload>
/**
 * Model OrganizationRequest
 * 
 */
export type OrganizationRequest = $Result.DefaultSelection<Prisma.$OrganizationRequestPayload>
/**
 * Model PendingSubscriptionPayment
 * 
 */
export type PendingSubscriptionPayment = $Result.DefaultSelection<Prisma.$PendingSubscriptionPaymentPayload>
/**
 * Model PaymentOrder
 * 
 */
export type PaymentOrder = $Result.DefaultSelection<Prisma.$PaymentOrderPayload>
/**
 * Model PaymentSetting
 * 
 */
export type PaymentSetting = $Result.DefaultSelection<Prisma.$PaymentSettingPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model EventInvitation
 * 
 */
export type EventInvitation = $Result.DefaultSelection<Prisma.$EventInvitationPayload>
/**
 * Model EventDepartmentBroadcast
 * 
 */
export type EventDepartmentBroadcast = $Result.DefaultSelection<Prisma.$EventDepartmentBroadcastPayload>
/**
 * Model InvitationRSVP
 * 
 */
export type InvitationRSVP = $Result.DefaultSelection<Prisma.$InvitationRSVPPayload>
/**
 * Model UserPage
 * 
 */
export type UserPage = $Result.DefaultSelection<Prisma.$UserPagePayload>
/**
 * Model Post
 * 
 */
export type Post = $Result.DefaultSelection<Prisma.$PostPayload>
/**
 * Model Like
 * 
 */
export type Like = $Result.DefaultSelection<Prisma.$LikePayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model PostRead
 * 
 */
export type PostRead = $Result.DefaultSelection<Prisma.$PostReadPayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model TaskMessage
 * 
 */
export type TaskMessage = $Result.DefaultSelection<Prisma.$TaskMessagePayload>
/**
 * Model TaskAttachment
 * 
 */
export type TaskAttachment = $Result.DefaultSelection<Prisma.$TaskAttachmentPayload>
/**
 * Model DepartmentMonthlyReport
 * 
 */
export type DepartmentMonthlyReport = $Result.DefaultSelection<Prisma.$DepartmentMonthlyReportPayload>
/**
 * Model PushSubscription
 * 
 */
export type PushSubscription = $Result.DefaultSelection<Prisma.$PushSubscriptionPayload>
/**
 * Model UserPersonalTask
 * 
 */
export type UserPersonalTask = $Result.DefaultSelection<Prisma.$UserPersonalTaskPayload>
/**
 * Model UserFinancialGoal
 * 
 */
export type UserFinancialGoal = $Result.DefaultSelection<Prisma.$UserFinancialGoalPayload>
/**
 * Model UserFinancialProfile
 * 
 */
export type UserFinancialProfile = $Result.DefaultSelection<Prisma.$UserFinancialProfilePayload>
/**
 * Model UserMonthlyStatement
 * 
 */
export type UserMonthlyStatement = $Result.DefaultSelection<Prisma.$UserMonthlyStatementPayload>
/**
 * Model UserFinancialEntry
 * 
 */
export type UserFinancialEntry = $Result.DefaultSelection<Prisma.$UserFinancialEntryPayload>
/**
 * Model UserMonthlyProgress
 * 
 */
export type UserMonthlyProgress = $Result.DefaultSelection<Prisma.$UserMonthlyProgressPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const InvitationStatus: {
  ACTIVE: 'ACTIVE',
  EXPIRED: 'EXPIRED',
  CANCELLED: 'CANCELLED'
};

export type InvitationStatus = (typeof InvitationStatus)[keyof typeof InvitationStatus]


export const InvitationType: {
  WEDDING: 'WEDDING',
  DINNER: 'DINNER',
  BIRTHDAY: 'BIRTHDAY',
  PARTY: 'PARTY',
  OTHER: 'OTHER'
};

export type InvitationType = (typeof InvitationType)[keyof typeof InvitationType]


export const DecisionVoteType: {
  FOR: 'FOR',
  AGAINST: 'AGAINST',
  ABSTAIN: 'ABSTAIN'
};

export type DecisionVoteType = (typeof DecisionVoteType)[keyof typeof DecisionVoteType]


export const NoteTextSize: {
  SMALL: 'SMALL',
  NORMAL: 'NORMAL',
  LARGE: 'LARGE'
};

export type NoteTextSize = (typeof NoteTextSize)[keyof typeof NoteTextSize]


export const UserRole: {
  USER: 'USER',
  ADMIN: 'ADMIN',
  SUPER_ADMIN: 'SUPER_ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const OrgRole: {
  OWNER: 'OWNER',
  ADMIN: 'ADMIN',
  MEMBER: 'MEMBER'
};

export type OrgRole = (typeof OrgRole)[keyof typeof OrgRole]


export const FileType: {
  IMAGE: 'IMAGE',
  PDF: 'PDF',
  WORD: 'WORD',
  AUDIO: 'AUDIO',
  OTHER: 'OTHER'
};

export type FileType = (typeof FileType)[keyof typeof FileType]


export const RequestStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  COMPLETED: 'COMPLETED'
};

export type RequestStatus = (typeof RequestStatus)[keyof typeof RequestStatus]


export const SubscriptionPlan: {
  FREE: 'FREE',
  BASIC: 'BASIC',
  PROFESSIONAL: 'PROFESSIONAL',
  ENTERPRISE: 'ENTERPRISE'
};

export type SubscriptionPlan = (typeof SubscriptionPlan)[keyof typeof SubscriptionPlan]


export const EventType: {
  PROFESSIONAL: 'PROFESSIONAL',
  DINNER: 'DINNER',
  MEETING: 'MEETING',
  PARTY: 'PARTY',
  CONFERENCE: 'CONFERENCE',
  WORKSHOP: 'WORKSHOP',
  OTHER: 'OTHER'
};

export type EventType = (typeof EventType)[keyof typeof EventType]


export const PaymentOrderStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type PaymentOrderStatus = (typeof PaymentOrderStatus)[keyof typeof PaymentOrderStatus]


export const PostType: {
  TWEET: 'TWEET',
  CONTENT: 'CONTENT'
};

export type PostType = (typeof PostType)[keyof typeof PostType]


export const TaskStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type TaskStatus = (typeof TaskStatus)[keyof typeof TaskStatus]


export const TaskPriority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type TaskPriority = (typeof TaskPriority)[keyof typeof TaskPriority]


export const PersonalTaskStatus: {
  TODO: 'TODO',
  IN_PROGRESS: 'IN_PROGRESS',
  DONE: 'DONE',
  CANCELLED: 'CANCELLED'
};

export type PersonalTaskStatus = (typeof PersonalTaskStatus)[keyof typeof PersonalTaskStatus]


export const PersonalTaskPriority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type PersonalTaskPriority = (typeof PersonalTaskPriority)[keyof typeof PersonalTaskPriority]


export const FinancialGoalType: {
  ANNUAL_SAVINGS: 'ANNUAL_SAVINGS',
  MATERIAL_PURCHASE: 'MATERIAL_PURCHASE'
};

export type FinancialGoalType = (typeof FinancialGoalType)[keyof typeof FinancialGoalType]


export const FinancialEntryType: {
  SALARY: 'SALARY',
  SUPPLEMENTARY_INCOME: 'SUPPLEMENTARY_INCOME',
  EXPENSE: 'EXPENSE'
};

export type FinancialEntryType = (typeof FinancialEntryType)[keyof typeof FinancialEntryType]

}

export type InvitationStatus = $Enums.InvitationStatus

export const InvitationStatus: typeof $Enums.InvitationStatus

export type InvitationType = $Enums.InvitationType

export const InvitationType: typeof $Enums.InvitationType

export type DecisionVoteType = $Enums.DecisionVoteType

export const DecisionVoteType: typeof $Enums.DecisionVoteType

export type NoteTextSize = $Enums.NoteTextSize

export const NoteTextSize: typeof $Enums.NoteTextSize

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type OrgRole = $Enums.OrgRole

export const OrgRole: typeof $Enums.OrgRole

export type FileType = $Enums.FileType

export const FileType: typeof $Enums.FileType

export type RequestStatus = $Enums.RequestStatus

export const RequestStatus: typeof $Enums.RequestStatus

export type SubscriptionPlan = $Enums.SubscriptionPlan

export const SubscriptionPlan: typeof $Enums.SubscriptionPlan

export type EventType = $Enums.EventType

export const EventType: typeof $Enums.EventType

export type PaymentOrderStatus = $Enums.PaymentOrderStatus

export const PaymentOrderStatus: typeof $Enums.PaymentOrderStatus

export type PostType = $Enums.PostType

export const PostType: typeof $Enums.PostType

export type TaskStatus = $Enums.TaskStatus

export const TaskStatus: typeof $Enums.TaskStatus

export type TaskPriority = $Enums.TaskPriority

export const TaskPriority: typeof $Enums.TaskPriority

export type PersonalTaskStatus = $Enums.PersonalTaskStatus

export const PersonalTaskStatus: typeof $Enums.PersonalTaskStatus

export type PersonalTaskPriority = $Enums.PersonalTaskPriority

export const PersonalTaskPriority: typeof $Enums.PersonalTaskPriority

export type FinancialGoalType = $Enums.FinancialGoalType

export const FinancialGoalType: typeof $Enums.FinancialGoalType

export type FinancialEntryType = $Enums.FinancialEntryType

export const FinancialEntryType: typeof $Enums.FinancialEntryType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userInvitation`: Exposes CRUD operations for the **UserInvitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserInvitations
    * const userInvitations = await prisma.userInvitation.findMany()
    * ```
    */
  get userInvitation(): Prisma.UserInvitationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invitationGuest`: Exposes CRUD operations for the **InvitationGuest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvitationGuests
    * const invitationGuests = await prisma.invitationGuest.findMany()
    * ```
    */
  get invitationGuest(): Prisma.InvitationGuestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.follow`: Exposes CRUD operations for the **Follow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Follows
    * const follows = await prisma.follow.findMany()
    * ```
    */
  get follow(): Prisma.FollowDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): Prisma.OrganizationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.organizationMember`: Exposes CRUD operations for the **OrganizationMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrganizationMembers
    * const organizationMembers = await prisma.organizationMember.findMany()
    * ```
    */
  get organizationMember(): Prisma.OrganizationMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.department`: Exposes CRUD operations for the **Department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.DepartmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.departmentDocument`: Exposes CRUD operations for the **DepartmentDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DepartmentDocuments
    * const departmentDocuments = await prisma.departmentDocument.findMany()
    * ```
    */
  get departmentDocument(): Prisma.DepartmentDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.departmentGoal`: Exposes CRUD operations for the **DepartmentGoal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DepartmentGoals
    * const departmentGoals = await prisma.departmentGoal.findMany()
    * ```
    */
  get departmentGoal(): Prisma.DepartmentGoalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.departmentMeeting`: Exposes CRUD operations for the **DepartmentMeeting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DepartmentMeetings
    * const departmentMeetings = await prisma.departmentMeeting.findMany()
    * ```
    */
  get departmentMeeting(): Prisma.DepartmentMeetingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.departmentPoll`: Exposes CRUD operations for the **DepartmentPoll** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DepartmentPolls
    * const departmentPolls = await prisma.departmentPoll.findMany()
    * ```
    */
  get departmentPoll(): Prisma.DepartmentPollDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pollVote`: Exposes CRUD operations for the **PollVote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PollVotes
    * const pollVotes = await prisma.pollVote.findMany()
    * ```
    */
  get pollVote(): Prisma.PollVoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teamDecision`: Exposes CRUD operations for the **TeamDecision** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamDecisions
    * const teamDecisions = await prisma.teamDecision.findMany()
    * ```
    */
  get teamDecision(): Prisma.TeamDecisionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.decisionVote`: Exposes CRUD operations for the **DecisionVote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DecisionVotes
    * const decisionVotes = await prisma.decisionVote.findMany()
    * ```
    */
  get decisionVote(): Prisma.DecisionVoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.departmentMember`: Exposes CRUD operations for the **DepartmentMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DepartmentMembers
    * const departmentMembers = await prisma.departmentMember.findMany()
    * ```
    */
  get departmentMember(): Prisma.DepartmentMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.group`: Exposes CRUD operations for the **Group** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Groups
    * const groups = await prisma.group.findMany()
    * ```
    */
  get group(): Prisma.GroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.groupDocument`: Exposes CRUD operations for the **GroupDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GroupDocuments
    * const groupDocuments = await prisma.groupDocument.findMany()
    * ```
    */
  get groupDocument(): Prisma.GroupDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.groupNote`: Exposes CRUD operations for the **GroupNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GroupNotes
    * const groupNotes = await prisma.groupNote.findMany()
    * ```
    */
  get groupNote(): Prisma.GroupNoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.groupMember`: Exposes CRUD operations for the **GroupMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GroupMembers
    * const groupMembers = await prisma.groupMember.findMany()
    * ```
    */
  get groupMember(): Prisma.GroupMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attachment`: Exposes CRUD operations for the **Attachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attachments
    * const attachments = await prisma.attachment.findMany()
    * ```
    */
  get attachment(): Prisma.AttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.announcement`: Exposes CRUD operations for the **Announcement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Announcements
    * const announcements = await prisma.announcement.findMany()
    * ```
    */
  get announcement(): Prisma.AnnouncementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.announcementRead`: Exposes CRUD operations for the **AnnouncementRead** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnnouncementReads
    * const announcementReads = await prisma.announcementRead.findMany()
    * ```
    */
  get announcementRead(): Prisma.AnnouncementReadDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.organizationRequest`: Exposes CRUD operations for the **OrganizationRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrganizationRequests
    * const organizationRequests = await prisma.organizationRequest.findMany()
    * ```
    */
  get organizationRequest(): Prisma.OrganizationRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pendingSubscriptionPayment`: Exposes CRUD operations for the **PendingSubscriptionPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PendingSubscriptionPayments
    * const pendingSubscriptionPayments = await prisma.pendingSubscriptionPayment.findMany()
    * ```
    */
  get pendingSubscriptionPayment(): Prisma.PendingSubscriptionPaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentOrder`: Exposes CRUD operations for the **PaymentOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentOrders
    * const paymentOrders = await prisma.paymentOrder.findMany()
    * ```
    */
  get paymentOrder(): Prisma.PaymentOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentSetting`: Exposes CRUD operations for the **PaymentSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentSettings
    * const paymentSettings = await prisma.paymentSetting.findMany()
    * ```
    */
  get paymentSetting(): Prisma.PaymentSettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eventInvitation`: Exposes CRUD operations for the **EventInvitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventInvitations
    * const eventInvitations = await prisma.eventInvitation.findMany()
    * ```
    */
  get eventInvitation(): Prisma.EventInvitationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eventDepartmentBroadcast`: Exposes CRUD operations for the **EventDepartmentBroadcast** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventDepartmentBroadcasts
    * const eventDepartmentBroadcasts = await prisma.eventDepartmentBroadcast.findMany()
    * ```
    */
  get eventDepartmentBroadcast(): Prisma.EventDepartmentBroadcastDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invitationRSVP`: Exposes CRUD operations for the **InvitationRSVP** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvitationRSVPS
    * const invitationRSVPS = await prisma.invitationRSVP.findMany()
    * ```
    */
  get invitationRSVP(): Prisma.InvitationRSVPDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPage`: Exposes CRUD operations for the **UserPage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPages
    * const userPages = await prisma.userPage.findMany()
    * ```
    */
  get userPage(): Prisma.UserPageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.like`: Exposes CRUD operations for the **Like** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Likes
    * const likes = await prisma.like.findMany()
    * ```
    */
  get like(): Prisma.LikeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.postRead`: Exposes CRUD operations for the **PostRead** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostReads
    * const postReads = await prisma.postRead.findMany()
    * ```
    */
  get postRead(): Prisma.PostReadDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskMessage`: Exposes CRUD operations for the **TaskMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskMessages
    * const taskMessages = await prisma.taskMessage.findMany()
    * ```
    */
  get taskMessage(): Prisma.TaskMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskAttachment`: Exposes CRUD operations for the **TaskAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskAttachments
    * const taskAttachments = await prisma.taskAttachment.findMany()
    * ```
    */
  get taskAttachment(): Prisma.TaskAttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.departmentMonthlyReport`: Exposes CRUD operations for the **DepartmentMonthlyReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DepartmentMonthlyReports
    * const departmentMonthlyReports = await prisma.departmentMonthlyReport.findMany()
    * ```
    */
  get departmentMonthlyReport(): Prisma.DepartmentMonthlyReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pushSubscription`: Exposes CRUD operations for the **PushSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PushSubscriptions
    * const pushSubscriptions = await prisma.pushSubscription.findMany()
    * ```
    */
  get pushSubscription(): Prisma.PushSubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPersonalTask`: Exposes CRUD operations for the **UserPersonalTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPersonalTasks
    * const userPersonalTasks = await prisma.userPersonalTask.findMany()
    * ```
    */
  get userPersonalTask(): Prisma.UserPersonalTaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userFinancialGoal`: Exposes CRUD operations for the **UserFinancialGoal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserFinancialGoals
    * const userFinancialGoals = await prisma.userFinancialGoal.findMany()
    * ```
    */
  get userFinancialGoal(): Prisma.UserFinancialGoalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userFinancialProfile`: Exposes CRUD operations for the **UserFinancialProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserFinancialProfiles
    * const userFinancialProfiles = await prisma.userFinancialProfile.findMany()
    * ```
    */
  get userFinancialProfile(): Prisma.UserFinancialProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userMonthlyStatement`: Exposes CRUD operations for the **UserMonthlyStatement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserMonthlyStatements
    * const userMonthlyStatements = await prisma.userMonthlyStatement.findMany()
    * ```
    */
  get userMonthlyStatement(): Prisma.UserMonthlyStatementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userFinancialEntry`: Exposes CRUD operations for the **UserFinancialEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserFinancialEntries
    * const userFinancialEntries = await prisma.userFinancialEntry.findMany()
    * ```
    */
  get userFinancialEntry(): Prisma.UserFinancialEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userMonthlyProgress`: Exposes CRUD operations for the **UserMonthlyProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserMonthlyProgresses
    * const userMonthlyProgresses = await prisma.userMonthlyProgress.findMany()
    * ```
    */
  get userMonthlyProgress(): Prisma.UserMonthlyProgressDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.3.0
   * Query Engine version: 9d6ad21cbbceab97458517b147a6a09ff43aa735
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    UserInvitation: 'UserInvitation',
    InvitationGuest: 'InvitationGuest',
    Follow: 'Follow',
    Organization: 'Organization',
    OrganizationMember: 'OrganizationMember',
    Department: 'Department',
    DepartmentDocument: 'DepartmentDocument',
    DepartmentGoal: 'DepartmentGoal',
    DepartmentMeeting: 'DepartmentMeeting',
    DepartmentPoll: 'DepartmentPoll',
    PollVote: 'PollVote',
    TeamDecision: 'TeamDecision',
    DecisionVote: 'DecisionVote',
    DepartmentMember: 'DepartmentMember',
    Group: 'Group',
    GroupDocument: 'GroupDocument',
    GroupNote: 'GroupNote',
    GroupMember: 'GroupMember',
    Message: 'Message',
    Attachment: 'Attachment',
    Notification: 'Notification',
    Announcement: 'Announcement',
    AnnouncementRead: 'AnnouncementRead',
    OrganizationRequest: 'OrganizationRequest',
    PendingSubscriptionPayment: 'PendingSubscriptionPayment',
    PaymentOrder: 'PaymentOrder',
    PaymentSetting: 'PaymentSetting',
    Subscription: 'Subscription',
    EventInvitation: 'EventInvitation',
    EventDepartmentBroadcast: 'EventDepartmentBroadcast',
    InvitationRSVP: 'InvitationRSVP',
    UserPage: 'UserPage',
    Post: 'Post',
    Like: 'Like',
    Comment: 'Comment',
    PostRead: 'PostRead',
    Task: 'Task',
    TaskMessage: 'TaskMessage',
    TaskAttachment: 'TaskAttachment',
    DepartmentMonthlyReport: 'DepartmentMonthlyReport',
    PushSubscription: 'PushSubscription',
    UserPersonalTask: 'UserPersonalTask',
    UserFinancialGoal: 'UserFinancialGoal',
    UserFinancialProfile: 'UserFinancialProfile',
    UserMonthlyStatement: 'UserMonthlyStatement',
    UserFinancialEntry: 'UserFinancialEntry',
    UserMonthlyProgress: 'UserMonthlyProgress'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "userInvitation" | "invitationGuest" | "follow" | "organization" | "organizationMember" | "department" | "departmentDocument" | "departmentGoal" | "departmentMeeting" | "departmentPoll" | "pollVote" | "teamDecision" | "decisionVote" | "departmentMember" | "group" | "groupDocument" | "groupNote" | "groupMember" | "message" | "attachment" | "notification" | "announcement" | "announcementRead" | "organizationRequest" | "pendingSubscriptionPayment" | "paymentOrder" | "paymentSetting" | "subscription" | "eventInvitation" | "eventDepartmentBroadcast" | "invitationRSVP" | "userPage" | "post" | "like" | "comment" | "postRead" | "task" | "taskMessage" | "taskAttachment" | "departmentMonthlyReport" | "pushSubscription" | "userPersonalTask" | "userFinancialGoal" | "userFinancialProfile" | "userMonthlyStatement" | "userFinancialEntry" | "userMonthlyProgress"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserInvitation: {
        payload: Prisma.$UserInvitationPayload<ExtArgs>
        fields: Prisma.UserInvitationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserInvitationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInvitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserInvitationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInvitationPayload>
          }
          findFirst: {
            args: Prisma.UserInvitationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInvitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserInvitationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInvitationPayload>
          }
          findMany: {
            args: Prisma.UserInvitationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInvitationPayload>[]
          }
          create: {
            args: Prisma.UserInvitationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInvitationPayload>
          }
          createMany: {
            args: Prisma.UserInvitationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserInvitationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInvitationPayload>[]
          }
          delete: {
            args: Prisma.UserInvitationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInvitationPayload>
          }
          update: {
            args: Prisma.UserInvitationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInvitationPayload>
          }
          deleteMany: {
            args: Prisma.UserInvitationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserInvitationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserInvitationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInvitationPayload>[]
          }
          upsert: {
            args: Prisma.UserInvitationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInvitationPayload>
          }
          aggregate: {
            args: Prisma.UserInvitationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserInvitation>
          }
          groupBy: {
            args: Prisma.UserInvitationGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserInvitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserInvitationCountArgs<ExtArgs>
            result: $Utils.Optional<UserInvitationCountAggregateOutputType> | number
          }
        }
      }
      InvitationGuest: {
        payload: Prisma.$InvitationGuestPayload<ExtArgs>
        fields: Prisma.InvitationGuestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvitationGuestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationGuestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvitationGuestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationGuestPayload>
          }
          findFirst: {
            args: Prisma.InvitationGuestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationGuestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvitationGuestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationGuestPayload>
          }
          findMany: {
            args: Prisma.InvitationGuestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationGuestPayload>[]
          }
          create: {
            args: Prisma.InvitationGuestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationGuestPayload>
          }
          createMany: {
            args: Prisma.InvitationGuestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvitationGuestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationGuestPayload>[]
          }
          delete: {
            args: Prisma.InvitationGuestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationGuestPayload>
          }
          update: {
            args: Prisma.InvitationGuestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationGuestPayload>
          }
          deleteMany: {
            args: Prisma.InvitationGuestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvitationGuestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvitationGuestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationGuestPayload>[]
          }
          upsert: {
            args: Prisma.InvitationGuestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationGuestPayload>
          }
          aggregate: {
            args: Prisma.InvitationGuestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvitationGuest>
          }
          groupBy: {
            args: Prisma.InvitationGuestGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvitationGuestGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvitationGuestCountArgs<ExtArgs>
            result: $Utils.Optional<InvitationGuestCountAggregateOutputType> | number
          }
        }
      }
      Follow: {
        payload: Prisma.$FollowPayload<ExtArgs>
        fields: Prisma.FollowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FollowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FollowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          findFirst: {
            args: Prisma.FollowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FollowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          findMany: {
            args: Prisma.FollowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>[]
          }
          create: {
            args: Prisma.FollowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          createMany: {
            args: Prisma.FollowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FollowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>[]
          }
          delete: {
            args: Prisma.FollowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          update: {
            args: Prisma.FollowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          deleteMany: {
            args: Prisma.FollowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FollowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FollowUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>[]
          }
          upsert: {
            args: Prisma.FollowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          aggregate: {
            args: Prisma.FollowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFollow>
          }
          groupBy: {
            args: Prisma.FollowGroupByArgs<ExtArgs>
            result: $Utils.Optional<FollowGroupByOutputType>[]
          }
          count: {
            args: Prisma.FollowCountArgs<ExtArgs>
            result: $Utils.Optional<FollowCountAggregateOutputType> | number
          }
        }
      }
      Organization: {
        payload: Prisma.$OrganizationPayload<ExtArgs>
        fields: Prisma.OrganizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findFirst: {
            args: Prisma.OrganizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findMany: {
            args: Prisma.OrganizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          create: {
            args: Prisma.OrganizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          createMany: {
            args: Prisma.OrganizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          delete: {
            args: Prisma.OrganizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          update: {
            args: Prisma.OrganizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrganizationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          upsert: {
            args: Prisma.OrganizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganization>
          }
          groupBy: {
            args: Prisma.OrganizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationCountAggregateOutputType> | number
          }
        }
      }
      OrganizationMember: {
        payload: Prisma.$OrganizationMemberPayload<ExtArgs>
        fields: Prisma.OrganizationMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
          }
          findFirst: {
            args: Prisma.OrganizationMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
          }
          findMany: {
            args: Prisma.OrganizationMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>[]
          }
          create: {
            args: Prisma.OrganizationMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
          }
          createMany: {
            args: Prisma.OrganizationMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>[]
          }
          delete: {
            args: Prisma.OrganizationMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
          }
          update: {
            args: Prisma.OrganizationMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrganizationMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>[]
          }
          upsert: {
            args: Prisma.OrganizationMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
          }
          aggregate: {
            args: Prisma.OrganizationMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganizationMember>
          }
          groupBy: {
            args: Prisma.OrganizationMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationMemberCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationMemberCountAggregateOutputType> | number
          }
        }
      }
      Department: {
        payload: Prisma.$DepartmentPayload<ExtArgs>
        fields: Prisma.DepartmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findFirst: {
            args: Prisma.DepartmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findMany: {
            args: Prisma.DepartmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          create: {
            args: Prisma.DepartmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          createMany: {
            args: Prisma.DepartmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepartmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          delete: {
            args: Prisma.DepartmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          update: {
            args: Prisma.DepartmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DepartmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          upsert: {
            args: Prisma.DepartmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          aggregate: {
            args: Prisma.DepartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartment>
          }
          groupBy: {
            args: Prisma.DepartmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentCountAggregateOutputType> | number
          }
        }
      }
      DepartmentDocument: {
        payload: Prisma.$DepartmentDocumentPayload<ExtArgs>
        fields: Prisma.DepartmentDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentDocumentPayload>
          }
          findFirst: {
            args: Prisma.DepartmentDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentDocumentPayload>
          }
          findMany: {
            args: Prisma.DepartmentDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentDocumentPayload>[]
          }
          create: {
            args: Prisma.DepartmentDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentDocumentPayload>
          }
          createMany: {
            args: Prisma.DepartmentDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepartmentDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentDocumentPayload>[]
          }
          delete: {
            args: Prisma.DepartmentDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentDocumentPayload>
          }
          update: {
            args: Prisma.DepartmentDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentDocumentPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DepartmentDocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentDocumentPayload>[]
          }
          upsert: {
            args: Prisma.DepartmentDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentDocumentPayload>
          }
          aggregate: {
            args: Prisma.DepartmentDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartmentDocument>
          }
          groupBy: {
            args: Prisma.DepartmentDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentDocumentCountAggregateOutputType> | number
          }
        }
      }
      DepartmentGoal: {
        payload: Prisma.$DepartmentGoalPayload<ExtArgs>
        fields: Prisma.DepartmentGoalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentGoalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentGoalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentGoalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentGoalPayload>
          }
          findFirst: {
            args: Prisma.DepartmentGoalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentGoalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentGoalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentGoalPayload>
          }
          findMany: {
            args: Prisma.DepartmentGoalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentGoalPayload>[]
          }
          create: {
            args: Prisma.DepartmentGoalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentGoalPayload>
          }
          createMany: {
            args: Prisma.DepartmentGoalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepartmentGoalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentGoalPayload>[]
          }
          delete: {
            args: Prisma.DepartmentGoalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentGoalPayload>
          }
          update: {
            args: Prisma.DepartmentGoalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentGoalPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentGoalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentGoalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DepartmentGoalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentGoalPayload>[]
          }
          upsert: {
            args: Prisma.DepartmentGoalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentGoalPayload>
          }
          aggregate: {
            args: Prisma.DepartmentGoalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartmentGoal>
          }
          groupBy: {
            args: Prisma.DepartmentGoalGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentGoalGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentGoalCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentGoalCountAggregateOutputType> | number
          }
        }
      }
      DepartmentMeeting: {
        payload: Prisma.$DepartmentMeetingPayload<ExtArgs>
        fields: Prisma.DepartmentMeetingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentMeetingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentMeetingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentMeetingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentMeetingPayload>
          }
          findFirst: {
            args: Prisma.DepartmentMeetingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentMeetingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentMeetingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentMeetingPayload>
          }
          findMany: {
            args: Prisma.DepartmentMeetingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentMeetingPayload>[]
          }
          create: {
            args: Prisma.DepartmentMeetingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentMeetingPayload>
          }
          createMany: {
            args: Prisma.DepartmentMeetingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepartmentMeetingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentMeetingPayload>[]
          }
          delete: {
            args: Prisma.DepartmentMeetingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentMeetingPayload>
          }
          update: {
            args: Prisma.DepartmentMeetingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentMeetingPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentMeetingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentMeetingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DepartmentMeetingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentMeetingPayload>[]
          }
          upsert: {
            args: Prisma.DepartmentMeetingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentMeetingPayload>
          }
          aggregate: {
            args: Prisma.DepartmentMeetingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartmentMeeting>
          }
          groupBy: {
            args: Prisma.DepartmentMeetingGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentMeetingGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentMeetingCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentMeetingCountAggregateOutputType> | number
          }
        }
      }
      DepartmentPoll: {
        payload: Prisma.$DepartmentPollPayload<ExtArgs>
        fields: Prisma.DepartmentPollFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentPollFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPollPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentPollFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPollPayload>
          }
          findFirst: {
            args: Prisma.DepartmentPollFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPollPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentPollFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPollPayload>
          }
          findMany: {
            args: Prisma.DepartmentPollFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPollPayload>[]
          }
          create: {
            args: Prisma.DepartmentPollCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPollPayload>
          }
          createMany: {
            args: Prisma.DepartmentPollCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepartmentPollCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPollPayload>[]
          }
          delete: {
            args: Prisma.DepartmentPollDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPollPayload>
          }
          update: {
            args: Prisma.DepartmentPollUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPollPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentPollDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentPollUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DepartmentPollUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPollPayload>[]
          }
          upsert: {
            args: Prisma.DepartmentPollUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPollPayload>
          }
          aggregate: {
            args: Prisma.DepartmentPollAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartmentPoll>
          }
          groupBy: {
            args: Prisma.DepartmentPollGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentPollGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentPollCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentPollCountAggregateOutputType> | number
          }
        }
      }
      PollVote: {
        payload: Prisma.$PollVotePayload<ExtArgs>
        fields: Prisma.PollVoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PollVoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollVotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PollVoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollVotePayload>
          }
          findFirst: {
            args: Prisma.PollVoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollVotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PollVoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollVotePayload>
          }
          findMany: {
            args: Prisma.PollVoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollVotePayload>[]
          }
          create: {
            args: Prisma.PollVoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollVotePayload>
          }
          createMany: {
            args: Prisma.PollVoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PollVoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollVotePayload>[]
          }
          delete: {
            args: Prisma.PollVoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollVotePayload>
          }
          update: {
            args: Prisma.PollVoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollVotePayload>
          }
          deleteMany: {
            args: Prisma.PollVoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PollVoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PollVoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollVotePayload>[]
          }
          upsert: {
            args: Prisma.PollVoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollVotePayload>
          }
          aggregate: {
            args: Prisma.PollVoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePollVote>
          }
          groupBy: {
            args: Prisma.PollVoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<PollVoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.PollVoteCountArgs<ExtArgs>
            result: $Utils.Optional<PollVoteCountAggregateOutputType> | number
          }
        }
      }
      TeamDecision: {
        payload: Prisma.$TeamDecisionPayload<ExtArgs>
        fields: Prisma.TeamDecisionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamDecisionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamDecisionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamDecisionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamDecisionPayload>
          }
          findFirst: {
            args: Prisma.TeamDecisionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamDecisionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamDecisionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamDecisionPayload>
          }
          findMany: {
            args: Prisma.TeamDecisionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamDecisionPayload>[]
          }
          create: {
            args: Prisma.TeamDecisionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamDecisionPayload>
          }
          createMany: {
            args: Prisma.TeamDecisionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamDecisionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamDecisionPayload>[]
          }
          delete: {
            args: Prisma.TeamDecisionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamDecisionPayload>
          }
          update: {
            args: Prisma.TeamDecisionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamDecisionPayload>
          }
          deleteMany: {
            args: Prisma.TeamDecisionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamDecisionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamDecisionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamDecisionPayload>[]
          }
          upsert: {
            args: Prisma.TeamDecisionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamDecisionPayload>
          }
          aggregate: {
            args: Prisma.TeamDecisionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamDecision>
          }
          groupBy: {
            args: Prisma.TeamDecisionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamDecisionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamDecisionCountArgs<ExtArgs>
            result: $Utils.Optional<TeamDecisionCountAggregateOutputType> | number
          }
        }
      }
      DecisionVote: {
        payload: Prisma.$DecisionVotePayload<ExtArgs>
        fields: Prisma.DecisionVoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DecisionVoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionVotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DecisionVoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionVotePayload>
          }
          findFirst: {
            args: Prisma.DecisionVoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionVotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DecisionVoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionVotePayload>
          }
          findMany: {
            args: Prisma.DecisionVoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionVotePayload>[]
          }
          create: {
            args: Prisma.DecisionVoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionVotePayload>
          }
          createMany: {
            args: Prisma.DecisionVoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DecisionVoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionVotePayload>[]
          }
          delete: {
            args: Prisma.DecisionVoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionVotePayload>
          }
          update: {
            args: Prisma.DecisionVoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionVotePayload>
          }
          deleteMany: {
            args: Prisma.DecisionVoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DecisionVoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DecisionVoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionVotePayload>[]
          }
          upsert: {
            args: Prisma.DecisionVoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionVotePayload>
          }
          aggregate: {
            args: Prisma.DecisionVoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDecisionVote>
          }
          groupBy: {
            args: Prisma.DecisionVoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<DecisionVoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.DecisionVoteCountArgs<ExtArgs>
            result: $Utils.Optional<DecisionVoteCountAggregateOutputType> | number
          }
        }
      }
      DepartmentMember: {
        payload: Prisma.$DepartmentMemberPayload<ExtArgs>
        fields: Prisma.DepartmentMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentMemberPayload>
          }
          findFirst: {
            args: Prisma.DepartmentMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentMemberPayload>
          }
          findMany: {
            args: Prisma.DepartmentMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentMemberPayload>[]
          }
          create: {
            args: Prisma.DepartmentMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentMemberPayload>
          }
          createMany: {
            args: Prisma.DepartmentMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepartmentMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentMemberPayload>[]
          }
          delete: {
            args: Prisma.DepartmentMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentMemberPayload>
          }
          update: {
            args: Prisma.DepartmentMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentMemberPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DepartmentMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentMemberPayload>[]
          }
          upsert: {
            args: Prisma.DepartmentMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentMemberPayload>
          }
          aggregate: {
            args: Prisma.DepartmentMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartmentMember>
          }
          groupBy: {
            args: Prisma.DepartmentMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentMemberCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentMemberCountAggregateOutputType> | number
          }
        }
      }
      Group: {
        payload: Prisma.$GroupPayload<ExtArgs>
        fields: Prisma.GroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          findFirst: {
            args: Prisma.GroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          findMany: {
            args: Prisma.GroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          create: {
            args: Prisma.GroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          createMany: {
            args: Prisma.GroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          delete: {
            args: Prisma.GroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          update: {
            args: Prisma.GroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          deleteMany: {
            args: Prisma.GroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          upsert: {
            args: Prisma.GroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          aggregate: {
            args: Prisma.GroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroup>
          }
          groupBy: {
            args: Prisma.GroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupCountArgs<ExtArgs>
            result: $Utils.Optional<GroupCountAggregateOutputType> | number
          }
        }
      }
      GroupDocument: {
        payload: Prisma.$GroupDocumentPayload<ExtArgs>
        fields: Prisma.GroupDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupDocumentPayload>
          }
          findFirst: {
            args: Prisma.GroupDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupDocumentPayload>
          }
          findMany: {
            args: Prisma.GroupDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupDocumentPayload>[]
          }
          create: {
            args: Prisma.GroupDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupDocumentPayload>
          }
          createMany: {
            args: Prisma.GroupDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupDocumentPayload>[]
          }
          delete: {
            args: Prisma.GroupDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupDocumentPayload>
          }
          update: {
            args: Prisma.GroupDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupDocumentPayload>
          }
          deleteMany: {
            args: Prisma.GroupDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GroupDocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupDocumentPayload>[]
          }
          upsert: {
            args: Prisma.GroupDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupDocumentPayload>
          }
          aggregate: {
            args: Prisma.GroupDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroupDocument>
          }
          groupBy: {
            args: Prisma.GroupDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<GroupDocumentCountAggregateOutputType> | number
          }
        }
      }
      GroupNote: {
        payload: Prisma.$GroupNotePayload<ExtArgs>
        fields: Prisma.GroupNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupNoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupNoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupNotePayload>
          }
          findFirst: {
            args: Prisma.GroupNoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupNoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupNotePayload>
          }
          findMany: {
            args: Prisma.GroupNoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupNotePayload>[]
          }
          create: {
            args: Prisma.GroupNoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupNotePayload>
          }
          createMany: {
            args: Prisma.GroupNoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupNoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupNotePayload>[]
          }
          delete: {
            args: Prisma.GroupNoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupNotePayload>
          }
          update: {
            args: Prisma.GroupNoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupNotePayload>
          }
          deleteMany: {
            args: Prisma.GroupNoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupNoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GroupNoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupNotePayload>[]
          }
          upsert: {
            args: Prisma.GroupNoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupNotePayload>
          }
          aggregate: {
            args: Prisma.GroupNoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroupNote>
          }
          groupBy: {
            args: Prisma.GroupNoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupNoteCountArgs<ExtArgs>
            result: $Utils.Optional<GroupNoteCountAggregateOutputType> | number
          }
        }
      }
      GroupMember: {
        payload: Prisma.$GroupMemberPayload<ExtArgs>
        fields: Prisma.GroupMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          findFirst: {
            args: Prisma.GroupMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          findMany: {
            args: Prisma.GroupMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>[]
          }
          create: {
            args: Prisma.GroupMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          createMany: {
            args: Prisma.GroupMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>[]
          }
          delete: {
            args: Prisma.GroupMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          update: {
            args: Prisma.GroupMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          deleteMany: {
            args: Prisma.GroupMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GroupMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>[]
          }
          upsert: {
            args: Prisma.GroupMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          aggregate: {
            args: Prisma.GroupMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroupMember>
          }
          groupBy: {
            args: Prisma.GroupMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupMemberCountArgs<ExtArgs>
            result: $Utils.Optional<GroupMemberCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      Attachment: {
        payload: Prisma.$AttachmentPayload<ExtArgs>
        fields: Prisma.AttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          findFirst: {
            args: Prisma.AttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          findMany: {
            args: Prisma.AttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
          }
          create: {
            args: Prisma.AttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          createMany: {
            args: Prisma.AttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
          }
          delete: {
            args: Prisma.AttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          update: {
            args: Prisma.AttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          deleteMany: {
            args: Prisma.AttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
          }
          upsert: {
            args: Prisma.AttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          aggregate: {
            args: Prisma.AttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttachment>
          }
          groupBy: {
            args: Prisma.AttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<AttachmentCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Announcement: {
        payload: Prisma.$AnnouncementPayload<ExtArgs>
        fields: Prisma.AnnouncementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnnouncementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnnouncementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          findFirst: {
            args: Prisma.AnnouncementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnnouncementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          findMany: {
            args: Prisma.AnnouncementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
          }
          create: {
            args: Prisma.AnnouncementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          createMany: {
            args: Prisma.AnnouncementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnnouncementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
          }
          delete: {
            args: Prisma.AnnouncementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          update: {
            args: Prisma.AnnouncementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          deleteMany: {
            args: Prisma.AnnouncementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnnouncementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnnouncementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
          }
          upsert: {
            args: Prisma.AnnouncementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          aggregate: {
            args: Prisma.AnnouncementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnnouncement>
          }
          groupBy: {
            args: Prisma.AnnouncementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnnouncementCountArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementCountAggregateOutputType> | number
          }
        }
      }
      AnnouncementRead: {
        payload: Prisma.$AnnouncementReadPayload<ExtArgs>
        fields: Prisma.AnnouncementReadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnnouncementReadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementReadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnnouncementReadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementReadPayload>
          }
          findFirst: {
            args: Prisma.AnnouncementReadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementReadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnnouncementReadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementReadPayload>
          }
          findMany: {
            args: Prisma.AnnouncementReadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementReadPayload>[]
          }
          create: {
            args: Prisma.AnnouncementReadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementReadPayload>
          }
          createMany: {
            args: Prisma.AnnouncementReadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnnouncementReadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementReadPayload>[]
          }
          delete: {
            args: Prisma.AnnouncementReadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementReadPayload>
          }
          update: {
            args: Prisma.AnnouncementReadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementReadPayload>
          }
          deleteMany: {
            args: Prisma.AnnouncementReadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnnouncementReadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnnouncementReadUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementReadPayload>[]
          }
          upsert: {
            args: Prisma.AnnouncementReadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementReadPayload>
          }
          aggregate: {
            args: Prisma.AnnouncementReadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnnouncementRead>
          }
          groupBy: {
            args: Prisma.AnnouncementReadGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementReadGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnnouncementReadCountArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementReadCountAggregateOutputType> | number
          }
        }
      }
      OrganizationRequest: {
        payload: Prisma.$OrganizationRequestPayload<ExtArgs>
        fields: Prisma.OrganizationRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationRequestPayload>
          }
          findFirst: {
            args: Prisma.OrganizationRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationRequestPayload>
          }
          findMany: {
            args: Prisma.OrganizationRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationRequestPayload>[]
          }
          create: {
            args: Prisma.OrganizationRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationRequestPayload>
          }
          createMany: {
            args: Prisma.OrganizationRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationRequestPayload>[]
          }
          delete: {
            args: Prisma.OrganizationRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationRequestPayload>
          }
          update: {
            args: Prisma.OrganizationRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationRequestPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrganizationRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationRequestPayload>[]
          }
          upsert: {
            args: Prisma.OrganizationRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationRequestPayload>
          }
          aggregate: {
            args: Prisma.OrganizationRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganizationRequest>
          }
          groupBy: {
            args: Prisma.OrganizationRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationRequestCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationRequestCountAggregateOutputType> | number
          }
        }
      }
      PendingSubscriptionPayment: {
        payload: Prisma.$PendingSubscriptionPaymentPayload<ExtArgs>
        fields: Prisma.PendingSubscriptionPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PendingSubscriptionPaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingSubscriptionPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PendingSubscriptionPaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingSubscriptionPaymentPayload>
          }
          findFirst: {
            args: Prisma.PendingSubscriptionPaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingSubscriptionPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PendingSubscriptionPaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingSubscriptionPaymentPayload>
          }
          findMany: {
            args: Prisma.PendingSubscriptionPaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingSubscriptionPaymentPayload>[]
          }
          create: {
            args: Prisma.PendingSubscriptionPaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingSubscriptionPaymentPayload>
          }
          createMany: {
            args: Prisma.PendingSubscriptionPaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PendingSubscriptionPaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingSubscriptionPaymentPayload>[]
          }
          delete: {
            args: Prisma.PendingSubscriptionPaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingSubscriptionPaymentPayload>
          }
          update: {
            args: Prisma.PendingSubscriptionPaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingSubscriptionPaymentPayload>
          }
          deleteMany: {
            args: Prisma.PendingSubscriptionPaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PendingSubscriptionPaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PendingSubscriptionPaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingSubscriptionPaymentPayload>[]
          }
          upsert: {
            args: Prisma.PendingSubscriptionPaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingSubscriptionPaymentPayload>
          }
          aggregate: {
            args: Prisma.PendingSubscriptionPaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePendingSubscriptionPayment>
          }
          groupBy: {
            args: Prisma.PendingSubscriptionPaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PendingSubscriptionPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PendingSubscriptionPaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PendingSubscriptionPaymentCountAggregateOutputType> | number
          }
        }
      }
      PaymentOrder: {
        payload: Prisma.$PaymentOrderPayload<ExtArgs>
        fields: Prisma.PaymentOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentOrderPayload>
          }
          findFirst: {
            args: Prisma.PaymentOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentOrderPayload>
          }
          findMany: {
            args: Prisma.PaymentOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentOrderPayload>[]
          }
          create: {
            args: Prisma.PaymentOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentOrderPayload>
          }
          createMany: {
            args: Prisma.PaymentOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentOrderPayload>[]
          }
          delete: {
            args: Prisma.PaymentOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentOrderPayload>
          }
          update: {
            args: Prisma.PaymentOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentOrderPayload>
          }
          deleteMany: {
            args: Prisma.PaymentOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentOrderPayload>[]
          }
          upsert: {
            args: Prisma.PaymentOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentOrderPayload>
          }
          aggregate: {
            args: Prisma.PaymentOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentOrder>
          }
          groupBy: {
            args: Prisma.PaymentOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentOrderCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentOrderCountAggregateOutputType> | number
          }
        }
      }
      PaymentSetting: {
        payload: Prisma.$PaymentSettingPayload<ExtArgs>
        fields: Prisma.PaymentSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentSettingPayload>
          }
          findFirst: {
            args: Prisma.PaymentSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentSettingPayload>
          }
          findMany: {
            args: Prisma.PaymentSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentSettingPayload>[]
          }
          create: {
            args: Prisma.PaymentSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentSettingPayload>
          }
          createMany: {
            args: Prisma.PaymentSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentSettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentSettingPayload>[]
          }
          delete: {
            args: Prisma.PaymentSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentSettingPayload>
          }
          update: {
            args: Prisma.PaymentSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentSettingPayload>
          }
          deleteMany: {
            args: Prisma.PaymentSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentSettingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentSettingPayload>[]
          }
          upsert: {
            args: Prisma.PaymentSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentSettingPayload>
          }
          aggregate: {
            args: Prisma.PaymentSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentSetting>
          }
          groupBy: {
            args: Prisma.PaymentSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentSettingCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentSettingCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      EventInvitation: {
        payload: Prisma.$EventInvitationPayload<ExtArgs>
        fields: Prisma.EventInvitationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventInvitationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventInvitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventInvitationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventInvitationPayload>
          }
          findFirst: {
            args: Prisma.EventInvitationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventInvitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventInvitationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventInvitationPayload>
          }
          findMany: {
            args: Prisma.EventInvitationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventInvitationPayload>[]
          }
          create: {
            args: Prisma.EventInvitationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventInvitationPayload>
          }
          createMany: {
            args: Prisma.EventInvitationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventInvitationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventInvitationPayload>[]
          }
          delete: {
            args: Prisma.EventInvitationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventInvitationPayload>
          }
          update: {
            args: Prisma.EventInvitationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventInvitationPayload>
          }
          deleteMany: {
            args: Prisma.EventInvitationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventInvitationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventInvitationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventInvitationPayload>[]
          }
          upsert: {
            args: Prisma.EventInvitationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventInvitationPayload>
          }
          aggregate: {
            args: Prisma.EventInvitationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventInvitation>
          }
          groupBy: {
            args: Prisma.EventInvitationGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventInvitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventInvitationCountArgs<ExtArgs>
            result: $Utils.Optional<EventInvitationCountAggregateOutputType> | number
          }
        }
      }
      EventDepartmentBroadcast: {
        payload: Prisma.$EventDepartmentBroadcastPayload<ExtArgs>
        fields: Prisma.EventDepartmentBroadcastFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventDepartmentBroadcastFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventDepartmentBroadcastPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventDepartmentBroadcastFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventDepartmentBroadcastPayload>
          }
          findFirst: {
            args: Prisma.EventDepartmentBroadcastFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventDepartmentBroadcastPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventDepartmentBroadcastFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventDepartmentBroadcastPayload>
          }
          findMany: {
            args: Prisma.EventDepartmentBroadcastFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventDepartmentBroadcastPayload>[]
          }
          create: {
            args: Prisma.EventDepartmentBroadcastCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventDepartmentBroadcastPayload>
          }
          createMany: {
            args: Prisma.EventDepartmentBroadcastCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventDepartmentBroadcastCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventDepartmentBroadcastPayload>[]
          }
          delete: {
            args: Prisma.EventDepartmentBroadcastDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventDepartmentBroadcastPayload>
          }
          update: {
            args: Prisma.EventDepartmentBroadcastUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventDepartmentBroadcastPayload>
          }
          deleteMany: {
            args: Prisma.EventDepartmentBroadcastDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventDepartmentBroadcastUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventDepartmentBroadcastUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventDepartmentBroadcastPayload>[]
          }
          upsert: {
            args: Prisma.EventDepartmentBroadcastUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventDepartmentBroadcastPayload>
          }
          aggregate: {
            args: Prisma.EventDepartmentBroadcastAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventDepartmentBroadcast>
          }
          groupBy: {
            args: Prisma.EventDepartmentBroadcastGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventDepartmentBroadcastGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventDepartmentBroadcastCountArgs<ExtArgs>
            result: $Utils.Optional<EventDepartmentBroadcastCountAggregateOutputType> | number
          }
        }
      }
      InvitationRSVP: {
        payload: Prisma.$InvitationRSVPPayload<ExtArgs>
        fields: Prisma.InvitationRSVPFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvitationRSVPFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationRSVPPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvitationRSVPFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationRSVPPayload>
          }
          findFirst: {
            args: Prisma.InvitationRSVPFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationRSVPPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvitationRSVPFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationRSVPPayload>
          }
          findMany: {
            args: Prisma.InvitationRSVPFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationRSVPPayload>[]
          }
          create: {
            args: Prisma.InvitationRSVPCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationRSVPPayload>
          }
          createMany: {
            args: Prisma.InvitationRSVPCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvitationRSVPCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationRSVPPayload>[]
          }
          delete: {
            args: Prisma.InvitationRSVPDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationRSVPPayload>
          }
          update: {
            args: Prisma.InvitationRSVPUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationRSVPPayload>
          }
          deleteMany: {
            args: Prisma.InvitationRSVPDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvitationRSVPUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvitationRSVPUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationRSVPPayload>[]
          }
          upsert: {
            args: Prisma.InvitationRSVPUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationRSVPPayload>
          }
          aggregate: {
            args: Prisma.InvitationRSVPAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvitationRSVP>
          }
          groupBy: {
            args: Prisma.InvitationRSVPGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvitationRSVPGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvitationRSVPCountArgs<ExtArgs>
            result: $Utils.Optional<InvitationRSVPCountAggregateOutputType> | number
          }
        }
      }
      UserPage: {
        payload: Prisma.$UserPagePayload<ExtArgs>
        fields: Prisma.UserPageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPagePayload>
          }
          findFirst: {
            args: Prisma.UserPageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPagePayload>
          }
          findMany: {
            args: Prisma.UserPageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPagePayload>[]
          }
          create: {
            args: Prisma.UserPageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPagePayload>
          }
          createMany: {
            args: Prisma.UserPageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserPageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPagePayload>[]
          }
          delete: {
            args: Prisma.UserPageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPagePayload>
          }
          update: {
            args: Prisma.UserPageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPagePayload>
          }
          deleteMany: {
            args: Prisma.UserPageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserPageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPagePayload>[]
          }
          upsert: {
            args: Prisma.UserPageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPagePayload>
          }
          aggregate: {
            args: Prisma.UserPageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPage>
          }
          groupBy: {
            args: Prisma.UserPageGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPageGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPageCountArgs<ExtArgs>
            result: $Utils.Optional<UserPageCountAggregateOutputType> | number
          }
        }
      }
      Post: {
        payload: Prisma.$PostPayload<ExtArgs>
        fields: Prisma.PostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findFirst: {
            args: Prisma.PostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findMany: {
            args: Prisma.PostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          create: {
            args: Prisma.PostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          createMany: {
            args: Prisma.PostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          delete: {
            args: Prisma.PostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          update: {
            args: Prisma.PostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          deleteMany: {
            args: Prisma.PostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          upsert: {
            args: Prisma.PostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          aggregate: {
            args: Prisma.PostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePost>
          }
          groupBy: {
            args: Prisma.PostGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostCountArgs<ExtArgs>
            result: $Utils.Optional<PostCountAggregateOutputType> | number
          }
        }
      }
      Like: {
        payload: Prisma.$LikePayload<ExtArgs>
        fields: Prisma.LikeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LikeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LikeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          findFirst: {
            args: Prisma.LikeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LikeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          findMany: {
            args: Prisma.LikeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>[]
          }
          create: {
            args: Prisma.LikeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          createMany: {
            args: Prisma.LikeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LikeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>[]
          }
          delete: {
            args: Prisma.LikeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          update: {
            args: Prisma.LikeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          deleteMany: {
            args: Prisma.LikeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LikeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LikeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>[]
          }
          upsert: {
            args: Prisma.LikeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          aggregate: {
            args: Prisma.LikeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLike>
          }
          groupBy: {
            args: Prisma.LikeGroupByArgs<ExtArgs>
            result: $Utils.Optional<LikeGroupByOutputType>[]
          }
          count: {
            args: Prisma.LikeCountArgs<ExtArgs>
            result: $Utils.Optional<LikeCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      PostRead: {
        payload: Prisma.$PostReadPayload<ExtArgs>
        fields: Prisma.PostReadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostReadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostReadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostReadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostReadPayload>
          }
          findFirst: {
            args: Prisma.PostReadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostReadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostReadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostReadPayload>
          }
          findMany: {
            args: Prisma.PostReadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostReadPayload>[]
          }
          create: {
            args: Prisma.PostReadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostReadPayload>
          }
          createMany: {
            args: Prisma.PostReadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostReadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostReadPayload>[]
          }
          delete: {
            args: Prisma.PostReadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostReadPayload>
          }
          update: {
            args: Prisma.PostReadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostReadPayload>
          }
          deleteMany: {
            args: Prisma.PostReadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostReadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostReadUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostReadPayload>[]
          }
          upsert: {
            args: Prisma.PostReadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostReadPayload>
          }
          aggregate: {
            args: Prisma.PostReadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostRead>
          }
          groupBy: {
            args: Prisma.PostReadGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostReadGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostReadCountArgs<ExtArgs>
            result: $Utils.Optional<PostReadCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      TaskMessage: {
        payload: Prisma.$TaskMessagePayload<ExtArgs>
        fields: Prisma.TaskMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskMessagePayload>
          }
          findFirst: {
            args: Prisma.TaskMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskMessagePayload>
          }
          findMany: {
            args: Prisma.TaskMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskMessagePayload>[]
          }
          create: {
            args: Prisma.TaskMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskMessagePayload>
          }
          createMany: {
            args: Prisma.TaskMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskMessagePayload>[]
          }
          delete: {
            args: Prisma.TaskMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskMessagePayload>
          }
          update: {
            args: Prisma.TaskMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskMessagePayload>
          }
          deleteMany: {
            args: Prisma.TaskMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskMessagePayload>[]
          }
          upsert: {
            args: Prisma.TaskMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskMessagePayload>
          }
          aggregate: {
            args: Prisma.TaskMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskMessage>
          }
          groupBy: {
            args: Prisma.TaskMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskMessageCountArgs<ExtArgs>
            result: $Utils.Optional<TaskMessageCountAggregateOutputType> | number
          }
        }
      }
      TaskAttachment: {
        payload: Prisma.$TaskAttachmentPayload<ExtArgs>
        fields: Prisma.TaskAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAttachmentPayload>
          }
          findFirst: {
            args: Prisma.TaskAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAttachmentPayload>
          }
          findMany: {
            args: Prisma.TaskAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAttachmentPayload>[]
          }
          create: {
            args: Prisma.TaskAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAttachmentPayload>
          }
          createMany: {
            args: Prisma.TaskAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskAttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAttachmentPayload>[]
          }
          delete: {
            args: Prisma.TaskAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAttachmentPayload>
          }
          update: {
            args: Prisma.TaskAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.TaskAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskAttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAttachmentPayload>[]
          }
          upsert: {
            args: Prisma.TaskAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAttachmentPayload>
          }
          aggregate: {
            args: Prisma.TaskAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskAttachment>
          }
          groupBy: {
            args: Prisma.TaskAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<TaskAttachmentCountAggregateOutputType> | number
          }
        }
      }
      DepartmentMonthlyReport: {
        payload: Prisma.$DepartmentMonthlyReportPayload<ExtArgs>
        fields: Prisma.DepartmentMonthlyReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentMonthlyReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentMonthlyReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentMonthlyReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentMonthlyReportPayload>
          }
          findFirst: {
            args: Prisma.DepartmentMonthlyReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentMonthlyReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentMonthlyReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentMonthlyReportPayload>
          }
          findMany: {
            args: Prisma.DepartmentMonthlyReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentMonthlyReportPayload>[]
          }
          create: {
            args: Prisma.DepartmentMonthlyReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentMonthlyReportPayload>
          }
          createMany: {
            args: Prisma.DepartmentMonthlyReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepartmentMonthlyReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentMonthlyReportPayload>[]
          }
          delete: {
            args: Prisma.DepartmentMonthlyReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentMonthlyReportPayload>
          }
          update: {
            args: Prisma.DepartmentMonthlyReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentMonthlyReportPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentMonthlyReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentMonthlyReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DepartmentMonthlyReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentMonthlyReportPayload>[]
          }
          upsert: {
            args: Prisma.DepartmentMonthlyReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentMonthlyReportPayload>
          }
          aggregate: {
            args: Prisma.DepartmentMonthlyReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartmentMonthlyReport>
          }
          groupBy: {
            args: Prisma.DepartmentMonthlyReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentMonthlyReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentMonthlyReportCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentMonthlyReportCountAggregateOutputType> | number
          }
        }
      }
      PushSubscription: {
        payload: Prisma.$PushSubscriptionPayload<ExtArgs>
        fields: Prisma.PushSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PushSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PushSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.PushSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PushSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          findMany: {
            args: Prisma.PushSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>[]
          }
          create: {
            args: Prisma.PushSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          createMany: {
            args: Prisma.PushSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PushSubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.PushSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          update: {
            args: Prisma.PushSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.PushSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PushSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PushSubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.PushSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.PushSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePushSubscription>
          }
          groupBy: {
            args: Prisma.PushSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PushSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PushSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<PushSubscriptionCountAggregateOutputType> | number
          }
        }
      }
      UserPersonalTask: {
        payload: Prisma.$UserPersonalTaskPayload<ExtArgs>
        fields: Prisma.UserPersonalTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPersonalTaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPersonalTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPersonalTaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPersonalTaskPayload>
          }
          findFirst: {
            args: Prisma.UserPersonalTaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPersonalTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPersonalTaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPersonalTaskPayload>
          }
          findMany: {
            args: Prisma.UserPersonalTaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPersonalTaskPayload>[]
          }
          create: {
            args: Prisma.UserPersonalTaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPersonalTaskPayload>
          }
          createMany: {
            args: Prisma.UserPersonalTaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserPersonalTaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPersonalTaskPayload>[]
          }
          delete: {
            args: Prisma.UserPersonalTaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPersonalTaskPayload>
          }
          update: {
            args: Prisma.UserPersonalTaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPersonalTaskPayload>
          }
          deleteMany: {
            args: Prisma.UserPersonalTaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPersonalTaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserPersonalTaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPersonalTaskPayload>[]
          }
          upsert: {
            args: Prisma.UserPersonalTaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPersonalTaskPayload>
          }
          aggregate: {
            args: Prisma.UserPersonalTaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPersonalTask>
          }
          groupBy: {
            args: Prisma.UserPersonalTaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPersonalTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPersonalTaskCountArgs<ExtArgs>
            result: $Utils.Optional<UserPersonalTaskCountAggregateOutputType> | number
          }
        }
      }
      UserFinancialGoal: {
        payload: Prisma.$UserFinancialGoalPayload<ExtArgs>
        fields: Prisma.UserFinancialGoalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFinancialGoalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFinancialGoalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFinancialGoalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFinancialGoalPayload>
          }
          findFirst: {
            args: Prisma.UserFinancialGoalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFinancialGoalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFinancialGoalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFinancialGoalPayload>
          }
          findMany: {
            args: Prisma.UserFinancialGoalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFinancialGoalPayload>[]
          }
          create: {
            args: Prisma.UserFinancialGoalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFinancialGoalPayload>
          }
          createMany: {
            args: Prisma.UserFinancialGoalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserFinancialGoalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFinancialGoalPayload>[]
          }
          delete: {
            args: Prisma.UserFinancialGoalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFinancialGoalPayload>
          }
          update: {
            args: Prisma.UserFinancialGoalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFinancialGoalPayload>
          }
          deleteMany: {
            args: Prisma.UserFinancialGoalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserFinancialGoalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserFinancialGoalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFinancialGoalPayload>[]
          }
          upsert: {
            args: Prisma.UserFinancialGoalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFinancialGoalPayload>
          }
          aggregate: {
            args: Prisma.UserFinancialGoalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserFinancialGoal>
          }
          groupBy: {
            args: Prisma.UserFinancialGoalGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserFinancialGoalGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserFinancialGoalCountArgs<ExtArgs>
            result: $Utils.Optional<UserFinancialGoalCountAggregateOutputType> | number
          }
        }
      }
      UserFinancialProfile: {
        payload: Prisma.$UserFinancialProfilePayload<ExtArgs>
        fields: Prisma.UserFinancialProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFinancialProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFinancialProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFinancialProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFinancialProfilePayload>
          }
          findFirst: {
            args: Prisma.UserFinancialProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFinancialProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFinancialProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFinancialProfilePayload>
          }
          findMany: {
            args: Prisma.UserFinancialProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFinancialProfilePayload>[]
          }
          create: {
            args: Prisma.UserFinancialProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFinancialProfilePayload>
          }
          createMany: {
            args: Prisma.UserFinancialProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserFinancialProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFinancialProfilePayload>[]
          }
          delete: {
            args: Prisma.UserFinancialProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFinancialProfilePayload>
          }
          update: {
            args: Prisma.UserFinancialProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFinancialProfilePayload>
          }
          deleteMany: {
            args: Prisma.UserFinancialProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserFinancialProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserFinancialProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFinancialProfilePayload>[]
          }
          upsert: {
            args: Prisma.UserFinancialProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFinancialProfilePayload>
          }
          aggregate: {
            args: Prisma.UserFinancialProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserFinancialProfile>
          }
          groupBy: {
            args: Prisma.UserFinancialProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserFinancialProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserFinancialProfileCountArgs<ExtArgs>
            result: $Utils.Optional<UserFinancialProfileCountAggregateOutputType> | number
          }
        }
      }
      UserMonthlyStatement: {
        payload: Prisma.$UserMonthlyStatementPayload<ExtArgs>
        fields: Prisma.UserMonthlyStatementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserMonthlyStatementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMonthlyStatementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserMonthlyStatementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMonthlyStatementPayload>
          }
          findFirst: {
            args: Prisma.UserMonthlyStatementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMonthlyStatementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserMonthlyStatementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMonthlyStatementPayload>
          }
          findMany: {
            args: Prisma.UserMonthlyStatementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMonthlyStatementPayload>[]
          }
          create: {
            args: Prisma.UserMonthlyStatementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMonthlyStatementPayload>
          }
          createMany: {
            args: Prisma.UserMonthlyStatementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserMonthlyStatementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMonthlyStatementPayload>[]
          }
          delete: {
            args: Prisma.UserMonthlyStatementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMonthlyStatementPayload>
          }
          update: {
            args: Prisma.UserMonthlyStatementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMonthlyStatementPayload>
          }
          deleteMany: {
            args: Prisma.UserMonthlyStatementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserMonthlyStatementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserMonthlyStatementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMonthlyStatementPayload>[]
          }
          upsert: {
            args: Prisma.UserMonthlyStatementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMonthlyStatementPayload>
          }
          aggregate: {
            args: Prisma.UserMonthlyStatementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserMonthlyStatement>
          }
          groupBy: {
            args: Prisma.UserMonthlyStatementGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserMonthlyStatementGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserMonthlyStatementCountArgs<ExtArgs>
            result: $Utils.Optional<UserMonthlyStatementCountAggregateOutputType> | number
          }
        }
      }
      UserFinancialEntry: {
        payload: Prisma.$UserFinancialEntryPayload<ExtArgs>
        fields: Prisma.UserFinancialEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFinancialEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFinancialEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFinancialEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFinancialEntryPayload>
          }
          findFirst: {
            args: Prisma.UserFinancialEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFinancialEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFinancialEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFinancialEntryPayload>
          }
          findMany: {
            args: Prisma.UserFinancialEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFinancialEntryPayload>[]
          }
          create: {
            args: Prisma.UserFinancialEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFinancialEntryPayload>
          }
          createMany: {
            args: Prisma.UserFinancialEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserFinancialEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFinancialEntryPayload>[]
          }
          delete: {
            args: Prisma.UserFinancialEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFinancialEntryPayload>
          }
          update: {
            args: Prisma.UserFinancialEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFinancialEntryPayload>
          }
          deleteMany: {
            args: Prisma.UserFinancialEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserFinancialEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserFinancialEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFinancialEntryPayload>[]
          }
          upsert: {
            args: Prisma.UserFinancialEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFinancialEntryPayload>
          }
          aggregate: {
            args: Prisma.UserFinancialEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserFinancialEntry>
          }
          groupBy: {
            args: Prisma.UserFinancialEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserFinancialEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserFinancialEntryCountArgs<ExtArgs>
            result: $Utils.Optional<UserFinancialEntryCountAggregateOutputType> | number
          }
        }
      }
      UserMonthlyProgress: {
        payload: Prisma.$UserMonthlyProgressPayload<ExtArgs>
        fields: Prisma.UserMonthlyProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserMonthlyProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMonthlyProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserMonthlyProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMonthlyProgressPayload>
          }
          findFirst: {
            args: Prisma.UserMonthlyProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMonthlyProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserMonthlyProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMonthlyProgressPayload>
          }
          findMany: {
            args: Prisma.UserMonthlyProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMonthlyProgressPayload>[]
          }
          create: {
            args: Prisma.UserMonthlyProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMonthlyProgressPayload>
          }
          createMany: {
            args: Prisma.UserMonthlyProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserMonthlyProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMonthlyProgressPayload>[]
          }
          delete: {
            args: Prisma.UserMonthlyProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMonthlyProgressPayload>
          }
          update: {
            args: Prisma.UserMonthlyProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMonthlyProgressPayload>
          }
          deleteMany: {
            args: Prisma.UserMonthlyProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserMonthlyProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserMonthlyProgressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMonthlyProgressPayload>[]
          }
          upsert: {
            args: Prisma.UserMonthlyProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMonthlyProgressPayload>
          }
          aggregate: {
            args: Prisma.UserMonthlyProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserMonthlyProgress>
          }
          groupBy: {
            args: Prisma.UserMonthlyProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserMonthlyProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserMonthlyProgressCountArgs<ExtArgs>
            result: $Utils.Optional<UserMonthlyProgressCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    userInvitation?: UserInvitationOmit
    invitationGuest?: InvitationGuestOmit
    follow?: FollowOmit
    organization?: OrganizationOmit
    organizationMember?: OrganizationMemberOmit
    department?: DepartmentOmit
    departmentDocument?: DepartmentDocumentOmit
    departmentGoal?: DepartmentGoalOmit
    departmentMeeting?: DepartmentMeetingOmit
    departmentPoll?: DepartmentPollOmit
    pollVote?: PollVoteOmit
    teamDecision?: TeamDecisionOmit
    decisionVote?: DecisionVoteOmit
    departmentMember?: DepartmentMemberOmit
    group?: GroupOmit
    groupDocument?: GroupDocumentOmit
    groupNote?: GroupNoteOmit
    groupMember?: GroupMemberOmit
    message?: MessageOmit
    attachment?: AttachmentOmit
    notification?: NotificationOmit
    announcement?: AnnouncementOmit
    announcementRead?: AnnouncementReadOmit
    organizationRequest?: OrganizationRequestOmit
    pendingSubscriptionPayment?: PendingSubscriptionPaymentOmit
    paymentOrder?: PaymentOrderOmit
    paymentSetting?: PaymentSettingOmit
    subscription?: SubscriptionOmit
    eventInvitation?: EventInvitationOmit
    eventDepartmentBroadcast?: EventDepartmentBroadcastOmit
    invitationRSVP?: InvitationRSVPOmit
    userPage?: UserPageOmit
    post?: PostOmit
    like?: LikeOmit
    comment?: CommentOmit
    postRead?: PostReadOmit
    task?: TaskOmit
    taskMessage?: TaskMessageOmit
    taskAttachment?: TaskAttachmentOmit
    departmentMonthlyReport?: DepartmentMonthlyReportOmit
    pushSubscription?: PushSubscriptionOmit
    userPersonalTask?: UserPersonalTaskOmit
    userFinancialGoal?: UserFinancialGoalOmit
    userFinancialProfile?: UserFinancialProfileOmit
    userMonthlyStatement?: UserMonthlyStatementOmit
    userFinancialEntry?: UserFinancialEntryOmit
    userMonthlyProgress?: UserMonthlyProgressOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    publishedAnnouncements: number
    deptMemberships: number
    groupMemberships: number
    sentMessages: number
    notifications: number
    orgMemberships: number
    likes: number
    comments: number
    postReads: number
    assignedTasks: number
    createdTasks: number
    headedDepartments: number
    taskMessages: number
    departmentMonthlyReports: number
    createdMeetings: number
    createdPolls: number
    createdDecisions: number
    pollVotes: number
    decisionVotes: number
    pushSubscriptions: number
    invitations: number
    personalTasks: number
    financialGoals: number
    monthlyStatements: number
    financialEntries: number
    followers: number
    following: number
    uploadedDepartmentDocuments: number
    groupNotes: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    publishedAnnouncements?: boolean | UserCountOutputTypeCountPublishedAnnouncementsArgs
    deptMemberships?: boolean | UserCountOutputTypeCountDeptMembershipsArgs
    groupMemberships?: boolean | UserCountOutputTypeCountGroupMembershipsArgs
    sentMessages?: boolean | UserCountOutputTypeCountSentMessagesArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    orgMemberships?: boolean | UserCountOutputTypeCountOrgMembershipsArgs
    likes?: boolean | UserCountOutputTypeCountLikesArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
    postReads?: boolean | UserCountOutputTypeCountPostReadsArgs
    assignedTasks?: boolean | UserCountOutputTypeCountAssignedTasksArgs
    createdTasks?: boolean | UserCountOutputTypeCountCreatedTasksArgs
    headedDepartments?: boolean | UserCountOutputTypeCountHeadedDepartmentsArgs
    taskMessages?: boolean | UserCountOutputTypeCountTaskMessagesArgs
    departmentMonthlyReports?: boolean | UserCountOutputTypeCountDepartmentMonthlyReportsArgs
    createdMeetings?: boolean | UserCountOutputTypeCountCreatedMeetingsArgs
    createdPolls?: boolean | UserCountOutputTypeCountCreatedPollsArgs
    createdDecisions?: boolean | UserCountOutputTypeCountCreatedDecisionsArgs
    pollVotes?: boolean | UserCountOutputTypeCountPollVotesArgs
    decisionVotes?: boolean | UserCountOutputTypeCountDecisionVotesArgs
    pushSubscriptions?: boolean | UserCountOutputTypeCountPushSubscriptionsArgs
    invitations?: boolean | UserCountOutputTypeCountInvitationsArgs
    personalTasks?: boolean | UserCountOutputTypeCountPersonalTasksArgs
    financialGoals?: boolean | UserCountOutputTypeCountFinancialGoalsArgs
    monthlyStatements?: boolean | UserCountOutputTypeCountMonthlyStatementsArgs
    financialEntries?: boolean | UserCountOutputTypeCountFinancialEntriesArgs
    followers?: boolean | UserCountOutputTypeCountFollowersArgs
    following?: boolean | UserCountOutputTypeCountFollowingArgs
    uploadedDepartmentDocuments?: boolean | UserCountOutputTypeCountUploadedDepartmentDocumentsArgs
    groupNotes?: boolean | UserCountOutputTypeCountGroupNotesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPublishedAnnouncementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnouncementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDeptMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGroupMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrgMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPostReadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostReadWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountHeadedDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTaskMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDepartmentMonthlyReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentMonthlyReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedMeetingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentMeetingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedPollsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentPollWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedDecisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamDecisionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPollVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PollVoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDecisionVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DecisionVoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPushSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PushSubscriptionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserInvitationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPersonalTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPersonalTaskWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFinancialGoalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFinancialGoalWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMonthlyStatementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserMonthlyStatementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFinancialEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFinancialEntryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFollowersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFollowingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUploadedDepartmentDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentDocumentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGroupNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupNoteWhereInput
  }


  /**
   * Count Type UserInvitationCountOutputType
   */

  export type UserInvitationCountOutputType = {
    guests: number
  }

  export type UserInvitationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guests?: boolean | UserInvitationCountOutputTypeCountGuestsArgs
  }

  // Custom InputTypes
  /**
   * UserInvitationCountOutputType without action
   */
  export type UserInvitationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitationCountOutputType
     */
    select?: UserInvitationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserInvitationCountOutputType without action
   */
  export type UserInvitationCountOutputTypeCountGuestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationGuestWhereInput
  }


  /**
   * Count Type OrganizationCountOutputType
   */

  export type OrganizationCountOutputType = {
    departments: number
    members: number
    events: number
  }

  export type OrganizationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    departments?: boolean | OrganizationCountOutputTypeCountDepartmentsArgs
    members?: boolean | OrganizationCountOutputTypeCountMembersArgs
    events?: boolean | OrganizationCountOutputTypeCountEventsArgs
  }

  // Custom InputTypes
  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationMemberWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventInvitationWhereInput
  }


  /**
   * Count Type DepartmentCountOutputType
   */

  export type DepartmentCountOutputType = {
    members: number
    conversations: number
    tasks: number
    eventBroadcasts: number
    monthlyReports: number
    goals: number
    meetings: number
    polls: number
    teamDecisions: number
    documents: number
  }

  export type DepartmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | DepartmentCountOutputTypeCountMembersArgs
    conversations?: boolean | DepartmentCountOutputTypeCountConversationsArgs
    tasks?: boolean | DepartmentCountOutputTypeCountTasksArgs
    eventBroadcasts?: boolean | DepartmentCountOutputTypeCountEventBroadcastsArgs
    monthlyReports?: boolean | DepartmentCountOutputTypeCountMonthlyReportsArgs
    goals?: boolean | DepartmentCountOutputTypeCountGoalsArgs
    meetings?: boolean | DepartmentCountOutputTypeCountMeetingsArgs
    polls?: boolean | DepartmentCountOutputTypeCountPollsArgs
    teamDecisions?: boolean | DepartmentCountOutputTypeCountTeamDecisionsArgs
    documents?: boolean | DepartmentCountOutputTypeCountDocumentsArgs
  }

  // Custom InputTypes
  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCountOutputType
     */
    select?: DepartmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentMemberWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountEventBroadcastsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventDepartmentBroadcastWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountMonthlyReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentMonthlyReportWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountGoalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentGoalWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountMeetingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentMeetingWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountPollsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentPollWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountTeamDecisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamDecisionWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentDocumentWhereInput
  }


  /**
   * Count Type DepartmentPollCountOutputType
   */

  export type DepartmentPollCountOutputType = {
    votes: number
  }

  export type DepartmentPollCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    votes?: boolean | DepartmentPollCountOutputTypeCountVotesArgs
  }

  // Custom InputTypes
  /**
   * DepartmentPollCountOutputType without action
   */
  export type DepartmentPollCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentPollCountOutputType
     */
    select?: DepartmentPollCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartmentPollCountOutputType without action
   */
  export type DepartmentPollCountOutputTypeCountVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PollVoteWhereInput
  }


  /**
   * Count Type TeamDecisionCountOutputType
   */

  export type TeamDecisionCountOutputType = {
    votes: number
  }

  export type TeamDecisionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    votes?: boolean | TeamDecisionCountOutputTypeCountVotesArgs
  }

  // Custom InputTypes
  /**
   * TeamDecisionCountOutputType without action
   */
  export type TeamDecisionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamDecisionCountOutputType
     */
    select?: TeamDecisionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeamDecisionCountOutputType without action
   */
  export type TeamDecisionCountOutputTypeCountVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DecisionVoteWhereInput
  }


  /**
   * Count Type GroupCountOutputType
   */

  export type GroupCountOutputType = {
    members: number
    messages: number
    documents: number
  }

  export type GroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | GroupCountOutputTypeCountMembersArgs
    messages?: boolean | GroupCountOutputTypeCountMessagesArgs
    documents?: boolean | GroupCountOutputTypeCountDocumentsArgs
  }

  // Custom InputTypes
  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupCountOutputType
     */
    select?: GroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupMemberWhereInput
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupDocumentWhereInput
  }


  /**
   * Count Type GroupDocumentCountOutputType
   */

  export type GroupDocumentCountOutputType = {
    notes: number
  }

  export type GroupDocumentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notes?: boolean | GroupDocumentCountOutputTypeCountNotesArgs
  }

  // Custom InputTypes
  /**
   * GroupDocumentCountOutputType without action
   */
  export type GroupDocumentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupDocumentCountOutputType
     */
    select?: GroupDocumentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GroupDocumentCountOutputType without action
   */
  export type GroupDocumentCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupNoteWhereInput
  }


  /**
   * Count Type MessageCountOutputType
   */

  export type MessageCountOutputType = {
    attachments: number
  }

  export type MessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | MessageCountOutputTypeCountAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCountOutputType
     */
    select?: MessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
  }


  /**
   * Count Type AnnouncementCountOutputType
   */

  export type AnnouncementCountOutputType = {
    reads: number
  }

  export type AnnouncementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reads?: boolean | AnnouncementCountOutputTypeCountReadsArgs
  }

  // Custom InputTypes
  /**
   * AnnouncementCountOutputType without action
   */
  export type AnnouncementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnouncementCountOutputType
     */
    select?: AnnouncementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AnnouncementCountOutputType without action
   */
  export type AnnouncementCountOutputTypeCountReadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnouncementReadWhereInput
  }


  /**
   * Count Type EventInvitationCountOutputType
   */

  export type EventInvitationCountOutputType = {
    rsvps: number
    departmentBroadcasts: number
  }

  export type EventInvitationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rsvps?: boolean | EventInvitationCountOutputTypeCountRsvpsArgs
    departmentBroadcasts?: boolean | EventInvitationCountOutputTypeCountDepartmentBroadcastsArgs
  }

  // Custom InputTypes
  /**
   * EventInvitationCountOutputType without action
   */
  export type EventInvitationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventInvitationCountOutputType
     */
    select?: EventInvitationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EventInvitationCountOutputType without action
   */
  export type EventInvitationCountOutputTypeCountRsvpsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationRSVPWhereInput
  }

  /**
   * EventInvitationCountOutputType without action
   */
  export type EventInvitationCountOutputTypeCountDepartmentBroadcastsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventDepartmentBroadcastWhereInput
  }


  /**
   * Count Type UserPageCountOutputType
   */

  export type UserPageCountOutputType = {
    posts: number
  }

  export type UserPageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | UserPageCountOutputTypeCountPostsArgs
  }

  // Custom InputTypes
  /**
   * UserPageCountOutputType without action
   */
  export type UserPageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPageCountOutputType
     */
    select?: UserPageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserPageCountOutputType without action
   */
  export type UserPageCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }


  /**
   * Count Type PostCountOutputType
   */

  export type PostCountOutputType = {
    likes: number
    comments: number
    postReads: number
  }

  export type PostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    likes?: boolean | PostCountOutputTypeCountLikesArgs
    comments?: boolean | PostCountOutputTypeCountCommentsArgs
    postReads?: boolean | PostCountOutputTypeCountPostReadsArgs
  }

  // Custom InputTypes
  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCountOutputType
     */
    select?: PostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountPostReadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostReadWhereInput
  }


  /**
   * Count Type CommentCountOutputType
   */

  export type CommentCountOutputType = {
    replies: number
  }

  export type CommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | CommentCountOutputTypeCountRepliesArgs
  }

  // Custom InputTypes
  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type TaskCountOutputType
   */

  export type TaskCountOutputType = {
    messages: number
    attachments: number
  }

  export type TaskCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | TaskCountOutputTypeCountMessagesArgs
    attachments?: boolean | TaskCountOutputTypeCountAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCountOutputType
     */
    select?: TaskCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskMessageWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskAttachmentWhereInput
  }


  /**
   * Count Type TaskMessageCountOutputType
   */

  export type TaskMessageCountOutputType = {
    attachments: number
  }

  export type TaskMessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | TaskMessageCountOutputTypeCountAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * TaskMessageCountOutputType without action
   */
  export type TaskMessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskMessageCountOutputType
     */
    select?: TaskMessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaskMessageCountOutputType without action
   */
  export type TaskMessageCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskAttachmentWhereInput
  }


  /**
   * Count Type UserFinancialGoalCountOutputType
   */

  export type UserFinancialGoalCountOutputType = {
    progress: number
  }

  export type UserFinancialGoalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    progress?: boolean | UserFinancialGoalCountOutputTypeCountProgressArgs
  }

  // Custom InputTypes
  /**
   * UserFinancialGoalCountOutputType without action
   */
  export type UserFinancialGoalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinancialGoalCountOutputType
     */
    select?: UserFinancialGoalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserFinancialGoalCountOutputType without action
   */
  export type UserFinancialGoalCountOutputTypeCountProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserMonthlyProgressWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    avatarUrl: string | null
    password: string | null
    phone: string | null
    publicKey: string | null
    encryptedPrivateKey: string | null
    otpCode: string | null
    otpExpiry: Date | null
    isVerified: boolean | null
    deviceId: string | null
    allowedCountry: string | null
    isBanned: boolean | null
    isFirstLogin: boolean | null
    lastSeen: Date | null
    isOnline: boolean | null
    role: $Enums.UserRole | null
    canPublishNotifications: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    avatarUrl: string | null
    password: string | null
    phone: string | null
    publicKey: string | null
    encryptedPrivateKey: string | null
    otpCode: string | null
    otpExpiry: Date | null
    isVerified: boolean | null
    deviceId: string | null
    allowedCountry: string | null
    isBanned: boolean | null
    isFirstLogin: boolean | null
    lastSeen: Date | null
    isOnline: boolean | null
    role: $Enums.UserRole | null
    canPublishNotifications: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    avatarUrl: number
    password: number
    phone: number
    publicKey: number
    encryptedPrivateKey: number
    otpCode: number
    otpExpiry: number
    isVerified: number
    deviceId: number
    deviceInfo: number
    location: number
    allowedCountry: number
    isBanned: number
    isFirstLogin: number
    currentLocation: number
    lastSeen: number
    isOnline: number
    role: number
    canPublishNotifications: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    avatarUrl?: true
    password?: true
    phone?: true
    publicKey?: true
    encryptedPrivateKey?: true
    otpCode?: true
    otpExpiry?: true
    isVerified?: true
    deviceId?: true
    allowedCountry?: true
    isBanned?: true
    isFirstLogin?: true
    lastSeen?: true
    isOnline?: true
    role?: true
    canPublishNotifications?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    avatarUrl?: true
    password?: true
    phone?: true
    publicKey?: true
    encryptedPrivateKey?: true
    otpCode?: true
    otpExpiry?: true
    isVerified?: true
    deviceId?: true
    allowedCountry?: true
    isBanned?: true
    isFirstLogin?: true
    lastSeen?: true
    isOnline?: true
    role?: true
    canPublishNotifications?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    avatarUrl?: true
    password?: true
    phone?: true
    publicKey?: true
    encryptedPrivateKey?: true
    otpCode?: true
    otpExpiry?: true
    isVerified?: true
    deviceId?: true
    deviceInfo?: true
    location?: true
    allowedCountry?: true
    isBanned?: true
    isFirstLogin?: true
    currentLocation?: true
    lastSeen?: true
    isOnline?: true
    role?: true
    canPublishNotifications?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string | null
    avatarUrl: string | null
    password: string
    phone: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode: string | null
    otpExpiry: Date | null
    isVerified: boolean
    deviceId: string | null
    deviceInfo: JsonValue | null
    location: JsonValue | null
    allowedCountry: string | null
    isBanned: boolean
    isFirstLogin: boolean
    currentLocation: JsonValue | null
    lastSeen: Date | null
    isOnline: boolean
    role: $Enums.UserRole
    canPublishNotifications: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    avatarUrl?: boolean
    password?: boolean
    phone?: boolean
    publicKey?: boolean
    encryptedPrivateKey?: boolean
    otpCode?: boolean
    otpExpiry?: boolean
    isVerified?: boolean
    deviceId?: boolean
    deviceInfo?: boolean
    location?: boolean
    allowedCountry?: boolean
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: boolean
    lastSeen?: boolean
    isOnline?: boolean
    role?: boolean
    canPublishNotifications?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publishedAnnouncements?: boolean | User$publishedAnnouncementsArgs<ExtArgs>
    deptMemberships?: boolean | User$deptMembershipsArgs<ExtArgs>
    groupMemberships?: boolean | User$groupMembershipsArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    orgMemberships?: boolean | User$orgMembershipsArgs<ExtArgs>
    userPage?: boolean | User$userPageArgs<ExtArgs>
    likes?: boolean | User$likesArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    postReads?: boolean | User$postReadsArgs<ExtArgs>
    assignedTasks?: boolean | User$assignedTasksArgs<ExtArgs>
    createdTasks?: boolean | User$createdTasksArgs<ExtArgs>
    headedDepartments?: boolean | User$headedDepartmentsArgs<ExtArgs>
    taskMessages?: boolean | User$taskMessagesArgs<ExtArgs>
    departmentMonthlyReports?: boolean | User$departmentMonthlyReportsArgs<ExtArgs>
    createdMeetings?: boolean | User$createdMeetingsArgs<ExtArgs>
    createdPolls?: boolean | User$createdPollsArgs<ExtArgs>
    createdDecisions?: boolean | User$createdDecisionsArgs<ExtArgs>
    pollVotes?: boolean | User$pollVotesArgs<ExtArgs>
    decisionVotes?: boolean | User$decisionVotesArgs<ExtArgs>
    pushSubscriptions?: boolean | User$pushSubscriptionsArgs<ExtArgs>
    invitations?: boolean | User$invitationsArgs<ExtArgs>
    personalTasks?: boolean | User$personalTasksArgs<ExtArgs>
    financialGoals?: boolean | User$financialGoalsArgs<ExtArgs>
    financialProfile?: boolean | User$financialProfileArgs<ExtArgs>
    monthlyStatements?: boolean | User$monthlyStatementsArgs<ExtArgs>
    financialEntries?: boolean | User$financialEntriesArgs<ExtArgs>
    followers?: boolean | User$followersArgs<ExtArgs>
    following?: boolean | User$followingArgs<ExtArgs>
    uploadedDepartmentDocuments?: boolean | User$uploadedDepartmentDocumentsArgs<ExtArgs>
    groupNotes?: boolean | User$groupNotesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    avatarUrl?: boolean
    password?: boolean
    phone?: boolean
    publicKey?: boolean
    encryptedPrivateKey?: boolean
    otpCode?: boolean
    otpExpiry?: boolean
    isVerified?: boolean
    deviceId?: boolean
    deviceInfo?: boolean
    location?: boolean
    allowedCountry?: boolean
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: boolean
    lastSeen?: boolean
    isOnline?: boolean
    role?: boolean
    canPublishNotifications?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    avatarUrl?: boolean
    password?: boolean
    phone?: boolean
    publicKey?: boolean
    encryptedPrivateKey?: boolean
    otpCode?: boolean
    otpExpiry?: boolean
    isVerified?: boolean
    deviceId?: boolean
    deviceInfo?: boolean
    location?: boolean
    allowedCountry?: boolean
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: boolean
    lastSeen?: boolean
    isOnline?: boolean
    role?: boolean
    canPublishNotifications?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    avatarUrl?: boolean
    password?: boolean
    phone?: boolean
    publicKey?: boolean
    encryptedPrivateKey?: boolean
    otpCode?: boolean
    otpExpiry?: boolean
    isVerified?: boolean
    deviceId?: boolean
    deviceInfo?: boolean
    location?: boolean
    allowedCountry?: boolean
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: boolean
    lastSeen?: boolean
    isOnline?: boolean
    role?: boolean
    canPublishNotifications?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "avatarUrl" | "password" | "phone" | "publicKey" | "encryptedPrivateKey" | "otpCode" | "otpExpiry" | "isVerified" | "deviceId" | "deviceInfo" | "location" | "allowedCountry" | "isBanned" | "isFirstLogin" | "currentLocation" | "lastSeen" | "isOnline" | "role" | "canPublishNotifications" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    publishedAnnouncements?: boolean | User$publishedAnnouncementsArgs<ExtArgs>
    deptMemberships?: boolean | User$deptMembershipsArgs<ExtArgs>
    groupMemberships?: boolean | User$groupMembershipsArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    orgMemberships?: boolean | User$orgMembershipsArgs<ExtArgs>
    userPage?: boolean | User$userPageArgs<ExtArgs>
    likes?: boolean | User$likesArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    postReads?: boolean | User$postReadsArgs<ExtArgs>
    assignedTasks?: boolean | User$assignedTasksArgs<ExtArgs>
    createdTasks?: boolean | User$createdTasksArgs<ExtArgs>
    headedDepartments?: boolean | User$headedDepartmentsArgs<ExtArgs>
    taskMessages?: boolean | User$taskMessagesArgs<ExtArgs>
    departmentMonthlyReports?: boolean | User$departmentMonthlyReportsArgs<ExtArgs>
    createdMeetings?: boolean | User$createdMeetingsArgs<ExtArgs>
    createdPolls?: boolean | User$createdPollsArgs<ExtArgs>
    createdDecisions?: boolean | User$createdDecisionsArgs<ExtArgs>
    pollVotes?: boolean | User$pollVotesArgs<ExtArgs>
    decisionVotes?: boolean | User$decisionVotesArgs<ExtArgs>
    pushSubscriptions?: boolean | User$pushSubscriptionsArgs<ExtArgs>
    invitations?: boolean | User$invitationsArgs<ExtArgs>
    personalTasks?: boolean | User$personalTasksArgs<ExtArgs>
    financialGoals?: boolean | User$financialGoalsArgs<ExtArgs>
    financialProfile?: boolean | User$financialProfileArgs<ExtArgs>
    monthlyStatements?: boolean | User$monthlyStatementsArgs<ExtArgs>
    financialEntries?: boolean | User$financialEntriesArgs<ExtArgs>
    followers?: boolean | User$followersArgs<ExtArgs>
    following?: boolean | User$followingArgs<ExtArgs>
    uploadedDepartmentDocuments?: boolean | User$uploadedDepartmentDocumentsArgs<ExtArgs>
    groupNotes?: boolean | User$groupNotesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      publishedAnnouncements: Prisma.$AnnouncementPayload<ExtArgs>[]
      deptMemberships: Prisma.$DepartmentMemberPayload<ExtArgs>[]
      groupMemberships: Prisma.$GroupMemberPayload<ExtArgs>[]
      sentMessages: Prisma.$MessagePayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      orgMemberships: Prisma.$OrganizationMemberPayload<ExtArgs>[]
      userPage: Prisma.$UserPagePayload<ExtArgs> | null
      likes: Prisma.$LikePayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      postReads: Prisma.$PostReadPayload<ExtArgs>[]
      assignedTasks: Prisma.$TaskPayload<ExtArgs>[]
      createdTasks: Prisma.$TaskPayload<ExtArgs>[]
      headedDepartments: Prisma.$DepartmentPayload<ExtArgs>[]
      taskMessages: Prisma.$TaskMessagePayload<ExtArgs>[]
      departmentMonthlyReports: Prisma.$DepartmentMonthlyReportPayload<ExtArgs>[]
      createdMeetings: Prisma.$DepartmentMeetingPayload<ExtArgs>[]
      createdPolls: Prisma.$DepartmentPollPayload<ExtArgs>[]
      createdDecisions: Prisma.$TeamDecisionPayload<ExtArgs>[]
      pollVotes: Prisma.$PollVotePayload<ExtArgs>[]
      decisionVotes: Prisma.$DecisionVotePayload<ExtArgs>[]
      pushSubscriptions: Prisma.$PushSubscriptionPayload<ExtArgs>[]
      invitations: Prisma.$UserInvitationPayload<ExtArgs>[]
      personalTasks: Prisma.$UserPersonalTaskPayload<ExtArgs>[]
      financialGoals: Prisma.$UserFinancialGoalPayload<ExtArgs>[]
      financialProfile: Prisma.$UserFinancialProfilePayload<ExtArgs> | null
      monthlyStatements: Prisma.$UserMonthlyStatementPayload<ExtArgs>[]
      financialEntries: Prisma.$UserFinancialEntryPayload<ExtArgs>[]
      followers: Prisma.$FollowPayload<ExtArgs>[]
      following: Prisma.$FollowPayload<ExtArgs>[]
      uploadedDepartmentDocuments: Prisma.$DepartmentDocumentPayload<ExtArgs>[]
      groupNotes: Prisma.$GroupNotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string | null
      avatarUrl: string | null
      password: string
      phone: string | null
      publicKey: string
      encryptedPrivateKey: string
      otpCode: string | null
      otpExpiry: Date | null
      isVerified: boolean
      deviceId: string | null
      deviceInfo: Prisma.JsonValue | null
      location: Prisma.JsonValue | null
      allowedCountry: string | null
      isBanned: boolean
      isFirstLogin: boolean
      currentLocation: Prisma.JsonValue | null
      lastSeen: Date | null
      isOnline: boolean
      role: $Enums.UserRole
      canPublishNotifications: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    publishedAnnouncements<T extends User$publishedAnnouncementsArgs<ExtArgs> = {}>(args?: Subset<T, User$publishedAnnouncementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deptMemberships<T extends User$deptMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$deptMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    groupMemberships<T extends User$groupMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$groupMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentMessages<T extends User$sentMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orgMemberships<T extends User$orgMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$orgMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userPage<T extends User$userPageArgs<ExtArgs> = {}>(args?: Subset<T, User$userPageArgs<ExtArgs>>): Prisma__UserPageClient<$Result.GetResult<Prisma.$UserPagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    likes<T extends User$likesArgs<ExtArgs> = {}>(args?: Subset<T, User$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    postReads<T extends User$postReadsArgs<ExtArgs> = {}>(args?: Subset<T, User$postReadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostReadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignedTasks<T extends User$assignedTasksArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdTasks<T extends User$createdTasksArgs<ExtArgs> = {}>(args?: Subset<T, User$createdTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    headedDepartments<T extends User$headedDepartmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$headedDepartmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    taskMessages<T extends User$taskMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$taskMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    departmentMonthlyReports<T extends User$departmentMonthlyReportsArgs<ExtArgs> = {}>(args?: Subset<T, User$departmentMonthlyReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentMonthlyReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdMeetings<T extends User$createdMeetingsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdMeetingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentMeetingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdPolls<T extends User$createdPollsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdPollsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPollPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdDecisions<T extends User$createdDecisionsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdDecisionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamDecisionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pollVotes<T extends User$pollVotesArgs<ExtArgs> = {}>(args?: Subset<T, User$pollVotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PollVotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    decisionVotes<T extends User$decisionVotesArgs<ExtArgs> = {}>(args?: Subset<T, User$decisionVotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DecisionVotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pushSubscriptions<T extends User$pushSubscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, User$pushSubscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invitations<T extends User$invitationsArgs<ExtArgs> = {}>(args?: Subset<T, User$invitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    personalTasks<T extends User$personalTasksArgs<ExtArgs> = {}>(args?: Subset<T, User$personalTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPersonalTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    financialGoals<T extends User$financialGoalsArgs<ExtArgs> = {}>(args?: Subset<T, User$financialGoalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFinancialGoalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    financialProfile<T extends User$financialProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$financialProfileArgs<ExtArgs>>): Prisma__UserFinancialProfileClient<$Result.GetResult<Prisma.$UserFinancialProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    monthlyStatements<T extends User$monthlyStatementsArgs<ExtArgs> = {}>(args?: Subset<T, User$monthlyStatementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserMonthlyStatementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    financialEntries<T extends User$financialEntriesArgs<ExtArgs> = {}>(args?: Subset<T, User$financialEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFinancialEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    followers<T extends User$followersArgs<ExtArgs> = {}>(args?: Subset<T, User$followersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    following<T extends User$followingArgs<ExtArgs> = {}>(args?: Subset<T, User$followingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    uploadedDepartmentDocuments<T extends User$uploadedDepartmentDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, User$uploadedDepartmentDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    groupNotes<T extends User$groupNotesArgs<ExtArgs> = {}>(args?: Subset<T, User$groupNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly publicKey: FieldRef<"User", 'String'>
    readonly encryptedPrivateKey: FieldRef<"User", 'String'>
    readonly otpCode: FieldRef<"User", 'String'>
    readonly otpExpiry: FieldRef<"User", 'DateTime'>
    readonly isVerified: FieldRef<"User", 'Boolean'>
    readonly deviceId: FieldRef<"User", 'String'>
    readonly deviceInfo: FieldRef<"User", 'Json'>
    readonly location: FieldRef<"User", 'Json'>
    readonly allowedCountry: FieldRef<"User", 'String'>
    readonly isBanned: FieldRef<"User", 'Boolean'>
    readonly isFirstLogin: FieldRef<"User", 'Boolean'>
    readonly currentLocation: FieldRef<"User", 'Json'>
    readonly lastSeen: FieldRef<"User", 'DateTime'>
    readonly isOnline: FieldRef<"User", 'Boolean'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly canPublishNotifications: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.publishedAnnouncements
   */
  export type User$publishedAnnouncementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    where?: AnnouncementWhereInput
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    cursor?: AnnouncementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * User.deptMemberships
   */
  export type User$deptMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentMember
     */
    select?: DepartmentMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentMember
     */
    omit?: DepartmentMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentMemberInclude<ExtArgs> | null
    where?: DepartmentMemberWhereInput
    orderBy?: DepartmentMemberOrderByWithRelationInput | DepartmentMemberOrderByWithRelationInput[]
    cursor?: DepartmentMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentMemberScalarFieldEnum | DepartmentMemberScalarFieldEnum[]
  }

  /**
   * User.groupMemberships
   */
  export type User$groupMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    where?: GroupMemberWhereInput
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    cursor?: GroupMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * User.sentMessages
   */
  export type User$sentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.orgMemberships
   */
  export type User$orgMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    where?: OrganizationMemberWhereInput
    orderBy?: OrganizationMemberOrderByWithRelationInput | OrganizationMemberOrderByWithRelationInput[]
    cursor?: OrganizationMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrganizationMemberScalarFieldEnum | OrganizationMemberScalarFieldEnum[]
  }

  /**
   * User.userPage
   */
  export type User$userPageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPage
     */
    select?: UserPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPage
     */
    omit?: UserPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPageInclude<ExtArgs> | null
    where?: UserPageWhereInput
  }

  /**
   * User.likes
   */
  export type User$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    where?: LikeWhereInput
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    cursor?: LikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User.postReads
   */
  export type User$postReadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostRead
     */
    select?: PostReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostRead
     */
    omit?: PostReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostReadInclude<ExtArgs> | null
    where?: PostReadWhereInput
    orderBy?: PostReadOrderByWithRelationInput | PostReadOrderByWithRelationInput[]
    cursor?: PostReadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostReadScalarFieldEnum | PostReadScalarFieldEnum[]
  }

  /**
   * User.assignedTasks
   */
  export type User$assignedTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * User.createdTasks
   */
  export type User$createdTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * User.headedDepartments
   */
  export type User$headedDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    cursor?: DepartmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * User.taskMessages
   */
  export type User$taskMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskMessage
     */
    select?: TaskMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskMessage
     */
    omit?: TaskMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskMessageInclude<ExtArgs> | null
    where?: TaskMessageWhereInput
    orderBy?: TaskMessageOrderByWithRelationInput | TaskMessageOrderByWithRelationInput[]
    cursor?: TaskMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskMessageScalarFieldEnum | TaskMessageScalarFieldEnum[]
  }

  /**
   * User.departmentMonthlyReports
   */
  export type User$departmentMonthlyReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentMonthlyReport
     */
    select?: DepartmentMonthlyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentMonthlyReport
     */
    omit?: DepartmentMonthlyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentMonthlyReportInclude<ExtArgs> | null
    where?: DepartmentMonthlyReportWhereInput
    orderBy?: DepartmentMonthlyReportOrderByWithRelationInput | DepartmentMonthlyReportOrderByWithRelationInput[]
    cursor?: DepartmentMonthlyReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentMonthlyReportScalarFieldEnum | DepartmentMonthlyReportScalarFieldEnum[]
  }

  /**
   * User.createdMeetings
   */
  export type User$createdMeetingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentMeeting
     */
    select?: DepartmentMeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentMeeting
     */
    omit?: DepartmentMeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentMeetingInclude<ExtArgs> | null
    where?: DepartmentMeetingWhereInput
    orderBy?: DepartmentMeetingOrderByWithRelationInput | DepartmentMeetingOrderByWithRelationInput[]
    cursor?: DepartmentMeetingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentMeetingScalarFieldEnum | DepartmentMeetingScalarFieldEnum[]
  }

  /**
   * User.createdPolls
   */
  export type User$createdPollsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentPoll
     */
    select?: DepartmentPollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentPoll
     */
    omit?: DepartmentPollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentPollInclude<ExtArgs> | null
    where?: DepartmentPollWhereInput
    orderBy?: DepartmentPollOrderByWithRelationInput | DepartmentPollOrderByWithRelationInput[]
    cursor?: DepartmentPollWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentPollScalarFieldEnum | DepartmentPollScalarFieldEnum[]
  }

  /**
   * User.createdDecisions
   */
  export type User$createdDecisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamDecision
     */
    select?: TeamDecisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamDecision
     */
    omit?: TeamDecisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamDecisionInclude<ExtArgs> | null
    where?: TeamDecisionWhereInput
    orderBy?: TeamDecisionOrderByWithRelationInput | TeamDecisionOrderByWithRelationInput[]
    cursor?: TeamDecisionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamDecisionScalarFieldEnum | TeamDecisionScalarFieldEnum[]
  }

  /**
   * User.pollVotes
   */
  export type User$pollVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null
    where?: PollVoteWhereInput
    orderBy?: PollVoteOrderByWithRelationInput | PollVoteOrderByWithRelationInput[]
    cursor?: PollVoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PollVoteScalarFieldEnum | PollVoteScalarFieldEnum[]
  }

  /**
   * User.decisionVotes
   */
  export type User$decisionVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionVote
     */
    select?: DecisionVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DecisionVote
     */
    omit?: DecisionVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionVoteInclude<ExtArgs> | null
    where?: DecisionVoteWhereInput
    orderBy?: DecisionVoteOrderByWithRelationInput | DecisionVoteOrderByWithRelationInput[]
    cursor?: DecisionVoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DecisionVoteScalarFieldEnum | DecisionVoteScalarFieldEnum[]
  }

  /**
   * User.pushSubscriptions
   */
  export type User$pushSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    where?: PushSubscriptionWhereInput
    orderBy?: PushSubscriptionOrderByWithRelationInput | PushSubscriptionOrderByWithRelationInput[]
    cursor?: PushSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PushSubscriptionScalarFieldEnum | PushSubscriptionScalarFieldEnum[]
  }

  /**
   * User.invitations
   */
  export type User$invitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInvitation
     */
    omit?: UserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
    where?: UserInvitationWhereInput
    orderBy?: UserInvitationOrderByWithRelationInput | UserInvitationOrderByWithRelationInput[]
    cursor?: UserInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserInvitationScalarFieldEnum | UserInvitationScalarFieldEnum[]
  }

  /**
   * User.personalTasks
   */
  export type User$personalTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPersonalTask
     */
    select?: UserPersonalTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPersonalTask
     */
    omit?: UserPersonalTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPersonalTaskInclude<ExtArgs> | null
    where?: UserPersonalTaskWhereInput
    orderBy?: UserPersonalTaskOrderByWithRelationInput | UserPersonalTaskOrderByWithRelationInput[]
    cursor?: UserPersonalTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPersonalTaskScalarFieldEnum | UserPersonalTaskScalarFieldEnum[]
  }

  /**
   * User.financialGoals
   */
  export type User$financialGoalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinancialGoal
     */
    select?: UserFinancialGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinancialGoal
     */
    omit?: UserFinancialGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinancialGoalInclude<ExtArgs> | null
    where?: UserFinancialGoalWhereInput
    orderBy?: UserFinancialGoalOrderByWithRelationInput | UserFinancialGoalOrderByWithRelationInput[]
    cursor?: UserFinancialGoalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserFinancialGoalScalarFieldEnum | UserFinancialGoalScalarFieldEnum[]
  }

  /**
   * User.financialProfile
   */
  export type User$financialProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinancialProfile
     */
    select?: UserFinancialProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinancialProfile
     */
    omit?: UserFinancialProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinancialProfileInclude<ExtArgs> | null
    where?: UserFinancialProfileWhereInput
  }

  /**
   * User.monthlyStatements
   */
  export type User$monthlyStatementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMonthlyStatement
     */
    select?: UserMonthlyStatementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMonthlyStatement
     */
    omit?: UserMonthlyStatementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMonthlyStatementInclude<ExtArgs> | null
    where?: UserMonthlyStatementWhereInput
    orderBy?: UserMonthlyStatementOrderByWithRelationInput | UserMonthlyStatementOrderByWithRelationInput[]
    cursor?: UserMonthlyStatementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserMonthlyStatementScalarFieldEnum | UserMonthlyStatementScalarFieldEnum[]
  }

  /**
   * User.financialEntries
   */
  export type User$financialEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinancialEntry
     */
    select?: UserFinancialEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinancialEntry
     */
    omit?: UserFinancialEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinancialEntryInclude<ExtArgs> | null
    where?: UserFinancialEntryWhereInput
    orderBy?: UserFinancialEntryOrderByWithRelationInput | UserFinancialEntryOrderByWithRelationInput[]
    cursor?: UserFinancialEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserFinancialEntryScalarFieldEnum | UserFinancialEntryScalarFieldEnum[]
  }

  /**
   * User.followers
   */
  export type User$followersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    where?: FollowWhereInput
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    cursor?: FollowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * User.following
   */
  export type User$followingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    where?: FollowWhereInput
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    cursor?: FollowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * User.uploadedDepartmentDocuments
   */
  export type User$uploadedDepartmentDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentDocument
     */
    select?: DepartmentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentDocument
     */
    omit?: DepartmentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentDocumentInclude<ExtArgs> | null
    where?: DepartmentDocumentWhereInput
    orderBy?: DepartmentDocumentOrderByWithRelationInput | DepartmentDocumentOrderByWithRelationInput[]
    cursor?: DepartmentDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentDocumentScalarFieldEnum | DepartmentDocumentScalarFieldEnum[]
  }

  /**
   * User.groupNotes
   */
  export type User$groupNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupNote
     */
    select?: GroupNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupNote
     */
    omit?: GroupNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupNoteInclude<ExtArgs> | null
    where?: GroupNoteWhereInput
    orderBy?: GroupNoteOrderByWithRelationInput | GroupNoteOrderByWithRelationInput[]
    cursor?: GroupNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupNoteScalarFieldEnum | GroupNoteScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserInvitation
   */

  export type AggregateUserInvitation = {
    _count: UserInvitationCountAggregateOutputType | null
    _avg: UserInvitationAvgAggregateOutputType | null
    _sum: UserInvitationSumAggregateOutputType | null
    _min: UserInvitationMinAggregateOutputType | null
    _max: UserInvitationMaxAggregateOutputType | null
  }

  export type UserInvitationAvgAggregateOutputType = {
    maxGuests: number | null
  }

  export type UserInvitationSumAggregateOutputType = {
    maxGuests: number | null
  }

  export type UserInvitationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    status: $Enums.InvitationStatus | null
    title: string | null
    description: string | null
    imageBase64: string | null
    type: $Enums.InvitationType | null
    date: Date | null
    location: string | null
    maxGuests: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserInvitationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    status: $Enums.InvitationStatus | null
    title: string | null
    description: string | null
    imageBase64: string | null
    type: $Enums.InvitationType | null
    date: Date | null
    location: string | null
    maxGuests: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserInvitationCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    status: number
    title: number
    description: number
    imageBase64: number
    type: number
    date: number
    location: number
    maxGuests: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserInvitationAvgAggregateInputType = {
    maxGuests?: true
  }

  export type UserInvitationSumAggregateInputType = {
    maxGuests?: true
  }

  export type UserInvitationMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    status?: true
    title?: true
    description?: true
    imageBase64?: true
    type?: true
    date?: true
    location?: true
    maxGuests?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserInvitationMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    status?: true
    title?: true
    description?: true
    imageBase64?: true
    type?: true
    date?: true
    location?: true
    maxGuests?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserInvitationCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    status?: true
    title?: true
    description?: true
    imageBase64?: true
    type?: true
    date?: true
    location?: true
    maxGuests?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserInvitationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserInvitation to aggregate.
     */
    where?: UserInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInvitations to fetch.
     */
    orderBy?: UserInvitationOrderByWithRelationInput | UserInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserInvitations
    **/
    _count?: true | UserInvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserInvitationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserInvitationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserInvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserInvitationMaxAggregateInputType
  }

  export type GetUserInvitationAggregateType<T extends UserInvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateUserInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserInvitation[P]>
      : GetScalarType<T[P], AggregateUserInvitation[P]>
  }




  export type UserInvitationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserInvitationWhereInput
    orderBy?: UserInvitationOrderByWithAggregationInput | UserInvitationOrderByWithAggregationInput[]
    by: UserInvitationScalarFieldEnum[] | UserInvitationScalarFieldEnum
    having?: UserInvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserInvitationCountAggregateInputType | true
    _avg?: UserInvitationAvgAggregateInputType
    _sum?: UserInvitationSumAggregateInputType
    _min?: UserInvitationMinAggregateInputType
    _max?: UserInvitationMaxAggregateInputType
  }

  export type UserInvitationGroupByOutputType = {
    id: string
    userId: string
    token: string
    status: $Enums.InvitationStatus
    title: string
    description: string | null
    imageBase64: string | null
    type: $Enums.InvitationType
    date: Date
    location: string
    maxGuests: number | null
    createdAt: Date
    updatedAt: Date
    _count: UserInvitationCountAggregateOutputType | null
    _avg: UserInvitationAvgAggregateOutputType | null
    _sum: UserInvitationSumAggregateOutputType | null
    _min: UserInvitationMinAggregateOutputType | null
    _max: UserInvitationMaxAggregateOutputType | null
  }

  type GetUserInvitationGroupByPayload<T extends UserInvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserInvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserInvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserInvitationGroupByOutputType[P]>
            : GetScalarType<T[P], UserInvitationGroupByOutputType[P]>
        }
      >
    >


  export type UserInvitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    status?: boolean
    title?: boolean
    description?: boolean
    imageBase64?: boolean
    type?: boolean
    date?: boolean
    location?: boolean
    maxGuests?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    guests?: boolean | UserInvitation$guestsArgs<ExtArgs>
    _count?: boolean | UserInvitationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userInvitation"]>

  export type UserInvitationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    status?: boolean
    title?: boolean
    description?: boolean
    imageBase64?: boolean
    type?: boolean
    date?: boolean
    location?: boolean
    maxGuests?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userInvitation"]>

  export type UserInvitationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    status?: boolean
    title?: boolean
    description?: boolean
    imageBase64?: boolean
    type?: boolean
    date?: boolean
    location?: boolean
    maxGuests?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userInvitation"]>

  export type UserInvitationSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    status?: boolean
    title?: boolean
    description?: boolean
    imageBase64?: boolean
    type?: boolean
    date?: boolean
    location?: boolean
    maxGuests?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInvitationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "status" | "title" | "description" | "imageBase64" | "type" | "date" | "location" | "maxGuests" | "createdAt" | "updatedAt", ExtArgs["result"]["userInvitation"]>
  export type UserInvitationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    guests?: boolean | UserInvitation$guestsArgs<ExtArgs>
    _count?: boolean | UserInvitationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserInvitationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserInvitationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserInvitationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserInvitation"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      guests: Prisma.$InvitationGuestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      status: $Enums.InvitationStatus
      title: string
      description: string | null
      imageBase64: string | null
      type: $Enums.InvitationType
      date: Date
      location: string
      maxGuests: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userInvitation"]>
    composites: {}
  }

  type UserInvitationGetPayload<S extends boolean | null | undefined | UserInvitationDefaultArgs> = $Result.GetResult<Prisma.$UserInvitationPayload, S>

  type UserInvitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserInvitationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserInvitationCountAggregateInputType | true
    }

  export interface UserInvitationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserInvitation'], meta: { name: 'UserInvitation' } }
    /**
     * Find zero or one UserInvitation that matches the filter.
     * @param {UserInvitationFindUniqueArgs} args - Arguments to find a UserInvitation
     * @example
     * // Get one UserInvitation
     * const userInvitation = await prisma.userInvitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserInvitationFindUniqueArgs>(args: SelectSubset<T, UserInvitationFindUniqueArgs<ExtArgs>>): Prisma__UserInvitationClient<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserInvitation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserInvitationFindUniqueOrThrowArgs} args - Arguments to find a UserInvitation
     * @example
     * // Get one UserInvitation
     * const userInvitation = await prisma.userInvitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserInvitationFindUniqueOrThrowArgs>(args: SelectSubset<T, UserInvitationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserInvitationClient<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserInvitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInvitationFindFirstArgs} args - Arguments to find a UserInvitation
     * @example
     * // Get one UserInvitation
     * const userInvitation = await prisma.userInvitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserInvitationFindFirstArgs>(args?: SelectSubset<T, UserInvitationFindFirstArgs<ExtArgs>>): Prisma__UserInvitationClient<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserInvitation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInvitationFindFirstOrThrowArgs} args - Arguments to find a UserInvitation
     * @example
     * // Get one UserInvitation
     * const userInvitation = await prisma.userInvitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserInvitationFindFirstOrThrowArgs>(args?: SelectSubset<T, UserInvitationFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserInvitationClient<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserInvitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInvitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserInvitations
     * const userInvitations = await prisma.userInvitation.findMany()
     * 
     * // Get first 10 UserInvitations
     * const userInvitations = await prisma.userInvitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userInvitationWithIdOnly = await prisma.userInvitation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserInvitationFindManyArgs>(args?: SelectSubset<T, UserInvitationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserInvitation.
     * @param {UserInvitationCreateArgs} args - Arguments to create a UserInvitation.
     * @example
     * // Create one UserInvitation
     * const UserInvitation = await prisma.userInvitation.create({
     *   data: {
     *     // ... data to create a UserInvitation
     *   }
     * })
     * 
     */
    create<T extends UserInvitationCreateArgs>(args: SelectSubset<T, UserInvitationCreateArgs<ExtArgs>>): Prisma__UserInvitationClient<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserInvitations.
     * @param {UserInvitationCreateManyArgs} args - Arguments to create many UserInvitations.
     * @example
     * // Create many UserInvitations
     * const userInvitation = await prisma.userInvitation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserInvitationCreateManyArgs>(args?: SelectSubset<T, UserInvitationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserInvitations and returns the data saved in the database.
     * @param {UserInvitationCreateManyAndReturnArgs} args - Arguments to create many UserInvitations.
     * @example
     * // Create many UserInvitations
     * const userInvitation = await prisma.userInvitation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserInvitations and only return the `id`
     * const userInvitationWithIdOnly = await prisma.userInvitation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserInvitationCreateManyAndReturnArgs>(args?: SelectSubset<T, UserInvitationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserInvitation.
     * @param {UserInvitationDeleteArgs} args - Arguments to delete one UserInvitation.
     * @example
     * // Delete one UserInvitation
     * const UserInvitation = await prisma.userInvitation.delete({
     *   where: {
     *     // ... filter to delete one UserInvitation
     *   }
     * })
     * 
     */
    delete<T extends UserInvitationDeleteArgs>(args: SelectSubset<T, UserInvitationDeleteArgs<ExtArgs>>): Prisma__UserInvitationClient<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserInvitation.
     * @param {UserInvitationUpdateArgs} args - Arguments to update one UserInvitation.
     * @example
     * // Update one UserInvitation
     * const userInvitation = await prisma.userInvitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserInvitationUpdateArgs>(args: SelectSubset<T, UserInvitationUpdateArgs<ExtArgs>>): Prisma__UserInvitationClient<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserInvitations.
     * @param {UserInvitationDeleteManyArgs} args - Arguments to filter UserInvitations to delete.
     * @example
     * // Delete a few UserInvitations
     * const { count } = await prisma.userInvitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserInvitationDeleteManyArgs>(args?: SelectSubset<T, UserInvitationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserInvitations
     * const userInvitation = await prisma.userInvitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserInvitationUpdateManyArgs>(args: SelectSubset<T, UserInvitationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserInvitations and returns the data updated in the database.
     * @param {UserInvitationUpdateManyAndReturnArgs} args - Arguments to update many UserInvitations.
     * @example
     * // Update many UserInvitations
     * const userInvitation = await prisma.userInvitation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserInvitations and only return the `id`
     * const userInvitationWithIdOnly = await prisma.userInvitation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserInvitationUpdateManyAndReturnArgs>(args: SelectSubset<T, UserInvitationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserInvitation.
     * @param {UserInvitationUpsertArgs} args - Arguments to update or create a UserInvitation.
     * @example
     * // Update or create a UserInvitation
     * const userInvitation = await prisma.userInvitation.upsert({
     *   create: {
     *     // ... data to create a UserInvitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserInvitation we want to update
     *   }
     * })
     */
    upsert<T extends UserInvitationUpsertArgs>(args: SelectSubset<T, UserInvitationUpsertArgs<ExtArgs>>): Prisma__UserInvitationClient<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInvitationCountArgs} args - Arguments to filter UserInvitations to count.
     * @example
     * // Count the number of UserInvitations
     * const count = await prisma.userInvitation.count({
     *   where: {
     *     // ... the filter for the UserInvitations we want to count
     *   }
     * })
    **/
    count<T extends UserInvitationCountArgs>(
      args?: Subset<T, UserInvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserInvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserInvitationAggregateArgs>(args: Subset<T, UserInvitationAggregateArgs>): Prisma.PrismaPromise<GetUserInvitationAggregateType<T>>

    /**
     * Group by UserInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserInvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserInvitationGroupByArgs['orderBy'] }
        : { orderBy?: UserInvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserInvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserInvitation model
   */
  readonly fields: UserInvitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserInvitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserInvitationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    guests<T extends UserInvitation$guestsArgs<ExtArgs> = {}>(args?: Subset<T, UserInvitation$guestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationGuestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserInvitation model
   */
  interface UserInvitationFieldRefs {
    readonly id: FieldRef<"UserInvitation", 'String'>
    readonly userId: FieldRef<"UserInvitation", 'String'>
    readonly token: FieldRef<"UserInvitation", 'String'>
    readonly status: FieldRef<"UserInvitation", 'InvitationStatus'>
    readonly title: FieldRef<"UserInvitation", 'String'>
    readonly description: FieldRef<"UserInvitation", 'String'>
    readonly imageBase64: FieldRef<"UserInvitation", 'String'>
    readonly type: FieldRef<"UserInvitation", 'InvitationType'>
    readonly date: FieldRef<"UserInvitation", 'DateTime'>
    readonly location: FieldRef<"UserInvitation", 'String'>
    readonly maxGuests: FieldRef<"UserInvitation", 'Int'>
    readonly createdAt: FieldRef<"UserInvitation", 'DateTime'>
    readonly updatedAt: FieldRef<"UserInvitation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserInvitation findUnique
   */
  export type UserInvitationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInvitation
     */
    omit?: UserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
    /**
     * Filter, which UserInvitation to fetch.
     */
    where: UserInvitationWhereUniqueInput
  }

  /**
   * UserInvitation findUniqueOrThrow
   */
  export type UserInvitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInvitation
     */
    omit?: UserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
    /**
     * Filter, which UserInvitation to fetch.
     */
    where: UserInvitationWhereUniqueInput
  }

  /**
   * UserInvitation findFirst
   */
  export type UserInvitationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInvitation
     */
    omit?: UserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
    /**
     * Filter, which UserInvitation to fetch.
     */
    where?: UserInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInvitations to fetch.
     */
    orderBy?: UserInvitationOrderByWithRelationInput | UserInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserInvitations.
     */
    cursor?: UserInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserInvitations.
     */
    distinct?: UserInvitationScalarFieldEnum | UserInvitationScalarFieldEnum[]
  }

  /**
   * UserInvitation findFirstOrThrow
   */
  export type UserInvitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInvitation
     */
    omit?: UserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
    /**
     * Filter, which UserInvitation to fetch.
     */
    where?: UserInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInvitations to fetch.
     */
    orderBy?: UserInvitationOrderByWithRelationInput | UserInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserInvitations.
     */
    cursor?: UserInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserInvitations.
     */
    distinct?: UserInvitationScalarFieldEnum | UserInvitationScalarFieldEnum[]
  }

  /**
   * UserInvitation findMany
   */
  export type UserInvitationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInvitation
     */
    omit?: UserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
    /**
     * Filter, which UserInvitations to fetch.
     */
    where?: UserInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInvitations to fetch.
     */
    orderBy?: UserInvitationOrderByWithRelationInput | UserInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserInvitations.
     */
    cursor?: UserInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInvitations.
     */
    skip?: number
    distinct?: UserInvitationScalarFieldEnum | UserInvitationScalarFieldEnum[]
  }

  /**
   * UserInvitation create
   */
  export type UserInvitationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInvitation
     */
    omit?: UserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
    /**
     * The data needed to create a UserInvitation.
     */
    data: XOR<UserInvitationCreateInput, UserInvitationUncheckedCreateInput>
  }

  /**
   * UserInvitation createMany
   */
  export type UserInvitationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserInvitations.
     */
    data: UserInvitationCreateManyInput | UserInvitationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserInvitation createManyAndReturn
   */
  export type UserInvitationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserInvitation
     */
    omit?: UserInvitationOmit<ExtArgs> | null
    /**
     * The data used to create many UserInvitations.
     */
    data: UserInvitationCreateManyInput | UserInvitationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserInvitation update
   */
  export type UserInvitationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInvitation
     */
    omit?: UserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
    /**
     * The data needed to update a UserInvitation.
     */
    data: XOR<UserInvitationUpdateInput, UserInvitationUncheckedUpdateInput>
    /**
     * Choose, which UserInvitation to update.
     */
    where: UserInvitationWhereUniqueInput
  }

  /**
   * UserInvitation updateMany
   */
  export type UserInvitationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserInvitations.
     */
    data: XOR<UserInvitationUpdateManyMutationInput, UserInvitationUncheckedUpdateManyInput>
    /**
     * Filter which UserInvitations to update
     */
    where?: UserInvitationWhereInput
    /**
     * Limit how many UserInvitations to update.
     */
    limit?: number
  }

  /**
   * UserInvitation updateManyAndReturn
   */
  export type UserInvitationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserInvitation
     */
    omit?: UserInvitationOmit<ExtArgs> | null
    /**
     * The data used to update UserInvitations.
     */
    data: XOR<UserInvitationUpdateManyMutationInput, UserInvitationUncheckedUpdateManyInput>
    /**
     * Filter which UserInvitations to update
     */
    where?: UserInvitationWhereInput
    /**
     * Limit how many UserInvitations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserInvitation upsert
   */
  export type UserInvitationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInvitation
     */
    omit?: UserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
    /**
     * The filter to search for the UserInvitation to update in case it exists.
     */
    where: UserInvitationWhereUniqueInput
    /**
     * In case the UserInvitation found by the `where` argument doesn't exist, create a new UserInvitation with this data.
     */
    create: XOR<UserInvitationCreateInput, UserInvitationUncheckedCreateInput>
    /**
     * In case the UserInvitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserInvitationUpdateInput, UserInvitationUncheckedUpdateInput>
  }

  /**
   * UserInvitation delete
   */
  export type UserInvitationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInvitation
     */
    omit?: UserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
    /**
     * Filter which UserInvitation to delete.
     */
    where: UserInvitationWhereUniqueInput
  }

  /**
   * UserInvitation deleteMany
   */
  export type UserInvitationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserInvitations to delete
     */
    where?: UserInvitationWhereInput
    /**
     * Limit how many UserInvitations to delete.
     */
    limit?: number
  }

  /**
   * UserInvitation.guests
   */
  export type UserInvitation$guestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationGuest
     */
    select?: InvitationGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationGuest
     */
    omit?: InvitationGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationGuestInclude<ExtArgs> | null
    where?: InvitationGuestWhereInput
    orderBy?: InvitationGuestOrderByWithRelationInput | InvitationGuestOrderByWithRelationInput[]
    cursor?: InvitationGuestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvitationGuestScalarFieldEnum | InvitationGuestScalarFieldEnum[]
  }

  /**
   * UserInvitation without action
   */
  export type UserInvitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInvitation
     */
    omit?: UserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
  }


  /**
   * Model InvitationGuest
   */

  export type AggregateInvitationGuest = {
    _count: InvitationGuestCountAggregateOutputType | null
    _min: InvitationGuestMinAggregateOutputType | null
    _max: InvitationGuestMaxAggregateOutputType | null
  }

  export type InvitationGuestMinAggregateOutputType = {
    id: string | null
    invitationId: string | null
    name: string | null
    phone: string | null
    confirmedAt: Date | null
  }

  export type InvitationGuestMaxAggregateOutputType = {
    id: string | null
    invitationId: string | null
    name: string | null
    phone: string | null
    confirmedAt: Date | null
  }

  export type InvitationGuestCountAggregateOutputType = {
    id: number
    invitationId: number
    name: number
    phone: number
    confirmedAt: number
    _all: number
  }


  export type InvitationGuestMinAggregateInputType = {
    id?: true
    invitationId?: true
    name?: true
    phone?: true
    confirmedAt?: true
  }

  export type InvitationGuestMaxAggregateInputType = {
    id?: true
    invitationId?: true
    name?: true
    phone?: true
    confirmedAt?: true
  }

  export type InvitationGuestCountAggregateInputType = {
    id?: true
    invitationId?: true
    name?: true
    phone?: true
    confirmedAt?: true
    _all?: true
  }

  export type InvitationGuestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvitationGuest to aggregate.
     */
    where?: InvitationGuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvitationGuests to fetch.
     */
    orderBy?: InvitationGuestOrderByWithRelationInput | InvitationGuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvitationGuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvitationGuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvitationGuests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvitationGuests
    **/
    _count?: true | InvitationGuestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvitationGuestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvitationGuestMaxAggregateInputType
  }

  export type GetInvitationGuestAggregateType<T extends InvitationGuestAggregateArgs> = {
        [P in keyof T & keyof AggregateInvitationGuest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvitationGuest[P]>
      : GetScalarType<T[P], AggregateInvitationGuest[P]>
  }




  export type InvitationGuestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationGuestWhereInput
    orderBy?: InvitationGuestOrderByWithAggregationInput | InvitationGuestOrderByWithAggregationInput[]
    by: InvitationGuestScalarFieldEnum[] | InvitationGuestScalarFieldEnum
    having?: InvitationGuestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvitationGuestCountAggregateInputType | true
    _min?: InvitationGuestMinAggregateInputType
    _max?: InvitationGuestMaxAggregateInputType
  }

  export type InvitationGuestGroupByOutputType = {
    id: string
    invitationId: string
    name: string
    phone: string
    confirmedAt: Date
    _count: InvitationGuestCountAggregateOutputType | null
    _min: InvitationGuestMinAggregateOutputType | null
    _max: InvitationGuestMaxAggregateOutputType | null
  }

  type GetInvitationGuestGroupByPayload<T extends InvitationGuestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvitationGuestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvitationGuestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvitationGuestGroupByOutputType[P]>
            : GetScalarType<T[P], InvitationGuestGroupByOutputType[P]>
        }
      >
    >


  export type InvitationGuestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invitationId?: boolean
    name?: boolean
    phone?: boolean
    confirmedAt?: boolean
    invitation?: boolean | UserInvitationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitationGuest"]>

  export type InvitationGuestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invitationId?: boolean
    name?: boolean
    phone?: boolean
    confirmedAt?: boolean
    invitation?: boolean | UserInvitationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitationGuest"]>

  export type InvitationGuestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invitationId?: boolean
    name?: boolean
    phone?: boolean
    confirmedAt?: boolean
    invitation?: boolean | UserInvitationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitationGuest"]>

  export type InvitationGuestSelectScalar = {
    id?: boolean
    invitationId?: boolean
    name?: boolean
    phone?: boolean
    confirmedAt?: boolean
  }

  export type InvitationGuestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invitationId" | "name" | "phone" | "confirmedAt", ExtArgs["result"]["invitationGuest"]>
  export type InvitationGuestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invitation?: boolean | UserInvitationDefaultArgs<ExtArgs>
  }
  export type InvitationGuestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invitation?: boolean | UserInvitationDefaultArgs<ExtArgs>
  }
  export type InvitationGuestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invitation?: boolean | UserInvitationDefaultArgs<ExtArgs>
  }

  export type $InvitationGuestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvitationGuest"
    objects: {
      invitation: Prisma.$UserInvitationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invitationId: string
      name: string
      phone: string
      confirmedAt: Date
    }, ExtArgs["result"]["invitationGuest"]>
    composites: {}
  }

  type InvitationGuestGetPayload<S extends boolean | null | undefined | InvitationGuestDefaultArgs> = $Result.GetResult<Prisma.$InvitationGuestPayload, S>

  type InvitationGuestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvitationGuestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvitationGuestCountAggregateInputType | true
    }

  export interface InvitationGuestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvitationGuest'], meta: { name: 'InvitationGuest' } }
    /**
     * Find zero or one InvitationGuest that matches the filter.
     * @param {InvitationGuestFindUniqueArgs} args - Arguments to find a InvitationGuest
     * @example
     * // Get one InvitationGuest
     * const invitationGuest = await prisma.invitationGuest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvitationGuestFindUniqueArgs>(args: SelectSubset<T, InvitationGuestFindUniqueArgs<ExtArgs>>): Prisma__InvitationGuestClient<$Result.GetResult<Prisma.$InvitationGuestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InvitationGuest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvitationGuestFindUniqueOrThrowArgs} args - Arguments to find a InvitationGuest
     * @example
     * // Get one InvitationGuest
     * const invitationGuest = await prisma.invitationGuest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvitationGuestFindUniqueOrThrowArgs>(args: SelectSubset<T, InvitationGuestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvitationGuestClient<$Result.GetResult<Prisma.$InvitationGuestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvitationGuest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationGuestFindFirstArgs} args - Arguments to find a InvitationGuest
     * @example
     * // Get one InvitationGuest
     * const invitationGuest = await prisma.invitationGuest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvitationGuestFindFirstArgs>(args?: SelectSubset<T, InvitationGuestFindFirstArgs<ExtArgs>>): Prisma__InvitationGuestClient<$Result.GetResult<Prisma.$InvitationGuestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvitationGuest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationGuestFindFirstOrThrowArgs} args - Arguments to find a InvitationGuest
     * @example
     * // Get one InvitationGuest
     * const invitationGuest = await prisma.invitationGuest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvitationGuestFindFirstOrThrowArgs>(args?: SelectSubset<T, InvitationGuestFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvitationGuestClient<$Result.GetResult<Prisma.$InvitationGuestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InvitationGuests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationGuestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvitationGuests
     * const invitationGuests = await prisma.invitationGuest.findMany()
     * 
     * // Get first 10 InvitationGuests
     * const invitationGuests = await prisma.invitationGuest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invitationGuestWithIdOnly = await prisma.invitationGuest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvitationGuestFindManyArgs>(args?: SelectSubset<T, InvitationGuestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationGuestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InvitationGuest.
     * @param {InvitationGuestCreateArgs} args - Arguments to create a InvitationGuest.
     * @example
     * // Create one InvitationGuest
     * const InvitationGuest = await prisma.invitationGuest.create({
     *   data: {
     *     // ... data to create a InvitationGuest
     *   }
     * })
     * 
     */
    create<T extends InvitationGuestCreateArgs>(args: SelectSubset<T, InvitationGuestCreateArgs<ExtArgs>>): Prisma__InvitationGuestClient<$Result.GetResult<Prisma.$InvitationGuestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InvitationGuests.
     * @param {InvitationGuestCreateManyArgs} args - Arguments to create many InvitationGuests.
     * @example
     * // Create many InvitationGuests
     * const invitationGuest = await prisma.invitationGuest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvitationGuestCreateManyArgs>(args?: SelectSubset<T, InvitationGuestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvitationGuests and returns the data saved in the database.
     * @param {InvitationGuestCreateManyAndReturnArgs} args - Arguments to create many InvitationGuests.
     * @example
     * // Create many InvitationGuests
     * const invitationGuest = await prisma.invitationGuest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvitationGuests and only return the `id`
     * const invitationGuestWithIdOnly = await prisma.invitationGuest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvitationGuestCreateManyAndReturnArgs>(args?: SelectSubset<T, InvitationGuestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationGuestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InvitationGuest.
     * @param {InvitationGuestDeleteArgs} args - Arguments to delete one InvitationGuest.
     * @example
     * // Delete one InvitationGuest
     * const InvitationGuest = await prisma.invitationGuest.delete({
     *   where: {
     *     // ... filter to delete one InvitationGuest
     *   }
     * })
     * 
     */
    delete<T extends InvitationGuestDeleteArgs>(args: SelectSubset<T, InvitationGuestDeleteArgs<ExtArgs>>): Prisma__InvitationGuestClient<$Result.GetResult<Prisma.$InvitationGuestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InvitationGuest.
     * @param {InvitationGuestUpdateArgs} args - Arguments to update one InvitationGuest.
     * @example
     * // Update one InvitationGuest
     * const invitationGuest = await prisma.invitationGuest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvitationGuestUpdateArgs>(args: SelectSubset<T, InvitationGuestUpdateArgs<ExtArgs>>): Prisma__InvitationGuestClient<$Result.GetResult<Prisma.$InvitationGuestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InvitationGuests.
     * @param {InvitationGuestDeleteManyArgs} args - Arguments to filter InvitationGuests to delete.
     * @example
     * // Delete a few InvitationGuests
     * const { count } = await prisma.invitationGuest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvitationGuestDeleteManyArgs>(args?: SelectSubset<T, InvitationGuestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvitationGuests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationGuestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvitationGuests
     * const invitationGuest = await prisma.invitationGuest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvitationGuestUpdateManyArgs>(args: SelectSubset<T, InvitationGuestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvitationGuests and returns the data updated in the database.
     * @param {InvitationGuestUpdateManyAndReturnArgs} args - Arguments to update many InvitationGuests.
     * @example
     * // Update many InvitationGuests
     * const invitationGuest = await prisma.invitationGuest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InvitationGuests and only return the `id`
     * const invitationGuestWithIdOnly = await prisma.invitationGuest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvitationGuestUpdateManyAndReturnArgs>(args: SelectSubset<T, InvitationGuestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationGuestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InvitationGuest.
     * @param {InvitationGuestUpsertArgs} args - Arguments to update or create a InvitationGuest.
     * @example
     * // Update or create a InvitationGuest
     * const invitationGuest = await prisma.invitationGuest.upsert({
     *   create: {
     *     // ... data to create a InvitationGuest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvitationGuest we want to update
     *   }
     * })
     */
    upsert<T extends InvitationGuestUpsertArgs>(args: SelectSubset<T, InvitationGuestUpsertArgs<ExtArgs>>): Prisma__InvitationGuestClient<$Result.GetResult<Prisma.$InvitationGuestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InvitationGuests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationGuestCountArgs} args - Arguments to filter InvitationGuests to count.
     * @example
     * // Count the number of InvitationGuests
     * const count = await prisma.invitationGuest.count({
     *   where: {
     *     // ... the filter for the InvitationGuests we want to count
     *   }
     * })
    **/
    count<T extends InvitationGuestCountArgs>(
      args?: Subset<T, InvitationGuestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvitationGuestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvitationGuest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationGuestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvitationGuestAggregateArgs>(args: Subset<T, InvitationGuestAggregateArgs>): Prisma.PrismaPromise<GetInvitationGuestAggregateType<T>>

    /**
     * Group by InvitationGuest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationGuestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvitationGuestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvitationGuestGroupByArgs['orderBy'] }
        : { orderBy?: InvitationGuestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvitationGuestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvitationGuestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvitationGuest model
   */
  readonly fields: InvitationGuestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvitationGuest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvitationGuestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invitation<T extends UserInvitationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserInvitationDefaultArgs<ExtArgs>>): Prisma__UserInvitationClient<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvitationGuest model
   */
  interface InvitationGuestFieldRefs {
    readonly id: FieldRef<"InvitationGuest", 'String'>
    readonly invitationId: FieldRef<"InvitationGuest", 'String'>
    readonly name: FieldRef<"InvitationGuest", 'String'>
    readonly phone: FieldRef<"InvitationGuest", 'String'>
    readonly confirmedAt: FieldRef<"InvitationGuest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InvitationGuest findUnique
   */
  export type InvitationGuestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationGuest
     */
    select?: InvitationGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationGuest
     */
    omit?: InvitationGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationGuestInclude<ExtArgs> | null
    /**
     * Filter, which InvitationGuest to fetch.
     */
    where: InvitationGuestWhereUniqueInput
  }

  /**
   * InvitationGuest findUniqueOrThrow
   */
  export type InvitationGuestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationGuest
     */
    select?: InvitationGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationGuest
     */
    omit?: InvitationGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationGuestInclude<ExtArgs> | null
    /**
     * Filter, which InvitationGuest to fetch.
     */
    where: InvitationGuestWhereUniqueInput
  }

  /**
   * InvitationGuest findFirst
   */
  export type InvitationGuestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationGuest
     */
    select?: InvitationGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationGuest
     */
    omit?: InvitationGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationGuestInclude<ExtArgs> | null
    /**
     * Filter, which InvitationGuest to fetch.
     */
    where?: InvitationGuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvitationGuests to fetch.
     */
    orderBy?: InvitationGuestOrderByWithRelationInput | InvitationGuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvitationGuests.
     */
    cursor?: InvitationGuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvitationGuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvitationGuests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvitationGuests.
     */
    distinct?: InvitationGuestScalarFieldEnum | InvitationGuestScalarFieldEnum[]
  }

  /**
   * InvitationGuest findFirstOrThrow
   */
  export type InvitationGuestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationGuest
     */
    select?: InvitationGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationGuest
     */
    omit?: InvitationGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationGuestInclude<ExtArgs> | null
    /**
     * Filter, which InvitationGuest to fetch.
     */
    where?: InvitationGuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvitationGuests to fetch.
     */
    orderBy?: InvitationGuestOrderByWithRelationInput | InvitationGuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvitationGuests.
     */
    cursor?: InvitationGuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvitationGuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvitationGuests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvitationGuests.
     */
    distinct?: InvitationGuestScalarFieldEnum | InvitationGuestScalarFieldEnum[]
  }

  /**
   * InvitationGuest findMany
   */
  export type InvitationGuestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationGuest
     */
    select?: InvitationGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationGuest
     */
    omit?: InvitationGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationGuestInclude<ExtArgs> | null
    /**
     * Filter, which InvitationGuests to fetch.
     */
    where?: InvitationGuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvitationGuests to fetch.
     */
    orderBy?: InvitationGuestOrderByWithRelationInput | InvitationGuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvitationGuests.
     */
    cursor?: InvitationGuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvitationGuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvitationGuests.
     */
    skip?: number
    distinct?: InvitationGuestScalarFieldEnum | InvitationGuestScalarFieldEnum[]
  }

  /**
   * InvitationGuest create
   */
  export type InvitationGuestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationGuest
     */
    select?: InvitationGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationGuest
     */
    omit?: InvitationGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationGuestInclude<ExtArgs> | null
    /**
     * The data needed to create a InvitationGuest.
     */
    data: XOR<InvitationGuestCreateInput, InvitationGuestUncheckedCreateInput>
  }

  /**
   * InvitationGuest createMany
   */
  export type InvitationGuestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvitationGuests.
     */
    data: InvitationGuestCreateManyInput | InvitationGuestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvitationGuest createManyAndReturn
   */
  export type InvitationGuestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationGuest
     */
    select?: InvitationGuestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationGuest
     */
    omit?: InvitationGuestOmit<ExtArgs> | null
    /**
     * The data used to create many InvitationGuests.
     */
    data: InvitationGuestCreateManyInput | InvitationGuestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationGuestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvitationGuest update
   */
  export type InvitationGuestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationGuest
     */
    select?: InvitationGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationGuest
     */
    omit?: InvitationGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationGuestInclude<ExtArgs> | null
    /**
     * The data needed to update a InvitationGuest.
     */
    data: XOR<InvitationGuestUpdateInput, InvitationGuestUncheckedUpdateInput>
    /**
     * Choose, which InvitationGuest to update.
     */
    where: InvitationGuestWhereUniqueInput
  }

  /**
   * InvitationGuest updateMany
   */
  export type InvitationGuestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvitationGuests.
     */
    data: XOR<InvitationGuestUpdateManyMutationInput, InvitationGuestUncheckedUpdateManyInput>
    /**
     * Filter which InvitationGuests to update
     */
    where?: InvitationGuestWhereInput
    /**
     * Limit how many InvitationGuests to update.
     */
    limit?: number
  }

  /**
   * InvitationGuest updateManyAndReturn
   */
  export type InvitationGuestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationGuest
     */
    select?: InvitationGuestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationGuest
     */
    omit?: InvitationGuestOmit<ExtArgs> | null
    /**
     * The data used to update InvitationGuests.
     */
    data: XOR<InvitationGuestUpdateManyMutationInput, InvitationGuestUncheckedUpdateManyInput>
    /**
     * Filter which InvitationGuests to update
     */
    where?: InvitationGuestWhereInput
    /**
     * Limit how many InvitationGuests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationGuestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvitationGuest upsert
   */
  export type InvitationGuestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationGuest
     */
    select?: InvitationGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationGuest
     */
    omit?: InvitationGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationGuestInclude<ExtArgs> | null
    /**
     * The filter to search for the InvitationGuest to update in case it exists.
     */
    where: InvitationGuestWhereUniqueInput
    /**
     * In case the InvitationGuest found by the `where` argument doesn't exist, create a new InvitationGuest with this data.
     */
    create: XOR<InvitationGuestCreateInput, InvitationGuestUncheckedCreateInput>
    /**
     * In case the InvitationGuest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvitationGuestUpdateInput, InvitationGuestUncheckedUpdateInput>
  }

  /**
   * InvitationGuest delete
   */
  export type InvitationGuestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationGuest
     */
    select?: InvitationGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationGuest
     */
    omit?: InvitationGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationGuestInclude<ExtArgs> | null
    /**
     * Filter which InvitationGuest to delete.
     */
    where: InvitationGuestWhereUniqueInput
  }

  /**
   * InvitationGuest deleteMany
   */
  export type InvitationGuestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvitationGuests to delete
     */
    where?: InvitationGuestWhereInput
    /**
     * Limit how many InvitationGuests to delete.
     */
    limit?: number
  }

  /**
   * InvitationGuest without action
   */
  export type InvitationGuestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationGuest
     */
    select?: InvitationGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationGuest
     */
    omit?: InvitationGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationGuestInclude<ExtArgs> | null
  }


  /**
   * Model Follow
   */

  export type AggregateFollow = {
    _count: FollowCountAggregateOutputType | null
    _min: FollowMinAggregateOutputType | null
    _max: FollowMaxAggregateOutputType | null
  }

  export type FollowMinAggregateOutputType = {
    id: string | null
    followerId: string | null
    followingId: string | null
    createdAt: Date | null
  }

  export type FollowMaxAggregateOutputType = {
    id: string | null
    followerId: string | null
    followingId: string | null
    createdAt: Date | null
  }

  export type FollowCountAggregateOutputType = {
    id: number
    followerId: number
    followingId: number
    createdAt: number
    _all: number
  }


  export type FollowMinAggregateInputType = {
    id?: true
    followerId?: true
    followingId?: true
    createdAt?: true
  }

  export type FollowMaxAggregateInputType = {
    id?: true
    followerId?: true
    followingId?: true
    createdAt?: true
  }

  export type FollowCountAggregateInputType = {
    id?: true
    followerId?: true
    followingId?: true
    createdAt?: true
    _all?: true
  }

  export type FollowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Follow to aggregate.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Follows
    **/
    _count?: true | FollowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FollowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FollowMaxAggregateInputType
  }

  export type GetFollowAggregateType<T extends FollowAggregateArgs> = {
        [P in keyof T & keyof AggregateFollow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFollow[P]>
      : GetScalarType<T[P], AggregateFollow[P]>
  }




  export type FollowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowWhereInput
    orderBy?: FollowOrderByWithAggregationInput | FollowOrderByWithAggregationInput[]
    by: FollowScalarFieldEnum[] | FollowScalarFieldEnum
    having?: FollowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FollowCountAggregateInputType | true
    _min?: FollowMinAggregateInputType
    _max?: FollowMaxAggregateInputType
  }

  export type FollowGroupByOutputType = {
    id: string
    followerId: string
    followingId: string
    createdAt: Date
    _count: FollowCountAggregateOutputType | null
    _min: FollowMinAggregateOutputType | null
    _max: FollowMaxAggregateOutputType | null
  }

  type GetFollowGroupByPayload<T extends FollowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FollowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FollowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FollowGroupByOutputType[P]>
            : GetScalarType<T[P], FollowGroupByOutputType[P]>
        }
      >
    >


  export type FollowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    followerId?: boolean
    followingId?: boolean
    createdAt?: boolean
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["follow"]>

  export type FollowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    followerId?: boolean
    followingId?: boolean
    createdAt?: boolean
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["follow"]>

  export type FollowSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    followerId?: boolean
    followingId?: boolean
    createdAt?: boolean
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["follow"]>

  export type FollowSelectScalar = {
    id?: boolean
    followerId?: boolean
    followingId?: boolean
    createdAt?: boolean
  }

  export type FollowOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "followerId" | "followingId" | "createdAt", ExtArgs["result"]["follow"]>
  export type FollowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FollowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FollowIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FollowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Follow"
    objects: {
      follower: Prisma.$UserPayload<ExtArgs>
      following: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      followerId: string
      followingId: string
      createdAt: Date
    }, ExtArgs["result"]["follow"]>
    composites: {}
  }

  type FollowGetPayload<S extends boolean | null | undefined | FollowDefaultArgs> = $Result.GetResult<Prisma.$FollowPayload, S>

  type FollowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FollowFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FollowCountAggregateInputType | true
    }

  export interface FollowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Follow'], meta: { name: 'Follow' } }
    /**
     * Find zero or one Follow that matches the filter.
     * @param {FollowFindUniqueArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FollowFindUniqueArgs>(args: SelectSubset<T, FollowFindUniqueArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Follow that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FollowFindUniqueOrThrowArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FollowFindUniqueOrThrowArgs>(args: SelectSubset<T, FollowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Follow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindFirstArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FollowFindFirstArgs>(args?: SelectSubset<T, FollowFindFirstArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Follow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindFirstOrThrowArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FollowFindFirstOrThrowArgs>(args?: SelectSubset<T, FollowFindFirstOrThrowArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Follows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Follows
     * const follows = await prisma.follow.findMany()
     * 
     * // Get first 10 Follows
     * const follows = await prisma.follow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const followWithIdOnly = await prisma.follow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FollowFindManyArgs>(args?: SelectSubset<T, FollowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Follow.
     * @param {FollowCreateArgs} args - Arguments to create a Follow.
     * @example
     * // Create one Follow
     * const Follow = await prisma.follow.create({
     *   data: {
     *     // ... data to create a Follow
     *   }
     * })
     * 
     */
    create<T extends FollowCreateArgs>(args: SelectSubset<T, FollowCreateArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Follows.
     * @param {FollowCreateManyArgs} args - Arguments to create many Follows.
     * @example
     * // Create many Follows
     * const follow = await prisma.follow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FollowCreateManyArgs>(args?: SelectSubset<T, FollowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Follows and returns the data saved in the database.
     * @param {FollowCreateManyAndReturnArgs} args - Arguments to create many Follows.
     * @example
     * // Create many Follows
     * const follow = await prisma.follow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Follows and only return the `id`
     * const followWithIdOnly = await prisma.follow.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FollowCreateManyAndReturnArgs>(args?: SelectSubset<T, FollowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Follow.
     * @param {FollowDeleteArgs} args - Arguments to delete one Follow.
     * @example
     * // Delete one Follow
     * const Follow = await prisma.follow.delete({
     *   where: {
     *     // ... filter to delete one Follow
     *   }
     * })
     * 
     */
    delete<T extends FollowDeleteArgs>(args: SelectSubset<T, FollowDeleteArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Follow.
     * @param {FollowUpdateArgs} args - Arguments to update one Follow.
     * @example
     * // Update one Follow
     * const follow = await prisma.follow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FollowUpdateArgs>(args: SelectSubset<T, FollowUpdateArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Follows.
     * @param {FollowDeleteManyArgs} args - Arguments to filter Follows to delete.
     * @example
     * // Delete a few Follows
     * const { count } = await prisma.follow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FollowDeleteManyArgs>(args?: SelectSubset<T, FollowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Follows
     * const follow = await prisma.follow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FollowUpdateManyArgs>(args: SelectSubset<T, FollowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Follows and returns the data updated in the database.
     * @param {FollowUpdateManyAndReturnArgs} args - Arguments to update many Follows.
     * @example
     * // Update many Follows
     * const follow = await prisma.follow.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Follows and only return the `id`
     * const followWithIdOnly = await prisma.follow.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FollowUpdateManyAndReturnArgs>(args: SelectSubset<T, FollowUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Follow.
     * @param {FollowUpsertArgs} args - Arguments to update or create a Follow.
     * @example
     * // Update or create a Follow
     * const follow = await prisma.follow.upsert({
     *   create: {
     *     // ... data to create a Follow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Follow we want to update
     *   }
     * })
     */
    upsert<T extends FollowUpsertArgs>(args: SelectSubset<T, FollowUpsertArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowCountArgs} args - Arguments to filter Follows to count.
     * @example
     * // Count the number of Follows
     * const count = await prisma.follow.count({
     *   where: {
     *     // ... the filter for the Follows we want to count
     *   }
     * })
    **/
    count<T extends FollowCountArgs>(
      args?: Subset<T, FollowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FollowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Follow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FollowAggregateArgs>(args: Subset<T, FollowAggregateArgs>): Prisma.PrismaPromise<GetFollowAggregateType<T>>

    /**
     * Group by Follow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FollowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FollowGroupByArgs['orderBy'] }
        : { orderBy?: FollowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FollowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFollowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Follow model
   */
  readonly fields: FollowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Follow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FollowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    follower<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    following<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Follow model
   */
  interface FollowFieldRefs {
    readonly id: FieldRef<"Follow", 'String'>
    readonly followerId: FieldRef<"Follow", 'String'>
    readonly followingId: FieldRef<"Follow", 'String'>
    readonly createdAt: FieldRef<"Follow", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Follow findUnique
   */
  export type FollowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow findUniqueOrThrow
   */
  export type FollowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow findFirst
   */
  export type FollowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Follows.
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Follows.
     */
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * Follow findFirstOrThrow
   */
  export type FollowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Follows.
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Follows.
     */
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * Follow findMany
   */
  export type FollowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follows to fetch.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Follows.
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * Follow create
   */
  export type FollowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * The data needed to create a Follow.
     */
    data: XOR<FollowCreateInput, FollowUncheckedCreateInput>
  }

  /**
   * Follow createMany
   */
  export type FollowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Follows.
     */
    data: FollowCreateManyInput | FollowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Follow createManyAndReturn
   */
  export type FollowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * The data used to create many Follows.
     */
    data: FollowCreateManyInput | FollowCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Follow update
   */
  export type FollowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * The data needed to update a Follow.
     */
    data: XOR<FollowUpdateInput, FollowUncheckedUpdateInput>
    /**
     * Choose, which Follow to update.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow updateMany
   */
  export type FollowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Follows.
     */
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyInput>
    /**
     * Filter which Follows to update
     */
    where?: FollowWhereInput
    /**
     * Limit how many Follows to update.
     */
    limit?: number
  }

  /**
   * Follow updateManyAndReturn
   */
  export type FollowUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * The data used to update Follows.
     */
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyInput>
    /**
     * Filter which Follows to update
     */
    where?: FollowWhereInput
    /**
     * Limit how many Follows to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Follow upsert
   */
  export type FollowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * The filter to search for the Follow to update in case it exists.
     */
    where: FollowWhereUniqueInput
    /**
     * In case the Follow found by the `where` argument doesn't exist, create a new Follow with this data.
     */
    create: XOR<FollowCreateInput, FollowUncheckedCreateInput>
    /**
     * In case the Follow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FollowUpdateInput, FollowUncheckedUpdateInput>
  }

  /**
   * Follow delete
   */
  export type FollowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter which Follow to delete.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow deleteMany
   */
  export type FollowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Follows to delete
     */
    where?: FollowWhereInput
    /**
     * Limit how many Follows to delete.
     */
    limit?: number
  }

  /**
   * Follow without action
   */
  export type FollowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
  }


  /**
   * Model Organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    logo: string | null
    address: string | null
    isSuspended: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    ownerId: string | null
  }

  export type OrganizationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    logo: string | null
    address: string | null
    isSuspended: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    ownerId: string | null
  }

  export type OrganizationCountAggregateOutputType = {
    id: number
    name: number
    code: number
    logo: number
    address: number
    isSuspended: number
    createdAt: number
    updatedAt: number
    ownerId: number
    _all: number
  }


  export type OrganizationMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    logo?: true
    address?: true
    isSuspended?: true
    createdAt?: true
    updatedAt?: true
    ownerId?: true
  }

  export type OrganizationMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    logo?: true
    address?: true
    isSuspended?: true
    createdAt?: true
    updatedAt?: true
    ownerId?: true
  }

  export type OrganizationCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    logo?: true
    address?: true
    isSuspended?: true
    createdAt?: true
    updatedAt?: true
    ownerId?: true
    _all?: true
  }

  export type OrganizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type OrganizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationWhereInput
    orderBy?: OrganizationOrderByWithAggregationInput | OrganizationOrderByWithAggregationInput[]
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum
    having?: OrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }

  export type OrganizationGroupByOutputType = {
    id: string
    name: string
    code: string
    logo: string | null
    address: string | null
    isSuspended: boolean
    createdAt: Date
    updatedAt: Date
    ownerId: string
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    logo?: boolean
    address?: boolean
    isSuspended?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ownerId?: boolean
    departments?: boolean | Organization$departmentsArgs<ExtArgs>
    members?: boolean | Organization$membersArgs<ExtArgs>
    subscription?: boolean | Organization$subscriptionArgs<ExtArgs>
    events?: boolean | Organization$eventsArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    logo?: boolean
    address?: boolean
    isSuspended?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ownerId?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    logo?: boolean
    address?: boolean
    isSuspended?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ownerId?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    logo?: boolean
    address?: boolean
    isSuspended?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ownerId?: boolean
  }

  export type OrganizationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "logo" | "address" | "isSuspended" | "createdAt" | "updatedAt" | "ownerId", ExtArgs["result"]["organization"]>
  export type OrganizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    departments?: boolean | Organization$departmentsArgs<ExtArgs>
    members?: boolean | Organization$membersArgs<ExtArgs>
    subscription?: boolean | Organization$subscriptionArgs<ExtArgs>
    events?: boolean | Organization$eventsArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrganizationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type OrganizationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OrganizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Organization"
    objects: {
      departments: Prisma.$DepartmentPayload<ExtArgs>[]
      members: Prisma.$OrganizationMemberPayload<ExtArgs>[]
      subscription: Prisma.$SubscriptionPayload<ExtArgs> | null
      events: Prisma.$EventInvitationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      logo: string | null
      address: string | null
      isSuspended: boolean
      createdAt: Date
      updatedAt: Date
      ownerId: string
    }, ExtArgs["result"]["organization"]>
    composites: {}
  }

  type OrganizationGetPayload<S extends boolean | null | undefined | OrganizationDefaultArgs> = $Result.GetResult<Prisma.$OrganizationPayload, S>

  type OrganizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrganizationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizationCountAggregateInputType | true
    }

  export interface OrganizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organization'], meta: { name: 'Organization' } }
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationFindUniqueArgs>(args: SelectSubset<T, OrganizationFindUniqueArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Organization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationFindFirstArgs>(args?: SelectSubset<T, OrganizationFindFirstArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationFindManyArgs>(args?: SelectSubset<T, OrganizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
     */
    create<T extends OrganizationCreateArgs>(args: SelectSubset<T, OrganizationCreateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Organizations.
     * @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationCreateManyArgs>(args?: SelectSubset<T, OrganizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Organizations and returns the data saved in the database.
     * @param {OrganizationCreateManyAndReturnArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
     */
    delete<T extends OrganizationDeleteArgs>(args: SelectSubset<T, OrganizationDeleteArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationUpdateArgs>(args: SelectSubset<T, OrganizationUpdateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationDeleteManyArgs>(args?: SelectSubset<T, OrganizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationUpdateManyArgs>(args: SelectSubset<T, OrganizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations and returns the data updated in the database.
     * @param {OrganizationUpdateManyAndReturnArgs} args - Arguments to update many Organizations.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrganizationUpdateManyAndReturnArgs>(args: SelectSubset<T, OrganizationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationUpsertArgs>(args: SelectSubset<T, OrganizationUpsertArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organization model
   */
  readonly fields: OrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    departments<T extends Organization$departmentsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$departmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    members<T extends Organization$membersArgs<ExtArgs> = {}>(args?: Subset<T, Organization$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscription<T extends Organization$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, Organization$subscriptionArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    events<T extends Organization$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Organization model
   */
  interface OrganizationFieldRefs {
    readonly id: FieldRef<"Organization", 'String'>
    readonly name: FieldRef<"Organization", 'String'>
    readonly code: FieldRef<"Organization", 'String'>
    readonly logo: FieldRef<"Organization", 'String'>
    readonly address: FieldRef<"Organization", 'String'>
    readonly isSuspended: FieldRef<"Organization", 'Boolean'>
    readonly createdAt: FieldRef<"Organization", 'DateTime'>
    readonly updatedAt: FieldRef<"Organization", 'DateTime'>
    readonly ownerId: FieldRef<"Organization", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Organization findUnique
   */
  export type OrganizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findFirst
   */
  export type OrganizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization create
   */
  export type OrganizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
  }

  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization createManyAndReturn
   */
  export type OrganizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization update
   */
  export type OrganizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to update.
     */
    limit?: number
  }

  /**
   * Organization updateManyAndReturn
   */
  export type OrganizationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to update.
     */
    limit?: number
  }

  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
  }

  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to delete.
     */
    limit?: number
  }

  /**
   * Organization.departments
   */
  export type Organization$departmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    cursor?: DepartmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Organization.members
   */
  export type Organization$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    where?: OrganizationMemberWhereInput
    orderBy?: OrganizationMemberOrderByWithRelationInput | OrganizationMemberOrderByWithRelationInput[]
    cursor?: OrganizationMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrganizationMemberScalarFieldEnum | OrganizationMemberScalarFieldEnum[]
  }

  /**
   * Organization.subscription
   */
  export type Organization$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
  }

  /**
   * Organization.events
   */
  export type Organization$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventInvitation
     */
    select?: EventInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventInvitation
     */
    omit?: EventInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInvitationInclude<ExtArgs> | null
    where?: EventInvitationWhereInput
    orderBy?: EventInvitationOrderByWithRelationInput | EventInvitationOrderByWithRelationInput[]
    cursor?: EventInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventInvitationScalarFieldEnum | EventInvitationScalarFieldEnum[]
  }

  /**
   * Organization without action
   */
  export type OrganizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
  }


  /**
   * Model OrganizationMember
   */

  export type AggregateOrganizationMember = {
    _count: OrganizationMemberCountAggregateOutputType | null
    _min: OrganizationMemberMinAggregateOutputType | null
    _max: OrganizationMemberMaxAggregateOutputType | null
  }

  export type OrganizationMemberMinAggregateOutputType = {
    id: string | null
    userId: string | null
    orgId: string | null
    role: $Enums.OrgRole | null
    joinedAt: Date | null
  }

  export type OrganizationMemberMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    orgId: string | null
    role: $Enums.OrgRole | null
    joinedAt: Date | null
  }

  export type OrganizationMemberCountAggregateOutputType = {
    id: number
    userId: number
    orgId: number
    role: number
    joinedAt: number
    _all: number
  }


  export type OrganizationMemberMinAggregateInputType = {
    id?: true
    userId?: true
    orgId?: true
    role?: true
    joinedAt?: true
  }

  export type OrganizationMemberMaxAggregateInputType = {
    id?: true
    userId?: true
    orgId?: true
    role?: true
    joinedAt?: true
  }

  export type OrganizationMemberCountAggregateInputType = {
    id?: true
    userId?: true
    orgId?: true
    role?: true
    joinedAt?: true
    _all?: true
  }

  export type OrganizationMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganizationMember to aggregate.
     */
    where?: OrganizationMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationMembers to fetch.
     */
    orderBy?: OrganizationMemberOrderByWithRelationInput | OrganizationMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrganizationMembers
    **/
    _count?: true | OrganizationMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMemberMaxAggregateInputType
  }

  export type GetOrganizationMemberAggregateType<T extends OrganizationMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganizationMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganizationMember[P]>
      : GetScalarType<T[P], AggregateOrganizationMember[P]>
  }




  export type OrganizationMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationMemberWhereInput
    orderBy?: OrganizationMemberOrderByWithAggregationInput | OrganizationMemberOrderByWithAggregationInput[]
    by: OrganizationMemberScalarFieldEnum[] | OrganizationMemberScalarFieldEnum
    having?: OrganizationMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationMemberCountAggregateInputType | true
    _min?: OrganizationMemberMinAggregateInputType
    _max?: OrganizationMemberMaxAggregateInputType
  }

  export type OrganizationMemberGroupByOutputType = {
    id: string
    userId: string
    orgId: string
    role: $Enums.OrgRole
    joinedAt: Date
    _count: OrganizationMemberCountAggregateOutputType | null
    _min: OrganizationMemberMinAggregateOutputType | null
    _max: OrganizationMemberMaxAggregateOutputType | null
  }

  type GetOrganizationMemberGroupByPayload<T extends OrganizationMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationMemberGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationMemberGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    orgId?: boolean
    role?: boolean
    joinedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationMember"]>

  export type OrganizationMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    orgId?: boolean
    role?: boolean
    joinedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationMember"]>

  export type OrganizationMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    orgId?: boolean
    role?: boolean
    joinedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationMember"]>

  export type OrganizationMemberSelectScalar = {
    id?: boolean
    userId?: boolean
    orgId?: boolean
    role?: boolean
    joinedAt?: boolean
  }

  export type OrganizationMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "orgId" | "role" | "joinedAt", ExtArgs["result"]["organizationMember"]>
  export type OrganizationMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OrganizationMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OrganizationMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OrganizationMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrganizationMember"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      orgId: string
      role: $Enums.OrgRole
      joinedAt: Date
    }, ExtArgs["result"]["organizationMember"]>
    composites: {}
  }

  type OrganizationMemberGetPayload<S extends boolean | null | undefined | OrganizationMemberDefaultArgs> = $Result.GetResult<Prisma.$OrganizationMemberPayload, S>

  type OrganizationMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrganizationMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizationMemberCountAggregateInputType | true
    }

  export interface OrganizationMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrganizationMember'], meta: { name: 'OrganizationMember' } }
    /**
     * Find zero or one OrganizationMember that matches the filter.
     * @param {OrganizationMemberFindUniqueArgs} args - Arguments to find a OrganizationMember
     * @example
     * // Get one OrganizationMember
     * const organizationMember = await prisma.organizationMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationMemberFindUniqueArgs>(args: SelectSubset<T, OrganizationMemberFindUniqueArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrganizationMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganizationMemberFindUniqueOrThrowArgs} args - Arguments to find a OrganizationMember
     * @example
     * // Get one OrganizationMember
     * const organizationMember = await prisma.organizationMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrganizationMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMemberFindFirstArgs} args - Arguments to find a OrganizationMember
     * @example
     * // Get one OrganizationMember
     * const organizationMember = await prisma.organizationMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationMemberFindFirstArgs>(args?: SelectSubset<T, OrganizationMemberFindFirstArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrganizationMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMemberFindFirstOrThrowArgs} args - Arguments to find a OrganizationMember
     * @example
     * // Get one OrganizationMember
     * const organizationMember = await prisma.organizationMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrganizationMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrganizationMembers
     * const organizationMembers = await prisma.organizationMember.findMany()
     * 
     * // Get first 10 OrganizationMembers
     * const organizationMembers = await prisma.organizationMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationMemberWithIdOnly = await prisma.organizationMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationMemberFindManyArgs>(args?: SelectSubset<T, OrganizationMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrganizationMember.
     * @param {OrganizationMemberCreateArgs} args - Arguments to create a OrganizationMember.
     * @example
     * // Create one OrganizationMember
     * const OrganizationMember = await prisma.organizationMember.create({
     *   data: {
     *     // ... data to create a OrganizationMember
     *   }
     * })
     * 
     */
    create<T extends OrganizationMemberCreateArgs>(args: SelectSubset<T, OrganizationMemberCreateArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrganizationMembers.
     * @param {OrganizationMemberCreateManyArgs} args - Arguments to create many OrganizationMembers.
     * @example
     * // Create many OrganizationMembers
     * const organizationMember = await prisma.organizationMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationMemberCreateManyArgs>(args?: SelectSubset<T, OrganizationMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrganizationMembers and returns the data saved in the database.
     * @param {OrganizationMemberCreateManyAndReturnArgs} args - Arguments to create many OrganizationMembers.
     * @example
     * // Create many OrganizationMembers
     * const organizationMember = await prisma.organizationMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrganizationMembers and only return the `id`
     * const organizationMemberWithIdOnly = await prisma.organizationMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrganizationMember.
     * @param {OrganizationMemberDeleteArgs} args - Arguments to delete one OrganizationMember.
     * @example
     * // Delete one OrganizationMember
     * const OrganizationMember = await prisma.organizationMember.delete({
     *   where: {
     *     // ... filter to delete one OrganizationMember
     *   }
     * })
     * 
     */
    delete<T extends OrganizationMemberDeleteArgs>(args: SelectSubset<T, OrganizationMemberDeleteArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrganizationMember.
     * @param {OrganizationMemberUpdateArgs} args - Arguments to update one OrganizationMember.
     * @example
     * // Update one OrganizationMember
     * const organizationMember = await prisma.organizationMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationMemberUpdateArgs>(args: SelectSubset<T, OrganizationMemberUpdateArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrganizationMembers.
     * @param {OrganizationMemberDeleteManyArgs} args - Arguments to filter OrganizationMembers to delete.
     * @example
     * // Delete a few OrganizationMembers
     * const { count } = await prisma.organizationMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationMemberDeleteManyArgs>(args?: SelectSubset<T, OrganizationMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganizationMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrganizationMembers
     * const organizationMember = await prisma.organizationMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationMemberUpdateManyArgs>(args: SelectSubset<T, OrganizationMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganizationMembers and returns the data updated in the database.
     * @param {OrganizationMemberUpdateManyAndReturnArgs} args - Arguments to update many OrganizationMembers.
     * @example
     * // Update many OrganizationMembers
     * const organizationMember = await prisma.organizationMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrganizationMembers and only return the `id`
     * const organizationMemberWithIdOnly = await prisma.organizationMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrganizationMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, OrganizationMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrganizationMember.
     * @param {OrganizationMemberUpsertArgs} args - Arguments to update or create a OrganizationMember.
     * @example
     * // Update or create a OrganizationMember
     * const organizationMember = await prisma.organizationMember.upsert({
     *   create: {
     *     // ... data to create a OrganizationMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrganizationMember we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationMemberUpsertArgs>(args: SelectSubset<T, OrganizationMemberUpsertArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrganizationMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMemberCountArgs} args - Arguments to filter OrganizationMembers to count.
     * @example
     * // Count the number of OrganizationMembers
     * const count = await prisma.organizationMember.count({
     *   where: {
     *     // ... the filter for the OrganizationMembers we want to count
     *   }
     * })
    **/
    count<T extends OrganizationMemberCountArgs>(
      args?: Subset<T, OrganizationMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrganizationMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationMemberAggregateArgs>(args: Subset<T, OrganizationMemberAggregateArgs>): Prisma.PrismaPromise<GetOrganizationMemberAggregateType<T>>

    /**
     * Group by OrganizationMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationMemberGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrganizationMember model
   */
  readonly fields: OrganizationMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrganizationMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrganizationMember model
   */
  interface OrganizationMemberFieldRefs {
    readonly id: FieldRef<"OrganizationMember", 'String'>
    readonly userId: FieldRef<"OrganizationMember", 'String'>
    readonly orgId: FieldRef<"OrganizationMember", 'String'>
    readonly role: FieldRef<"OrganizationMember", 'OrgRole'>
    readonly joinedAt: FieldRef<"OrganizationMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrganizationMember findUnique
   */
  export type OrganizationMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationMember to fetch.
     */
    where: OrganizationMemberWhereUniqueInput
  }

  /**
   * OrganizationMember findUniqueOrThrow
   */
  export type OrganizationMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationMember to fetch.
     */
    where: OrganizationMemberWhereUniqueInput
  }

  /**
   * OrganizationMember findFirst
   */
  export type OrganizationMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationMember to fetch.
     */
    where?: OrganizationMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationMembers to fetch.
     */
    orderBy?: OrganizationMemberOrderByWithRelationInput | OrganizationMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationMembers.
     */
    cursor?: OrganizationMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationMembers.
     */
    distinct?: OrganizationMemberScalarFieldEnum | OrganizationMemberScalarFieldEnum[]
  }

  /**
   * OrganizationMember findFirstOrThrow
   */
  export type OrganizationMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationMember to fetch.
     */
    where?: OrganizationMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationMembers to fetch.
     */
    orderBy?: OrganizationMemberOrderByWithRelationInput | OrganizationMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationMembers.
     */
    cursor?: OrganizationMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationMembers.
     */
    distinct?: OrganizationMemberScalarFieldEnum | OrganizationMemberScalarFieldEnum[]
  }

  /**
   * OrganizationMember findMany
   */
  export type OrganizationMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationMembers to fetch.
     */
    where?: OrganizationMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationMembers to fetch.
     */
    orderBy?: OrganizationMemberOrderByWithRelationInput | OrganizationMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrganizationMembers.
     */
    cursor?: OrganizationMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationMembers.
     */
    skip?: number
    distinct?: OrganizationMemberScalarFieldEnum | OrganizationMemberScalarFieldEnum[]
  }

  /**
   * OrganizationMember create
   */
  export type OrganizationMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a OrganizationMember.
     */
    data: XOR<OrganizationMemberCreateInput, OrganizationMemberUncheckedCreateInput>
  }

  /**
   * OrganizationMember createMany
   */
  export type OrganizationMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrganizationMembers.
     */
    data: OrganizationMemberCreateManyInput | OrganizationMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrganizationMember createManyAndReturn
   */
  export type OrganizationMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * The data used to create many OrganizationMembers.
     */
    data: OrganizationMemberCreateManyInput | OrganizationMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrganizationMember update
   */
  export type OrganizationMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a OrganizationMember.
     */
    data: XOR<OrganizationMemberUpdateInput, OrganizationMemberUncheckedUpdateInput>
    /**
     * Choose, which OrganizationMember to update.
     */
    where: OrganizationMemberWhereUniqueInput
  }

  /**
   * OrganizationMember updateMany
   */
  export type OrganizationMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrganizationMembers.
     */
    data: XOR<OrganizationMemberUpdateManyMutationInput, OrganizationMemberUncheckedUpdateManyInput>
    /**
     * Filter which OrganizationMembers to update
     */
    where?: OrganizationMemberWhereInput
    /**
     * Limit how many OrganizationMembers to update.
     */
    limit?: number
  }

  /**
   * OrganizationMember updateManyAndReturn
   */
  export type OrganizationMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * The data used to update OrganizationMembers.
     */
    data: XOR<OrganizationMemberUpdateManyMutationInput, OrganizationMemberUncheckedUpdateManyInput>
    /**
     * Filter which OrganizationMembers to update
     */
    where?: OrganizationMemberWhereInput
    /**
     * Limit how many OrganizationMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrganizationMember upsert
   */
  export type OrganizationMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the OrganizationMember to update in case it exists.
     */
    where: OrganizationMemberWhereUniqueInput
    /**
     * In case the OrganizationMember found by the `where` argument doesn't exist, create a new OrganizationMember with this data.
     */
    create: XOR<OrganizationMemberCreateInput, OrganizationMemberUncheckedCreateInput>
    /**
     * In case the OrganizationMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationMemberUpdateInput, OrganizationMemberUncheckedUpdateInput>
  }

  /**
   * OrganizationMember delete
   */
  export type OrganizationMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * Filter which OrganizationMember to delete.
     */
    where: OrganizationMemberWhereUniqueInput
  }

  /**
   * OrganizationMember deleteMany
   */
  export type OrganizationMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganizationMembers to delete
     */
    where?: OrganizationMemberWhereInput
    /**
     * Limit how many OrganizationMembers to delete.
     */
    limit?: number
  }

  /**
   * OrganizationMember without action
   */
  export type OrganizationMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
  }


  /**
   * Model Department
   */

  export type AggregateDepartment = {
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentMinAggregateOutputType = {
    id: string | null
    name: string | null
    orgId: string | null
    publicKey: string | null
    headId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    orgId: string | null
    publicKey: string | null
    headId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentCountAggregateOutputType = {
    id: number
    name: number
    orgId: number
    publicKey: number
    headId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DepartmentMinAggregateInputType = {
    id?: true
    name?: true
    orgId?: true
    publicKey?: true
    headId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentMaxAggregateInputType = {
    id?: true
    name?: true
    orgId?: true
    publicKey?: true
    headId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentCountAggregateInputType = {
    id?: true
    name?: true
    orgId?: true
    publicKey?: true
    headId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Department to aggregate.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departments
    **/
    _count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }




  export type DepartmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithAggregationInput | DepartmentOrderByWithAggregationInput[]
    by: DepartmentScalarFieldEnum[] | DepartmentScalarFieldEnum
    having?: DepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentCountAggregateInputType | true
    _min?: DepartmentMinAggregateInputType
    _max?: DepartmentMaxAggregateInputType
  }

  export type DepartmentGroupByOutputType = {
    id: string
    name: string
    orgId: string
    publicKey: string
    headId: string | null
    createdAt: Date
    updatedAt: Date
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  type GetDepartmentGroupByPayload<T extends DepartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    orgId?: boolean
    publicKey?: boolean
    headId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    head?: boolean | Department$headArgs<ExtArgs>
    members?: boolean | Department$membersArgs<ExtArgs>
    conversations?: boolean | Department$conversationsArgs<ExtArgs>
    tasks?: boolean | Department$tasksArgs<ExtArgs>
    eventBroadcasts?: boolean | Department$eventBroadcastsArgs<ExtArgs>
    monthlyReports?: boolean | Department$monthlyReportsArgs<ExtArgs>
    goals?: boolean | Department$goalsArgs<ExtArgs>
    meetings?: boolean | Department$meetingsArgs<ExtArgs>
    polls?: boolean | Department$pollsArgs<ExtArgs>
    teamDecisions?: boolean | Department$teamDecisionsArgs<ExtArgs>
    documents?: boolean | Department$documentsArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    orgId?: boolean
    publicKey?: boolean
    headId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    head?: boolean | Department$headArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    orgId?: boolean
    publicKey?: boolean
    headId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    head?: boolean | Department$headArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectScalar = {
    id?: boolean
    name?: boolean
    orgId?: boolean
    publicKey?: boolean
    headId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DepartmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "orgId" | "publicKey" | "headId" | "createdAt" | "updatedAt", ExtArgs["result"]["department"]>
  export type DepartmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    head?: boolean | Department$headArgs<ExtArgs>
    members?: boolean | Department$membersArgs<ExtArgs>
    conversations?: boolean | Department$conversationsArgs<ExtArgs>
    tasks?: boolean | Department$tasksArgs<ExtArgs>
    eventBroadcasts?: boolean | Department$eventBroadcastsArgs<ExtArgs>
    monthlyReports?: boolean | Department$monthlyReportsArgs<ExtArgs>
    goals?: boolean | Department$goalsArgs<ExtArgs>
    meetings?: boolean | Department$meetingsArgs<ExtArgs>
    polls?: boolean | Department$pollsArgs<ExtArgs>
    teamDecisions?: boolean | Department$teamDecisionsArgs<ExtArgs>
    documents?: boolean | Department$documentsArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DepartmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    head?: boolean | Department$headArgs<ExtArgs>
  }
  export type DepartmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    head?: boolean | Department$headArgs<ExtArgs>
  }

  export type $DepartmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Department"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      head: Prisma.$UserPayload<ExtArgs> | null
      members: Prisma.$DepartmentMemberPayload<ExtArgs>[]
      conversations: Prisma.$GroupPayload<ExtArgs>[]
      tasks: Prisma.$TaskPayload<ExtArgs>[]
      eventBroadcasts: Prisma.$EventDepartmentBroadcastPayload<ExtArgs>[]
      monthlyReports: Prisma.$DepartmentMonthlyReportPayload<ExtArgs>[]
      goals: Prisma.$DepartmentGoalPayload<ExtArgs>[]
      meetings: Prisma.$DepartmentMeetingPayload<ExtArgs>[]
      polls: Prisma.$DepartmentPollPayload<ExtArgs>[]
      teamDecisions: Prisma.$TeamDecisionPayload<ExtArgs>[]
      documents: Prisma.$DepartmentDocumentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      orgId: string
      publicKey: string
      headId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["department"]>
    composites: {}
  }

  type DepartmentGetPayload<S extends boolean | null | undefined | DepartmentDefaultArgs> = $Result.GetResult<Prisma.$DepartmentPayload, S>

  type DepartmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DepartmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepartmentCountAggregateInputType | true
    }

  export interface DepartmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Department'], meta: { name: 'Department' } }
    /**
     * Find zero or one Department that matches the filter.
     * @param {DepartmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentFindUniqueArgs>(args: SelectSubset<T, DepartmentFindUniqueArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Department that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DepartmentFindUniqueOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentFindFirstArgs>(args?: SelectSubset<T, DepartmentFindFirstArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentWithIdOnly = await prisma.department.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentFindManyArgs>(args?: SelectSubset<T, DepartmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Department.
     * @param {DepartmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
     */
    create<T extends DepartmentCreateArgs>(args: SelectSubset<T, DepartmentCreateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Departments.
     * @param {DepartmentCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentCreateManyArgs>(args?: SelectSubset<T, DepartmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Departments and returns the data saved in the database.
     * @param {DepartmentCreateManyAndReturnArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepartmentCreateManyAndReturnArgs>(args?: SelectSubset<T, DepartmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Department.
     * @param {DepartmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
     */
    delete<T extends DepartmentDeleteArgs>(args: SelectSubset<T, DepartmentDeleteArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Department.
     * @param {DepartmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentUpdateArgs>(args: SelectSubset<T, DepartmentUpdateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Departments.
     * @param {DepartmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentDeleteManyArgs>(args?: SelectSubset<T, DepartmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentUpdateManyArgs>(args: SelectSubset<T, DepartmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments and returns the data updated in the database.
     * @param {DepartmentUpdateManyAndReturnArgs} args - Arguments to update many Departments.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DepartmentUpdateManyAndReturnArgs>(args: SelectSubset<T, DepartmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Department.
     * @param {DepartmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentUpsertArgs>(args: SelectSubset<T, DepartmentUpsertArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends DepartmentCountArgs>(
      args?: Subset<T, DepartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): Prisma.PrismaPromise<GetDepartmentAggregateType<T>>

    /**
     * Group by Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Department model
   */
  readonly fields: DepartmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    head<T extends Department$headArgs<ExtArgs> = {}>(args?: Subset<T, Department$headArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    members<T extends Department$membersArgs<ExtArgs> = {}>(args?: Subset<T, Department$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conversations<T extends Department$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, Department$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tasks<T extends Department$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Department$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    eventBroadcasts<T extends Department$eventBroadcastsArgs<ExtArgs> = {}>(args?: Subset<T, Department$eventBroadcastsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventDepartmentBroadcastPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    monthlyReports<T extends Department$monthlyReportsArgs<ExtArgs> = {}>(args?: Subset<T, Department$monthlyReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentMonthlyReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    goals<T extends Department$goalsArgs<ExtArgs> = {}>(args?: Subset<T, Department$goalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentGoalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    meetings<T extends Department$meetingsArgs<ExtArgs> = {}>(args?: Subset<T, Department$meetingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentMeetingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    polls<T extends Department$pollsArgs<ExtArgs> = {}>(args?: Subset<T, Department$pollsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPollPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teamDecisions<T extends Department$teamDecisionsArgs<ExtArgs> = {}>(args?: Subset<T, Department$teamDecisionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamDecisionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends Department$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Department$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Department model
   */
  interface DepartmentFieldRefs {
    readonly id: FieldRef<"Department", 'String'>
    readonly name: FieldRef<"Department", 'String'>
    readonly orgId: FieldRef<"Department", 'String'>
    readonly publicKey: FieldRef<"Department", 'String'>
    readonly headId: FieldRef<"Department", 'String'>
    readonly createdAt: FieldRef<"Department", 'DateTime'>
    readonly updatedAt: FieldRef<"Department", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Department findUnique
   */
  export type DepartmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findUniqueOrThrow
   */
  export type DepartmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findFirst
   */
  export type DepartmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findFirstOrThrow
   */
  export type DepartmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findMany
   */
  export type DepartmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Departments to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department create
   */
  export type DepartmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Department.
     */
    data: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
  }

  /**
   * Department createMany
   */
  export type DepartmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department createManyAndReturn
   */
  export type DepartmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Department update
   */
  export type DepartmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Department.
     */
    data: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
    /**
     * Choose, which Department to update.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department updateMany
   */
  export type DepartmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
  }

  /**
   * Department updateManyAndReturn
   */
  export type DepartmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Department upsert
   */
  export type DepartmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Department to update in case it exists.
     */
    where: DepartmentWhereUniqueInput
    /**
     * In case the Department found by the `where` argument doesn't exist, create a new Department with this data.
     */
    create: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
    /**
     * In case the Department was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
  }

  /**
   * Department delete
   */
  export type DepartmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter which Department to delete.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department deleteMany
   */
  export type DepartmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departments to delete
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to delete.
     */
    limit?: number
  }

  /**
   * Department.head
   */
  export type Department$headArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Department.members
   */
  export type Department$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentMember
     */
    select?: DepartmentMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentMember
     */
    omit?: DepartmentMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentMemberInclude<ExtArgs> | null
    where?: DepartmentMemberWhereInput
    orderBy?: DepartmentMemberOrderByWithRelationInput | DepartmentMemberOrderByWithRelationInput[]
    cursor?: DepartmentMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentMemberScalarFieldEnum | DepartmentMemberScalarFieldEnum[]
  }

  /**
   * Department.conversations
   */
  export type Department$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    where?: GroupWhereInput
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    cursor?: GroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Department.tasks
   */
  export type Department$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Department.eventBroadcasts
   */
  export type Department$eventBroadcastsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventDepartmentBroadcast
     */
    select?: EventDepartmentBroadcastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventDepartmentBroadcast
     */
    omit?: EventDepartmentBroadcastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventDepartmentBroadcastInclude<ExtArgs> | null
    where?: EventDepartmentBroadcastWhereInput
    orderBy?: EventDepartmentBroadcastOrderByWithRelationInput | EventDepartmentBroadcastOrderByWithRelationInput[]
    cursor?: EventDepartmentBroadcastWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventDepartmentBroadcastScalarFieldEnum | EventDepartmentBroadcastScalarFieldEnum[]
  }

  /**
   * Department.monthlyReports
   */
  export type Department$monthlyReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentMonthlyReport
     */
    select?: DepartmentMonthlyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentMonthlyReport
     */
    omit?: DepartmentMonthlyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentMonthlyReportInclude<ExtArgs> | null
    where?: DepartmentMonthlyReportWhereInput
    orderBy?: DepartmentMonthlyReportOrderByWithRelationInput | DepartmentMonthlyReportOrderByWithRelationInput[]
    cursor?: DepartmentMonthlyReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentMonthlyReportScalarFieldEnum | DepartmentMonthlyReportScalarFieldEnum[]
  }

  /**
   * Department.goals
   */
  export type Department$goalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentGoal
     */
    select?: DepartmentGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentGoal
     */
    omit?: DepartmentGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentGoalInclude<ExtArgs> | null
    where?: DepartmentGoalWhereInput
    orderBy?: DepartmentGoalOrderByWithRelationInput | DepartmentGoalOrderByWithRelationInput[]
    cursor?: DepartmentGoalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentGoalScalarFieldEnum | DepartmentGoalScalarFieldEnum[]
  }

  /**
   * Department.meetings
   */
  export type Department$meetingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentMeeting
     */
    select?: DepartmentMeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentMeeting
     */
    omit?: DepartmentMeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentMeetingInclude<ExtArgs> | null
    where?: DepartmentMeetingWhereInput
    orderBy?: DepartmentMeetingOrderByWithRelationInput | DepartmentMeetingOrderByWithRelationInput[]
    cursor?: DepartmentMeetingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentMeetingScalarFieldEnum | DepartmentMeetingScalarFieldEnum[]
  }

  /**
   * Department.polls
   */
  export type Department$pollsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentPoll
     */
    select?: DepartmentPollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentPoll
     */
    omit?: DepartmentPollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentPollInclude<ExtArgs> | null
    where?: DepartmentPollWhereInput
    orderBy?: DepartmentPollOrderByWithRelationInput | DepartmentPollOrderByWithRelationInput[]
    cursor?: DepartmentPollWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentPollScalarFieldEnum | DepartmentPollScalarFieldEnum[]
  }

  /**
   * Department.teamDecisions
   */
  export type Department$teamDecisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamDecision
     */
    select?: TeamDecisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamDecision
     */
    omit?: TeamDecisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamDecisionInclude<ExtArgs> | null
    where?: TeamDecisionWhereInput
    orderBy?: TeamDecisionOrderByWithRelationInput | TeamDecisionOrderByWithRelationInput[]
    cursor?: TeamDecisionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamDecisionScalarFieldEnum | TeamDecisionScalarFieldEnum[]
  }

  /**
   * Department.documents
   */
  export type Department$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentDocument
     */
    select?: DepartmentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentDocument
     */
    omit?: DepartmentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentDocumentInclude<ExtArgs> | null
    where?: DepartmentDocumentWhereInput
    orderBy?: DepartmentDocumentOrderByWithRelationInput | DepartmentDocumentOrderByWithRelationInput[]
    cursor?: DepartmentDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentDocumentScalarFieldEnum | DepartmentDocumentScalarFieldEnum[]
  }

  /**
   * Department without action
   */
  export type DepartmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
  }


  /**
   * Model DepartmentDocument
   */

  export type AggregateDepartmentDocument = {
    _count: DepartmentDocumentCountAggregateOutputType | null
    _min: DepartmentDocumentMinAggregateOutputType | null
    _max: DepartmentDocumentMaxAggregateOutputType | null
  }

  export type DepartmentDocumentMinAggregateOutputType = {
    id: string | null
    deptId: string | null
    filename: string | null
    type: $Enums.FileType | null
    data: string | null
    uploadedBy: string | null
    createdAt: Date | null
  }

  export type DepartmentDocumentMaxAggregateOutputType = {
    id: string | null
    deptId: string | null
    filename: string | null
    type: $Enums.FileType | null
    data: string | null
    uploadedBy: string | null
    createdAt: Date | null
  }

  export type DepartmentDocumentCountAggregateOutputType = {
    id: number
    deptId: number
    filename: number
    type: number
    data: number
    uploadedBy: number
    createdAt: number
    _all: number
  }


  export type DepartmentDocumentMinAggregateInputType = {
    id?: true
    deptId?: true
    filename?: true
    type?: true
    data?: true
    uploadedBy?: true
    createdAt?: true
  }

  export type DepartmentDocumentMaxAggregateInputType = {
    id?: true
    deptId?: true
    filename?: true
    type?: true
    data?: true
    uploadedBy?: true
    createdAt?: true
  }

  export type DepartmentDocumentCountAggregateInputType = {
    id?: true
    deptId?: true
    filename?: true
    type?: true
    data?: true
    uploadedBy?: true
    createdAt?: true
    _all?: true
  }

  export type DepartmentDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DepartmentDocument to aggregate.
     */
    where?: DepartmentDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentDocuments to fetch.
     */
    orderBy?: DepartmentDocumentOrderByWithRelationInput | DepartmentDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DepartmentDocuments
    **/
    _count?: true | DepartmentDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentDocumentMaxAggregateInputType
  }

  export type GetDepartmentDocumentAggregateType<T extends DepartmentDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartmentDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartmentDocument[P]>
      : GetScalarType<T[P], AggregateDepartmentDocument[P]>
  }




  export type DepartmentDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentDocumentWhereInput
    orderBy?: DepartmentDocumentOrderByWithAggregationInput | DepartmentDocumentOrderByWithAggregationInput[]
    by: DepartmentDocumentScalarFieldEnum[] | DepartmentDocumentScalarFieldEnum
    having?: DepartmentDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentDocumentCountAggregateInputType | true
    _min?: DepartmentDocumentMinAggregateInputType
    _max?: DepartmentDocumentMaxAggregateInputType
  }

  export type DepartmentDocumentGroupByOutputType = {
    id: string
    deptId: string
    filename: string
    type: $Enums.FileType
    data: string
    uploadedBy: string
    createdAt: Date
    _count: DepartmentDocumentCountAggregateOutputType | null
    _min: DepartmentDocumentMinAggregateOutputType | null
    _max: DepartmentDocumentMaxAggregateOutputType | null
  }

  type GetDepartmentDocumentGroupByPayload<T extends DepartmentDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentDocumentGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deptId?: boolean
    filename?: boolean
    type?: boolean
    data?: boolean
    uploadedBy?: boolean
    createdAt?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["departmentDocument"]>

  export type DepartmentDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deptId?: boolean
    filename?: boolean
    type?: boolean
    data?: boolean
    uploadedBy?: boolean
    createdAt?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["departmentDocument"]>

  export type DepartmentDocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deptId?: boolean
    filename?: boolean
    type?: boolean
    data?: boolean
    uploadedBy?: boolean
    createdAt?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["departmentDocument"]>

  export type DepartmentDocumentSelectScalar = {
    id?: boolean
    deptId?: boolean
    filename?: boolean
    type?: boolean
    data?: boolean
    uploadedBy?: boolean
    createdAt?: boolean
  }

  export type DepartmentDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "deptId" | "filename" | "type" | "data" | "uploadedBy" | "createdAt", ExtArgs["result"]["departmentDocument"]>
  export type DepartmentDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DepartmentDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DepartmentDocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DepartmentDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DepartmentDocument"
    objects: {
      department: Prisma.$DepartmentPayload<ExtArgs>
      uploader: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      deptId: string
      filename: string
      type: $Enums.FileType
      data: string
      uploadedBy: string
      createdAt: Date
    }, ExtArgs["result"]["departmentDocument"]>
    composites: {}
  }

  type DepartmentDocumentGetPayload<S extends boolean | null | undefined | DepartmentDocumentDefaultArgs> = $Result.GetResult<Prisma.$DepartmentDocumentPayload, S>

  type DepartmentDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DepartmentDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepartmentDocumentCountAggregateInputType | true
    }

  export interface DepartmentDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DepartmentDocument'], meta: { name: 'DepartmentDocument' } }
    /**
     * Find zero or one DepartmentDocument that matches the filter.
     * @param {DepartmentDocumentFindUniqueArgs} args - Arguments to find a DepartmentDocument
     * @example
     * // Get one DepartmentDocument
     * const departmentDocument = await prisma.departmentDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentDocumentFindUniqueArgs>(args: SelectSubset<T, DepartmentDocumentFindUniqueArgs<ExtArgs>>): Prisma__DepartmentDocumentClient<$Result.GetResult<Prisma.$DepartmentDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DepartmentDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DepartmentDocumentFindUniqueOrThrowArgs} args - Arguments to find a DepartmentDocument
     * @example
     * // Get one DepartmentDocument
     * const departmentDocument = await prisma.departmentDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentDocumentClient<$Result.GetResult<Prisma.$DepartmentDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DepartmentDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentDocumentFindFirstArgs} args - Arguments to find a DepartmentDocument
     * @example
     * // Get one DepartmentDocument
     * const departmentDocument = await prisma.departmentDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentDocumentFindFirstArgs>(args?: SelectSubset<T, DepartmentDocumentFindFirstArgs<ExtArgs>>): Prisma__DepartmentDocumentClient<$Result.GetResult<Prisma.$DepartmentDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DepartmentDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentDocumentFindFirstOrThrowArgs} args - Arguments to find a DepartmentDocument
     * @example
     * // Get one DepartmentDocument
     * const departmentDocument = await prisma.departmentDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentDocumentClient<$Result.GetResult<Prisma.$DepartmentDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DepartmentDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DepartmentDocuments
     * const departmentDocuments = await prisma.departmentDocument.findMany()
     * 
     * // Get first 10 DepartmentDocuments
     * const departmentDocuments = await prisma.departmentDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentDocumentWithIdOnly = await prisma.departmentDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentDocumentFindManyArgs>(args?: SelectSubset<T, DepartmentDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DepartmentDocument.
     * @param {DepartmentDocumentCreateArgs} args - Arguments to create a DepartmentDocument.
     * @example
     * // Create one DepartmentDocument
     * const DepartmentDocument = await prisma.departmentDocument.create({
     *   data: {
     *     // ... data to create a DepartmentDocument
     *   }
     * })
     * 
     */
    create<T extends DepartmentDocumentCreateArgs>(args: SelectSubset<T, DepartmentDocumentCreateArgs<ExtArgs>>): Prisma__DepartmentDocumentClient<$Result.GetResult<Prisma.$DepartmentDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DepartmentDocuments.
     * @param {DepartmentDocumentCreateManyArgs} args - Arguments to create many DepartmentDocuments.
     * @example
     * // Create many DepartmentDocuments
     * const departmentDocument = await prisma.departmentDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentDocumentCreateManyArgs>(args?: SelectSubset<T, DepartmentDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DepartmentDocuments and returns the data saved in the database.
     * @param {DepartmentDocumentCreateManyAndReturnArgs} args - Arguments to create many DepartmentDocuments.
     * @example
     * // Create many DepartmentDocuments
     * const departmentDocument = await prisma.departmentDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DepartmentDocuments and only return the `id`
     * const departmentDocumentWithIdOnly = await prisma.departmentDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepartmentDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, DepartmentDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentDocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DepartmentDocument.
     * @param {DepartmentDocumentDeleteArgs} args - Arguments to delete one DepartmentDocument.
     * @example
     * // Delete one DepartmentDocument
     * const DepartmentDocument = await prisma.departmentDocument.delete({
     *   where: {
     *     // ... filter to delete one DepartmentDocument
     *   }
     * })
     * 
     */
    delete<T extends DepartmentDocumentDeleteArgs>(args: SelectSubset<T, DepartmentDocumentDeleteArgs<ExtArgs>>): Prisma__DepartmentDocumentClient<$Result.GetResult<Prisma.$DepartmentDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DepartmentDocument.
     * @param {DepartmentDocumentUpdateArgs} args - Arguments to update one DepartmentDocument.
     * @example
     * // Update one DepartmentDocument
     * const departmentDocument = await prisma.departmentDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentDocumentUpdateArgs>(args: SelectSubset<T, DepartmentDocumentUpdateArgs<ExtArgs>>): Prisma__DepartmentDocumentClient<$Result.GetResult<Prisma.$DepartmentDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DepartmentDocuments.
     * @param {DepartmentDocumentDeleteManyArgs} args - Arguments to filter DepartmentDocuments to delete.
     * @example
     * // Delete a few DepartmentDocuments
     * const { count } = await prisma.departmentDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentDocumentDeleteManyArgs>(args?: SelectSubset<T, DepartmentDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DepartmentDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DepartmentDocuments
     * const departmentDocument = await prisma.departmentDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentDocumentUpdateManyArgs>(args: SelectSubset<T, DepartmentDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DepartmentDocuments and returns the data updated in the database.
     * @param {DepartmentDocumentUpdateManyAndReturnArgs} args - Arguments to update many DepartmentDocuments.
     * @example
     * // Update many DepartmentDocuments
     * const departmentDocument = await prisma.departmentDocument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DepartmentDocuments and only return the `id`
     * const departmentDocumentWithIdOnly = await prisma.departmentDocument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DepartmentDocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, DepartmentDocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentDocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DepartmentDocument.
     * @param {DepartmentDocumentUpsertArgs} args - Arguments to update or create a DepartmentDocument.
     * @example
     * // Update or create a DepartmentDocument
     * const departmentDocument = await prisma.departmentDocument.upsert({
     *   create: {
     *     // ... data to create a DepartmentDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DepartmentDocument we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentDocumentUpsertArgs>(args: SelectSubset<T, DepartmentDocumentUpsertArgs<ExtArgs>>): Prisma__DepartmentDocumentClient<$Result.GetResult<Prisma.$DepartmentDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DepartmentDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentDocumentCountArgs} args - Arguments to filter DepartmentDocuments to count.
     * @example
     * // Count the number of DepartmentDocuments
     * const count = await prisma.departmentDocument.count({
     *   where: {
     *     // ... the filter for the DepartmentDocuments we want to count
     *   }
     * })
    **/
    count<T extends DepartmentDocumentCountArgs>(
      args?: Subset<T, DepartmentDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DepartmentDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentDocumentAggregateArgs>(args: Subset<T, DepartmentDocumentAggregateArgs>): Prisma.PrismaPromise<GetDepartmentDocumentAggregateType<T>>

    /**
     * Group by DepartmentDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentDocumentGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DepartmentDocument model
   */
  readonly fields: DepartmentDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DepartmentDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    department<T extends DepartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DepartmentDefaultArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    uploader<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DepartmentDocument model
   */
  interface DepartmentDocumentFieldRefs {
    readonly id: FieldRef<"DepartmentDocument", 'String'>
    readonly deptId: FieldRef<"DepartmentDocument", 'String'>
    readonly filename: FieldRef<"DepartmentDocument", 'String'>
    readonly type: FieldRef<"DepartmentDocument", 'FileType'>
    readonly data: FieldRef<"DepartmentDocument", 'String'>
    readonly uploadedBy: FieldRef<"DepartmentDocument", 'String'>
    readonly createdAt: FieldRef<"DepartmentDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DepartmentDocument findUnique
   */
  export type DepartmentDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentDocument
     */
    select?: DepartmentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentDocument
     */
    omit?: DepartmentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentDocumentInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentDocument to fetch.
     */
    where: DepartmentDocumentWhereUniqueInput
  }

  /**
   * DepartmentDocument findUniqueOrThrow
   */
  export type DepartmentDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentDocument
     */
    select?: DepartmentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentDocument
     */
    omit?: DepartmentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentDocumentInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentDocument to fetch.
     */
    where: DepartmentDocumentWhereUniqueInput
  }

  /**
   * DepartmentDocument findFirst
   */
  export type DepartmentDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentDocument
     */
    select?: DepartmentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentDocument
     */
    omit?: DepartmentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentDocumentInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentDocument to fetch.
     */
    where?: DepartmentDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentDocuments to fetch.
     */
    orderBy?: DepartmentDocumentOrderByWithRelationInput | DepartmentDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DepartmentDocuments.
     */
    cursor?: DepartmentDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DepartmentDocuments.
     */
    distinct?: DepartmentDocumentScalarFieldEnum | DepartmentDocumentScalarFieldEnum[]
  }

  /**
   * DepartmentDocument findFirstOrThrow
   */
  export type DepartmentDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentDocument
     */
    select?: DepartmentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentDocument
     */
    omit?: DepartmentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentDocumentInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentDocument to fetch.
     */
    where?: DepartmentDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentDocuments to fetch.
     */
    orderBy?: DepartmentDocumentOrderByWithRelationInput | DepartmentDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DepartmentDocuments.
     */
    cursor?: DepartmentDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DepartmentDocuments.
     */
    distinct?: DepartmentDocumentScalarFieldEnum | DepartmentDocumentScalarFieldEnum[]
  }

  /**
   * DepartmentDocument findMany
   */
  export type DepartmentDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentDocument
     */
    select?: DepartmentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentDocument
     */
    omit?: DepartmentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentDocumentInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentDocuments to fetch.
     */
    where?: DepartmentDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentDocuments to fetch.
     */
    orderBy?: DepartmentDocumentOrderByWithRelationInput | DepartmentDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DepartmentDocuments.
     */
    cursor?: DepartmentDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentDocuments.
     */
    skip?: number
    distinct?: DepartmentDocumentScalarFieldEnum | DepartmentDocumentScalarFieldEnum[]
  }

  /**
   * DepartmentDocument create
   */
  export type DepartmentDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentDocument
     */
    select?: DepartmentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentDocument
     */
    omit?: DepartmentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a DepartmentDocument.
     */
    data: XOR<DepartmentDocumentCreateInput, DepartmentDocumentUncheckedCreateInput>
  }

  /**
   * DepartmentDocument createMany
   */
  export type DepartmentDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DepartmentDocuments.
     */
    data: DepartmentDocumentCreateManyInput | DepartmentDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DepartmentDocument createManyAndReturn
   */
  export type DepartmentDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentDocument
     */
    select?: DepartmentDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentDocument
     */
    omit?: DepartmentDocumentOmit<ExtArgs> | null
    /**
     * The data used to create many DepartmentDocuments.
     */
    data: DepartmentDocumentCreateManyInput | DepartmentDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DepartmentDocument update
   */
  export type DepartmentDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentDocument
     */
    select?: DepartmentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentDocument
     */
    omit?: DepartmentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a DepartmentDocument.
     */
    data: XOR<DepartmentDocumentUpdateInput, DepartmentDocumentUncheckedUpdateInput>
    /**
     * Choose, which DepartmentDocument to update.
     */
    where: DepartmentDocumentWhereUniqueInput
  }

  /**
   * DepartmentDocument updateMany
   */
  export type DepartmentDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DepartmentDocuments.
     */
    data: XOR<DepartmentDocumentUpdateManyMutationInput, DepartmentDocumentUncheckedUpdateManyInput>
    /**
     * Filter which DepartmentDocuments to update
     */
    where?: DepartmentDocumentWhereInput
    /**
     * Limit how many DepartmentDocuments to update.
     */
    limit?: number
  }

  /**
   * DepartmentDocument updateManyAndReturn
   */
  export type DepartmentDocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentDocument
     */
    select?: DepartmentDocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentDocument
     */
    omit?: DepartmentDocumentOmit<ExtArgs> | null
    /**
     * The data used to update DepartmentDocuments.
     */
    data: XOR<DepartmentDocumentUpdateManyMutationInput, DepartmentDocumentUncheckedUpdateManyInput>
    /**
     * Filter which DepartmentDocuments to update
     */
    where?: DepartmentDocumentWhereInput
    /**
     * Limit how many DepartmentDocuments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentDocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DepartmentDocument upsert
   */
  export type DepartmentDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentDocument
     */
    select?: DepartmentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentDocument
     */
    omit?: DepartmentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the DepartmentDocument to update in case it exists.
     */
    where: DepartmentDocumentWhereUniqueInput
    /**
     * In case the DepartmentDocument found by the `where` argument doesn't exist, create a new DepartmentDocument with this data.
     */
    create: XOR<DepartmentDocumentCreateInput, DepartmentDocumentUncheckedCreateInput>
    /**
     * In case the DepartmentDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentDocumentUpdateInput, DepartmentDocumentUncheckedUpdateInput>
  }

  /**
   * DepartmentDocument delete
   */
  export type DepartmentDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentDocument
     */
    select?: DepartmentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentDocument
     */
    omit?: DepartmentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentDocumentInclude<ExtArgs> | null
    /**
     * Filter which DepartmentDocument to delete.
     */
    where: DepartmentDocumentWhereUniqueInput
  }

  /**
   * DepartmentDocument deleteMany
   */
  export type DepartmentDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DepartmentDocuments to delete
     */
    where?: DepartmentDocumentWhereInput
    /**
     * Limit how many DepartmentDocuments to delete.
     */
    limit?: number
  }

  /**
   * DepartmentDocument without action
   */
  export type DepartmentDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentDocument
     */
    select?: DepartmentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentDocument
     */
    omit?: DepartmentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentDocumentInclude<ExtArgs> | null
  }


  /**
   * Model DepartmentGoal
   */

  export type AggregateDepartmentGoal = {
    _count: DepartmentGoalCountAggregateOutputType | null
    _avg: DepartmentGoalAvgAggregateOutputType | null
    _sum: DepartmentGoalSumAggregateOutputType | null
    _min: DepartmentGoalMinAggregateOutputType | null
    _max: DepartmentGoalMaxAggregateOutputType | null
  }

  export type DepartmentGoalAvgAggregateOutputType = {
    targetValue: number | null
    currentValue: number | null
  }

  export type DepartmentGoalSumAggregateOutputType = {
    targetValue: number | null
    currentValue: number | null
  }

  export type DepartmentGoalMinAggregateOutputType = {
    id: string | null
    deptId: string | null
    title: string | null
    description: string | null
    targetValue: number | null
    currentValue: number | null
    period: string | null
    periodKey: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentGoalMaxAggregateOutputType = {
    id: string | null
    deptId: string | null
    title: string | null
    description: string | null
    targetValue: number | null
    currentValue: number | null
    period: string | null
    periodKey: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentGoalCountAggregateOutputType = {
    id: number
    deptId: number
    title: number
    description: number
    targetValue: number
    currentValue: number
    period: number
    periodKey: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DepartmentGoalAvgAggregateInputType = {
    targetValue?: true
    currentValue?: true
  }

  export type DepartmentGoalSumAggregateInputType = {
    targetValue?: true
    currentValue?: true
  }

  export type DepartmentGoalMinAggregateInputType = {
    id?: true
    deptId?: true
    title?: true
    description?: true
    targetValue?: true
    currentValue?: true
    period?: true
    periodKey?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentGoalMaxAggregateInputType = {
    id?: true
    deptId?: true
    title?: true
    description?: true
    targetValue?: true
    currentValue?: true
    period?: true
    periodKey?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentGoalCountAggregateInputType = {
    id?: true
    deptId?: true
    title?: true
    description?: true
    targetValue?: true
    currentValue?: true
    period?: true
    periodKey?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepartmentGoalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DepartmentGoal to aggregate.
     */
    where?: DepartmentGoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentGoals to fetch.
     */
    orderBy?: DepartmentGoalOrderByWithRelationInput | DepartmentGoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentGoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentGoals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentGoals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DepartmentGoals
    **/
    _count?: true | DepartmentGoalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepartmentGoalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepartmentGoalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentGoalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentGoalMaxAggregateInputType
  }

  export type GetDepartmentGoalAggregateType<T extends DepartmentGoalAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartmentGoal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartmentGoal[P]>
      : GetScalarType<T[P], AggregateDepartmentGoal[P]>
  }




  export type DepartmentGoalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentGoalWhereInput
    orderBy?: DepartmentGoalOrderByWithAggregationInput | DepartmentGoalOrderByWithAggregationInput[]
    by: DepartmentGoalScalarFieldEnum[] | DepartmentGoalScalarFieldEnum
    having?: DepartmentGoalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentGoalCountAggregateInputType | true
    _avg?: DepartmentGoalAvgAggregateInputType
    _sum?: DepartmentGoalSumAggregateInputType
    _min?: DepartmentGoalMinAggregateInputType
    _max?: DepartmentGoalMaxAggregateInputType
  }

  export type DepartmentGoalGroupByOutputType = {
    id: string
    deptId: string
    title: string
    description: string | null
    targetValue: number | null
    currentValue: number
    period: string
    periodKey: string
    createdAt: Date
    updatedAt: Date
    _count: DepartmentGoalCountAggregateOutputType | null
    _avg: DepartmentGoalAvgAggregateOutputType | null
    _sum: DepartmentGoalSumAggregateOutputType | null
    _min: DepartmentGoalMinAggregateOutputType | null
    _max: DepartmentGoalMaxAggregateOutputType | null
  }

  type GetDepartmentGoalGroupByPayload<T extends DepartmentGoalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentGoalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentGoalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentGoalGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentGoalGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentGoalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deptId?: boolean
    title?: boolean
    description?: boolean
    targetValue?: boolean
    currentValue?: boolean
    period?: boolean
    periodKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["departmentGoal"]>

  export type DepartmentGoalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deptId?: boolean
    title?: boolean
    description?: boolean
    targetValue?: boolean
    currentValue?: boolean
    period?: boolean
    periodKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["departmentGoal"]>

  export type DepartmentGoalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deptId?: boolean
    title?: boolean
    description?: boolean
    targetValue?: boolean
    currentValue?: boolean
    period?: boolean
    periodKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["departmentGoal"]>

  export type DepartmentGoalSelectScalar = {
    id?: boolean
    deptId?: boolean
    title?: boolean
    description?: boolean
    targetValue?: boolean
    currentValue?: boolean
    period?: boolean
    periodKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DepartmentGoalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "deptId" | "title" | "description" | "targetValue" | "currentValue" | "period" | "periodKey" | "createdAt" | "updatedAt", ExtArgs["result"]["departmentGoal"]>
  export type DepartmentGoalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }
  export type DepartmentGoalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }
  export type DepartmentGoalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }

  export type $DepartmentGoalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DepartmentGoal"
    objects: {
      department: Prisma.$DepartmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      deptId: string
      title: string
      description: string | null
      targetValue: number | null
      currentValue: number
      period: string
      periodKey: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["departmentGoal"]>
    composites: {}
  }

  type DepartmentGoalGetPayload<S extends boolean | null | undefined | DepartmentGoalDefaultArgs> = $Result.GetResult<Prisma.$DepartmentGoalPayload, S>

  type DepartmentGoalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DepartmentGoalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepartmentGoalCountAggregateInputType | true
    }

  export interface DepartmentGoalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DepartmentGoal'], meta: { name: 'DepartmentGoal' } }
    /**
     * Find zero or one DepartmentGoal that matches the filter.
     * @param {DepartmentGoalFindUniqueArgs} args - Arguments to find a DepartmentGoal
     * @example
     * // Get one DepartmentGoal
     * const departmentGoal = await prisma.departmentGoal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentGoalFindUniqueArgs>(args: SelectSubset<T, DepartmentGoalFindUniqueArgs<ExtArgs>>): Prisma__DepartmentGoalClient<$Result.GetResult<Prisma.$DepartmentGoalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DepartmentGoal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DepartmentGoalFindUniqueOrThrowArgs} args - Arguments to find a DepartmentGoal
     * @example
     * // Get one DepartmentGoal
     * const departmentGoal = await prisma.departmentGoal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentGoalFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentGoalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentGoalClient<$Result.GetResult<Prisma.$DepartmentGoalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DepartmentGoal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGoalFindFirstArgs} args - Arguments to find a DepartmentGoal
     * @example
     * // Get one DepartmentGoal
     * const departmentGoal = await prisma.departmentGoal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentGoalFindFirstArgs>(args?: SelectSubset<T, DepartmentGoalFindFirstArgs<ExtArgs>>): Prisma__DepartmentGoalClient<$Result.GetResult<Prisma.$DepartmentGoalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DepartmentGoal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGoalFindFirstOrThrowArgs} args - Arguments to find a DepartmentGoal
     * @example
     * // Get one DepartmentGoal
     * const departmentGoal = await prisma.departmentGoal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentGoalFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentGoalFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentGoalClient<$Result.GetResult<Prisma.$DepartmentGoalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DepartmentGoals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGoalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DepartmentGoals
     * const departmentGoals = await prisma.departmentGoal.findMany()
     * 
     * // Get first 10 DepartmentGoals
     * const departmentGoals = await prisma.departmentGoal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentGoalWithIdOnly = await prisma.departmentGoal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentGoalFindManyArgs>(args?: SelectSubset<T, DepartmentGoalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentGoalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DepartmentGoal.
     * @param {DepartmentGoalCreateArgs} args - Arguments to create a DepartmentGoal.
     * @example
     * // Create one DepartmentGoal
     * const DepartmentGoal = await prisma.departmentGoal.create({
     *   data: {
     *     // ... data to create a DepartmentGoal
     *   }
     * })
     * 
     */
    create<T extends DepartmentGoalCreateArgs>(args: SelectSubset<T, DepartmentGoalCreateArgs<ExtArgs>>): Prisma__DepartmentGoalClient<$Result.GetResult<Prisma.$DepartmentGoalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DepartmentGoals.
     * @param {DepartmentGoalCreateManyArgs} args - Arguments to create many DepartmentGoals.
     * @example
     * // Create many DepartmentGoals
     * const departmentGoal = await prisma.departmentGoal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentGoalCreateManyArgs>(args?: SelectSubset<T, DepartmentGoalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DepartmentGoals and returns the data saved in the database.
     * @param {DepartmentGoalCreateManyAndReturnArgs} args - Arguments to create many DepartmentGoals.
     * @example
     * // Create many DepartmentGoals
     * const departmentGoal = await prisma.departmentGoal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DepartmentGoals and only return the `id`
     * const departmentGoalWithIdOnly = await prisma.departmentGoal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepartmentGoalCreateManyAndReturnArgs>(args?: SelectSubset<T, DepartmentGoalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentGoalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DepartmentGoal.
     * @param {DepartmentGoalDeleteArgs} args - Arguments to delete one DepartmentGoal.
     * @example
     * // Delete one DepartmentGoal
     * const DepartmentGoal = await prisma.departmentGoal.delete({
     *   where: {
     *     // ... filter to delete one DepartmentGoal
     *   }
     * })
     * 
     */
    delete<T extends DepartmentGoalDeleteArgs>(args: SelectSubset<T, DepartmentGoalDeleteArgs<ExtArgs>>): Prisma__DepartmentGoalClient<$Result.GetResult<Prisma.$DepartmentGoalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DepartmentGoal.
     * @param {DepartmentGoalUpdateArgs} args - Arguments to update one DepartmentGoal.
     * @example
     * // Update one DepartmentGoal
     * const departmentGoal = await prisma.departmentGoal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentGoalUpdateArgs>(args: SelectSubset<T, DepartmentGoalUpdateArgs<ExtArgs>>): Prisma__DepartmentGoalClient<$Result.GetResult<Prisma.$DepartmentGoalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DepartmentGoals.
     * @param {DepartmentGoalDeleteManyArgs} args - Arguments to filter DepartmentGoals to delete.
     * @example
     * // Delete a few DepartmentGoals
     * const { count } = await prisma.departmentGoal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentGoalDeleteManyArgs>(args?: SelectSubset<T, DepartmentGoalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DepartmentGoals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGoalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DepartmentGoals
     * const departmentGoal = await prisma.departmentGoal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentGoalUpdateManyArgs>(args: SelectSubset<T, DepartmentGoalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DepartmentGoals and returns the data updated in the database.
     * @param {DepartmentGoalUpdateManyAndReturnArgs} args - Arguments to update many DepartmentGoals.
     * @example
     * // Update many DepartmentGoals
     * const departmentGoal = await prisma.departmentGoal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DepartmentGoals and only return the `id`
     * const departmentGoalWithIdOnly = await prisma.departmentGoal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DepartmentGoalUpdateManyAndReturnArgs>(args: SelectSubset<T, DepartmentGoalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentGoalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DepartmentGoal.
     * @param {DepartmentGoalUpsertArgs} args - Arguments to update or create a DepartmentGoal.
     * @example
     * // Update or create a DepartmentGoal
     * const departmentGoal = await prisma.departmentGoal.upsert({
     *   create: {
     *     // ... data to create a DepartmentGoal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DepartmentGoal we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentGoalUpsertArgs>(args: SelectSubset<T, DepartmentGoalUpsertArgs<ExtArgs>>): Prisma__DepartmentGoalClient<$Result.GetResult<Prisma.$DepartmentGoalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DepartmentGoals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGoalCountArgs} args - Arguments to filter DepartmentGoals to count.
     * @example
     * // Count the number of DepartmentGoals
     * const count = await prisma.departmentGoal.count({
     *   where: {
     *     // ... the filter for the DepartmentGoals we want to count
     *   }
     * })
    **/
    count<T extends DepartmentGoalCountArgs>(
      args?: Subset<T, DepartmentGoalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentGoalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DepartmentGoal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGoalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentGoalAggregateArgs>(args: Subset<T, DepartmentGoalAggregateArgs>): Prisma.PrismaPromise<GetDepartmentGoalAggregateType<T>>

    /**
     * Group by DepartmentGoal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGoalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentGoalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentGoalGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentGoalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentGoalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentGoalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DepartmentGoal model
   */
  readonly fields: DepartmentGoalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DepartmentGoal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentGoalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    department<T extends DepartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DepartmentDefaultArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DepartmentGoal model
   */
  interface DepartmentGoalFieldRefs {
    readonly id: FieldRef<"DepartmentGoal", 'String'>
    readonly deptId: FieldRef<"DepartmentGoal", 'String'>
    readonly title: FieldRef<"DepartmentGoal", 'String'>
    readonly description: FieldRef<"DepartmentGoal", 'String'>
    readonly targetValue: FieldRef<"DepartmentGoal", 'Float'>
    readonly currentValue: FieldRef<"DepartmentGoal", 'Float'>
    readonly period: FieldRef<"DepartmentGoal", 'String'>
    readonly periodKey: FieldRef<"DepartmentGoal", 'String'>
    readonly createdAt: FieldRef<"DepartmentGoal", 'DateTime'>
    readonly updatedAt: FieldRef<"DepartmentGoal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DepartmentGoal findUnique
   */
  export type DepartmentGoalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentGoal
     */
    select?: DepartmentGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentGoal
     */
    omit?: DepartmentGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentGoalInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentGoal to fetch.
     */
    where: DepartmentGoalWhereUniqueInput
  }

  /**
   * DepartmentGoal findUniqueOrThrow
   */
  export type DepartmentGoalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentGoal
     */
    select?: DepartmentGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentGoal
     */
    omit?: DepartmentGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentGoalInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentGoal to fetch.
     */
    where: DepartmentGoalWhereUniqueInput
  }

  /**
   * DepartmentGoal findFirst
   */
  export type DepartmentGoalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentGoal
     */
    select?: DepartmentGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentGoal
     */
    omit?: DepartmentGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentGoalInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentGoal to fetch.
     */
    where?: DepartmentGoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentGoals to fetch.
     */
    orderBy?: DepartmentGoalOrderByWithRelationInput | DepartmentGoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DepartmentGoals.
     */
    cursor?: DepartmentGoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentGoals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentGoals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DepartmentGoals.
     */
    distinct?: DepartmentGoalScalarFieldEnum | DepartmentGoalScalarFieldEnum[]
  }

  /**
   * DepartmentGoal findFirstOrThrow
   */
  export type DepartmentGoalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentGoal
     */
    select?: DepartmentGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentGoal
     */
    omit?: DepartmentGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentGoalInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentGoal to fetch.
     */
    where?: DepartmentGoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentGoals to fetch.
     */
    orderBy?: DepartmentGoalOrderByWithRelationInput | DepartmentGoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DepartmentGoals.
     */
    cursor?: DepartmentGoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentGoals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentGoals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DepartmentGoals.
     */
    distinct?: DepartmentGoalScalarFieldEnum | DepartmentGoalScalarFieldEnum[]
  }

  /**
   * DepartmentGoal findMany
   */
  export type DepartmentGoalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentGoal
     */
    select?: DepartmentGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentGoal
     */
    omit?: DepartmentGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentGoalInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentGoals to fetch.
     */
    where?: DepartmentGoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentGoals to fetch.
     */
    orderBy?: DepartmentGoalOrderByWithRelationInput | DepartmentGoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DepartmentGoals.
     */
    cursor?: DepartmentGoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentGoals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentGoals.
     */
    skip?: number
    distinct?: DepartmentGoalScalarFieldEnum | DepartmentGoalScalarFieldEnum[]
  }

  /**
   * DepartmentGoal create
   */
  export type DepartmentGoalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentGoal
     */
    select?: DepartmentGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentGoal
     */
    omit?: DepartmentGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentGoalInclude<ExtArgs> | null
    /**
     * The data needed to create a DepartmentGoal.
     */
    data: XOR<DepartmentGoalCreateInput, DepartmentGoalUncheckedCreateInput>
  }

  /**
   * DepartmentGoal createMany
   */
  export type DepartmentGoalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DepartmentGoals.
     */
    data: DepartmentGoalCreateManyInput | DepartmentGoalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DepartmentGoal createManyAndReturn
   */
  export type DepartmentGoalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentGoal
     */
    select?: DepartmentGoalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentGoal
     */
    omit?: DepartmentGoalOmit<ExtArgs> | null
    /**
     * The data used to create many DepartmentGoals.
     */
    data: DepartmentGoalCreateManyInput | DepartmentGoalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentGoalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DepartmentGoal update
   */
  export type DepartmentGoalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentGoal
     */
    select?: DepartmentGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentGoal
     */
    omit?: DepartmentGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentGoalInclude<ExtArgs> | null
    /**
     * The data needed to update a DepartmentGoal.
     */
    data: XOR<DepartmentGoalUpdateInput, DepartmentGoalUncheckedUpdateInput>
    /**
     * Choose, which DepartmentGoal to update.
     */
    where: DepartmentGoalWhereUniqueInput
  }

  /**
   * DepartmentGoal updateMany
   */
  export type DepartmentGoalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DepartmentGoals.
     */
    data: XOR<DepartmentGoalUpdateManyMutationInput, DepartmentGoalUncheckedUpdateManyInput>
    /**
     * Filter which DepartmentGoals to update
     */
    where?: DepartmentGoalWhereInput
    /**
     * Limit how many DepartmentGoals to update.
     */
    limit?: number
  }

  /**
   * DepartmentGoal updateManyAndReturn
   */
  export type DepartmentGoalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentGoal
     */
    select?: DepartmentGoalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentGoal
     */
    omit?: DepartmentGoalOmit<ExtArgs> | null
    /**
     * The data used to update DepartmentGoals.
     */
    data: XOR<DepartmentGoalUpdateManyMutationInput, DepartmentGoalUncheckedUpdateManyInput>
    /**
     * Filter which DepartmentGoals to update
     */
    where?: DepartmentGoalWhereInput
    /**
     * Limit how many DepartmentGoals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentGoalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DepartmentGoal upsert
   */
  export type DepartmentGoalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentGoal
     */
    select?: DepartmentGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentGoal
     */
    omit?: DepartmentGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentGoalInclude<ExtArgs> | null
    /**
     * The filter to search for the DepartmentGoal to update in case it exists.
     */
    where: DepartmentGoalWhereUniqueInput
    /**
     * In case the DepartmentGoal found by the `where` argument doesn't exist, create a new DepartmentGoal with this data.
     */
    create: XOR<DepartmentGoalCreateInput, DepartmentGoalUncheckedCreateInput>
    /**
     * In case the DepartmentGoal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentGoalUpdateInput, DepartmentGoalUncheckedUpdateInput>
  }

  /**
   * DepartmentGoal delete
   */
  export type DepartmentGoalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentGoal
     */
    select?: DepartmentGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentGoal
     */
    omit?: DepartmentGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentGoalInclude<ExtArgs> | null
    /**
     * Filter which DepartmentGoal to delete.
     */
    where: DepartmentGoalWhereUniqueInput
  }

  /**
   * DepartmentGoal deleteMany
   */
  export type DepartmentGoalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DepartmentGoals to delete
     */
    where?: DepartmentGoalWhereInput
    /**
     * Limit how many DepartmentGoals to delete.
     */
    limit?: number
  }

  /**
   * DepartmentGoal without action
   */
  export type DepartmentGoalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentGoal
     */
    select?: DepartmentGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentGoal
     */
    omit?: DepartmentGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentGoalInclude<ExtArgs> | null
  }


  /**
   * Model DepartmentMeeting
   */

  export type AggregateDepartmentMeeting = {
    _count: DepartmentMeetingCountAggregateOutputType | null
    _min: DepartmentMeetingMinAggregateOutputType | null
    _max: DepartmentMeetingMaxAggregateOutputType | null
  }

  export type DepartmentMeetingMinAggregateOutputType = {
    id: string | null
    deptId: string | null
    title: string | null
    description: string | null
    agenda: string | null
    meetingDate: Date | null
    location: string | null
    createdBy: string | null
    minutes: string | null
    minutesAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentMeetingMaxAggregateOutputType = {
    id: string | null
    deptId: string | null
    title: string | null
    description: string | null
    agenda: string | null
    meetingDate: Date | null
    location: string | null
    createdBy: string | null
    minutes: string | null
    minutesAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentMeetingCountAggregateOutputType = {
    id: number
    deptId: number
    title: number
    description: number
    agenda: number
    meetingDate: number
    location: number
    createdBy: number
    minutes: number
    minutesAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DepartmentMeetingMinAggregateInputType = {
    id?: true
    deptId?: true
    title?: true
    description?: true
    agenda?: true
    meetingDate?: true
    location?: true
    createdBy?: true
    minutes?: true
    minutesAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentMeetingMaxAggregateInputType = {
    id?: true
    deptId?: true
    title?: true
    description?: true
    agenda?: true
    meetingDate?: true
    location?: true
    createdBy?: true
    minutes?: true
    minutesAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentMeetingCountAggregateInputType = {
    id?: true
    deptId?: true
    title?: true
    description?: true
    agenda?: true
    meetingDate?: true
    location?: true
    createdBy?: true
    minutes?: true
    minutesAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepartmentMeetingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DepartmentMeeting to aggregate.
     */
    where?: DepartmentMeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentMeetings to fetch.
     */
    orderBy?: DepartmentMeetingOrderByWithRelationInput | DepartmentMeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentMeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentMeetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentMeetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DepartmentMeetings
    **/
    _count?: true | DepartmentMeetingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMeetingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMeetingMaxAggregateInputType
  }

  export type GetDepartmentMeetingAggregateType<T extends DepartmentMeetingAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartmentMeeting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartmentMeeting[P]>
      : GetScalarType<T[P], AggregateDepartmentMeeting[P]>
  }




  export type DepartmentMeetingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentMeetingWhereInput
    orderBy?: DepartmentMeetingOrderByWithAggregationInput | DepartmentMeetingOrderByWithAggregationInput[]
    by: DepartmentMeetingScalarFieldEnum[] | DepartmentMeetingScalarFieldEnum
    having?: DepartmentMeetingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentMeetingCountAggregateInputType | true
    _min?: DepartmentMeetingMinAggregateInputType
    _max?: DepartmentMeetingMaxAggregateInputType
  }

  export type DepartmentMeetingGroupByOutputType = {
    id: string
    deptId: string
    title: string
    description: string | null
    agenda: string | null
    meetingDate: Date
    location: string | null
    createdBy: string
    minutes: string | null
    minutesAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: DepartmentMeetingCountAggregateOutputType | null
    _min: DepartmentMeetingMinAggregateOutputType | null
    _max: DepartmentMeetingMaxAggregateOutputType | null
  }

  type GetDepartmentMeetingGroupByPayload<T extends DepartmentMeetingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentMeetingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentMeetingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentMeetingGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentMeetingGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentMeetingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deptId?: boolean
    title?: boolean
    description?: boolean
    agenda?: boolean
    meetingDate?: boolean
    location?: boolean
    createdBy?: boolean
    minutes?: boolean
    minutesAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["departmentMeeting"]>

  export type DepartmentMeetingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deptId?: boolean
    title?: boolean
    description?: boolean
    agenda?: boolean
    meetingDate?: boolean
    location?: boolean
    createdBy?: boolean
    minutes?: boolean
    minutesAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["departmentMeeting"]>

  export type DepartmentMeetingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deptId?: boolean
    title?: boolean
    description?: boolean
    agenda?: boolean
    meetingDate?: boolean
    location?: boolean
    createdBy?: boolean
    minutes?: boolean
    minutesAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["departmentMeeting"]>

  export type DepartmentMeetingSelectScalar = {
    id?: boolean
    deptId?: boolean
    title?: boolean
    description?: boolean
    agenda?: boolean
    meetingDate?: boolean
    location?: boolean
    createdBy?: boolean
    minutes?: boolean
    minutesAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DepartmentMeetingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "deptId" | "title" | "description" | "agenda" | "meetingDate" | "location" | "createdBy" | "minutes" | "minutesAt" | "createdAt" | "updatedAt", ExtArgs["result"]["departmentMeeting"]>
  export type DepartmentMeetingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DepartmentMeetingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DepartmentMeetingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DepartmentMeetingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DepartmentMeeting"
    objects: {
      department: Prisma.$DepartmentPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      deptId: string
      title: string
      description: string | null
      agenda: string | null
      meetingDate: Date
      location: string | null
      createdBy: string
      minutes: string | null
      minutesAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["departmentMeeting"]>
    composites: {}
  }

  type DepartmentMeetingGetPayload<S extends boolean | null | undefined | DepartmentMeetingDefaultArgs> = $Result.GetResult<Prisma.$DepartmentMeetingPayload, S>

  type DepartmentMeetingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DepartmentMeetingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepartmentMeetingCountAggregateInputType | true
    }

  export interface DepartmentMeetingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DepartmentMeeting'], meta: { name: 'DepartmentMeeting' } }
    /**
     * Find zero or one DepartmentMeeting that matches the filter.
     * @param {DepartmentMeetingFindUniqueArgs} args - Arguments to find a DepartmentMeeting
     * @example
     * // Get one DepartmentMeeting
     * const departmentMeeting = await prisma.departmentMeeting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentMeetingFindUniqueArgs>(args: SelectSubset<T, DepartmentMeetingFindUniqueArgs<ExtArgs>>): Prisma__DepartmentMeetingClient<$Result.GetResult<Prisma.$DepartmentMeetingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DepartmentMeeting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DepartmentMeetingFindUniqueOrThrowArgs} args - Arguments to find a DepartmentMeeting
     * @example
     * // Get one DepartmentMeeting
     * const departmentMeeting = await prisma.departmentMeeting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentMeetingFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentMeetingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentMeetingClient<$Result.GetResult<Prisma.$DepartmentMeetingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DepartmentMeeting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentMeetingFindFirstArgs} args - Arguments to find a DepartmentMeeting
     * @example
     * // Get one DepartmentMeeting
     * const departmentMeeting = await prisma.departmentMeeting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentMeetingFindFirstArgs>(args?: SelectSubset<T, DepartmentMeetingFindFirstArgs<ExtArgs>>): Prisma__DepartmentMeetingClient<$Result.GetResult<Prisma.$DepartmentMeetingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DepartmentMeeting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentMeetingFindFirstOrThrowArgs} args - Arguments to find a DepartmentMeeting
     * @example
     * // Get one DepartmentMeeting
     * const departmentMeeting = await prisma.departmentMeeting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentMeetingFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentMeetingFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentMeetingClient<$Result.GetResult<Prisma.$DepartmentMeetingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DepartmentMeetings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentMeetingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DepartmentMeetings
     * const departmentMeetings = await prisma.departmentMeeting.findMany()
     * 
     * // Get first 10 DepartmentMeetings
     * const departmentMeetings = await prisma.departmentMeeting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentMeetingWithIdOnly = await prisma.departmentMeeting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentMeetingFindManyArgs>(args?: SelectSubset<T, DepartmentMeetingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentMeetingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DepartmentMeeting.
     * @param {DepartmentMeetingCreateArgs} args - Arguments to create a DepartmentMeeting.
     * @example
     * // Create one DepartmentMeeting
     * const DepartmentMeeting = await prisma.departmentMeeting.create({
     *   data: {
     *     // ... data to create a DepartmentMeeting
     *   }
     * })
     * 
     */
    create<T extends DepartmentMeetingCreateArgs>(args: SelectSubset<T, DepartmentMeetingCreateArgs<ExtArgs>>): Prisma__DepartmentMeetingClient<$Result.GetResult<Prisma.$DepartmentMeetingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DepartmentMeetings.
     * @param {DepartmentMeetingCreateManyArgs} args - Arguments to create many DepartmentMeetings.
     * @example
     * // Create many DepartmentMeetings
     * const departmentMeeting = await prisma.departmentMeeting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentMeetingCreateManyArgs>(args?: SelectSubset<T, DepartmentMeetingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DepartmentMeetings and returns the data saved in the database.
     * @param {DepartmentMeetingCreateManyAndReturnArgs} args - Arguments to create many DepartmentMeetings.
     * @example
     * // Create many DepartmentMeetings
     * const departmentMeeting = await prisma.departmentMeeting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DepartmentMeetings and only return the `id`
     * const departmentMeetingWithIdOnly = await prisma.departmentMeeting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepartmentMeetingCreateManyAndReturnArgs>(args?: SelectSubset<T, DepartmentMeetingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentMeetingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DepartmentMeeting.
     * @param {DepartmentMeetingDeleteArgs} args - Arguments to delete one DepartmentMeeting.
     * @example
     * // Delete one DepartmentMeeting
     * const DepartmentMeeting = await prisma.departmentMeeting.delete({
     *   where: {
     *     // ... filter to delete one DepartmentMeeting
     *   }
     * })
     * 
     */
    delete<T extends DepartmentMeetingDeleteArgs>(args: SelectSubset<T, DepartmentMeetingDeleteArgs<ExtArgs>>): Prisma__DepartmentMeetingClient<$Result.GetResult<Prisma.$DepartmentMeetingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DepartmentMeeting.
     * @param {DepartmentMeetingUpdateArgs} args - Arguments to update one DepartmentMeeting.
     * @example
     * // Update one DepartmentMeeting
     * const departmentMeeting = await prisma.departmentMeeting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentMeetingUpdateArgs>(args: SelectSubset<T, DepartmentMeetingUpdateArgs<ExtArgs>>): Prisma__DepartmentMeetingClient<$Result.GetResult<Prisma.$DepartmentMeetingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DepartmentMeetings.
     * @param {DepartmentMeetingDeleteManyArgs} args - Arguments to filter DepartmentMeetings to delete.
     * @example
     * // Delete a few DepartmentMeetings
     * const { count } = await prisma.departmentMeeting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentMeetingDeleteManyArgs>(args?: SelectSubset<T, DepartmentMeetingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DepartmentMeetings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentMeetingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DepartmentMeetings
     * const departmentMeeting = await prisma.departmentMeeting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentMeetingUpdateManyArgs>(args: SelectSubset<T, DepartmentMeetingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DepartmentMeetings and returns the data updated in the database.
     * @param {DepartmentMeetingUpdateManyAndReturnArgs} args - Arguments to update many DepartmentMeetings.
     * @example
     * // Update many DepartmentMeetings
     * const departmentMeeting = await prisma.departmentMeeting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DepartmentMeetings and only return the `id`
     * const departmentMeetingWithIdOnly = await prisma.departmentMeeting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DepartmentMeetingUpdateManyAndReturnArgs>(args: SelectSubset<T, DepartmentMeetingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentMeetingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DepartmentMeeting.
     * @param {DepartmentMeetingUpsertArgs} args - Arguments to update or create a DepartmentMeeting.
     * @example
     * // Update or create a DepartmentMeeting
     * const departmentMeeting = await prisma.departmentMeeting.upsert({
     *   create: {
     *     // ... data to create a DepartmentMeeting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DepartmentMeeting we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentMeetingUpsertArgs>(args: SelectSubset<T, DepartmentMeetingUpsertArgs<ExtArgs>>): Prisma__DepartmentMeetingClient<$Result.GetResult<Prisma.$DepartmentMeetingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DepartmentMeetings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentMeetingCountArgs} args - Arguments to filter DepartmentMeetings to count.
     * @example
     * // Count the number of DepartmentMeetings
     * const count = await prisma.departmentMeeting.count({
     *   where: {
     *     // ... the filter for the DepartmentMeetings we want to count
     *   }
     * })
    **/
    count<T extends DepartmentMeetingCountArgs>(
      args?: Subset<T, DepartmentMeetingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentMeetingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DepartmentMeeting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentMeetingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentMeetingAggregateArgs>(args: Subset<T, DepartmentMeetingAggregateArgs>): Prisma.PrismaPromise<GetDepartmentMeetingAggregateType<T>>

    /**
     * Group by DepartmentMeeting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentMeetingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentMeetingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentMeetingGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentMeetingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentMeetingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentMeetingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DepartmentMeeting model
   */
  readonly fields: DepartmentMeetingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DepartmentMeeting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentMeetingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    department<T extends DepartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DepartmentDefaultArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DepartmentMeeting model
   */
  interface DepartmentMeetingFieldRefs {
    readonly id: FieldRef<"DepartmentMeeting", 'String'>
    readonly deptId: FieldRef<"DepartmentMeeting", 'String'>
    readonly title: FieldRef<"DepartmentMeeting", 'String'>
    readonly description: FieldRef<"DepartmentMeeting", 'String'>
    readonly agenda: FieldRef<"DepartmentMeeting", 'String'>
    readonly meetingDate: FieldRef<"DepartmentMeeting", 'DateTime'>
    readonly location: FieldRef<"DepartmentMeeting", 'String'>
    readonly createdBy: FieldRef<"DepartmentMeeting", 'String'>
    readonly minutes: FieldRef<"DepartmentMeeting", 'String'>
    readonly minutesAt: FieldRef<"DepartmentMeeting", 'DateTime'>
    readonly createdAt: FieldRef<"DepartmentMeeting", 'DateTime'>
    readonly updatedAt: FieldRef<"DepartmentMeeting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DepartmentMeeting findUnique
   */
  export type DepartmentMeetingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentMeeting
     */
    select?: DepartmentMeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentMeeting
     */
    omit?: DepartmentMeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentMeetingInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentMeeting to fetch.
     */
    where: DepartmentMeetingWhereUniqueInput
  }

  /**
   * DepartmentMeeting findUniqueOrThrow
   */
  export type DepartmentMeetingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentMeeting
     */
    select?: DepartmentMeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentMeeting
     */
    omit?: DepartmentMeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentMeetingInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentMeeting to fetch.
     */
    where: DepartmentMeetingWhereUniqueInput
  }

  /**
   * DepartmentMeeting findFirst
   */
  export type DepartmentMeetingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentMeeting
     */
    select?: DepartmentMeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentMeeting
     */
    omit?: DepartmentMeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentMeetingInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentMeeting to fetch.
     */
    where?: DepartmentMeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentMeetings to fetch.
     */
    orderBy?: DepartmentMeetingOrderByWithRelationInput | DepartmentMeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DepartmentMeetings.
     */
    cursor?: DepartmentMeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentMeetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentMeetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DepartmentMeetings.
     */
    distinct?: DepartmentMeetingScalarFieldEnum | DepartmentMeetingScalarFieldEnum[]
  }

  /**
   * DepartmentMeeting findFirstOrThrow
   */
  export type DepartmentMeetingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentMeeting
     */
    select?: DepartmentMeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentMeeting
     */
    omit?: DepartmentMeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentMeetingInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentMeeting to fetch.
     */
    where?: DepartmentMeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentMeetings to fetch.
     */
    orderBy?: DepartmentMeetingOrderByWithRelationInput | DepartmentMeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DepartmentMeetings.
     */
    cursor?: DepartmentMeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentMeetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentMeetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DepartmentMeetings.
     */
    distinct?: DepartmentMeetingScalarFieldEnum | DepartmentMeetingScalarFieldEnum[]
  }

  /**
   * DepartmentMeeting findMany
   */
  export type DepartmentMeetingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentMeeting
     */
    select?: DepartmentMeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentMeeting
     */
    omit?: DepartmentMeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentMeetingInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentMeetings to fetch.
     */
    where?: DepartmentMeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentMeetings to fetch.
     */
    orderBy?: DepartmentMeetingOrderByWithRelationInput | DepartmentMeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DepartmentMeetings.
     */
    cursor?: DepartmentMeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentMeetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentMeetings.
     */
    skip?: number
    distinct?: DepartmentMeetingScalarFieldEnum | DepartmentMeetingScalarFieldEnum[]
  }

  /**
   * DepartmentMeeting create
   */
  export type DepartmentMeetingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentMeeting
     */
    select?: DepartmentMeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentMeeting
     */
    omit?: DepartmentMeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentMeetingInclude<ExtArgs> | null
    /**
     * The data needed to create a DepartmentMeeting.
     */
    data: XOR<DepartmentMeetingCreateInput, DepartmentMeetingUncheckedCreateInput>
  }

  /**
   * DepartmentMeeting createMany
   */
  export type DepartmentMeetingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DepartmentMeetings.
     */
    data: DepartmentMeetingCreateManyInput | DepartmentMeetingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DepartmentMeeting createManyAndReturn
   */
  export type DepartmentMeetingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentMeeting
     */
    select?: DepartmentMeetingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentMeeting
     */
    omit?: DepartmentMeetingOmit<ExtArgs> | null
    /**
     * The data used to create many DepartmentMeetings.
     */
    data: DepartmentMeetingCreateManyInput | DepartmentMeetingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentMeetingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DepartmentMeeting update
   */
  export type DepartmentMeetingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentMeeting
     */
    select?: DepartmentMeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentMeeting
     */
    omit?: DepartmentMeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentMeetingInclude<ExtArgs> | null
    /**
     * The data needed to update a DepartmentMeeting.
     */
    data: XOR<DepartmentMeetingUpdateInput, DepartmentMeetingUncheckedUpdateInput>
    /**
     * Choose, which DepartmentMeeting to update.
     */
    where: DepartmentMeetingWhereUniqueInput
  }

  /**
   * DepartmentMeeting updateMany
   */
  export type DepartmentMeetingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DepartmentMeetings.
     */
    data: XOR<DepartmentMeetingUpdateManyMutationInput, DepartmentMeetingUncheckedUpdateManyInput>
    /**
     * Filter which DepartmentMeetings to update
     */
    where?: DepartmentMeetingWhereInput
    /**
     * Limit how many DepartmentMeetings to update.
     */
    limit?: number
  }

  /**
   * DepartmentMeeting updateManyAndReturn
   */
  export type DepartmentMeetingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentMeeting
     */
    select?: DepartmentMeetingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentMeeting
     */
    omit?: DepartmentMeetingOmit<ExtArgs> | null
    /**
     * The data used to update DepartmentMeetings.
     */
    data: XOR<DepartmentMeetingUpdateManyMutationInput, DepartmentMeetingUncheckedUpdateManyInput>
    /**
     * Filter which DepartmentMeetings to update
     */
    where?: DepartmentMeetingWhereInput
    /**
     * Limit how many DepartmentMeetings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentMeetingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DepartmentMeeting upsert
   */
  export type DepartmentMeetingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentMeeting
     */
    select?: DepartmentMeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentMeeting
     */
    omit?: DepartmentMeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentMeetingInclude<ExtArgs> | null
    /**
     * The filter to search for the DepartmentMeeting to update in case it exists.
     */
    where: DepartmentMeetingWhereUniqueInput
    /**
     * In case the DepartmentMeeting found by the `where` argument doesn't exist, create a new DepartmentMeeting with this data.
     */
    create: XOR<DepartmentMeetingCreateInput, DepartmentMeetingUncheckedCreateInput>
    /**
     * In case the DepartmentMeeting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentMeetingUpdateInput, DepartmentMeetingUncheckedUpdateInput>
  }

  /**
   * DepartmentMeeting delete
   */
  export type DepartmentMeetingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentMeeting
     */
    select?: DepartmentMeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentMeeting
     */
    omit?: DepartmentMeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentMeetingInclude<ExtArgs> | null
    /**
     * Filter which DepartmentMeeting to delete.
     */
    where: DepartmentMeetingWhereUniqueInput
  }

  /**
   * DepartmentMeeting deleteMany
   */
  export type DepartmentMeetingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DepartmentMeetings to delete
     */
    where?: DepartmentMeetingWhereInput
    /**
     * Limit how many DepartmentMeetings to delete.
     */
    limit?: number
  }

  /**
   * DepartmentMeeting without action
   */
  export type DepartmentMeetingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentMeeting
     */
    select?: DepartmentMeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentMeeting
     */
    omit?: DepartmentMeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentMeetingInclude<ExtArgs> | null
  }


  /**
   * Model DepartmentPoll
   */

  export type AggregateDepartmentPoll = {
    _count: DepartmentPollCountAggregateOutputType | null
    _min: DepartmentPollMinAggregateOutputType | null
    _max: DepartmentPollMaxAggregateOutputType | null
  }

  export type DepartmentPollMinAggregateOutputType = {
    id: string | null
    deptId: string | null
    question: string | null
    endDate: Date | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentPollMaxAggregateOutputType = {
    id: string | null
    deptId: string | null
    question: string | null
    endDate: Date | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentPollCountAggregateOutputType = {
    id: number
    deptId: number
    question: number
    options: number
    endDate: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DepartmentPollMinAggregateInputType = {
    id?: true
    deptId?: true
    question?: true
    endDate?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentPollMaxAggregateInputType = {
    id?: true
    deptId?: true
    question?: true
    endDate?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentPollCountAggregateInputType = {
    id?: true
    deptId?: true
    question?: true
    options?: true
    endDate?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepartmentPollAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DepartmentPoll to aggregate.
     */
    where?: DepartmentPollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentPolls to fetch.
     */
    orderBy?: DepartmentPollOrderByWithRelationInput | DepartmentPollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentPollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentPolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentPolls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DepartmentPolls
    **/
    _count?: true | DepartmentPollCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentPollMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentPollMaxAggregateInputType
  }

  export type GetDepartmentPollAggregateType<T extends DepartmentPollAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartmentPoll]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartmentPoll[P]>
      : GetScalarType<T[P], AggregateDepartmentPoll[P]>
  }




  export type DepartmentPollGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentPollWhereInput
    orderBy?: DepartmentPollOrderByWithAggregationInput | DepartmentPollOrderByWithAggregationInput[]
    by: DepartmentPollScalarFieldEnum[] | DepartmentPollScalarFieldEnum
    having?: DepartmentPollScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentPollCountAggregateInputType | true
    _min?: DepartmentPollMinAggregateInputType
    _max?: DepartmentPollMaxAggregateInputType
  }

  export type DepartmentPollGroupByOutputType = {
    id: string
    deptId: string
    question: string
    options: JsonValue
    endDate: Date | null
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: DepartmentPollCountAggregateOutputType | null
    _min: DepartmentPollMinAggregateOutputType | null
    _max: DepartmentPollMaxAggregateOutputType | null
  }

  type GetDepartmentPollGroupByPayload<T extends DepartmentPollGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentPollGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentPollGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentPollGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentPollGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentPollSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deptId?: boolean
    question?: boolean
    options?: boolean
    endDate?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    votes?: boolean | DepartmentPoll$votesArgs<ExtArgs>
    _count?: boolean | DepartmentPollCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["departmentPoll"]>

  export type DepartmentPollSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deptId?: boolean
    question?: boolean
    options?: boolean
    endDate?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["departmentPoll"]>

  export type DepartmentPollSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deptId?: boolean
    question?: boolean
    options?: boolean
    endDate?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["departmentPoll"]>

  export type DepartmentPollSelectScalar = {
    id?: boolean
    deptId?: boolean
    question?: boolean
    options?: boolean
    endDate?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DepartmentPollOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "deptId" | "question" | "options" | "endDate" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["departmentPoll"]>
  export type DepartmentPollInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    votes?: boolean | DepartmentPoll$votesArgs<ExtArgs>
    _count?: boolean | DepartmentPollCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DepartmentPollIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DepartmentPollIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DepartmentPollPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DepartmentPoll"
    objects: {
      department: Prisma.$DepartmentPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
      votes: Prisma.$PollVotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      deptId: string
      question: string
      options: Prisma.JsonValue
      endDate: Date | null
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["departmentPoll"]>
    composites: {}
  }

  type DepartmentPollGetPayload<S extends boolean | null | undefined | DepartmentPollDefaultArgs> = $Result.GetResult<Prisma.$DepartmentPollPayload, S>

  type DepartmentPollCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DepartmentPollFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepartmentPollCountAggregateInputType | true
    }

  export interface DepartmentPollDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DepartmentPoll'], meta: { name: 'DepartmentPoll' } }
    /**
     * Find zero or one DepartmentPoll that matches the filter.
     * @param {DepartmentPollFindUniqueArgs} args - Arguments to find a DepartmentPoll
     * @example
     * // Get one DepartmentPoll
     * const departmentPoll = await prisma.departmentPoll.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentPollFindUniqueArgs>(args: SelectSubset<T, DepartmentPollFindUniqueArgs<ExtArgs>>): Prisma__DepartmentPollClient<$Result.GetResult<Prisma.$DepartmentPollPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DepartmentPoll that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DepartmentPollFindUniqueOrThrowArgs} args - Arguments to find a DepartmentPoll
     * @example
     * // Get one DepartmentPoll
     * const departmentPoll = await prisma.departmentPoll.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentPollFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentPollFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentPollClient<$Result.GetResult<Prisma.$DepartmentPollPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DepartmentPoll that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentPollFindFirstArgs} args - Arguments to find a DepartmentPoll
     * @example
     * // Get one DepartmentPoll
     * const departmentPoll = await prisma.departmentPoll.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentPollFindFirstArgs>(args?: SelectSubset<T, DepartmentPollFindFirstArgs<ExtArgs>>): Prisma__DepartmentPollClient<$Result.GetResult<Prisma.$DepartmentPollPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DepartmentPoll that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentPollFindFirstOrThrowArgs} args - Arguments to find a DepartmentPoll
     * @example
     * // Get one DepartmentPoll
     * const departmentPoll = await prisma.departmentPoll.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentPollFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentPollFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentPollClient<$Result.GetResult<Prisma.$DepartmentPollPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DepartmentPolls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentPollFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DepartmentPolls
     * const departmentPolls = await prisma.departmentPoll.findMany()
     * 
     * // Get first 10 DepartmentPolls
     * const departmentPolls = await prisma.departmentPoll.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentPollWithIdOnly = await prisma.departmentPoll.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentPollFindManyArgs>(args?: SelectSubset<T, DepartmentPollFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPollPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DepartmentPoll.
     * @param {DepartmentPollCreateArgs} args - Arguments to create a DepartmentPoll.
     * @example
     * // Create one DepartmentPoll
     * const DepartmentPoll = await prisma.departmentPoll.create({
     *   data: {
     *     // ... data to create a DepartmentPoll
     *   }
     * })
     * 
     */
    create<T extends DepartmentPollCreateArgs>(args: SelectSubset<T, DepartmentPollCreateArgs<ExtArgs>>): Prisma__DepartmentPollClient<$Result.GetResult<Prisma.$DepartmentPollPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DepartmentPolls.
     * @param {DepartmentPollCreateManyArgs} args - Arguments to create many DepartmentPolls.
     * @example
     * // Create many DepartmentPolls
     * const departmentPoll = await prisma.departmentPoll.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentPollCreateManyArgs>(args?: SelectSubset<T, DepartmentPollCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DepartmentPolls and returns the data saved in the database.
     * @param {DepartmentPollCreateManyAndReturnArgs} args - Arguments to create many DepartmentPolls.
     * @example
     * // Create many DepartmentPolls
     * const departmentPoll = await prisma.departmentPoll.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DepartmentPolls and only return the `id`
     * const departmentPollWithIdOnly = await prisma.departmentPoll.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepartmentPollCreateManyAndReturnArgs>(args?: SelectSubset<T, DepartmentPollCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPollPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DepartmentPoll.
     * @param {DepartmentPollDeleteArgs} args - Arguments to delete one DepartmentPoll.
     * @example
     * // Delete one DepartmentPoll
     * const DepartmentPoll = await prisma.departmentPoll.delete({
     *   where: {
     *     // ... filter to delete one DepartmentPoll
     *   }
     * })
     * 
     */
    delete<T extends DepartmentPollDeleteArgs>(args: SelectSubset<T, DepartmentPollDeleteArgs<ExtArgs>>): Prisma__DepartmentPollClient<$Result.GetResult<Prisma.$DepartmentPollPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DepartmentPoll.
     * @param {DepartmentPollUpdateArgs} args - Arguments to update one DepartmentPoll.
     * @example
     * // Update one DepartmentPoll
     * const departmentPoll = await prisma.departmentPoll.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentPollUpdateArgs>(args: SelectSubset<T, DepartmentPollUpdateArgs<ExtArgs>>): Prisma__DepartmentPollClient<$Result.GetResult<Prisma.$DepartmentPollPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DepartmentPolls.
     * @param {DepartmentPollDeleteManyArgs} args - Arguments to filter DepartmentPolls to delete.
     * @example
     * // Delete a few DepartmentPolls
     * const { count } = await prisma.departmentPoll.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentPollDeleteManyArgs>(args?: SelectSubset<T, DepartmentPollDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DepartmentPolls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentPollUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DepartmentPolls
     * const departmentPoll = await prisma.departmentPoll.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentPollUpdateManyArgs>(args: SelectSubset<T, DepartmentPollUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DepartmentPolls and returns the data updated in the database.
     * @param {DepartmentPollUpdateManyAndReturnArgs} args - Arguments to update many DepartmentPolls.
     * @example
     * // Update many DepartmentPolls
     * const departmentPoll = await prisma.departmentPoll.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DepartmentPolls and only return the `id`
     * const departmentPollWithIdOnly = await prisma.departmentPoll.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DepartmentPollUpdateManyAndReturnArgs>(args: SelectSubset<T, DepartmentPollUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPollPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DepartmentPoll.
     * @param {DepartmentPollUpsertArgs} args - Arguments to update or create a DepartmentPoll.
     * @example
     * // Update or create a DepartmentPoll
     * const departmentPoll = await prisma.departmentPoll.upsert({
     *   create: {
     *     // ... data to create a DepartmentPoll
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DepartmentPoll we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentPollUpsertArgs>(args: SelectSubset<T, DepartmentPollUpsertArgs<ExtArgs>>): Prisma__DepartmentPollClient<$Result.GetResult<Prisma.$DepartmentPollPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DepartmentPolls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentPollCountArgs} args - Arguments to filter DepartmentPolls to count.
     * @example
     * // Count the number of DepartmentPolls
     * const count = await prisma.departmentPoll.count({
     *   where: {
     *     // ... the filter for the DepartmentPolls we want to count
     *   }
     * })
    **/
    count<T extends DepartmentPollCountArgs>(
      args?: Subset<T, DepartmentPollCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentPollCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DepartmentPoll.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentPollAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentPollAggregateArgs>(args: Subset<T, DepartmentPollAggregateArgs>): Prisma.PrismaPromise<GetDepartmentPollAggregateType<T>>

    /**
     * Group by DepartmentPoll.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentPollGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentPollGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentPollGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentPollGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentPollGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentPollGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DepartmentPoll model
   */
  readonly fields: DepartmentPollFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DepartmentPoll.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentPollClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    department<T extends DepartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DepartmentDefaultArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    votes<T extends DepartmentPoll$votesArgs<ExtArgs> = {}>(args?: Subset<T, DepartmentPoll$votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PollVotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DepartmentPoll model
   */
  interface DepartmentPollFieldRefs {
    readonly id: FieldRef<"DepartmentPoll", 'String'>
    readonly deptId: FieldRef<"DepartmentPoll", 'String'>
    readonly question: FieldRef<"DepartmentPoll", 'String'>
    readonly options: FieldRef<"DepartmentPoll", 'Json'>
    readonly endDate: FieldRef<"DepartmentPoll", 'DateTime'>
    readonly createdBy: FieldRef<"DepartmentPoll", 'String'>
    readonly createdAt: FieldRef<"DepartmentPoll", 'DateTime'>
    readonly updatedAt: FieldRef<"DepartmentPoll", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DepartmentPoll findUnique
   */
  export type DepartmentPollFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentPoll
     */
    select?: DepartmentPollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentPoll
     */
    omit?: DepartmentPollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentPollInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentPoll to fetch.
     */
    where: DepartmentPollWhereUniqueInput
  }

  /**
   * DepartmentPoll findUniqueOrThrow
   */
  export type DepartmentPollFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentPoll
     */
    select?: DepartmentPollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentPoll
     */
    omit?: DepartmentPollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentPollInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentPoll to fetch.
     */
    where: DepartmentPollWhereUniqueInput
  }

  /**
   * DepartmentPoll findFirst
   */
  export type DepartmentPollFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentPoll
     */
    select?: DepartmentPollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentPoll
     */
    omit?: DepartmentPollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentPollInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentPoll to fetch.
     */
    where?: DepartmentPollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentPolls to fetch.
     */
    orderBy?: DepartmentPollOrderByWithRelationInput | DepartmentPollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DepartmentPolls.
     */
    cursor?: DepartmentPollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentPolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentPolls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DepartmentPolls.
     */
    distinct?: DepartmentPollScalarFieldEnum | DepartmentPollScalarFieldEnum[]
  }

  /**
   * DepartmentPoll findFirstOrThrow
   */
  export type DepartmentPollFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentPoll
     */
    select?: DepartmentPollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentPoll
     */
    omit?: DepartmentPollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentPollInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentPoll to fetch.
     */
    where?: DepartmentPollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentPolls to fetch.
     */
    orderBy?: DepartmentPollOrderByWithRelationInput | DepartmentPollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DepartmentPolls.
     */
    cursor?: DepartmentPollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentPolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentPolls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DepartmentPolls.
     */
    distinct?: DepartmentPollScalarFieldEnum | DepartmentPollScalarFieldEnum[]
  }

  /**
   * DepartmentPoll findMany
   */
  export type DepartmentPollFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentPoll
     */
    select?: DepartmentPollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentPoll
     */
    omit?: DepartmentPollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentPollInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentPolls to fetch.
     */
    where?: DepartmentPollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentPolls to fetch.
     */
    orderBy?: DepartmentPollOrderByWithRelationInput | DepartmentPollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DepartmentPolls.
     */
    cursor?: DepartmentPollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentPolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentPolls.
     */
    skip?: number
    distinct?: DepartmentPollScalarFieldEnum | DepartmentPollScalarFieldEnum[]
  }

  /**
   * DepartmentPoll create
   */
  export type DepartmentPollCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentPoll
     */
    select?: DepartmentPollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentPoll
     */
    omit?: DepartmentPollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentPollInclude<ExtArgs> | null
    /**
     * The data needed to create a DepartmentPoll.
     */
    data: XOR<DepartmentPollCreateInput, DepartmentPollUncheckedCreateInput>
  }

  /**
   * DepartmentPoll createMany
   */
  export type DepartmentPollCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DepartmentPolls.
     */
    data: DepartmentPollCreateManyInput | DepartmentPollCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DepartmentPoll createManyAndReturn
   */
  export type DepartmentPollCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentPoll
     */
    select?: DepartmentPollSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentPoll
     */
    omit?: DepartmentPollOmit<ExtArgs> | null
    /**
     * The data used to create many DepartmentPolls.
     */
    data: DepartmentPollCreateManyInput | DepartmentPollCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentPollIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DepartmentPoll update
   */
  export type DepartmentPollUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentPoll
     */
    select?: DepartmentPollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentPoll
     */
    omit?: DepartmentPollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentPollInclude<ExtArgs> | null
    /**
     * The data needed to update a DepartmentPoll.
     */
    data: XOR<DepartmentPollUpdateInput, DepartmentPollUncheckedUpdateInput>
    /**
     * Choose, which DepartmentPoll to update.
     */
    where: DepartmentPollWhereUniqueInput
  }

  /**
   * DepartmentPoll updateMany
   */
  export type DepartmentPollUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DepartmentPolls.
     */
    data: XOR<DepartmentPollUpdateManyMutationInput, DepartmentPollUncheckedUpdateManyInput>
    /**
     * Filter which DepartmentPolls to update
     */
    where?: DepartmentPollWhereInput
    /**
     * Limit how many DepartmentPolls to update.
     */
    limit?: number
  }

  /**
   * DepartmentPoll updateManyAndReturn
   */
  export type DepartmentPollUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentPoll
     */
    select?: DepartmentPollSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentPoll
     */
    omit?: DepartmentPollOmit<ExtArgs> | null
    /**
     * The data used to update DepartmentPolls.
     */
    data: XOR<DepartmentPollUpdateManyMutationInput, DepartmentPollUncheckedUpdateManyInput>
    /**
     * Filter which DepartmentPolls to update
     */
    where?: DepartmentPollWhereInput
    /**
     * Limit how many DepartmentPolls to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentPollIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DepartmentPoll upsert
   */
  export type DepartmentPollUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentPoll
     */
    select?: DepartmentPollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentPoll
     */
    omit?: DepartmentPollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentPollInclude<ExtArgs> | null
    /**
     * The filter to search for the DepartmentPoll to update in case it exists.
     */
    where: DepartmentPollWhereUniqueInput
    /**
     * In case the DepartmentPoll found by the `where` argument doesn't exist, create a new DepartmentPoll with this data.
     */
    create: XOR<DepartmentPollCreateInput, DepartmentPollUncheckedCreateInput>
    /**
     * In case the DepartmentPoll was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentPollUpdateInput, DepartmentPollUncheckedUpdateInput>
  }

  /**
   * DepartmentPoll delete
   */
  export type DepartmentPollDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentPoll
     */
    select?: DepartmentPollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentPoll
     */
    omit?: DepartmentPollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentPollInclude<ExtArgs> | null
    /**
     * Filter which DepartmentPoll to delete.
     */
    where: DepartmentPollWhereUniqueInput
  }

  /**
   * DepartmentPoll deleteMany
   */
  export type DepartmentPollDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DepartmentPolls to delete
     */
    where?: DepartmentPollWhereInput
    /**
     * Limit how many DepartmentPolls to delete.
     */
    limit?: number
  }

  /**
   * DepartmentPoll.votes
   */
  export type DepartmentPoll$votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null
    where?: PollVoteWhereInput
    orderBy?: PollVoteOrderByWithRelationInput | PollVoteOrderByWithRelationInput[]
    cursor?: PollVoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PollVoteScalarFieldEnum | PollVoteScalarFieldEnum[]
  }

  /**
   * DepartmentPoll without action
   */
  export type DepartmentPollDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentPoll
     */
    select?: DepartmentPollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentPoll
     */
    omit?: DepartmentPollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentPollInclude<ExtArgs> | null
  }


  /**
   * Model PollVote
   */

  export type AggregatePollVote = {
    _count: PollVoteCountAggregateOutputType | null
    _avg: PollVoteAvgAggregateOutputType | null
    _sum: PollVoteSumAggregateOutputType | null
    _min: PollVoteMinAggregateOutputType | null
    _max: PollVoteMaxAggregateOutputType | null
  }

  export type PollVoteAvgAggregateOutputType = {
    optionIndex: number | null
  }

  export type PollVoteSumAggregateOutputType = {
    optionIndex: number | null
  }

  export type PollVoteMinAggregateOutputType = {
    id: string | null
    pollId: string | null
    userId: string | null
    optionIndex: number | null
    createdAt: Date | null
  }

  export type PollVoteMaxAggregateOutputType = {
    id: string | null
    pollId: string | null
    userId: string | null
    optionIndex: number | null
    createdAt: Date | null
  }

  export type PollVoteCountAggregateOutputType = {
    id: number
    pollId: number
    userId: number
    optionIndex: number
    createdAt: number
    _all: number
  }


  export type PollVoteAvgAggregateInputType = {
    optionIndex?: true
  }

  export type PollVoteSumAggregateInputType = {
    optionIndex?: true
  }

  export type PollVoteMinAggregateInputType = {
    id?: true
    pollId?: true
    userId?: true
    optionIndex?: true
    createdAt?: true
  }

  export type PollVoteMaxAggregateInputType = {
    id?: true
    pollId?: true
    userId?: true
    optionIndex?: true
    createdAt?: true
  }

  export type PollVoteCountAggregateInputType = {
    id?: true
    pollId?: true
    userId?: true
    optionIndex?: true
    createdAt?: true
    _all?: true
  }

  export type PollVoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PollVote to aggregate.
     */
    where?: PollVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PollVotes to fetch.
     */
    orderBy?: PollVoteOrderByWithRelationInput | PollVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PollVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PollVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PollVotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PollVotes
    **/
    _count?: true | PollVoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PollVoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PollVoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PollVoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PollVoteMaxAggregateInputType
  }

  export type GetPollVoteAggregateType<T extends PollVoteAggregateArgs> = {
        [P in keyof T & keyof AggregatePollVote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePollVote[P]>
      : GetScalarType<T[P], AggregatePollVote[P]>
  }




  export type PollVoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PollVoteWhereInput
    orderBy?: PollVoteOrderByWithAggregationInput | PollVoteOrderByWithAggregationInput[]
    by: PollVoteScalarFieldEnum[] | PollVoteScalarFieldEnum
    having?: PollVoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PollVoteCountAggregateInputType | true
    _avg?: PollVoteAvgAggregateInputType
    _sum?: PollVoteSumAggregateInputType
    _min?: PollVoteMinAggregateInputType
    _max?: PollVoteMaxAggregateInputType
  }

  export type PollVoteGroupByOutputType = {
    id: string
    pollId: string
    userId: string
    optionIndex: number
    createdAt: Date
    _count: PollVoteCountAggregateOutputType | null
    _avg: PollVoteAvgAggregateOutputType | null
    _sum: PollVoteSumAggregateOutputType | null
    _min: PollVoteMinAggregateOutputType | null
    _max: PollVoteMaxAggregateOutputType | null
  }

  type GetPollVoteGroupByPayload<T extends PollVoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PollVoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PollVoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PollVoteGroupByOutputType[P]>
            : GetScalarType<T[P], PollVoteGroupByOutputType[P]>
        }
      >
    >


  export type PollVoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pollId?: boolean
    userId?: boolean
    optionIndex?: boolean
    createdAt?: boolean
    poll?: boolean | DepartmentPollDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pollVote"]>

  export type PollVoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pollId?: boolean
    userId?: boolean
    optionIndex?: boolean
    createdAt?: boolean
    poll?: boolean | DepartmentPollDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pollVote"]>

  export type PollVoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pollId?: boolean
    userId?: boolean
    optionIndex?: boolean
    createdAt?: boolean
    poll?: boolean | DepartmentPollDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pollVote"]>

  export type PollVoteSelectScalar = {
    id?: boolean
    pollId?: boolean
    userId?: boolean
    optionIndex?: boolean
    createdAt?: boolean
  }

  export type PollVoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pollId" | "userId" | "optionIndex" | "createdAt", ExtArgs["result"]["pollVote"]>
  export type PollVoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    poll?: boolean | DepartmentPollDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PollVoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    poll?: boolean | DepartmentPollDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PollVoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    poll?: boolean | DepartmentPollDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PollVotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PollVote"
    objects: {
      poll: Prisma.$DepartmentPollPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      pollId: string
      userId: string
      optionIndex: number
      createdAt: Date
    }, ExtArgs["result"]["pollVote"]>
    composites: {}
  }

  type PollVoteGetPayload<S extends boolean | null | undefined | PollVoteDefaultArgs> = $Result.GetResult<Prisma.$PollVotePayload, S>

  type PollVoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PollVoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PollVoteCountAggregateInputType | true
    }

  export interface PollVoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PollVote'], meta: { name: 'PollVote' } }
    /**
     * Find zero or one PollVote that matches the filter.
     * @param {PollVoteFindUniqueArgs} args - Arguments to find a PollVote
     * @example
     * // Get one PollVote
     * const pollVote = await prisma.pollVote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PollVoteFindUniqueArgs>(args: SelectSubset<T, PollVoteFindUniqueArgs<ExtArgs>>): Prisma__PollVoteClient<$Result.GetResult<Prisma.$PollVotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PollVote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PollVoteFindUniqueOrThrowArgs} args - Arguments to find a PollVote
     * @example
     * // Get one PollVote
     * const pollVote = await prisma.pollVote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PollVoteFindUniqueOrThrowArgs>(args: SelectSubset<T, PollVoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PollVoteClient<$Result.GetResult<Prisma.$PollVotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PollVote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollVoteFindFirstArgs} args - Arguments to find a PollVote
     * @example
     * // Get one PollVote
     * const pollVote = await prisma.pollVote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PollVoteFindFirstArgs>(args?: SelectSubset<T, PollVoteFindFirstArgs<ExtArgs>>): Prisma__PollVoteClient<$Result.GetResult<Prisma.$PollVotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PollVote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollVoteFindFirstOrThrowArgs} args - Arguments to find a PollVote
     * @example
     * // Get one PollVote
     * const pollVote = await prisma.pollVote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PollVoteFindFirstOrThrowArgs>(args?: SelectSubset<T, PollVoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__PollVoteClient<$Result.GetResult<Prisma.$PollVotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PollVotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollVoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PollVotes
     * const pollVotes = await prisma.pollVote.findMany()
     * 
     * // Get first 10 PollVotes
     * const pollVotes = await prisma.pollVote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pollVoteWithIdOnly = await prisma.pollVote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PollVoteFindManyArgs>(args?: SelectSubset<T, PollVoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PollVotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PollVote.
     * @param {PollVoteCreateArgs} args - Arguments to create a PollVote.
     * @example
     * // Create one PollVote
     * const PollVote = await prisma.pollVote.create({
     *   data: {
     *     // ... data to create a PollVote
     *   }
     * })
     * 
     */
    create<T extends PollVoteCreateArgs>(args: SelectSubset<T, PollVoteCreateArgs<ExtArgs>>): Prisma__PollVoteClient<$Result.GetResult<Prisma.$PollVotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PollVotes.
     * @param {PollVoteCreateManyArgs} args - Arguments to create many PollVotes.
     * @example
     * // Create many PollVotes
     * const pollVote = await prisma.pollVote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PollVoteCreateManyArgs>(args?: SelectSubset<T, PollVoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PollVotes and returns the data saved in the database.
     * @param {PollVoteCreateManyAndReturnArgs} args - Arguments to create many PollVotes.
     * @example
     * // Create many PollVotes
     * const pollVote = await prisma.pollVote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PollVotes and only return the `id`
     * const pollVoteWithIdOnly = await prisma.pollVote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PollVoteCreateManyAndReturnArgs>(args?: SelectSubset<T, PollVoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PollVotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PollVote.
     * @param {PollVoteDeleteArgs} args - Arguments to delete one PollVote.
     * @example
     * // Delete one PollVote
     * const PollVote = await prisma.pollVote.delete({
     *   where: {
     *     // ... filter to delete one PollVote
     *   }
     * })
     * 
     */
    delete<T extends PollVoteDeleteArgs>(args: SelectSubset<T, PollVoteDeleteArgs<ExtArgs>>): Prisma__PollVoteClient<$Result.GetResult<Prisma.$PollVotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PollVote.
     * @param {PollVoteUpdateArgs} args - Arguments to update one PollVote.
     * @example
     * // Update one PollVote
     * const pollVote = await prisma.pollVote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PollVoteUpdateArgs>(args: SelectSubset<T, PollVoteUpdateArgs<ExtArgs>>): Prisma__PollVoteClient<$Result.GetResult<Prisma.$PollVotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PollVotes.
     * @param {PollVoteDeleteManyArgs} args - Arguments to filter PollVotes to delete.
     * @example
     * // Delete a few PollVotes
     * const { count } = await prisma.pollVote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PollVoteDeleteManyArgs>(args?: SelectSubset<T, PollVoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PollVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollVoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PollVotes
     * const pollVote = await prisma.pollVote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PollVoteUpdateManyArgs>(args: SelectSubset<T, PollVoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PollVotes and returns the data updated in the database.
     * @param {PollVoteUpdateManyAndReturnArgs} args - Arguments to update many PollVotes.
     * @example
     * // Update many PollVotes
     * const pollVote = await prisma.pollVote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PollVotes and only return the `id`
     * const pollVoteWithIdOnly = await prisma.pollVote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PollVoteUpdateManyAndReturnArgs>(args: SelectSubset<T, PollVoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PollVotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PollVote.
     * @param {PollVoteUpsertArgs} args - Arguments to update or create a PollVote.
     * @example
     * // Update or create a PollVote
     * const pollVote = await prisma.pollVote.upsert({
     *   create: {
     *     // ... data to create a PollVote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PollVote we want to update
     *   }
     * })
     */
    upsert<T extends PollVoteUpsertArgs>(args: SelectSubset<T, PollVoteUpsertArgs<ExtArgs>>): Prisma__PollVoteClient<$Result.GetResult<Prisma.$PollVotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PollVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollVoteCountArgs} args - Arguments to filter PollVotes to count.
     * @example
     * // Count the number of PollVotes
     * const count = await prisma.pollVote.count({
     *   where: {
     *     // ... the filter for the PollVotes we want to count
     *   }
     * })
    **/
    count<T extends PollVoteCountArgs>(
      args?: Subset<T, PollVoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PollVoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PollVote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollVoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PollVoteAggregateArgs>(args: Subset<T, PollVoteAggregateArgs>): Prisma.PrismaPromise<GetPollVoteAggregateType<T>>

    /**
     * Group by PollVote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollVoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PollVoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PollVoteGroupByArgs['orderBy'] }
        : { orderBy?: PollVoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PollVoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPollVoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PollVote model
   */
  readonly fields: PollVoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PollVote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PollVoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    poll<T extends DepartmentPollDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DepartmentPollDefaultArgs<ExtArgs>>): Prisma__DepartmentPollClient<$Result.GetResult<Prisma.$DepartmentPollPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PollVote model
   */
  interface PollVoteFieldRefs {
    readonly id: FieldRef<"PollVote", 'String'>
    readonly pollId: FieldRef<"PollVote", 'String'>
    readonly userId: FieldRef<"PollVote", 'String'>
    readonly optionIndex: FieldRef<"PollVote", 'Int'>
    readonly createdAt: FieldRef<"PollVote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PollVote findUnique
   */
  export type PollVoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null
    /**
     * Filter, which PollVote to fetch.
     */
    where: PollVoteWhereUniqueInput
  }

  /**
   * PollVote findUniqueOrThrow
   */
  export type PollVoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null
    /**
     * Filter, which PollVote to fetch.
     */
    where: PollVoteWhereUniqueInput
  }

  /**
   * PollVote findFirst
   */
  export type PollVoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null
    /**
     * Filter, which PollVote to fetch.
     */
    where?: PollVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PollVotes to fetch.
     */
    orderBy?: PollVoteOrderByWithRelationInput | PollVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PollVotes.
     */
    cursor?: PollVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PollVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PollVotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PollVotes.
     */
    distinct?: PollVoteScalarFieldEnum | PollVoteScalarFieldEnum[]
  }

  /**
   * PollVote findFirstOrThrow
   */
  export type PollVoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null
    /**
     * Filter, which PollVote to fetch.
     */
    where?: PollVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PollVotes to fetch.
     */
    orderBy?: PollVoteOrderByWithRelationInput | PollVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PollVotes.
     */
    cursor?: PollVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PollVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PollVotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PollVotes.
     */
    distinct?: PollVoteScalarFieldEnum | PollVoteScalarFieldEnum[]
  }

  /**
   * PollVote findMany
   */
  export type PollVoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null
    /**
     * Filter, which PollVotes to fetch.
     */
    where?: PollVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PollVotes to fetch.
     */
    orderBy?: PollVoteOrderByWithRelationInput | PollVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PollVotes.
     */
    cursor?: PollVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PollVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PollVotes.
     */
    skip?: number
    distinct?: PollVoteScalarFieldEnum | PollVoteScalarFieldEnum[]
  }

  /**
   * PollVote create
   */
  export type PollVoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null
    /**
     * The data needed to create a PollVote.
     */
    data: XOR<PollVoteCreateInput, PollVoteUncheckedCreateInput>
  }

  /**
   * PollVote createMany
   */
  export type PollVoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PollVotes.
     */
    data: PollVoteCreateManyInput | PollVoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PollVote createManyAndReturn
   */
  export type PollVoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null
    /**
     * The data used to create many PollVotes.
     */
    data: PollVoteCreateManyInput | PollVoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PollVote update
   */
  export type PollVoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null
    /**
     * The data needed to update a PollVote.
     */
    data: XOR<PollVoteUpdateInput, PollVoteUncheckedUpdateInput>
    /**
     * Choose, which PollVote to update.
     */
    where: PollVoteWhereUniqueInput
  }

  /**
   * PollVote updateMany
   */
  export type PollVoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PollVotes.
     */
    data: XOR<PollVoteUpdateManyMutationInput, PollVoteUncheckedUpdateManyInput>
    /**
     * Filter which PollVotes to update
     */
    where?: PollVoteWhereInput
    /**
     * Limit how many PollVotes to update.
     */
    limit?: number
  }

  /**
   * PollVote updateManyAndReturn
   */
  export type PollVoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null
    /**
     * The data used to update PollVotes.
     */
    data: XOR<PollVoteUpdateManyMutationInput, PollVoteUncheckedUpdateManyInput>
    /**
     * Filter which PollVotes to update
     */
    where?: PollVoteWhereInput
    /**
     * Limit how many PollVotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PollVote upsert
   */
  export type PollVoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null
    /**
     * The filter to search for the PollVote to update in case it exists.
     */
    where: PollVoteWhereUniqueInput
    /**
     * In case the PollVote found by the `where` argument doesn't exist, create a new PollVote with this data.
     */
    create: XOR<PollVoteCreateInput, PollVoteUncheckedCreateInput>
    /**
     * In case the PollVote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PollVoteUpdateInput, PollVoteUncheckedUpdateInput>
  }

  /**
   * PollVote delete
   */
  export type PollVoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null
    /**
     * Filter which PollVote to delete.
     */
    where: PollVoteWhereUniqueInput
  }

  /**
   * PollVote deleteMany
   */
  export type PollVoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PollVotes to delete
     */
    where?: PollVoteWhereInput
    /**
     * Limit how many PollVotes to delete.
     */
    limit?: number
  }

  /**
   * PollVote without action
   */
  export type PollVoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null
  }


  /**
   * Model TeamDecision
   */

  export type AggregateTeamDecision = {
    _count: TeamDecisionCountAggregateOutputType | null
    _min: TeamDecisionMinAggregateOutputType | null
    _max: TeamDecisionMaxAggregateOutputType | null
  }

  export type TeamDecisionMinAggregateOutputType = {
    id: string | null
    deptId: string | null
    title: string | null
    description: string | null
    voteDeadline: Date | null
    status: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamDecisionMaxAggregateOutputType = {
    id: string | null
    deptId: string | null
    title: string | null
    description: string | null
    voteDeadline: Date | null
    status: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamDecisionCountAggregateOutputType = {
    id: number
    deptId: number
    title: number
    description: number
    voteDeadline: number
    status: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeamDecisionMinAggregateInputType = {
    id?: true
    deptId?: true
    title?: true
    description?: true
    voteDeadline?: true
    status?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamDecisionMaxAggregateInputType = {
    id?: true
    deptId?: true
    title?: true
    description?: true
    voteDeadline?: true
    status?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamDecisionCountAggregateInputType = {
    id?: true
    deptId?: true
    title?: true
    description?: true
    voteDeadline?: true
    status?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeamDecisionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamDecision to aggregate.
     */
    where?: TeamDecisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamDecisions to fetch.
     */
    orderBy?: TeamDecisionOrderByWithRelationInput | TeamDecisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamDecisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamDecisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamDecisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamDecisions
    **/
    _count?: true | TeamDecisionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamDecisionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamDecisionMaxAggregateInputType
  }

  export type GetTeamDecisionAggregateType<T extends TeamDecisionAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamDecision]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamDecision[P]>
      : GetScalarType<T[P], AggregateTeamDecision[P]>
  }




  export type TeamDecisionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamDecisionWhereInput
    orderBy?: TeamDecisionOrderByWithAggregationInput | TeamDecisionOrderByWithAggregationInput[]
    by: TeamDecisionScalarFieldEnum[] | TeamDecisionScalarFieldEnum
    having?: TeamDecisionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamDecisionCountAggregateInputType | true
    _min?: TeamDecisionMinAggregateInputType
    _max?: TeamDecisionMaxAggregateInputType
  }

  export type TeamDecisionGroupByOutputType = {
    id: string
    deptId: string
    title: string
    description: string | null
    voteDeadline: Date | null
    status: string
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: TeamDecisionCountAggregateOutputType | null
    _min: TeamDecisionMinAggregateOutputType | null
    _max: TeamDecisionMaxAggregateOutputType | null
  }

  type GetTeamDecisionGroupByPayload<T extends TeamDecisionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamDecisionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamDecisionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamDecisionGroupByOutputType[P]>
            : GetScalarType<T[P], TeamDecisionGroupByOutputType[P]>
        }
      >
    >


  export type TeamDecisionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deptId?: boolean
    title?: boolean
    description?: boolean
    voteDeadline?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    votes?: boolean | TeamDecision$votesArgs<ExtArgs>
    _count?: boolean | TeamDecisionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamDecision"]>

  export type TeamDecisionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deptId?: boolean
    title?: boolean
    description?: boolean
    voteDeadline?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamDecision"]>

  export type TeamDecisionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deptId?: boolean
    title?: boolean
    description?: boolean
    voteDeadline?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamDecision"]>

  export type TeamDecisionSelectScalar = {
    id?: boolean
    deptId?: boolean
    title?: boolean
    description?: boolean
    voteDeadline?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeamDecisionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "deptId" | "title" | "description" | "voteDeadline" | "status" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["teamDecision"]>
  export type TeamDecisionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    votes?: boolean | TeamDecision$votesArgs<ExtArgs>
    _count?: boolean | TeamDecisionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeamDecisionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TeamDecisionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TeamDecisionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeamDecision"
    objects: {
      department: Prisma.$DepartmentPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
      votes: Prisma.$DecisionVotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      deptId: string
      title: string
      description: string | null
      voteDeadline: Date | null
      status: string
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["teamDecision"]>
    composites: {}
  }

  type TeamDecisionGetPayload<S extends boolean | null | undefined | TeamDecisionDefaultArgs> = $Result.GetResult<Prisma.$TeamDecisionPayload, S>

  type TeamDecisionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamDecisionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamDecisionCountAggregateInputType | true
    }

  export interface TeamDecisionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamDecision'], meta: { name: 'TeamDecision' } }
    /**
     * Find zero or one TeamDecision that matches the filter.
     * @param {TeamDecisionFindUniqueArgs} args - Arguments to find a TeamDecision
     * @example
     * // Get one TeamDecision
     * const teamDecision = await prisma.teamDecision.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamDecisionFindUniqueArgs>(args: SelectSubset<T, TeamDecisionFindUniqueArgs<ExtArgs>>): Prisma__TeamDecisionClient<$Result.GetResult<Prisma.$TeamDecisionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TeamDecision that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamDecisionFindUniqueOrThrowArgs} args - Arguments to find a TeamDecision
     * @example
     * // Get one TeamDecision
     * const teamDecision = await prisma.teamDecision.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamDecisionFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamDecisionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamDecisionClient<$Result.GetResult<Prisma.$TeamDecisionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamDecision that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamDecisionFindFirstArgs} args - Arguments to find a TeamDecision
     * @example
     * // Get one TeamDecision
     * const teamDecision = await prisma.teamDecision.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamDecisionFindFirstArgs>(args?: SelectSubset<T, TeamDecisionFindFirstArgs<ExtArgs>>): Prisma__TeamDecisionClient<$Result.GetResult<Prisma.$TeamDecisionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamDecision that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamDecisionFindFirstOrThrowArgs} args - Arguments to find a TeamDecision
     * @example
     * // Get one TeamDecision
     * const teamDecision = await prisma.teamDecision.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamDecisionFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamDecisionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamDecisionClient<$Result.GetResult<Prisma.$TeamDecisionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeamDecisions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamDecisionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamDecisions
     * const teamDecisions = await prisma.teamDecision.findMany()
     * 
     * // Get first 10 TeamDecisions
     * const teamDecisions = await prisma.teamDecision.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamDecisionWithIdOnly = await prisma.teamDecision.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamDecisionFindManyArgs>(args?: SelectSubset<T, TeamDecisionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamDecisionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TeamDecision.
     * @param {TeamDecisionCreateArgs} args - Arguments to create a TeamDecision.
     * @example
     * // Create one TeamDecision
     * const TeamDecision = await prisma.teamDecision.create({
     *   data: {
     *     // ... data to create a TeamDecision
     *   }
     * })
     * 
     */
    create<T extends TeamDecisionCreateArgs>(args: SelectSubset<T, TeamDecisionCreateArgs<ExtArgs>>): Prisma__TeamDecisionClient<$Result.GetResult<Prisma.$TeamDecisionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TeamDecisions.
     * @param {TeamDecisionCreateManyArgs} args - Arguments to create many TeamDecisions.
     * @example
     * // Create many TeamDecisions
     * const teamDecision = await prisma.teamDecision.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamDecisionCreateManyArgs>(args?: SelectSubset<T, TeamDecisionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeamDecisions and returns the data saved in the database.
     * @param {TeamDecisionCreateManyAndReturnArgs} args - Arguments to create many TeamDecisions.
     * @example
     * // Create many TeamDecisions
     * const teamDecision = await prisma.teamDecision.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeamDecisions and only return the `id`
     * const teamDecisionWithIdOnly = await prisma.teamDecision.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamDecisionCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamDecisionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamDecisionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TeamDecision.
     * @param {TeamDecisionDeleteArgs} args - Arguments to delete one TeamDecision.
     * @example
     * // Delete one TeamDecision
     * const TeamDecision = await prisma.teamDecision.delete({
     *   where: {
     *     // ... filter to delete one TeamDecision
     *   }
     * })
     * 
     */
    delete<T extends TeamDecisionDeleteArgs>(args: SelectSubset<T, TeamDecisionDeleteArgs<ExtArgs>>): Prisma__TeamDecisionClient<$Result.GetResult<Prisma.$TeamDecisionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TeamDecision.
     * @param {TeamDecisionUpdateArgs} args - Arguments to update one TeamDecision.
     * @example
     * // Update one TeamDecision
     * const teamDecision = await prisma.teamDecision.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamDecisionUpdateArgs>(args: SelectSubset<T, TeamDecisionUpdateArgs<ExtArgs>>): Prisma__TeamDecisionClient<$Result.GetResult<Prisma.$TeamDecisionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TeamDecisions.
     * @param {TeamDecisionDeleteManyArgs} args - Arguments to filter TeamDecisions to delete.
     * @example
     * // Delete a few TeamDecisions
     * const { count } = await prisma.teamDecision.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamDecisionDeleteManyArgs>(args?: SelectSubset<T, TeamDecisionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamDecisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamDecisionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamDecisions
     * const teamDecision = await prisma.teamDecision.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamDecisionUpdateManyArgs>(args: SelectSubset<T, TeamDecisionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamDecisions and returns the data updated in the database.
     * @param {TeamDecisionUpdateManyAndReturnArgs} args - Arguments to update many TeamDecisions.
     * @example
     * // Update many TeamDecisions
     * const teamDecision = await prisma.teamDecision.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TeamDecisions and only return the `id`
     * const teamDecisionWithIdOnly = await prisma.teamDecision.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeamDecisionUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamDecisionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamDecisionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TeamDecision.
     * @param {TeamDecisionUpsertArgs} args - Arguments to update or create a TeamDecision.
     * @example
     * // Update or create a TeamDecision
     * const teamDecision = await prisma.teamDecision.upsert({
     *   create: {
     *     // ... data to create a TeamDecision
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamDecision we want to update
     *   }
     * })
     */
    upsert<T extends TeamDecisionUpsertArgs>(args: SelectSubset<T, TeamDecisionUpsertArgs<ExtArgs>>): Prisma__TeamDecisionClient<$Result.GetResult<Prisma.$TeamDecisionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TeamDecisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamDecisionCountArgs} args - Arguments to filter TeamDecisions to count.
     * @example
     * // Count the number of TeamDecisions
     * const count = await prisma.teamDecision.count({
     *   where: {
     *     // ... the filter for the TeamDecisions we want to count
     *   }
     * })
    **/
    count<T extends TeamDecisionCountArgs>(
      args?: Subset<T, TeamDecisionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamDecisionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamDecision.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamDecisionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamDecisionAggregateArgs>(args: Subset<T, TeamDecisionAggregateArgs>): Prisma.PrismaPromise<GetTeamDecisionAggregateType<T>>

    /**
     * Group by TeamDecision.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamDecisionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamDecisionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamDecisionGroupByArgs['orderBy'] }
        : { orderBy?: TeamDecisionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamDecisionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamDecisionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeamDecision model
   */
  readonly fields: TeamDecisionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamDecision.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamDecisionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    department<T extends DepartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DepartmentDefaultArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    votes<T extends TeamDecision$votesArgs<ExtArgs> = {}>(args?: Subset<T, TeamDecision$votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DecisionVotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeamDecision model
   */
  interface TeamDecisionFieldRefs {
    readonly id: FieldRef<"TeamDecision", 'String'>
    readonly deptId: FieldRef<"TeamDecision", 'String'>
    readonly title: FieldRef<"TeamDecision", 'String'>
    readonly description: FieldRef<"TeamDecision", 'String'>
    readonly voteDeadline: FieldRef<"TeamDecision", 'DateTime'>
    readonly status: FieldRef<"TeamDecision", 'String'>
    readonly createdBy: FieldRef<"TeamDecision", 'String'>
    readonly createdAt: FieldRef<"TeamDecision", 'DateTime'>
    readonly updatedAt: FieldRef<"TeamDecision", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TeamDecision findUnique
   */
  export type TeamDecisionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamDecision
     */
    select?: TeamDecisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamDecision
     */
    omit?: TeamDecisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamDecisionInclude<ExtArgs> | null
    /**
     * Filter, which TeamDecision to fetch.
     */
    where: TeamDecisionWhereUniqueInput
  }

  /**
   * TeamDecision findUniqueOrThrow
   */
  export type TeamDecisionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamDecision
     */
    select?: TeamDecisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamDecision
     */
    omit?: TeamDecisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamDecisionInclude<ExtArgs> | null
    /**
     * Filter, which TeamDecision to fetch.
     */
    where: TeamDecisionWhereUniqueInput
  }

  /**
   * TeamDecision findFirst
   */
  export type TeamDecisionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamDecision
     */
    select?: TeamDecisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamDecision
     */
    omit?: TeamDecisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamDecisionInclude<ExtArgs> | null
    /**
     * Filter, which TeamDecision to fetch.
     */
    where?: TeamDecisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamDecisions to fetch.
     */
    orderBy?: TeamDecisionOrderByWithRelationInput | TeamDecisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamDecisions.
     */
    cursor?: TeamDecisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamDecisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamDecisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamDecisions.
     */
    distinct?: TeamDecisionScalarFieldEnum | TeamDecisionScalarFieldEnum[]
  }

  /**
   * TeamDecision findFirstOrThrow
   */
  export type TeamDecisionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamDecision
     */
    select?: TeamDecisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamDecision
     */
    omit?: TeamDecisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamDecisionInclude<ExtArgs> | null
    /**
     * Filter, which TeamDecision to fetch.
     */
    where?: TeamDecisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamDecisions to fetch.
     */
    orderBy?: TeamDecisionOrderByWithRelationInput | TeamDecisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamDecisions.
     */
    cursor?: TeamDecisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamDecisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamDecisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamDecisions.
     */
    distinct?: TeamDecisionScalarFieldEnum | TeamDecisionScalarFieldEnum[]
  }

  /**
   * TeamDecision findMany
   */
  export type TeamDecisionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamDecision
     */
    select?: TeamDecisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamDecision
     */
    omit?: TeamDecisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamDecisionInclude<ExtArgs> | null
    /**
     * Filter, which TeamDecisions to fetch.
     */
    where?: TeamDecisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamDecisions to fetch.
     */
    orderBy?: TeamDecisionOrderByWithRelationInput | TeamDecisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamDecisions.
     */
    cursor?: TeamDecisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamDecisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamDecisions.
     */
    skip?: number
    distinct?: TeamDecisionScalarFieldEnum | TeamDecisionScalarFieldEnum[]
  }

  /**
   * TeamDecision create
   */
  export type TeamDecisionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamDecision
     */
    select?: TeamDecisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamDecision
     */
    omit?: TeamDecisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamDecisionInclude<ExtArgs> | null
    /**
     * The data needed to create a TeamDecision.
     */
    data: XOR<TeamDecisionCreateInput, TeamDecisionUncheckedCreateInput>
  }

  /**
   * TeamDecision createMany
   */
  export type TeamDecisionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamDecisions.
     */
    data: TeamDecisionCreateManyInput | TeamDecisionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeamDecision createManyAndReturn
   */
  export type TeamDecisionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamDecision
     */
    select?: TeamDecisionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamDecision
     */
    omit?: TeamDecisionOmit<ExtArgs> | null
    /**
     * The data used to create many TeamDecisions.
     */
    data: TeamDecisionCreateManyInput | TeamDecisionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamDecisionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamDecision update
   */
  export type TeamDecisionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamDecision
     */
    select?: TeamDecisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamDecision
     */
    omit?: TeamDecisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamDecisionInclude<ExtArgs> | null
    /**
     * The data needed to update a TeamDecision.
     */
    data: XOR<TeamDecisionUpdateInput, TeamDecisionUncheckedUpdateInput>
    /**
     * Choose, which TeamDecision to update.
     */
    where: TeamDecisionWhereUniqueInput
  }

  /**
   * TeamDecision updateMany
   */
  export type TeamDecisionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamDecisions.
     */
    data: XOR<TeamDecisionUpdateManyMutationInput, TeamDecisionUncheckedUpdateManyInput>
    /**
     * Filter which TeamDecisions to update
     */
    where?: TeamDecisionWhereInput
    /**
     * Limit how many TeamDecisions to update.
     */
    limit?: number
  }

  /**
   * TeamDecision updateManyAndReturn
   */
  export type TeamDecisionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamDecision
     */
    select?: TeamDecisionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamDecision
     */
    omit?: TeamDecisionOmit<ExtArgs> | null
    /**
     * The data used to update TeamDecisions.
     */
    data: XOR<TeamDecisionUpdateManyMutationInput, TeamDecisionUncheckedUpdateManyInput>
    /**
     * Filter which TeamDecisions to update
     */
    where?: TeamDecisionWhereInput
    /**
     * Limit how many TeamDecisions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamDecisionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamDecision upsert
   */
  export type TeamDecisionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamDecision
     */
    select?: TeamDecisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamDecision
     */
    omit?: TeamDecisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamDecisionInclude<ExtArgs> | null
    /**
     * The filter to search for the TeamDecision to update in case it exists.
     */
    where: TeamDecisionWhereUniqueInput
    /**
     * In case the TeamDecision found by the `where` argument doesn't exist, create a new TeamDecision with this data.
     */
    create: XOR<TeamDecisionCreateInput, TeamDecisionUncheckedCreateInput>
    /**
     * In case the TeamDecision was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamDecisionUpdateInput, TeamDecisionUncheckedUpdateInput>
  }

  /**
   * TeamDecision delete
   */
  export type TeamDecisionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamDecision
     */
    select?: TeamDecisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamDecision
     */
    omit?: TeamDecisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamDecisionInclude<ExtArgs> | null
    /**
     * Filter which TeamDecision to delete.
     */
    where: TeamDecisionWhereUniqueInput
  }

  /**
   * TeamDecision deleteMany
   */
  export type TeamDecisionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamDecisions to delete
     */
    where?: TeamDecisionWhereInput
    /**
     * Limit how many TeamDecisions to delete.
     */
    limit?: number
  }

  /**
   * TeamDecision.votes
   */
  export type TeamDecision$votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionVote
     */
    select?: DecisionVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DecisionVote
     */
    omit?: DecisionVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionVoteInclude<ExtArgs> | null
    where?: DecisionVoteWhereInput
    orderBy?: DecisionVoteOrderByWithRelationInput | DecisionVoteOrderByWithRelationInput[]
    cursor?: DecisionVoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DecisionVoteScalarFieldEnum | DecisionVoteScalarFieldEnum[]
  }

  /**
   * TeamDecision without action
   */
  export type TeamDecisionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamDecision
     */
    select?: TeamDecisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamDecision
     */
    omit?: TeamDecisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamDecisionInclude<ExtArgs> | null
  }


  /**
   * Model DecisionVote
   */

  export type AggregateDecisionVote = {
    _count: DecisionVoteCountAggregateOutputType | null
    _min: DecisionVoteMinAggregateOutputType | null
    _max: DecisionVoteMaxAggregateOutputType | null
  }

  export type DecisionVoteMinAggregateOutputType = {
    id: string | null
    decisionId: string | null
    userId: string | null
    vote: $Enums.DecisionVoteType | null
    createdAt: Date | null
  }

  export type DecisionVoteMaxAggregateOutputType = {
    id: string | null
    decisionId: string | null
    userId: string | null
    vote: $Enums.DecisionVoteType | null
    createdAt: Date | null
  }

  export type DecisionVoteCountAggregateOutputType = {
    id: number
    decisionId: number
    userId: number
    vote: number
    createdAt: number
    _all: number
  }


  export type DecisionVoteMinAggregateInputType = {
    id?: true
    decisionId?: true
    userId?: true
    vote?: true
    createdAt?: true
  }

  export type DecisionVoteMaxAggregateInputType = {
    id?: true
    decisionId?: true
    userId?: true
    vote?: true
    createdAt?: true
  }

  export type DecisionVoteCountAggregateInputType = {
    id?: true
    decisionId?: true
    userId?: true
    vote?: true
    createdAt?: true
    _all?: true
  }

  export type DecisionVoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DecisionVote to aggregate.
     */
    where?: DecisionVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DecisionVotes to fetch.
     */
    orderBy?: DecisionVoteOrderByWithRelationInput | DecisionVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DecisionVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DecisionVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DecisionVotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DecisionVotes
    **/
    _count?: true | DecisionVoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DecisionVoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DecisionVoteMaxAggregateInputType
  }

  export type GetDecisionVoteAggregateType<T extends DecisionVoteAggregateArgs> = {
        [P in keyof T & keyof AggregateDecisionVote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDecisionVote[P]>
      : GetScalarType<T[P], AggregateDecisionVote[P]>
  }




  export type DecisionVoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DecisionVoteWhereInput
    orderBy?: DecisionVoteOrderByWithAggregationInput | DecisionVoteOrderByWithAggregationInput[]
    by: DecisionVoteScalarFieldEnum[] | DecisionVoteScalarFieldEnum
    having?: DecisionVoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DecisionVoteCountAggregateInputType | true
    _min?: DecisionVoteMinAggregateInputType
    _max?: DecisionVoteMaxAggregateInputType
  }

  export type DecisionVoteGroupByOutputType = {
    id: string
    decisionId: string
    userId: string
    vote: $Enums.DecisionVoteType
    createdAt: Date
    _count: DecisionVoteCountAggregateOutputType | null
    _min: DecisionVoteMinAggregateOutputType | null
    _max: DecisionVoteMaxAggregateOutputType | null
  }

  type GetDecisionVoteGroupByPayload<T extends DecisionVoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DecisionVoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DecisionVoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DecisionVoteGroupByOutputType[P]>
            : GetScalarType<T[P], DecisionVoteGroupByOutputType[P]>
        }
      >
    >


  export type DecisionVoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    decisionId?: boolean
    userId?: boolean
    vote?: boolean
    createdAt?: boolean
    decision?: boolean | TeamDecisionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["decisionVote"]>

  export type DecisionVoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    decisionId?: boolean
    userId?: boolean
    vote?: boolean
    createdAt?: boolean
    decision?: boolean | TeamDecisionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["decisionVote"]>

  export type DecisionVoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    decisionId?: boolean
    userId?: boolean
    vote?: boolean
    createdAt?: boolean
    decision?: boolean | TeamDecisionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["decisionVote"]>

  export type DecisionVoteSelectScalar = {
    id?: boolean
    decisionId?: boolean
    userId?: boolean
    vote?: boolean
    createdAt?: boolean
  }

  export type DecisionVoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "decisionId" | "userId" | "vote" | "createdAt", ExtArgs["result"]["decisionVote"]>
  export type DecisionVoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    decision?: boolean | TeamDecisionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DecisionVoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    decision?: boolean | TeamDecisionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DecisionVoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    decision?: boolean | TeamDecisionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DecisionVotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DecisionVote"
    objects: {
      decision: Prisma.$TeamDecisionPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      decisionId: string
      userId: string
      vote: $Enums.DecisionVoteType
      createdAt: Date
    }, ExtArgs["result"]["decisionVote"]>
    composites: {}
  }

  type DecisionVoteGetPayload<S extends boolean | null | undefined | DecisionVoteDefaultArgs> = $Result.GetResult<Prisma.$DecisionVotePayload, S>

  type DecisionVoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DecisionVoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DecisionVoteCountAggregateInputType | true
    }

  export interface DecisionVoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DecisionVote'], meta: { name: 'DecisionVote' } }
    /**
     * Find zero or one DecisionVote that matches the filter.
     * @param {DecisionVoteFindUniqueArgs} args - Arguments to find a DecisionVote
     * @example
     * // Get one DecisionVote
     * const decisionVote = await prisma.decisionVote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DecisionVoteFindUniqueArgs>(args: SelectSubset<T, DecisionVoteFindUniqueArgs<ExtArgs>>): Prisma__DecisionVoteClient<$Result.GetResult<Prisma.$DecisionVotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DecisionVote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DecisionVoteFindUniqueOrThrowArgs} args - Arguments to find a DecisionVote
     * @example
     * // Get one DecisionVote
     * const decisionVote = await prisma.decisionVote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DecisionVoteFindUniqueOrThrowArgs>(args: SelectSubset<T, DecisionVoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DecisionVoteClient<$Result.GetResult<Prisma.$DecisionVotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DecisionVote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecisionVoteFindFirstArgs} args - Arguments to find a DecisionVote
     * @example
     * // Get one DecisionVote
     * const decisionVote = await prisma.decisionVote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DecisionVoteFindFirstArgs>(args?: SelectSubset<T, DecisionVoteFindFirstArgs<ExtArgs>>): Prisma__DecisionVoteClient<$Result.GetResult<Prisma.$DecisionVotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DecisionVote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecisionVoteFindFirstOrThrowArgs} args - Arguments to find a DecisionVote
     * @example
     * // Get one DecisionVote
     * const decisionVote = await prisma.decisionVote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DecisionVoteFindFirstOrThrowArgs>(args?: SelectSubset<T, DecisionVoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__DecisionVoteClient<$Result.GetResult<Prisma.$DecisionVotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DecisionVotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecisionVoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DecisionVotes
     * const decisionVotes = await prisma.decisionVote.findMany()
     * 
     * // Get first 10 DecisionVotes
     * const decisionVotes = await prisma.decisionVote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const decisionVoteWithIdOnly = await prisma.decisionVote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DecisionVoteFindManyArgs>(args?: SelectSubset<T, DecisionVoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DecisionVotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DecisionVote.
     * @param {DecisionVoteCreateArgs} args - Arguments to create a DecisionVote.
     * @example
     * // Create one DecisionVote
     * const DecisionVote = await prisma.decisionVote.create({
     *   data: {
     *     // ... data to create a DecisionVote
     *   }
     * })
     * 
     */
    create<T extends DecisionVoteCreateArgs>(args: SelectSubset<T, DecisionVoteCreateArgs<ExtArgs>>): Prisma__DecisionVoteClient<$Result.GetResult<Prisma.$DecisionVotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DecisionVotes.
     * @param {DecisionVoteCreateManyArgs} args - Arguments to create many DecisionVotes.
     * @example
     * // Create many DecisionVotes
     * const decisionVote = await prisma.decisionVote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DecisionVoteCreateManyArgs>(args?: SelectSubset<T, DecisionVoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DecisionVotes and returns the data saved in the database.
     * @param {DecisionVoteCreateManyAndReturnArgs} args - Arguments to create many DecisionVotes.
     * @example
     * // Create many DecisionVotes
     * const decisionVote = await prisma.decisionVote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DecisionVotes and only return the `id`
     * const decisionVoteWithIdOnly = await prisma.decisionVote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DecisionVoteCreateManyAndReturnArgs>(args?: SelectSubset<T, DecisionVoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DecisionVotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DecisionVote.
     * @param {DecisionVoteDeleteArgs} args - Arguments to delete one DecisionVote.
     * @example
     * // Delete one DecisionVote
     * const DecisionVote = await prisma.decisionVote.delete({
     *   where: {
     *     // ... filter to delete one DecisionVote
     *   }
     * })
     * 
     */
    delete<T extends DecisionVoteDeleteArgs>(args: SelectSubset<T, DecisionVoteDeleteArgs<ExtArgs>>): Prisma__DecisionVoteClient<$Result.GetResult<Prisma.$DecisionVotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DecisionVote.
     * @param {DecisionVoteUpdateArgs} args - Arguments to update one DecisionVote.
     * @example
     * // Update one DecisionVote
     * const decisionVote = await prisma.decisionVote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DecisionVoteUpdateArgs>(args: SelectSubset<T, DecisionVoteUpdateArgs<ExtArgs>>): Prisma__DecisionVoteClient<$Result.GetResult<Prisma.$DecisionVotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DecisionVotes.
     * @param {DecisionVoteDeleteManyArgs} args - Arguments to filter DecisionVotes to delete.
     * @example
     * // Delete a few DecisionVotes
     * const { count } = await prisma.decisionVote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DecisionVoteDeleteManyArgs>(args?: SelectSubset<T, DecisionVoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DecisionVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecisionVoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DecisionVotes
     * const decisionVote = await prisma.decisionVote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DecisionVoteUpdateManyArgs>(args: SelectSubset<T, DecisionVoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DecisionVotes and returns the data updated in the database.
     * @param {DecisionVoteUpdateManyAndReturnArgs} args - Arguments to update many DecisionVotes.
     * @example
     * // Update many DecisionVotes
     * const decisionVote = await prisma.decisionVote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DecisionVotes and only return the `id`
     * const decisionVoteWithIdOnly = await prisma.decisionVote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DecisionVoteUpdateManyAndReturnArgs>(args: SelectSubset<T, DecisionVoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DecisionVotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DecisionVote.
     * @param {DecisionVoteUpsertArgs} args - Arguments to update or create a DecisionVote.
     * @example
     * // Update or create a DecisionVote
     * const decisionVote = await prisma.decisionVote.upsert({
     *   create: {
     *     // ... data to create a DecisionVote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DecisionVote we want to update
     *   }
     * })
     */
    upsert<T extends DecisionVoteUpsertArgs>(args: SelectSubset<T, DecisionVoteUpsertArgs<ExtArgs>>): Prisma__DecisionVoteClient<$Result.GetResult<Prisma.$DecisionVotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DecisionVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecisionVoteCountArgs} args - Arguments to filter DecisionVotes to count.
     * @example
     * // Count the number of DecisionVotes
     * const count = await prisma.decisionVote.count({
     *   where: {
     *     // ... the filter for the DecisionVotes we want to count
     *   }
     * })
    **/
    count<T extends DecisionVoteCountArgs>(
      args?: Subset<T, DecisionVoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DecisionVoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DecisionVote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecisionVoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DecisionVoteAggregateArgs>(args: Subset<T, DecisionVoteAggregateArgs>): Prisma.PrismaPromise<GetDecisionVoteAggregateType<T>>

    /**
     * Group by DecisionVote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecisionVoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DecisionVoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DecisionVoteGroupByArgs['orderBy'] }
        : { orderBy?: DecisionVoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DecisionVoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDecisionVoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DecisionVote model
   */
  readonly fields: DecisionVoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DecisionVote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DecisionVoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    decision<T extends TeamDecisionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDecisionDefaultArgs<ExtArgs>>): Prisma__TeamDecisionClient<$Result.GetResult<Prisma.$TeamDecisionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DecisionVote model
   */
  interface DecisionVoteFieldRefs {
    readonly id: FieldRef<"DecisionVote", 'String'>
    readonly decisionId: FieldRef<"DecisionVote", 'String'>
    readonly userId: FieldRef<"DecisionVote", 'String'>
    readonly vote: FieldRef<"DecisionVote", 'DecisionVoteType'>
    readonly createdAt: FieldRef<"DecisionVote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DecisionVote findUnique
   */
  export type DecisionVoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionVote
     */
    select?: DecisionVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DecisionVote
     */
    omit?: DecisionVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionVoteInclude<ExtArgs> | null
    /**
     * Filter, which DecisionVote to fetch.
     */
    where: DecisionVoteWhereUniqueInput
  }

  /**
   * DecisionVote findUniqueOrThrow
   */
  export type DecisionVoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionVote
     */
    select?: DecisionVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DecisionVote
     */
    omit?: DecisionVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionVoteInclude<ExtArgs> | null
    /**
     * Filter, which DecisionVote to fetch.
     */
    where: DecisionVoteWhereUniqueInput
  }

  /**
   * DecisionVote findFirst
   */
  export type DecisionVoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionVote
     */
    select?: DecisionVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DecisionVote
     */
    omit?: DecisionVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionVoteInclude<ExtArgs> | null
    /**
     * Filter, which DecisionVote to fetch.
     */
    where?: DecisionVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DecisionVotes to fetch.
     */
    orderBy?: DecisionVoteOrderByWithRelationInput | DecisionVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DecisionVotes.
     */
    cursor?: DecisionVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DecisionVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DecisionVotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DecisionVotes.
     */
    distinct?: DecisionVoteScalarFieldEnum | DecisionVoteScalarFieldEnum[]
  }

  /**
   * DecisionVote findFirstOrThrow
   */
  export type DecisionVoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionVote
     */
    select?: DecisionVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DecisionVote
     */
    omit?: DecisionVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionVoteInclude<ExtArgs> | null
    /**
     * Filter, which DecisionVote to fetch.
     */
    where?: DecisionVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DecisionVotes to fetch.
     */
    orderBy?: DecisionVoteOrderByWithRelationInput | DecisionVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DecisionVotes.
     */
    cursor?: DecisionVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DecisionVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DecisionVotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DecisionVotes.
     */
    distinct?: DecisionVoteScalarFieldEnum | DecisionVoteScalarFieldEnum[]
  }

  /**
   * DecisionVote findMany
   */
  export type DecisionVoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionVote
     */
    select?: DecisionVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DecisionVote
     */
    omit?: DecisionVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionVoteInclude<ExtArgs> | null
    /**
     * Filter, which DecisionVotes to fetch.
     */
    where?: DecisionVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DecisionVotes to fetch.
     */
    orderBy?: DecisionVoteOrderByWithRelationInput | DecisionVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DecisionVotes.
     */
    cursor?: DecisionVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DecisionVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DecisionVotes.
     */
    skip?: number
    distinct?: DecisionVoteScalarFieldEnum | DecisionVoteScalarFieldEnum[]
  }

  /**
   * DecisionVote create
   */
  export type DecisionVoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionVote
     */
    select?: DecisionVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DecisionVote
     */
    omit?: DecisionVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionVoteInclude<ExtArgs> | null
    /**
     * The data needed to create a DecisionVote.
     */
    data: XOR<DecisionVoteCreateInput, DecisionVoteUncheckedCreateInput>
  }

  /**
   * DecisionVote createMany
   */
  export type DecisionVoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DecisionVotes.
     */
    data: DecisionVoteCreateManyInput | DecisionVoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DecisionVote createManyAndReturn
   */
  export type DecisionVoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionVote
     */
    select?: DecisionVoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DecisionVote
     */
    omit?: DecisionVoteOmit<ExtArgs> | null
    /**
     * The data used to create many DecisionVotes.
     */
    data: DecisionVoteCreateManyInput | DecisionVoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionVoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DecisionVote update
   */
  export type DecisionVoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionVote
     */
    select?: DecisionVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DecisionVote
     */
    omit?: DecisionVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionVoteInclude<ExtArgs> | null
    /**
     * The data needed to update a DecisionVote.
     */
    data: XOR<DecisionVoteUpdateInput, DecisionVoteUncheckedUpdateInput>
    /**
     * Choose, which DecisionVote to update.
     */
    where: DecisionVoteWhereUniqueInput
  }

  /**
   * DecisionVote updateMany
   */
  export type DecisionVoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DecisionVotes.
     */
    data: XOR<DecisionVoteUpdateManyMutationInput, DecisionVoteUncheckedUpdateManyInput>
    /**
     * Filter which DecisionVotes to update
     */
    where?: DecisionVoteWhereInput
    /**
     * Limit how many DecisionVotes to update.
     */
    limit?: number
  }

  /**
   * DecisionVote updateManyAndReturn
   */
  export type DecisionVoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionVote
     */
    select?: DecisionVoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DecisionVote
     */
    omit?: DecisionVoteOmit<ExtArgs> | null
    /**
     * The data used to update DecisionVotes.
     */
    data: XOR<DecisionVoteUpdateManyMutationInput, DecisionVoteUncheckedUpdateManyInput>
    /**
     * Filter which DecisionVotes to update
     */
    where?: DecisionVoteWhereInput
    /**
     * Limit how many DecisionVotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionVoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DecisionVote upsert
   */
  export type DecisionVoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionVote
     */
    select?: DecisionVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DecisionVote
     */
    omit?: DecisionVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionVoteInclude<ExtArgs> | null
    /**
     * The filter to search for the DecisionVote to update in case it exists.
     */
    where: DecisionVoteWhereUniqueInput
    /**
     * In case the DecisionVote found by the `where` argument doesn't exist, create a new DecisionVote with this data.
     */
    create: XOR<DecisionVoteCreateInput, DecisionVoteUncheckedCreateInput>
    /**
     * In case the DecisionVote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DecisionVoteUpdateInput, DecisionVoteUncheckedUpdateInput>
  }

  /**
   * DecisionVote delete
   */
  export type DecisionVoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionVote
     */
    select?: DecisionVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DecisionVote
     */
    omit?: DecisionVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionVoteInclude<ExtArgs> | null
    /**
     * Filter which DecisionVote to delete.
     */
    where: DecisionVoteWhereUniqueInput
  }

  /**
   * DecisionVote deleteMany
   */
  export type DecisionVoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DecisionVotes to delete
     */
    where?: DecisionVoteWhereInput
    /**
     * Limit how many DecisionVotes to delete.
     */
    limit?: number
  }

  /**
   * DecisionVote without action
   */
  export type DecisionVoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionVote
     */
    select?: DecisionVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DecisionVote
     */
    omit?: DecisionVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionVoteInclude<ExtArgs> | null
  }


  /**
   * Model DepartmentMember
   */

  export type AggregateDepartmentMember = {
    _count: DepartmentMemberCountAggregateOutputType | null
    _min: DepartmentMemberMinAggregateOutputType | null
    _max: DepartmentMemberMaxAggregateOutputType | null
  }

  export type DepartmentMemberMinAggregateOutputType = {
    id: string | null
    deptId: string | null
    userId: string | null
    encryptedDeptKey: string | null
  }

  export type DepartmentMemberMaxAggregateOutputType = {
    id: string | null
    deptId: string | null
    userId: string | null
    encryptedDeptKey: string | null
  }

  export type DepartmentMemberCountAggregateOutputType = {
    id: number
    deptId: number
    userId: number
    encryptedDeptKey: number
    _all: number
  }


  export type DepartmentMemberMinAggregateInputType = {
    id?: true
    deptId?: true
    userId?: true
    encryptedDeptKey?: true
  }

  export type DepartmentMemberMaxAggregateInputType = {
    id?: true
    deptId?: true
    userId?: true
    encryptedDeptKey?: true
  }

  export type DepartmentMemberCountAggregateInputType = {
    id?: true
    deptId?: true
    userId?: true
    encryptedDeptKey?: true
    _all?: true
  }

  export type DepartmentMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DepartmentMember to aggregate.
     */
    where?: DepartmentMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentMembers to fetch.
     */
    orderBy?: DepartmentMemberOrderByWithRelationInput | DepartmentMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DepartmentMembers
    **/
    _count?: true | DepartmentMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMemberMaxAggregateInputType
  }

  export type GetDepartmentMemberAggregateType<T extends DepartmentMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartmentMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartmentMember[P]>
      : GetScalarType<T[P], AggregateDepartmentMember[P]>
  }




  export type DepartmentMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentMemberWhereInput
    orderBy?: DepartmentMemberOrderByWithAggregationInput | DepartmentMemberOrderByWithAggregationInput[]
    by: DepartmentMemberScalarFieldEnum[] | DepartmentMemberScalarFieldEnum
    having?: DepartmentMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentMemberCountAggregateInputType | true
    _min?: DepartmentMemberMinAggregateInputType
    _max?: DepartmentMemberMaxAggregateInputType
  }

  export type DepartmentMemberGroupByOutputType = {
    id: string
    deptId: string
    userId: string
    encryptedDeptKey: string
    _count: DepartmentMemberCountAggregateOutputType | null
    _min: DepartmentMemberMinAggregateOutputType | null
    _max: DepartmentMemberMaxAggregateOutputType | null
  }

  type GetDepartmentMemberGroupByPayload<T extends DepartmentMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentMemberGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentMemberGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deptId?: boolean
    userId?: boolean
    encryptedDeptKey?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["departmentMember"]>

  export type DepartmentMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deptId?: boolean
    userId?: boolean
    encryptedDeptKey?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["departmentMember"]>

  export type DepartmentMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deptId?: boolean
    userId?: boolean
    encryptedDeptKey?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["departmentMember"]>

  export type DepartmentMemberSelectScalar = {
    id?: boolean
    deptId?: boolean
    userId?: boolean
    encryptedDeptKey?: boolean
  }

  export type DepartmentMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "deptId" | "userId" | "encryptedDeptKey", ExtArgs["result"]["departmentMember"]>
  export type DepartmentMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DepartmentMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DepartmentMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DepartmentMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DepartmentMember"
    objects: {
      department: Prisma.$DepartmentPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      deptId: string
      userId: string
      encryptedDeptKey: string
    }, ExtArgs["result"]["departmentMember"]>
    composites: {}
  }

  type DepartmentMemberGetPayload<S extends boolean | null | undefined | DepartmentMemberDefaultArgs> = $Result.GetResult<Prisma.$DepartmentMemberPayload, S>

  type DepartmentMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DepartmentMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepartmentMemberCountAggregateInputType | true
    }

  export interface DepartmentMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DepartmentMember'], meta: { name: 'DepartmentMember' } }
    /**
     * Find zero or one DepartmentMember that matches the filter.
     * @param {DepartmentMemberFindUniqueArgs} args - Arguments to find a DepartmentMember
     * @example
     * // Get one DepartmentMember
     * const departmentMember = await prisma.departmentMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentMemberFindUniqueArgs>(args: SelectSubset<T, DepartmentMemberFindUniqueArgs<ExtArgs>>): Prisma__DepartmentMemberClient<$Result.GetResult<Prisma.$DepartmentMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DepartmentMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DepartmentMemberFindUniqueOrThrowArgs} args - Arguments to find a DepartmentMember
     * @example
     * // Get one DepartmentMember
     * const departmentMember = await prisma.departmentMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentMemberClient<$Result.GetResult<Prisma.$DepartmentMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DepartmentMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentMemberFindFirstArgs} args - Arguments to find a DepartmentMember
     * @example
     * // Get one DepartmentMember
     * const departmentMember = await prisma.departmentMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentMemberFindFirstArgs>(args?: SelectSubset<T, DepartmentMemberFindFirstArgs<ExtArgs>>): Prisma__DepartmentMemberClient<$Result.GetResult<Prisma.$DepartmentMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DepartmentMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentMemberFindFirstOrThrowArgs} args - Arguments to find a DepartmentMember
     * @example
     * // Get one DepartmentMember
     * const departmentMember = await prisma.departmentMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentMemberClient<$Result.GetResult<Prisma.$DepartmentMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DepartmentMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DepartmentMembers
     * const departmentMembers = await prisma.departmentMember.findMany()
     * 
     * // Get first 10 DepartmentMembers
     * const departmentMembers = await prisma.departmentMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentMemberWithIdOnly = await prisma.departmentMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentMemberFindManyArgs>(args?: SelectSubset<T, DepartmentMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DepartmentMember.
     * @param {DepartmentMemberCreateArgs} args - Arguments to create a DepartmentMember.
     * @example
     * // Create one DepartmentMember
     * const DepartmentMember = await prisma.departmentMember.create({
     *   data: {
     *     // ... data to create a DepartmentMember
     *   }
     * })
     * 
     */
    create<T extends DepartmentMemberCreateArgs>(args: SelectSubset<T, DepartmentMemberCreateArgs<ExtArgs>>): Prisma__DepartmentMemberClient<$Result.GetResult<Prisma.$DepartmentMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DepartmentMembers.
     * @param {DepartmentMemberCreateManyArgs} args - Arguments to create many DepartmentMembers.
     * @example
     * // Create many DepartmentMembers
     * const departmentMember = await prisma.departmentMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentMemberCreateManyArgs>(args?: SelectSubset<T, DepartmentMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DepartmentMembers and returns the data saved in the database.
     * @param {DepartmentMemberCreateManyAndReturnArgs} args - Arguments to create many DepartmentMembers.
     * @example
     * // Create many DepartmentMembers
     * const departmentMember = await prisma.departmentMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DepartmentMembers and only return the `id`
     * const departmentMemberWithIdOnly = await prisma.departmentMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepartmentMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, DepartmentMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DepartmentMember.
     * @param {DepartmentMemberDeleteArgs} args - Arguments to delete one DepartmentMember.
     * @example
     * // Delete one DepartmentMember
     * const DepartmentMember = await prisma.departmentMember.delete({
     *   where: {
     *     // ... filter to delete one DepartmentMember
     *   }
     * })
     * 
     */
    delete<T extends DepartmentMemberDeleteArgs>(args: SelectSubset<T, DepartmentMemberDeleteArgs<ExtArgs>>): Prisma__DepartmentMemberClient<$Result.GetResult<Prisma.$DepartmentMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DepartmentMember.
     * @param {DepartmentMemberUpdateArgs} args - Arguments to update one DepartmentMember.
     * @example
     * // Update one DepartmentMember
     * const departmentMember = await prisma.departmentMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentMemberUpdateArgs>(args: SelectSubset<T, DepartmentMemberUpdateArgs<ExtArgs>>): Prisma__DepartmentMemberClient<$Result.GetResult<Prisma.$DepartmentMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DepartmentMembers.
     * @param {DepartmentMemberDeleteManyArgs} args - Arguments to filter DepartmentMembers to delete.
     * @example
     * // Delete a few DepartmentMembers
     * const { count } = await prisma.departmentMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentMemberDeleteManyArgs>(args?: SelectSubset<T, DepartmentMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DepartmentMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DepartmentMembers
     * const departmentMember = await prisma.departmentMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentMemberUpdateManyArgs>(args: SelectSubset<T, DepartmentMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DepartmentMembers and returns the data updated in the database.
     * @param {DepartmentMemberUpdateManyAndReturnArgs} args - Arguments to update many DepartmentMembers.
     * @example
     * // Update many DepartmentMembers
     * const departmentMember = await prisma.departmentMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DepartmentMembers and only return the `id`
     * const departmentMemberWithIdOnly = await prisma.departmentMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DepartmentMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, DepartmentMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DepartmentMember.
     * @param {DepartmentMemberUpsertArgs} args - Arguments to update or create a DepartmentMember.
     * @example
     * // Update or create a DepartmentMember
     * const departmentMember = await prisma.departmentMember.upsert({
     *   create: {
     *     // ... data to create a DepartmentMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DepartmentMember we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentMemberUpsertArgs>(args: SelectSubset<T, DepartmentMemberUpsertArgs<ExtArgs>>): Prisma__DepartmentMemberClient<$Result.GetResult<Prisma.$DepartmentMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DepartmentMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentMemberCountArgs} args - Arguments to filter DepartmentMembers to count.
     * @example
     * // Count the number of DepartmentMembers
     * const count = await prisma.departmentMember.count({
     *   where: {
     *     // ... the filter for the DepartmentMembers we want to count
     *   }
     * })
    **/
    count<T extends DepartmentMemberCountArgs>(
      args?: Subset<T, DepartmentMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DepartmentMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentMemberAggregateArgs>(args: Subset<T, DepartmentMemberAggregateArgs>): Prisma.PrismaPromise<GetDepartmentMemberAggregateType<T>>

    /**
     * Group by DepartmentMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentMemberGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DepartmentMember model
   */
  readonly fields: DepartmentMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DepartmentMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    department<T extends DepartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DepartmentDefaultArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DepartmentMember model
   */
  interface DepartmentMemberFieldRefs {
    readonly id: FieldRef<"DepartmentMember", 'String'>
    readonly deptId: FieldRef<"DepartmentMember", 'String'>
    readonly userId: FieldRef<"DepartmentMember", 'String'>
    readonly encryptedDeptKey: FieldRef<"DepartmentMember", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DepartmentMember findUnique
   */
  export type DepartmentMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentMember
     */
    select?: DepartmentMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentMember
     */
    omit?: DepartmentMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentMemberInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentMember to fetch.
     */
    where: DepartmentMemberWhereUniqueInput
  }

  /**
   * DepartmentMember findUniqueOrThrow
   */
  export type DepartmentMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentMember
     */
    select?: DepartmentMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentMember
     */
    omit?: DepartmentMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentMemberInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentMember to fetch.
     */
    where: DepartmentMemberWhereUniqueInput
  }

  /**
   * DepartmentMember findFirst
   */
  export type DepartmentMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentMember
     */
    select?: DepartmentMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentMember
     */
    omit?: DepartmentMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentMemberInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentMember to fetch.
     */
    where?: DepartmentMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentMembers to fetch.
     */
    orderBy?: DepartmentMemberOrderByWithRelationInput | DepartmentMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DepartmentMembers.
     */
    cursor?: DepartmentMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DepartmentMembers.
     */
    distinct?: DepartmentMemberScalarFieldEnum | DepartmentMemberScalarFieldEnum[]
  }

  /**
   * DepartmentMember findFirstOrThrow
   */
  export type DepartmentMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentMember
     */
    select?: DepartmentMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentMember
     */
    omit?: DepartmentMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentMemberInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentMember to fetch.
     */
    where?: DepartmentMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentMembers to fetch.
     */
    orderBy?: DepartmentMemberOrderByWithRelationInput | DepartmentMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DepartmentMembers.
     */
    cursor?: DepartmentMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DepartmentMembers.
     */
    distinct?: DepartmentMemberScalarFieldEnum | DepartmentMemberScalarFieldEnum[]
  }

  /**
   * DepartmentMember findMany
   */
  export type DepartmentMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentMember
     */
    select?: DepartmentMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentMember
     */
    omit?: DepartmentMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentMemberInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentMembers to fetch.
     */
    where?: DepartmentMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentMembers to fetch.
     */
    orderBy?: DepartmentMemberOrderByWithRelationInput | DepartmentMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DepartmentMembers.
     */
    cursor?: DepartmentMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentMembers.
     */
    skip?: number
    distinct?: DepartmentMemberScalarFieldEnum | DepartmentMemberScalarFieldEnum[]
  }

  /**
   * DepartmentMember create
   */
  export type DepartmentMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentMember
     */
    select?: DepartmentMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentMember
     */
    omit?: DepartmentMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a DepartmentMember.
     */
    data: XOR<DepartmentMemberCreateInput, DepartmentMemberUncheckedCreateInput>
  }

  /**
   * DepartmentMember createMany
   */
  export type DepartmentMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DepartmentMembers.
     */
    data: DepartmentMemberCreateManyInput | DepartmentMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DepartmentMember createManyAndReturn
   */
  export type DepartmentMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentMember
     */
    select?: DepartmentMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentMember
     */
    omit?: DepartmentMemberOmit<ExtArgs> | null
    /**
     * The data used to create many DepartmentMembers.
     */
    data: DepartmentMemberCreateManyInput | DepartmentMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DepartmentMember update
   */
  export type DepartmentMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentMember
     */
    select?: DepartmentMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentMember
     */
    omit?: DepartmentMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a DepartmentMember.
     */
    data: XOR<DepartmentMemberUpdateInput, DepartmentMemberUncheckedUpdateInput>
    /**
     * Choose, which DepartmentMember to update.
     */
    where: DepartmentMemberWhereUniqueInput
  }

  /**
   * DepartmentMember updateMany
   */
  export type DepartmentMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DepartmentMembers.
     */
    data: XOR<DepartmentMemberUpdateManyMutationInput, DepartmentMemberUncheckedUpdateManyInput>
    /**
     * Filter which DepartmentMembers to update
     */
    where?: DepartmentMemberWhereInput
    /**
     * Limit how many DepartmentMembers to update.
     */
    limit?: number
  }

  /**
   * DepartmentMember updateManyAndReturn
   */
  export type DepartmentMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentMember
     */
    select?: DepartmentMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentMember
     */
    omit?: DepartmentMemberOmit<ExtArgs> | null
    /**
     * The data used to update DepartmentMembers.
     */
    data: XOR<DepartmentMemberUpdateManyMutationInput, DepartmentMemberUncheckedUpdateManyInput>
    /**
     * Filter which DepartmentMembers to update
     */
    where?: DepartmentMemberWhereInput
    /**
     * Limit how many DepartmentMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DepartmentMember upsert
   */
  export type DepartmentMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentMember
     */
    select?: DepartmentMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentMember
     */
    omit?: DepartmentMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the DepartmentMember to update in case it exists.
     */
    where: DepartmentMemberWhereUniqueInput
    /**
     * In case the DepartmentMember found by the `where` argument doesn't exist, create a new DepartmentMember with this data.
     */
    create: XOR<DepartmentMemberCreateInput, DepartmentMemberUncheckedCreateInput>
    /**
     * In case the DepartmentMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentMemberUpdateInput, DepartmentMemberUncheckedUpdateInput>
  }

  /**
   * DepartmentMember delete
   */
  export type DepartmentMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentMember
     */
    select?: DepartmentMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentMember
     */
    omit?: DepartmentMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentMemberInclude<ExtArgs> | null
    /**
     * Filter which DepartmentMember to delete.
     */
    where: DepartmentMemberWhereUniqueInput
  }

  /**
   * DepartmentMember deleteMany
   */
  export type DepartmentMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DepartmentMembers to delete
     */
    where?: DepartmentMemberWhereInput
    /**
     * Limit how many DepartmentMembers to delete.
     */
    limit?: number
  }

  /**
   * DepartmentMember without action
   */
  export type DepartmentMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentMember
     */
    select?: DepartmentMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentMember
     */
    omit?: DepartmentMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentMemberInclude<ExtArgs> | null
  }


  /**
   * Model Group
   */

  export type AggregateGroup = {
    _count: GroupCountAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  export type GroupMinAggregateOutputType = {
    id: string | null
    name: string | null
    isDirect: boolean | null
    deptId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupMaxAggregateOutputType = {
    id: string | null
    name: string | null
    isDirect: boolean | null
    deptId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupCountAggregateOutputType = {
    id: number
    name: number
    isDirect: number
    deptId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GroupMinAggregateInputType = {
    id?: true
    name?: true
    isDirect?: true
    deptId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupMaxAggregateInputType = {
    id?: true
    name?: true
    isDirect?: true
    deptId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupCountAggregateInputType = {
    id?: true
    name?: true
    isDirect?: true
    deptId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Group to aggregate.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Groups
    **/
    _count?: true | GroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupMaxAggregateInputType
  }

  export type GetGroupAggregateType<T extends GroupAggregateArgs> = {
        [P in keyof T & keyof AggregateGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroup[P]>
      : GetScalarType<T[P], AggregateGroup[P]>
  }




  export type GroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupWhereInput
    orderBy?: GroupOrderByWithAggregationInput | GroupOrderByWithAggregationInput[]
    by: GroupScalarFieldEnum[] | GroupScalarFieldEnum
    having?: GroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupCountAggregateInputType | true
    _min?: GroupMinAggregateInputType
    _max?: GroupMaxAggregateInputType
  }

  export type GroupGroupByOutputType = {
    id: string
    name: string | null
    isDirect: boolean
    deptId: string | null
    createdAt: Date
    updatedAt: Date
    _count: GroupCountAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  type GetGroupGroupByPayload<T extends GroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupGroupByOutputType[P]>
            : GetScalarType<T[P], GroupGroupByOutputType[P]>
        }
      >
    >


  export type GroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isDirect?: boolean
    deptId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | Group$departmentArgs<ExtArgs>
    members?: boolean | Group$membersArgs<ExtArgs>
    messages?: boolean | Group$messagesArgs<ExtArgs>
    documents?: boolean | Group$documentsArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["group"]>

  export type GroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isDirect?: boolean
    deptId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | Group$departmentArgs<ExtArgs>
  }, ExtArgs["result"]["group"]>

  export type GroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isDirect?: boolean
    deptId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | Group$departmentArgs<ExtArgs>
  }, ExtArgs["result"]["group"]>

  export type GroupSelectScalar = {
    id?: boolean
    name?: boolean
    isDirect?: boolean
    deptId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "isDirect" | "deptId" | "createdAt" | "updatedAt", ExtArgs["result"]["group"]>
  export type GroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | Group$departmentArgs<ExtArgs>
    members?: boolean | Group$membersArgs<ExtArgs>
    messages?: boolean | Group$messagesArgs<ExtArgs>
    documents?: boolean | Group$documentsArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | Group$departmentArgs<ExtArgs>
  }
  export type GroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | Group$departmentArgs<ExtArgs>
  }

  export type $GroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Group"
    objects: {
      department: Prisma.$DepartmentPayload<ExtArgs> | null
      members: Prisma.$GroupMemberPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
      documents: Prisma.$GroupDocumentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      isDirect: boolean
      deptId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["group"]>
    composites: {}
  }

  type GroupGetPayload<S extends boolean | null | undefined | GroupDefaultArgs> = $Result.GetResult<Prisma.$GroupPayload, S>

  type GroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GroupCountAggregateInputType | true
    }

  export interface GroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Group'], meta: { name: 'Group' } }
    /**
     * Find zero or one Group that matches the filter.
     * @param {GroupFindUniqueArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupFindUniqueArgs>(args: SelectSubset<T, GroupFindUniqueArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Group that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GroupFindUniqueOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Group that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupFindFirstArgs>(args?: SelectSubset<T, GroupFindFirstArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Group that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Groups
     * const groups = await prisma.group.findMany()
     * 
     * // Get first 10 Groups
     * const groups = await prisma.group.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupWithIdOnly = await prisma.group.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupFindManyArgs>(args?: SelectSubset<T, GroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Group.
     * @param {GroupCreateArgs} args - Arguments to create a Group.
     * @example
     * // Create one Group
     * const Group = await prisma.group.create({
     *   data: {
     *     // ... data to create a Group
     *   }
     * })
     * 
     */
    create<T extends GroupCreateArgs>(args: SelectSubset<T, GroupCreateArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Groups.
     * @param {GroupCreateManyArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const group = await prisma.group.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupCreateManyArgs>(args?: SelectSubset<T, GroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Groups and returns the data saved in the database.
     * @param {GroupCreateManyAndReturnArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const group = await prisma.group.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Groups and only return the `id`
     * const groupWithIdOnly = await prisma.group.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Group.
     * @param {GroupDeleteArgs} args - Arguments to delete one Group.
     * @example
     * // Delete one Group
     * const Group = await prisma.group.delete({
     *   where: {
     *     // ... filter to delete one Group
     *   }
     * })
     * 
     */
    delete<T extends GroupDeleteArgs>(args: SelectSubset<T, GroupDeleteArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Group.
     * @param {GroupUpdateArgs} args - Arguments to update one Group.
     * @example
     * // Update one Group
     * const group = await prisma.group.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupUpdateArgs>(args: SelectSubset<T, GroupUpdateArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Groups.
     * @param {GroupDeleteManyArgs} args - Arguments to filter Groups to delete.
     * @example
     * // Delete a few Groups
     * const { count } = await prisma.group.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupDeleteManyArgs>(args?: SelectSubset<T, GroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Groups
     * const group = await prisma.group.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupUpdateManyArgs>(args: SelectSubset<T, GroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups and returns the data updated in the database.
     * @param {GroupUpdateManyAndReturnArgs} args - Arguments to update many Groups.
     * @example
     * // Update many Groups
     * const group = await prisma.group.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Groups and only return the `id`
     * const groupWithIdOnly = await prisma.group.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GroupUpdateManyAndReturnArgs>(args: SelectSubset<T, GroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Group.
     * @param {GroupUpsertArgs} args - Arguments to update or create a Group.
     * @example
     * // Update or create a Group
     * const group = await prisma.group.upsert({
     *   create: {
     *     // ... data to create a Group
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Group we want to update
     *   }
     * })
     */
    upsert<T extends GroupUpsertArgs>(args: SelectSubset<T, GroupUpsertArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupCountArgs} args - Arguments to filter Groups to count.
     * @example
     * // Count the number of Groups
     * const count = await prisma.group.count({
     *   where: {
     *     // ... the filter for the Groups we want to count
     *   }
     * })
    **/
    count<T extends GroupCountArgs>(
      args?: Subset<T, GroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupAggregateArgs>(args: Subset<T, GroupAggregateArgs>): Prisma.PrismaPromise<GetGroupAggregateType<T>>

    /**
     * Group by Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupGroupByArgs['orderBy'] }
        : { orderBy?: GroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Group model
   */
  readonly fields: GroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Group.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    department<T extends Group$departmentArgs<ExtArgs> = {}>(args?: Subset<T, Group$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    members<T extends Group$membersArgs<ExtArgs> = {}>(args?: Subset<T, Group$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends Group$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Group$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends Group$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Group$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Group model
   */
  interface GroupFieldRefs {
    readonly id: FieldRef<"Group", 'String'>
    readonly name: FieldRef<"Group", 'String'>
    readonly isDirect: FieldRef<"Group", 'Boolean'>
    readonly deptId: FieldRef<"Group", 'String'>
    readonly createdAt: FieldRef<"Group", 'DateTime'>
    readonly updatedAt: FieldRef<"Group", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Group findUnique
   */
  export type GroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group findUniqueOrThrow
   */
  export type GroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group findFirst
   */
  export type GroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group findFirstOrThrow
   */
  export type GroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group findMany
   */
  export type GroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Groups to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group create
   */
  export type GroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The data needed to create a Group.
     */
    data: XOR<GroupCreateInput, GroupUncheckedCreateInput>
  }

  /**
   * Group createMany
   */
  export type GroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Groups.
     */
    data: GroupCreateManyInput | GroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Group createManyAndReturn
   */
  export type GroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * The data used to create many Groups.
     */
    data: GroupCreateManyInput | GroupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Group update
   */
  export type GroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The data needed to update a Group.
     */
    data: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
    /**
     * Choose, which Group to update.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group updateMany
   */
  export type GroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Groups.
     */
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyInput>
    /**
     * Filter which Groups to update
     */
    where?: GroupWhereInput
    /**
     * Limit how many Groups to update.
     */
    limit?: number
  }

  /**
   * Group updateManyAndReturn
   */
  export type GroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * The data used to update Groups.
     */
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyInput>
    /**
     * Filter which Groups to update
     */
    where?: GroupWhereInput
    /**
     * Limit how many Groups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Group upsert
   */
  export type GroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The filter to search for the Group to update in case it exists.
     */
    where: GroupWhereUniqueInput
    /**
     * In case the Group found by the `where` argument doesn't exist, create a new Group with this data.
     */
    create: XOR<GroupCreateInput, GroupUncheckedCreateInput>
    /**
     * In case the Group was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
  }

  /**
   * Group delete
   */
  export type GroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter which Group to delete.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group deleteMany
   */
  export type GroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Groups to delete
     */
    where?: GroupWhereInput
    /**
     * Limit how many Groups to delete.
     */
    limit?: number
  }

  /**
   * Group.department
   */
  export type Group$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * Group.members
   */
  export type Group$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    where?: GroupMemberWhereInput
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    cursor?: GroupMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * Group.messages
   */
  export type Group$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Group.documents
   */
  export type Group$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupDocument
     */
    select?: GroupDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupDocument
     */
    omit?: GroupDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupDocumentInclude<ExtArgs> | null
    where?: GroupDocumentWhereInput
    orderBy?: GroupDocumentOrderByWithRelationInput | GroupDocumentOrderByWithRelationInput[]
    cursor?: GroupDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupDocumentScalarFieldEnum | GroupDocumentScalarFieldEnum[]
  }

  /**
   * Group without action
   */
  export type GroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
  }


  /**
   * Model GroupDocument
   */

  export type AggregateGroupDocument = {
    _count: GroupDocumentCountAggregateOutputType | null
    _min: GroupDocumentMinAggregateOutputType | null
    _max: GroupDocumentMaxAggregateOutputType | null
  }

  export type GroupDocumentMinAggregateOutputType = {
    id: string | null
    groupId: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupDocumentMaxAggregateOutputType = {
    id: string | null
    groupId: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupDocumentCountAggregateOutputType = {
    id: number
    groupId: number
    title: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GroupDocumentMinAggregateInputType = {
    id?: true
    groupId?: true
    title?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupDocumentMaxAggregateInputType = {
    id?: true
    groupId?: true
    title?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupDocumentCountAggregateInputType = {
    id?: true
    groupId?: true
    title?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GroupDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupDocument to aggregate.
     */
    where?: GroupDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupDocuments to fetch.
     */
    orderBy?: GroupDocumentOrderByWithRelationInput | GroupDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GroupDocuments
    **/
    _count?: true | GroupDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupDocumentMaxAggregateInputType
  }

  export type GetGroupDocumentAggregateType<T extends GroupDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupDocument[P]>
      : GetScalarType<T[P], AggregateGroupDocument[P]>
  }




  export type GroupDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupDocumentWhereInput
    orderBy?: GroupDocumentOrderByWithAggregationInput | GroupDocumentOrderByWithAggregationInput[]
    by: GroupDocumentScalarFieldEnum[] | GroupDocumentScalarFieldEnum
    having?: GroupDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupDocumentCountAggregateInputType | true
    _min?: GroupDocumentMinAggregateInputType
    _max?: GroupDocumentMaxAggregateInputType
  }

  export type GroupDocumentGroupByOutputType = {
    id: string
    groupId: string
    title: string
    createdAt: Date
    updatedAt: Date
    _count: GroupDocumentCountAggregateOutputType | null
    _min: GroupDocumentMinAggregateOutputType | null
    _max: GroupDocumentMaxAggregateOutputType | null
  }

  type GetGroupDocumentGroupByPayload<T extends GroupDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], GroupDocumentGroupByOutputType[P]>
        }
      >
    >


  export type GroupDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    notes?: boolean | GroupDocument$notesArgs<ExtArgs>
    _count?: boolean | GroupDocumentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupDocument"]>

  export type GroupDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupDocument"]>

  export type GroupDocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupDocument"]>

  export type GroupDocumentSelectScalar = {
    id?: boolean
    groupId?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GroupDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "groupId" | "title" | "createdAt" | "updatedAt", ExtArgs["result"]["groupDocument"]>
  export type GroupDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    notes?: boolean | GroupDocument$notesArgs<ExtArgs>
    _count?: boolean | GroupDocumentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GroupDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }
  export type GroupDocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }

  export type $GroupDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GroupDocument"
    objects: {
      group: Prisma.$GroupPayload<ExtArgs>
      notes: Prisma.$GroupNotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      groupId: string
      title: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["groupDocument"]>
    composites: {}
  }

  type GroupDocumentGetPayload<S extends boolean | null | undefined | GroupDocumentDefaultArgs> = $Result.GetResult<Prisma.$GroupDocumentPayload, S>

  type GroupDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GroupDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GroupDocumentCountAggregateInputType | true
    }

  export interface GroupDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GroupDocument'], meta: { name: 'GroupDocument' } }
    /**
     * Find zero or one GroupDocument that matches the filter.
     * @param {GroupDocumentFindUniqueArgs} args - Arguments to find a GroupDocument
     * @example
     * // Get one GroupDocument
     * const groupDocument = await prisma.groupDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupDocumentFindUniqueArgs>(args: SelectSubset<T, GroupDocumentFindUniqueArgs<ExtArgs>>): Prisma__GroupDocumentClient<$Result.GetResult<Prisma.$GroupDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GroupDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GroupDocumentFindUniqueOrThrowArgs} args - Arguments to find a GroupDocument
     * @example
     * // Get one GroupDocument
     * const groupDocument = await prisma.groupDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupDocumentClient<$Result.GetResult<Prisma.$GroupDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroupDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupDocumentFindFirstArgs} args - Arguments to find a GroupDocument
     * @example
     * // Get one GroupDocument
     * const groupDocument = await prisma.groupDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupDocumentFindFirstArgs>(args?: SelectSubset<T, GroupDocumentFindFirstArgs<ExtArgs>>): Prisma__GroupDocumentClient<$Result.GetResult<Prisma.$GroupDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroupDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupDocumentFindFirstOrThrowArgs} args - Arguments to find a GroupDocument
     * @example
     * // Get one GroupDocument
     * const groupDocument = await prisma.groupDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupDocumentClient<$Result.GetResult<Prisma.$GroupDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GroupDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GroupDocuments
     * const groupDocuments = await prisma.groupDocument.findMany()
     * 
     * // Get first 10 GroupDocuments
     * const groupDocuments = await prisma.groupDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupDocumentWithIdOnly = await prisma.groupDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupDocumentFindManyArgs>(args?: SelectSubset<T, GroupDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GroupDocument.
     * @param {GroupDocumentCreateArgs} args - Arguments to create a GroupDocument.
     * @example
     * // Create one GroupDocument
     * const GroupDocument = await prisma.groupDocument.create({
     *   data: {
     *     // ... data to create a GroupDocument
     *   }
     * })
     * 
     */
    create<T extends GroupDocumentCreateArgs>(args: SelectSubset<T, GroupDocumentCreateArgs<ExtArgs>>): Prisma__GroupDocumentClient<$Result.GetResult<Prisma.$GroupDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GroupDocuments.
     * @param {GroupDocumentCreateManyArgs} args - Arguments to create many GroupDocuments.
     * @example
     * // Create many GroupDocuments
     * const groupDocument = await prisma.groupDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupDocumentCreateManyArgs>(args?: SelectSubset<T, GroupDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GroupDocuments and returns the data saved in the database.
     * @param {GroupDocumentCreateManyAndReturnArgs} args - Arguments to create many GroupDocuments.
     * @example
     * // Create many GroupDocuments
     * const groupDocument = await prisma.groupDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GroupDocuments and only return the `id`
     * const groupDocumentWithIdOnly = await prisma.groupDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupDocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GroupDocument.
     * @param {GroupDocumentDeleteArgs} args - Arguments to delete one GroupDocument.
     * @example
     * // Delete one GroupDocument
     * const GroupDocument = await prisma.groupDocument.delete({
     *   where: {
     *     // ... filter to delete one GroupDocument
     *   }
     * })
     * 
     */
    delete<T extends GroupDocumentDeleteArgs>(args: SelectSubset<T, GroupDocumentDeleteArgs<ExtArgs>>): Prisma__GroupDocumentClient<$Result.GetResult<Prisma.$GroupDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GroupDocument.
     * @param {GroupDocumentUpdateArgs} args - Arguments to update one GroupDocument.
     * @example
     * // Update one GroupDocument
     * const groupDocument = await prisma.groupDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupDocumentUpdateArgs>(args: SelectSubset<T, GroupDocumentUpdateArgs<ExtArgs>>): Prisma__GroupDocumentClient<$Result.GetResult<Prisma.$GroupDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GroupDocuments.
     * @param {GroupDocumentDeleteManyArgs} args - Arguments to filter GroupDocuments to delete.
     * @example
     * // Delete a few GroupDocuments
     * const { count } = await prisma.groupDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupDocumentDeleteManyArgs>(args?: SelectSubset<T, GroupDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GroupDocuments
     * const groupDocument = await prisma.groupDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupDocumentUpdateManyArgs>(args: SelectSubset<T, GroupDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupDocuments and returns the data updated in the database.
     * @param {GroupDocumentUpdateManyAndReturnArgs} args - Arguments to update many GroupDocuments.
     * @example
     * // Update many GroupDocuments
     * const groupDocument = await prisma.groupDocument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GroupDocuments and only return the `id`
     * const groupDocumentWithIdOnly = await prisma.groupDocument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GroupDocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, GroupDocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupDocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GroupDocument.
     * @param {GroupDocumentUpsertArgs} args - Arguments to update or create a GroupDocument.
     * @example
     * // Update or create a GroupDocument
     * const groupDocument = await prisma.groupDocument.upsert({
     *   create: {
     *     // ... data to create a GroupDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GroupDocument we want to update
     *   }
     * })
     */
    upsert<T extends GroupDocumentUpsertArgs>(args: SelectSubset<T, GroupDocumentUpsertArgs<ExtArgs>>): Prisma__GroupDocumentClient<$Result.GetResult<Prisma.$GroupDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GroupDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupDocumentCountArgs} args - Arguments to filter GroupDocuments to count.
     * @example
     * // Count the number of GroupDocuments
     * const count = await prisma.groupDocument.count({
     *   where: {
     *     // ... the filter for the GroupDocuments we want to count
     *   }
     * })
    **/
    count<T extends GroupDocumentCountArgs>(
      args?: Subset<T, GroupDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GroupDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupDocumentAggregateArgs>(args: Subset<T, GroupDocumentAggregateArgs>): Prisma.PrismaPromise<GetGroupDocumentAggregateType<T>>

    /**
     * Group by GroupDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupDocumentGroupByArgs['orderBy'] }
        : { orderBy?: GroupDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GroupDocument model
   */
  readonly fields: GroupDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GroupDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group<T extends GroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupDefaultArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    notes<T extends GroupDocument$notesArgs<ExtArgs> = {}>(args?: Subset<T, GroupDocument$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GroupDocument model
   */
  interface GroupDocumentFieldRefs {
    readonly id: FieldRef<"GroupDocument", 'String'>
    readonly groupId: FieldRef<"GroupDocument", 'String'>
    readonly title: FieldRef<"GroupDocument", 'String'>
    readonly createdAt: FieldRef<"GroupDocument", 'DateTime'>
    readonly updatedAt: FieldRef<"GroupDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GroupDocument findUnique
   */
  export type GroupDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupDocument
     */
    select?: GroupDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupDocument
     */
    omit?: GroupDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupDocumentInclude<ExtArgs> | null
    /**
     * Filter, which GroupDocument to fetch.
     */
    where: GroupDocumentWhereUniqueInput
  }

  /**
   * GroupDocument findUniqueOrThrow
   */
  export type GroupDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupDocument
     */
    select?: GroupDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupDocument
     */
    omit?: GroupDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupDocumentInclude<ExtArgs> | null
    /**
     * Filter, which GroupDocument to fetch.
     */
    where: GroupDocumentWhereUniqueInput
  }

  /**
   * GroupDocument findFirst
   */
  export type GroupDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupDocument
     */
    select?: GroupDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupDocument
     */
    omit?: GroupDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupDocumentInclude<ExtArgs> | null
    /**
     * Filter, which GroupDocument to fetch.
     */
    where?: GroupDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupDocuments to fetch.
     */
    orderBy?: GroupDocumentOrderByWithRelationInput | GroupDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupDocuments.
     */
    cursor?: GroupDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupDocuments.
     */
    distinct?: GroupDocumentScalarFieldEnum | GroupDocumentScalarFieldEnum[]
  }

  /**
   * GroupDocument findFirstOrThrow
   */
  export type GroupDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupDocument
     */
    select?: GroupDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupDocument
     */
    omit?: GroupDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupDocumentInclude<ExtArgs> | null
    /**
     * Filter, which GroupDocument to fetch.
     */
    where?: GroupDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupDocuments to fetch.
     */
    orderBy?: GroupDocumentOrderByWithRelationInput | GroupDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupDocuments.
     */
    cursor?: GroupDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupDocuments.
     */
    distinct?: GroupDocumentScalarFieldEnum | GroupDocumentScalarFieldEnum[]
  }

  /**
   * GroupDocument findMany
   */
  export type GroupDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupDocument
     */
    select?: GroupDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupDocument
     */
    omit?: GroupDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupDocumentInclude<ExtArgs> | null
    /**
     * Filter, which GroupDocuments to fetch.
     */
    where?: GroupDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupDocuments to fetch.
     */
    orderBy?: GroupDocumentOrderByWithRelationInput | GroupDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GroupDocuments.
     */
    cursor?: GroupDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupDocuments.
     */
    skip?: number
    distinct?: GroupDocumentScalarFieldEnum | GroupDocumentScalarFieldEnum[]
  }

  /**
   * GroupDocument create
   */
  export type GroupDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupDocument
     */
    select?: GroupDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupDocument
     */
    omit?: GroupDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a GroupDocument.
     */
    data: XOR<GroupDocumentCreateInput, GroupDocumentUncheckedCreateInput>
  }

  /**
   * GroupDocument createMany
   */
  export type GroupDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GroupDocuments.
     */
    data: GroupDocumentCreateManyInput | GroupDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GroupDocument createManyAndReturn
   */
  export type GroupDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupDocument
     */
    select?: GroupDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GroupDocument
     */
    omit?: GroupDocumentOmit<ExtArgs> | null
    /**
     * The data used to create many GroupDocuments.
     */
    data: GroupDocumentCreateManyInput | GroupDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupDocument update
   */
  export type GroupDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupDocument
     */
    select?: GroupDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupDocument
     */
    omit?: GroupDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a GroupDocument.
     */
    data: XOR<GroupDocumentUpdateInput, GroupDocumentUncheckedUpdateInput>
    /**
     * Choose, which GroupDocument to update.
     */
    where: GroupDocumentWhereUniqueInput
  }

  /**
   * GroupDocument updateMany
   */
  export type GroupDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GroupDocuments.
     */
    data: XOR<GroupDocumentUpdateManyMutationInput, GroupDocumentUncheckedUpdateManyInput>
    /**
     * Filter which GroupDocuments to update
     */
    where?: GroupDocumentWhereInput
    /**
     * Limit how many GroupDocuments to update.
     */
    limit?: number
  }

  /**
   * GroupDocument updateManyAndReturn
   */
  export type GroupDocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupDocument
     */
    select?: GroupDocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GroupDocument
     */
    omit?: GroupDocumentOmit<ExtArgs> | null
    /**
     * The data used to update GroupDocuments.
     */
    data: XOR<GroupDocumentUpdateManyMutationInput, GroupDocumentUncheckedUpdateManyInput>
    /**
     * Filter which GroupDocuments to update
     */
    where?: GroupDocumentWhereInput
    /**
     * Limit how many GroupDocuments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupDocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupDocument upsert
   */
  export type GroupDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupDocument
     */
    select?: GroupDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupDocument
     */
    omit?: GroupDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the GroupDocument to update in case it exists.
     */
    where: GroupDocumentWhereUniqueInput
    /**
     * In case the GroupDocument found by the `where` argument doesn't exist, create a new GroupDocument with this data.
     */
    create: XOR<GroupDocumentCreateInput, GroupDocumentUncheckedCreateInput>
    /**
     * In case the GroupDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupDocumentUpdateInput, GroupDocumentUncheckedUpdateInput>
  }

  /**
   * GroupDocument delete
   */
  export type GroupDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupDocument
     */
    select?: GroupDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupDocument
     */
    omit?: GroupDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupDocumentInclude<ExtArgs> | null
    /**
     * Filter which GroupDocument to delete.
     */
    where: GroupDocumentWhereUniqueInput
  }

  /**
   * GroupDocument deleteMany
   */
  export type GroupDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupDocuments to delete
     */
    where?: GroupDocumentWhereInput
    /**
     * Limit how many GroupDocuments to delete.
     */
    limit?: number
  }

  /**
   * GroupDocument.notes
   */
  export type GroupDocument$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupNote
     */
    select?: GroupNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupNote
     */
    omit?: GroupNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupNoteInclude<ExtArgs> | null
    where?: GroupNoteWhereInput
    orderBy?: GroupNoteOrderByWithRelationInput | GroupNoteOrderByWithRelationInput[]
    cursor?: GroupNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupNoteScalarFieldEnum | GroupNoteScalarFieldEnum[]
  }

  /**
   * GroupDocument without action
   */
  export type GroupDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupDocument
     */
    select?: GroupDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupDocument
     */
    omit?: GroupDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupDocumentInclude<ExtArgs> | null
  }


  /**
   * Model GroupNote
   */

  export type AggregateGroupNote = {
    _count: GroupNoteCountAggregateOutputType | null
    _avg: GroupNoteAvgAggregateOutputType | null
    _sum: GroupNoteSumAggregateOutputType | null
    _min: GroupNoteMinAggregateOutputType | null
    _max: GroupNoteMaxAggregateOutputType | null
  }

  export type GroupNoteAvgAggregateOutputType = {
    order: number | null
  }

  export type GroupNoteSumAggregateOutputType = {
    order: number | null
  }

  export type GroupNoteMinAggregateOutputType = {
    id: string | null
    documentId: string | null
    title: string | null
    content: string | null
    textSize: $Enums.NoteTextSize | null
    order: number | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupNoteMaxAggregateOutputType = {
    id: string | null
    documentId: string | null
    title: string | null
    content: string | null
    textSize: $Enums.NoteTextSize | null
    order: number | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupNoteCountAggregateOutputType = {
    id: number
    documentId: number
    title: number
    content: number
    textSize: number
    order: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GroupNoteAvgAggregateInputType = {
    order?: true
  }

  export type GroupNoteSumAggregateInputType = {
    order?: true
  }

  export type GroupNoteMinAggregateInputType = {
    id?: true
    documentId?: true
    title?: true
    content?: true
    textSize?: true
    order?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupNoteMaxAggregateInputType = {
    id?: true
    documentId?: true
    title?: true
    content?: true
    textSize?: true
    order?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupNoteCountAggregateInputType = {
    id?: true
    documentId?: true
    title?: true
    content?: true
    textSize?: true
    order?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GroupNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupNote to aggregate.
     */
    where?: GroupNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupNotes to fetch.
     */
    orderBy?: GroupNoteOrderByWithRelationInput | GroupNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GroupNotes
    **/
    _count?: true | GroupNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupNoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupNoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupNoteMaxAggregateInputType
  }

  export type GetGroupNoteAggregateType<T extends GroupNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupNote[P]>
      : GetScalarType<T[P], AggregateGroupNote[P]>
  }




  export type GroupNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupNoteWhereInput
    orderBy?: GroupNoteOrderByWithAggregationInput | GroupNoteOrderByWithAggregationInput[]
    by: GroupNoteScalarFieldEnum[] | GroupNoteScalarFieldEnum
    having?: GroupNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupNoteCountAggregateInputType | true
    _avg?: GroupNoteAvgAggregateInputType
    _sum?: GroupNoteSumAggregateInputType
    _min?: GroupNoteMinAggregateInputType
    _max?: GroupNoteMaxAggregateInputType
  }

  export type GroupNoteGroupByOutputType = {
    id: string
    documentId: string
    title: string
    content: string
    textSize: $Enums.NoteTextSize
    order: number
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: GroupNoteCountAggregateOutputType | null
    _avg: GroupNoteAvgAggregateOutputType | null
    _sum: GroupNoteSumAggregateOutputType | null
    _min: GroupNoteMinAggregateOutputType | null
    _max: GroupNoteMaxAggregateOutputType | null
  }

  type GetGroupNoteGroupByPayload<T extends GroupNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupNoteGroupByOutputType[P]>
            : GetScalarType<T[P], GroupNoteGroupByOutputType[P]>
        }
      >
    >


  export type GroupNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    title?: boolean
    content?: boolean
    textSize?: boolean
    order?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    document?: boolean | GroupDocumentDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupNote"]>

  export type GroupNoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    title?: boolean
    content?: boolean
    textSize?: boolean
    order?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    document?: boolean | GroupDocumentDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupNote"]>

  export type GroupNoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    title?: boolean
    content?: boolean
    textSize?: boolean
    order?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    document?: boolean | GroupDocumentDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupNote"]>

  export type GroupNoteSelectScalar = {
    id?: boolean
    documentId?: boolean
    title?: boolean
    content?: boolean
    textSize?: boolean
    order?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GroupNoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "documentId" | "title" | "content" | "textSize" | "order" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["groupNote"]>
  export type GroupNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | GroupDocumentDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GroupNoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | GroupDocumentDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GroupNoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | GroupDocumentDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GroupNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GroupNote"
    objects: {
      document: Prisma.$GroupDocumentPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      documentId: string
      title: string
      content: string
      textSize: $Enums.NoteTextSize
      order: number
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["groupNote"]>
    composites: {}
  }

  type GroupNoteGetPayload<S extends boolean | null | undefined | GroupNoteDefaultArgs> = $Result.GetResult<Prisma.$GroupNotePayload, S>

  type GroupNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GroupNoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GroupNoteCountAggregateInputType | true
    }

  export interface GroupNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GroupNote'], meta: { name: 'GroupNote' } }
    /**
     * Find zero or one GroupNote that matches the filter.
     * @param {GroupNoteFindUniqueArgs} args - Arguments to find a GroupNote
     * @example
     * // Get one GroupNote
     * const groupNote = await prisma.groupNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupNoteFindUniqueArgs>(args: SelectSubset<T, GroupNoteFindUniqueArgs<ExtArgs>>): Prisma__GroupNoteClient<$Result.GetResult<Prisma.$GroupNotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GroupNote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GroupNoteFindUniqueOrThrowArgs} args - Arguments to find a GroupNote
     * @example
     * // Get one GroupNote
     * const groupNote = await prisma.groupNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupNoteFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupNoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupNoteClient<$Result.GetResult<Prisma.$GroupNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroupNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupNoteFindFirstArgs} args - Arguments to find a GroupNote
     * @example
     * // Get one GroupNote
     * const groupNote = await prisma.groupNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupNoteFindFirstArgs>(args?: SelectSubset<T, GroupNoteFindFirstArgs<ExtArgs>>): Prisma__GroupNoteClient<$Result.GetResult<Prisma.$GroupNotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroupNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupNoteFindFirstOrThrowArgs} args - Arguments to find a GroupNote
     * @example
     * // Get one GroupNote
     * const groupNote = await prisma.groupNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupNoteFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupNoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupNoteClient<$Result.GetResult<Prisma.$GroupNotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GroupNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupNoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GroupNotes
     * const groupNotes = await prisma.groupNote.findMany()
     * 
     * // Get first 10 GroupNotes
     * const groupNotes = await prisma.groupNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupNoteWithIdOnly = await prisma.groupNote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupNoteFindManyArgs>(args?: SelectSubset<T, GroupNoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GroupNote.
     * @param {GroupNoteCreateArgs} args - Arguments to create a GroupNote.
     * @example
     * // Create one GroupNote
     * const GroupNote = await prisma.groupNote.create({
     *   data: {
     *     // ... data to create a GroupNote
     *   }
     * })
     * 
     */
    create<T extends GroupNoteCreateArgs>(args: SelectSubset<T, GroupNoteCreateArgs<ExtArgs>>): Prisma__GroupNoteClient<$Result.GetResult<Prisma.$GroupNotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GroupNotes.
     * @param {GroupNoteCreateManyArgs} args - Arguments to create many GroupNotes.
     * @example
     * // Create many GroupNotes
     * const groupNote = await prisma.groupNote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupNoteCreateManyArgs>(args?: SelectSubset<T, GroupNoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GroupNotes and returns the data saved in the database.
     * @param {GroupNoteCreateManyAndReturnArgs} args - Arguments to create many GroupNotes.
     * @example
     * // Create many GroupNotes
     * const groupNote = await prisma.groupNote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GroupNotes and only return the `id`
     * const groupNoteWithIdOnly = await prisma.groupNote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupNoteCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupNoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupNotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GroupNote.
     * @param {GroupNoteDeleteArgs} args - Arguments to delete one GroupNote.
     * @example
     * // Delete one GroupNote
     * const GroupNote = await prisma.groupNote.delete({
     *   where: {
     *     // ... filter to delete one GroupNote
     *   }
     * })
     * 
     */
    delete<T extends GroupNoteDeleteArgs>(args: SelectSubset<T, GroupNoteDeleteArgs<ExtArgs>>): Prisma__GroupNoteClient<$Result.GetResult<Prisma.$GroupNotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GroupNote.
     * @param {GroupNoteUpdateArgs} args - Arguments to update one GroupNote.
     * @example
     * // Update one GroupNote
     * const groupNote = await prisma.groupNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupNoteUpdateArgs>(args: SelectSubset<T, GroupNoteUpdateArgs<ExtArgs>>): Prisma__GroupNoteClient<$Result.GetResult<Prisma.$GroupNotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GroupNotes.
     * @param {GroupNoteDeleteManyArgs} args - Arguments to filter GroupNotes to delete.
     * @example
     * // Delete a few GroupNotes
     * const { count } = await prisma.groupNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupNoteDeleteManyArgs>(args?: SelectSubset<T, GroupNoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GroupNotes
     * const groupNote = await prisma.groupNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupNoteUpdateManyArgs>(args: SelectSubset<T, GroupNoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupNotes and returns the data updated in the database.
     * @param {GroupNoteUpdateManyAndReturnArgs} args - Arguments to update many GroupNotes.
     * @example
     * // Update many GroupNotes
     * const groupNote = await prisma.groupNote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GroupNotes and only return the `id`
     * const groupNoteWithIdOnly = await prisma.groupNote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GroupNoteUpdateManyAndReturnArgs>(args: SelectSubset<T, GroupNoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupNotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GroupNote.
     * @param {GroupNoteUpsertArgs} args - Arguments to update or create a GroupNote.
     * @example
     * // Update or create a GroupNote
     * const groupNote = await prisma.groupNote.upsert({
     *   create: {
     *     // ... data to create a GroupNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GroupNote we want to update
     *   }
     * })
     */
    upsert<T extends GroupNoteUpsertArgs>(args: SelectSubset<T, GroupNoteUpsertArgs<ExtArgs>>): Prisma__GroupNoteClient<$Result.GetResult<Prisma.$GroupNotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GroupNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupNoteCountArgs} args - Arguments to filter GroupNotes to count.
     * @example
     * // Count the number of GroupNotes
     * const count = await prisma.groupNote.count({
     *   where: {
     *     // ... the filter for the GroupNotes we want to count
     *   }
     * })
    **/
    count<T extends GroupNoteCountArgs>(
      args?: Subset<T, GroupNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GroupNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupNoteAggregateArgs>(args: Subset<T, GroupNoteAggregateArgs>): Prisma.PrismaPromise<GetGroupNoteAggregateType<T>>

    /**
     * Group by GroupNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupNoteGroupByArgs['orderBy'] }
        : { orderBy?: GroupNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GroupNote model
   */
  readonly fields: GroupNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GroupNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    document<T extends GroupDocumentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupDocumentDefaultArgs<ExtArgs>>): Prisma__GroupDocumentClient<$Result.GetResult<Prisma.$GroupDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GroupNote model
   */
  interface GroupNoteFieldRefs {
    readonly id: FieldRef<"GroupNote", 'String'>
    readonly documentId: FieldRef<"GroupNote", 'String'>
    readonly title: FieldRef<"GroupNote", 'String'>
    readonly content: FieldRef<"GroupNote", 'String'>
    readonly textSize: FieldRef<"GroupNote", 'NoteTextSize'>
    readonly order: FieldRef<"GroupNote", 'Int'>
    readonly createdBy: FieldRef<"GroupNote", 'String'>
    readonly createdAt: FieldRef<"GroupNote", 'DateTime'>
    readonly updatedAt: FieldRef<"GroupNote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GroupNote findUnique
   */
  export type GroupNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupNote
     */
    select?: GroupNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupNote
     */
    omit?: GroupNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupNoteInclude<ExtArgs> | null
    /**
     * Filter, which GroupNote to fetch.
     */
    where: GroupNoteWhereUniqueInput
  }

  /**
   * GroupNote findUniqueOrThrow
   */
  export type GroupNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupNote
     */
    select?: GroupNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupNote
     */
    omit?: GroupNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupNoteInclude<ExtArgs> | null
    /**
     * Filter, which GroupNote to fetch.
     */
    where: GroupNoteWhereUniqueInput
  }

  /**
   * GroupNote findFirst
   */
  export type GroupNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupNote
     */
    select?: GroupNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupNote
     */
    omit?: GroupNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupNoteInclude<ExtArgs> | null
    /**
     * Filter, which GroupNote to fetch.
     */
    where?: GroupNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupNotes to fetch.
     */
    orderBy?: GroupNoteOrderByWithRelationInput | GroupNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupNotes.
     */
    cursor?: GroupNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupNotes.
     */
    distinct?: GroupNoteScalarFieldEnum | GroupNoteScalarFieldEnum[]
  }

  /**
   * GroupNote findFirstOrThrow
   */
  export type GroupNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupNote
     */
    select?: GroupNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupNote
     */
    omit?: GroupNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupNoteInclude<ExtArgs> | null
    /**
     * Filter, which GroupNote to fetch.
     */
    where?: GroupNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupNotes to fetch.
     */
    orderBy?: GroupNoteOrderByWithRelationInput | GroupNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupNotes.
     */
    cursor?: GroupNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupNotes.
     */
    distinct?: GroupNoteScalarFieldEnum | GroupNoteScalarFieldEnum[]
  }

  /**
   * GroupNote findMany
   */
  export type GroupNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupNote
     */
    select?: GroupNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupNote
     */
    omit?: GroupNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupNoteInclude<ExtArgs> | null
    /**
     * Filter, which GroupNotes to fetch.
     */
    where?: GroupNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupNotes to fetch.
     */
    orderBy?: GroupNoteOrderByWithRelationInput | GroupNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GroupNotes.
     */
    cursor?: GroupNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupNotes.
     */
    skip?: number
    distinct?: GroupNoteScalarFieldEnum | GroupNoteScalarFieldEnum[]
  }

  /**
   * GroupNote create
   */
  export type GroupNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupNote
     */
    select?: GroupNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupNote
     */
    omit?: GroupNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a GroupNote.
     */
    data: XOR<GroupNoteCreateInput, GroupNoteUncheckedCreateInput>
  }

  /**
   * GroupNote createMany
   */
  export type GroupNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GroupNotes.
     */
    data: GroupNoteCreateManyInput | GroupNoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GroupNote createManyAndReturn
   */
  export type GroupNoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupNote
     */
    select?: GroupNoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GroupNote
     */
    omit?: GroupNoteOmit<ExtArgs> | null
    /**
     * The data used to create many GroupNotes.
     */
    data: GroupNoteCreateManyInput | GroupNoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupNoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupNote update
   */
  export type GroupNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupNote
     */
    select?: GroupNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupNote
     */
    omit?: GroupNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a GroupNote.
     */
    data: XOR<GroupNoteUpdateInput, GroupNoteUncheckedUpdateInput>
    /**
     * Choose, which GroupNote to update.
     */
    where: GroupNoteWhereUniqueInput
  }

  /**
   * GroupNote updateMany
   */
  export type GroupNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GroupNotes.
     */
    data: XOR<GroupNoteUpdateManyMutationInput, GroupNoteUncheckedUpdateManyInput>
    /**
     * Filter which GroupNotes to update
     */
    where?: GroupNoteWhereInput
    /**
     * Limit how many GroupNotes to update.
     */
    limit?: number
  }

  /**
   * GroupNote updateManyAndReturn
   */
  export type GroupNoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupNote
     */
    select?: GroupNoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GroupNote
     */
    omit?: GroupNoteOmit<ExtArgs> | null
    /**
     * The data used to update GroupNotes.
     */
    data: XOR<GroupNoteUpdateManyMutationInput, GroupNoteUncheckedUpdateManyInput>
    /**
     * Filter which GroupNotes to update
     */
    where?: GroupNoteWhereInput
    /**
     * Limit how many GroupNotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupNoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupNote upsert
   */
  export type GroupNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupNote
     */
    select?: GroupNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupNote
     */
    omit?: GroupNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the GroupNote to update in case it exists.
     */
    where: GroupNoteWhereUniqueInput
    /**
     * In case the GroupNote found by the `where` argument doesn't exist, create a new GroupNote with this data.
     */
    create: XOR<GroupNoteCreateInput, GroupNoteUncheckedCreateInput>
    /**
     * In case the GroupNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupNoteUpdateInput, GroupNoteUncheckedUpdateInput>
  }

  /**
   * GroupNote delete
   */
  export type GroupNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupNote
     */
    select?: GroupNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupNote
     */
    omit?: GroupNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupNoteInclude<ExtArgs> | null
    /**
     * Filter which GroupNote to delete.
     */
    where: GroupNoteWhereUniqueInput
  }

  /**
   * GroupNote deleteMany
   */
  export type GroupNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupNotes to delete
     */
    where?: GroupNoteWhereInput
    /**
     * Limit how many GroupNotes to delete.
     */
    limit?: number
  }

  /**
   * GroupNote without action
   */
  export type GroupNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupNote
     */
    select?: GroupNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupNote
     */
    omit?: GroupNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupNoteInclude<ExtArgs> | null
  }


  /**
   * Model GroupMember
   */

  export type AggregateGroupMember = {
    _count: GroupMemberCountAggregateOutputType | null
    _min: GroupMemberMinAggregateOutputType | null
    _max: GroupMemberMaxAggregateOutputType | null
  }

  export type GroupMemberMinAggregateOutputType = {
    id: string | null
    groupId: string | null
    userId: string | null
    joinedAt: Date | null
    lastReadAt: Date | null
  }

  export type GroupMemberMaxAggregateOutputType = {
    id: string | null
    groupId: string | null
    userId: string | null
    joinedAt: Date | null
    lastReadAt: Date | null
  }

  export type GroupMemberCountAggregateOutputType = {
    id: number
    groupId: number
    userId: number
    joinedAt: number
    lastReadAt: number
    _all: number
  }


  export type GroupMemberMinAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    joinedAt?: true
    lastReadAt?: true
  }

  export type GroupMemberMaxAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    joinedAt?: true
    lastReadAt?: true
  }

  export type GroupMemberCountAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    joinedAt?: true
    lastReadAt?: true
    _all?: true
  }

  export type GroupMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupMember to aggregate.
     */
    where?: GroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMembers to fetch.
     */
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GroupMembers
    **/
    _count?: true | GroupMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupMemberMaxAggregateInputType
  }

  export type GetGroupMemberAggregateType<T extends GroupMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupMember[P]>
      : GetScalarType<T[P], AggregateGroupMember[P]>
  }




  export type GroupMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupMemberWhereInput
    orderBy?: GroupMemberOrderByWithAggregationInput | GroupMemberOrderByWithAggregationInput[]
    by: GroupMemberScalarFieldEnum[] | GroupMemberScalarFieldEnum
    having?: GroupMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupMemberCountAggregateInputType | true
    _min?: GroupMemberMinAggregateInputType
    _max?: GroupMemberMaxAggregateInputType
  }

  export type GroupMemberGroupByOutputType = {
    id: string
    groupId: string
    userId: string
    joinedAt: Date
    lastReadAt: Date
    _count: GroupMemberCountAggregateOutputType | null
    _min: GroupMemberMinAggregateOutputType | null
    _max: GroupMemberMaxAggregateOutputType | null
  }

  type GetGroupMemberGroupByPayload<T extends GroupMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupMemberGroupByOutputType[P]>
            : GetScalarType<T[P], GroupMemberGroupByOutputType[P]>
        }
      >
    >


  export type GroupMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    userId?: boolean
    joinedAt?: boolean
    lastReadAt?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupMember"]>

  export type GroupMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    userId?: boolean
    joinedAt?: boolean
    lastReadAt?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupMember"]>

  export type GroupMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    userId?: boolean
    joinedAt?: boolean
    lastReadAt?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupMember"]>

  export type GroupMemberSelectScalar = {
    id?: boolean
    groupId?: boolean
    userId?: boolean
    joinedAt?: boolean
    lastReadAt?: boolean
  }

  export type GroupMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "groupId" | "userId" | "joinedAt" | "lastReadAt", ExtArgs["result"]["groupMember"]>
  export type GroupMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GroupMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GroupMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GroupMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GroupMember"
    objects: {
      group: Prisma.$GroupPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      groupId: string
      userId: string
      joinedAt: Date
      lastReadAt: Date
    }, ExtArgs["result"]["groupMember"]>
    composites: {}
  }

  type GroupMemberGetPayload<S extends boolean | null | undefined | GroupMemberDefaultArgs> = $Result.GetResult<Prisma.$GroupMemberPayload, S>

  type GroupMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GroupMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GroupMemberCountAggregateInputType | true
    }

  export interface GroupMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GroupMember'], meta: { name: 'GroupMember' } }
    /**
     * Find zero or one GroupMember that matches the filter.
     * @param {GroupMemberFindUniqueArgs} args - Arguments to find a GroupMember
     * @example
     * // Get one GroupMember
     * const groupMember = await prisma.groupMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupMemberFindUniqueArgs>(args: SelectSubset<T, GroupMemberFindUniqueArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GroupMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GroupMemberFindUniqueOrThrowArgs} args - Arguments to find a GroupMember
     * @example
     * // Get one GroupMember
     * const groupMember = await prisma.groupMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroupMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberFindFirstArgs} args - Arguments to find a GroupMember
     * @example
     * // Get one GroupMember
     * const groupMember = await prisma.groupMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupMemberFindFirstArgs>(args?: SelectSubset<T, GroupMemberFindFirstArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroupMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberFindFirstOrThrowArgs} args - Arguments to find a GroupMember
     * @example
     * // Get one GroupMember
     * const groupMember = await prisma.groupMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GroupMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GroupMembers
     * const groupMembers = await prisma.groupMember.findMany()
     * 
     * // Get first 10 GroupMembers
     * const groupMembers = await prisma.groupMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupMemberWithIdOnly = await prisma.groupMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupMemberFindManyArgs>(args?: SelectSubset<T, GroupMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GroupMember.
     * @param {GroupMemberCreateArgs} args - Arguments to create a GroupMember.
     * @example
     * // Create one GroupMember
     * const GroupMember = await prisma.groupMember.create({
     *   data: {
     *     // ... data to create a GroupMember
     *   }
     * })
     * 
     */
    create<T extends GroupMemberCreateArgs>(args: SelectSubset<T, GroupMemberCreateArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GroupMembers.
     * @param {GroupMemberCreateManyArgs} args - Arguments to create many GroupMembers.
     * @example
     * // Create many GroupMembers
     * const groupMember = await prisma.groupMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupMemberCreateManyArgs>(args?: SelectSubset<T, GroupMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GroupMembers and returns the data saved in the database.
     * @param {GroupMemberCreateManyAndReturnArgs} args - Arguments to create many GroupMembers.
     * @example
     * // Create many GroupMembers
     * const groupMember = await prisma.groupMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GroupMembers and only return the `id`
     * const groupMemberWithIdOnly = await prisma.groupMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GroupMember.
     * @param {GroupMemberDeleteArgs} args - Arguments to delete one GroupMember.
     * @example
     * // Delete one GroupMember
     * const GroupMember = await prisma.groupMember.delete({
     *   where: {
     *     // ... filter to delete one GroupMember
     *   }
     * })
     * 
     */
    delete<T extends GroupMemberDeleteArgs>(args: SelectSubset<T, GroupMemberDeleteArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GroupMember.
     * @param {GroupMemberUpdateArgs} args - Arguments to update one GroupMember.
     * @example
     * // Update one GroupMember
     * const groupMember = await prisma.groupMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupMemberUpdateArgs>(args: SelectSubset<T, GroupMemberUpdateArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GroupMembers.
     * @param {GroupMemberDeleteManyArgs} args - Arguments to filter GroupMembers to delete.
     * @example
     * // Delete a few GroupMembers
     * const { count } = await prisma.groupMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupMemberDeleteManyArgs>(args?: SelectSubset<T, GroupMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GroupMembers
     * const groupMember = await prisma.groupMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupMemberUpdateManyArgs>(args: SelectSubset<T, GroupMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupMembers and returns the data updated in the database.
     * @param {GroupMemberUpdateManyAndReturnArgs} args - Arguments to update many GroupMembers.
     * @example
     * // Update many GroupMembers
     * const groupMember = await prisma.groupMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GroupMembers and only return the `id`
     * const groupMemberWithIdOnly = await prisma.groupMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GroupMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, GroupMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GroupMember.
     * @param {GroupMemberUpsertArgs} args - Arguments to update or create a GroupMember.
     * @example
     * // Update or create a GroupMember
     * const groupMember = await prisma.groupMember.upsert({
     *   create: {
     *     // ... data to create a GroupMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GroupMember we want to update
     *   }
     * })
     */
    upsert<T extends GroupMemberUpsertArgs>(args: SelectSubset<T, GroupMemberUpsertArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GroupMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberCountArgs} args - Arguments to filter GroupMembers to count.
     * @example
     * // Count the number of GroupMembers
     * const count = await prisma.groupMember.count({
     *   where: {
     *     // ... the filter for the GroupMembers we want to count
     *   }
     * })
    **/
    count<T extends GroupMemberCountArgs>(
      args?: Subset<T, GroupMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GroupMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupMemberAggregateArgs>(args: Subset<T, GroupMemberAggregateArgs>): Prisma.PrismaPromise<GetGroupMemberAggregateType<T>>

    /**
     * Group by GroupMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupMemberGroupByArgs['orderBy'] }
        : { orderBy?: GroupMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GroupMember model
   */
  readonly fields: GroupMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GroupMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group<T extends GroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupDefaultArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GroupMember model
   */
  interface GroupMemberFieldRefs {
    readonly id: FieldRef<"GroupMember", 'String'>
    readonly groupId: FieldRef<"GroupMember", 'String'>
    readonly userId: FieldRef<"GroupMember", 'String'>
    readonly joinedAt: FieldRef<"GroupMember", 'DateTime'>
    readonly lastReadAt: FieldRef<"GroupMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GroupMember findUnique
   */
  export type GroupMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which GroupMember to fetch.
     */
    where: GroupMemberWhereUniqueInput
  }

  /**
   * GroupMember findUniqueOrThrow
   */
  export type GroupMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which GroupMember to fetch.
     */
    where: GroupMemberWhereUniqueInput
  }

  /**
   * GroupMember findFirst
   */
  export type GroupMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which GroupMember to fetch.
     */
    where?: GroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMembers to fetch.
     */
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupMembers.
     */
    cursor?: GroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupMembers.
     */
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * GroupMember findFirstOrThrow
   */
  export type GroupMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which GroupMember to fetch.
     */
    where?: GroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMembers to fetch.
     */
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupMembers.
     */
    cursor?: GroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupMembers.
     */
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * GroupMember findMany
   */
  export type GroupMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which GroupMembers to fetch.
     */
    where?: GroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMembers to fetch.
     */
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GroupMembers.
     */
    cursor?: GroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMembers.
     */
    skip?: number
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * GroupMember create
   */
  export type GroupMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a GroupMember.
     */
    data: XOR<GroupMemberCreateInput, GroupMemberUncheckedCreateInput>
  }

  /**
   * GroupMember createMany
   */
  export type GroupMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GroupMembers.
     */
    data: GroupMemberCreateManyInput | GroupMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GroupMember createManyAndReturn
   */
  export type GroupMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * The data used to create many GroupMembers.
     */
    data: GroupMemberCreateManyInput | GroupMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupMember update
   */
  export type GroupMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a GroupMember.
     */
    data: XOR<GroupMemberUpdateInput, GroupMemberUncheckedUpdateInput>
    /**
     * Choose, which GroupMember to update.
     */
    where: GroupMemberWhereUniqueInput
  }

  /**
   * GroupMember updateMany
   */
  export type GroupMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GroupMembers.
     */
    data: XOR<GroupMemberUpdateManyMutationInput, GroupMemberUncheckedUpdateManyInput>
    /**
     * Filter which GroupMembers to update
     */
    where?: GroupMemberWhereInput
    /**
     * Limit how many GroupMembers to update.
     */
    limit?: number
  }

  /**
   * GroupMember updateManyAndReturn
   */
  export type GroupMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * The data used to update GroupMembers.
     */
    data: XOR<GroupMemberUpdateManyMutationInput, GroupMemberUncheckedUpdateManyInput>
    /**
     * Filter which GroupMembers to update
     */
    where?: GroupMemberWhereInput
    /**
     * Limit how many GroupMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupMember upsert
   */
  export type GroupMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the GroupMember to update in case it exists.
     */
    where: GroupMemberWhereUniqueInput
    /**
     * In case the GroupMember found by the `where` argument doesn't exist, create a new GroupMember with this data.
     */
    create: XOR<GroupMemberCreateInput, GroupMemberUncheckedCreateInput>
    /**
     * In case the GroupMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupMemberUpdateInput, GroupMemberUncheckedUpdateInput>
  }

  /**
   * GroupMember delete
   */
  export type GroupMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter which GroupMember to delete.
     */
    where: GroupMemberWhereUniqueInput
  }

  /**
   * GroupMember deleteMany
   */
  export type GroupMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupMembers to delete
     */
    where?: GroupMemberWhereInput
    /**
     * Limit how many GroupMembers to delete.
     */
    limit?: number
  }

  /**
   * GroupMember without action
   */
  export type GroupMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    content: string | null
    senderId: string | null
    groupId: string | null
    isEdited: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    content: string | null
    senderId: string | null
    groupId: string | null
    isEdited: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    content: number
    senderId: number
    groupId: number
    isEdited: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    content?: true
    senderId?: true
    groupId?: true
    isEdited?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    content?: true
    senderId?: true
    groupId?: true
    isEdited?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    content?: true
    senderId?: true
    groupId?: true
    isEdited?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    content: string
    senderId: string
    groupId: string
    isEdited: boolean
    createdAt: Date
    updatedAt: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    senderId?: boolean
    groupId?: boolean
    isEdited?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    attachments?: boolean | Message$attachmentsArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    senderId?: boolean
    groupId?: boolean
    isEdited?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    senderId?: boolean
    groupId?: boolean
    isEdited?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    content?: boolean
    senderId?: boolean
    groupId?: boolean
    isEdited?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "senderId" | "groupId" | "isEdited" | "createdAt" | "updatedAt", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | Message$attachmentsArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      attachments: Prisma.$AttachmentPayload<ExtArgs>[]
      group: Prisma.$GroupPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      senderId: string
      groupId: string
      isEdited: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attachments<T extends Message$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Message$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    group<T extends GroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupDefaultArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly groupId: FieldRef<"Message", 'String'>
    readonly isEdited: FieldRef<"Message", 'Boolean'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly updatedAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message.attachments
   */
  export type Message$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    cursor?: AttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model Attachment
   */

  export type AggregateAttachment = {
    _count: AttachmentCountAggregateOutputType | null
    _min: AttachmentMinAggregateOutputType | null
    _max: AttachmentMaxAggregateOutputType | null
  }

  export type AttachmentMinAggregateOutputType = {
    id: string | null
    messageId: string | null
    type: $Enums.FileType | null
    filename: string | null
    data: string | null
    createdAt: Date | null
  }

  export type AttachmentMaxAggregateOutputType = {
    id: string | null
    messageId: string | null
    type: $Enums.FileType | null
    filename: string | null
    data: string | null
    createdAt: Date | null
  }

  export type AttachmentCountAggregateOutputType = {
    id: number
    messageId: number
    type: number
    filename: number
    data: number
    createdAt: number
    _all: number
  }


  export type AttachmentMinAggregateInputType = {
    id?: true
    messageId?: true
    type?: true
    filename?: true
    data?: true
    createdAt?: true
  }

  export type AttachmentMaxAggregateInputType = {
    id?: true
    messageId?: true
    type?: true
    filename?: true
    data?: true
    createdAt?: true
  }

  export type AttachmentCountAggregateInputType = {
    id?: true
    messageId?: true
    type?: true
    filename?: true
    data?: true
    createdAt?: true
    _all?: true
  }

  export type AttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attachment to aggregate.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attachments
    **/
    _count?: true | AttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttachmentMaxAggregateInputType
  }

  export type GetAttachmentAggregateType<T extends AttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttachment[P]>
      : GetScalarType<T[P], AggregateAttachment[P]>
  }




  export type AttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithAggregationInput | AttachmentOrderByWithAggregationInput[]
    by: AttachmentScalarFieldEnum[] | AttachmentScalarFieldEnum
    having?: AttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttachmentCountAggregateInputType | true
    _min?: AttachmentMinAggregateInputType
    _max?: AttachmentMaxAggregateInputType
  }

  export type AttachmentGroupByOutputType = {
    id: string
    messageId: string
    type: $Enums.FileType
    filename: string
    data: string
    createdAt: Date
    _count: AttachmentCountAggregateOutputType | null
    _min: AttachmentMinAggregateOutputType | null
    _max: AttachmentMaxAggregateOutputType | null
  }

  type GetAttachmentGroupByPayload<T extends AttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], AttachmentGroupByOutputType[P]>
        }
      >
    >


  export type AttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    type?: boolean
    filename?: boolean
    data?: boolean
    createdAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attachment"]>

  export type AttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    type?: boolean
    filename?: boolean
    data?: boolean
    createdAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attachment"]>

  export type AttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    type?: boolean
    filename?: boolean
    data?: boolean
    createdAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attachment"]>

  export type AttachmentSelectScalar = {
    id?: boolean
    messageId?: boolean
    type?: boolean
    filename?: boolean
    data?: boolean
    createdAt?: boolean
  }

  export type AttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "messageId" | "type" | "filename" | "data" | "createdAt", ExtArgs["result"]["attachment"]>
  export type AttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }
  export type AttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }
  export type AttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }

  export type $AttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attachment"
    objects: {
      message: Prisma.$MessagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      messageId: string
      type: $Enums.FileType
      filename: string
      data: string
      createdAt: Date
    }, ExtArgs["result"]["attachment"]>
    composites: {}
  }

  type AttachmentGetPayload<S extends boolean | null | undefined | AttachmentDefaultArgs> = $Result.GetResult<Prisma.$AttachmentPayload, S>

  type AttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttachmentCountAggregateInputType | true
    }

  export interface AttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attachment'], meta: { name: 'Attachment' } }
    /**
     * Find zero or one Attachment that matches the filter.
     * @param {AttachmentFindUniqueArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttachmentFindUniqueArgs>(args: SelectSubset<T, AttachmentFindUniqueArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttachmentFindUniqueOrThrowArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindFirstArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttachmentFindFirstArgs>(args?: SelectSubset<T, AttachmentFindFirstArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindFirstOrThrowArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attachments
     * const attachments = await prisma.attachment.findMany()
     * 
     * // Get first 10 Attachments
     * const attachments = await prisma.attachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attachmentWithIdOnly = await prisma.attachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttachmentFindManyArgs>(args?: SelectSubset<T, AttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attachment.
     * @param {AttachmentCreateArgs} args - Arguments to create a Attachment.
     * @example
     * // Create one Attachment
     * const Attachment = await prisma.attachment.create({
     *   data: {
     *     // ... data to create a Attachment
     *   }
     * })
     * 
     */
    create<T extends AttachmentCreateArgs>(args: SelectSubset<T, AttachmentCreateArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attachments.
     * @param {AttachmentCreateManyArgs} args - Arguments to create many Attachments.
     * @example
     * // Create many Attachments
     * const attachment = await prisma.attachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttachmentCreateManyArgs>(args?: SelectSubset<T, AttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attachments and returns the data saved in the database.
     * @param {AttachmentCreateManyAndReturnArgs} args - Arguments to create many Attachments.
     * @example
     * // Create many Attachments
     * const attachment = await prisma.attachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attachments and only return the `id`
     * const attachmentWithIdOnly = await prisma.attachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Attachment.
     * @param {AttachmentDeleteArgs} args - Arguments to delete one Attachment.
     * @example
     * // Delete one Attachment
     * const Attachment = await prisma.attachment.delete({
     *   where: {
     *     // ... filter to delete one Attachment
     *   }
     * })
     * 
     */
    delete<T extends AttachmentDeleteArgs>(args: SelectSubset<T, AttachmentDeleteArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attachment.
     * @param {AttachmentUpdateArgs} args - Arguments to update one Attachment.
     * @example
     * // Update one Attachment
     * const attachment = await prisma.attachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttachmentUpdateArgs>(args: SelectSubset<T, AttachmentUpdateArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attachments.
     * @param {AttachmentDeleteManyArgs} args - Arguments to filter Attachments to delete.
     * @example
     * // Delete a few Attachments
     * const { count } = await prisma.attachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttachmentDeleteManyArgs>(args?: SelectSubset<T, AttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attachments
     * const attachment = await prisma.attachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttachmentUpdateManyArgs>(args: SelectSubset<T, AttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attachments and returns the data updated in the database.
     * @param {AttachmentUpdateManyAndReturnArgs} args - Arguments to update many Attachments.
     * @example
     * // Update many Attachments
     * const attachment = await prisma.attachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Attachments and only return the `id`
     * const attachmentWithIdOnly = await prisma.attachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Attachment.
     * @param {AttachmentUpsertArgs} args - Arguments to update or create a Attachment.
     * @example
     * // Update or create a Attachment
     * const attachment = await prisma.attachment.upsert({
     *   create: {
     *     // ... data to create a Attachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attachment we want to update
     *   }
     * })
     */
    upsert<T extends AttachmentUpsertArgs>(args: SelectSubset<T, AttachmentUpsertArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentCountArgs} args - Arguments to filter Attachments to count.
     * @example
     * // Count the number of Attachments
     * const count = await prisma.attachment.count({
     *   where: {
     *     // ... the filter for the Attachments we want to count
     *   }
     * })
    **/
    count<T extends AttachmentCountArgs>(
      args?: Subset<T, AttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttachmentAggregateArgs>(args: Subset<T, AttachmentAggregateArgs>): Prisma.PrismaPromise<GetAttachmentAggregateType<T>>

    /**
     * Group by Attachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttachmentGroupByArgs['orderBy'] }
        : { orderBy?: AttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attachment model
   */
  readonly fields: AttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends MessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageDefaultArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attachment model
   */
  interface AttachmentFieldRefs {
    readonly id: FieldRef<"Attachment", 'String'>
    readonly messageId: FieldRef<"Attachment", 'String'>
    readonly type: FieldRef<"Attachment", 'FileType'>
    readonly filename: FieldRef<"Attachment", 'String'>
    readonly data: FieldRef<"Attachment", 'String'>
    readonly createdAt: FieldRef<"Attachment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Attachment findUnique
   */
  export type AttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment findUniqueOrThrow
   */
  export type AttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment findFirst
   */
  export type AttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attachments.
     */
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment findFirstOrThrow
   */
  export type AttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attachments.
     */
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment findMany
   */
  export type AttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachments to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment create
   */
  export type AttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Attachment.
     */
    data: XOR<AttachmentCreateInput, AttachmentUncheckedCreateInput>
  }

  /**
   * Attachment createMany
   */
  export type AttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attachments.
     */
    data: AttachmentCreateManyInput | AttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Attachment createManyAndReturn
   */
  export type AttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many Attachments.
     */
    data: AttachmentCreateManyInput | AttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attachment update
   */
  export type AttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Attachment.
     */
    data: XOR<AttachmentUpdateInput, AttachmentUncheckedUpdateInput>
    /**
     * Choose, which Attachment to update.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment updateMany
   */
  export type AttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attachments.
     */
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyInput>
    /**
     * Filter which Attachments to update
     */
    where?: AttachmentWhereInput
    /**
     * Limit how many Attachments to update.
     */
    limit?: number
  }

  /**
   * Attachment updateManyAndReturn
   */
  export type AttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * The data used to update Attachments.
     */
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyInput>
    /**
     * Filter which Attachments to update
     */
    where?: AttachmentWhereInput
    /**
     * Limit how many Attachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attachment upsert
   */
  export type AttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Attachment to update in case it exists.
     */
    where: AttachmentWhereUniqueInput
    /**
     * In case the Attachment found by the `where` argument doesn't exist, create a new Attachment with this data.
     */
    create: XOR<AttachmentCreateInput, AttachmentUncheckedCreateInput>
    /**
     * In case the Attachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttachmentUpdateInput, AttachmentUncheckedUpdateInput>
  }

  /**
   * Attachment delete
   */
  export type AttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter which Attachment to delete.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment deleteMany
   */
  export type AttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attachments to delete
     */
    where?: AttachmentWhereInput
    /**
     * Limit how many Attachments to delete.
     */
    limit?: number
  }

  /**
   * Attachment without action
   */
  export type AttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    content: string | null
    userId: string | null
    expiresAt: Date | null
    createdAt: Date | null
    isRead: boolean | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    content: string | null
    userId: string | null
    expiresAt: Date | null
    createdAt: Date | null
    isRead: boolean | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    content: number
    userId: number
    expiresAt: number
    createdAt: number
    isRead: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    content?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    isRead?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    content?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    isRead?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    content?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    isRead?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    content: string
    userId: string | null
    expiresAt: Date | null
    createdAt: Date
    isRead: boolean
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    isRead?: boolean
    user?: boolean | Notification$userArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    isRead?: boolean
    user?: boolean | Notification$userArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    isRead?: boolean
    user?: boolean | Notification$userArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    content?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    isRead?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "userId" | "expiresAt" | "createdAt" | "isRead", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Notification$userArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Notification$userArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Notification$userArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      userId: string | null
      expiresAt: Date | null
      createdAt: Date
      isRead: boolean
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Notification$userArgs<ExtArgs> = {}>(args?: Subset<T, Notification$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly content: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly expiresAt: FieldRef<"Notification", 'DateTime'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification.user
   */
  export type Notification$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Announcement
   */

  export type AggregateAnnouncement = {
    _count: AnnouncementCountAggregateOutputType | null
    _min: AnnouncementMinAggregateOutputType | null
    _max: AnnouncementMaxAggregateOutputType | null
  }

  export type AnnouncementMinAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    publisherId: string | null
    expiresAt: Date | null
    createdAt: Date | null
    isActive: boolean | null
  }

  export type AnnouncementMaxAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    publisherId: string | null
    expiresAt: Date | null
    createdAt: Date | null
    isActive: boolean | null
  }

  export type AnnouncementCountAggregateOutputType = {
    id: number
    title: number
    content: number
    publisherId: number
    expiresAt: number
    createdAt: number
    isActive: number
    _all: number
  }


  export type AnnouncementMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    publisherId?: true
    expiresAt?: true
    createdAt?: true
    isActive?: true
  }

  export type AnnouncementMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    publisherId?: true
    expiresAt?: true
    createdAt?: true
    isActive?: true
  }

  export type AnnouncementCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    publisherId?: true
    expiresAt?: true
    createdAt?: true
    isActive?: true
    _all?: true
  }

  export type AnnouncementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Announcement to aggregate.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Announcements
    **/
    _count?: true | AnnouncementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnnouncementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnnouncementMaxAggregateInputType
  }

  export type GetAnnouncementAggregateType<T extends AnnouncementAggregateArgs> = {
        [P in keyof T & keyof AggregateAnnouncement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnnouncement[P]>
      : GetScalarType<T[P], AggregateAnnouncement[P]>
  }




  export type AnnouncementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnouncementWhereInput
    orderBy?: AnnouncementOrderByWithAggregationInput | AnnouncementOrderByWithAggregationInput[]
    by: AnnouncementScalarFieldEnum[] | AnnouncementScalarFieldEnum
    having?: AnnouncementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnnouncementCountAggregateInputType | true
    _min?: AnnouncementMinAggregateInputType
    _max?: AnnouncementMaxAggregateInputType
  }

  export type AnnouncementGroupByOutputType = {
    id: string
    title: string
    content: string
    publisherId: string
    expiresAt: Date
    createdAt: Date
    isActive: boolean
    _count: AnnouncementCountAggregateOutputType | null
    _min: AnnouncementMinAggregateOutputType | null
    _max: AnnouncementMaxAggregateOutputType | null
  }

  type GetAnnouncementGroupByPayload<T extends AnnouncementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnnouncementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnnouncementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnnouncementGroupByOutputType[P]>
            : GetScalarType<T[P], AnnouncementGroupByOutputType[P]>
        }
      >
    >


  export type AnnouncementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    publisherId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    isActive?: boolean
    publisher?: boolean | UserDefaultArgs<ExtArgs>
    reads?: boolean | Announcement$readsArgs<ExtArgs>
    _count?: boolean | AnnouncementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["announcement"]>

  export type AnnouncementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    publisherId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    isActive?: boolean
    publisher?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["announcement"]>

  export type AnnouncementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    publisherId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    isActive?: boolean
    publisher?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["announcement"]>

  export type AnnouncementSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    publisherId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    isActive?: boolean
  }

  export type AnnouncementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "content" | "publisherId" | "expiresAt" | "createdAt" | "isActive", ExtArgs["result"]["announcement"]>
  export type AnnouncementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    publisher?: boolean | UserDefaultArgs<ExtArgs>
    reads?: boolean | Announcement$readsArgs<ExtArgs>
    _count?: boolean | AnnouncementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AnnouncementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    publisher?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AnnouncementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    publisher?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AnnouncementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Announcement"
    objects: {
      publisher: Prisma.$UserPayload<ExtArgs>
      reads: Prisma.$AnnouncementReadPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      content: string
      publisherId: string
      expiresAt: Date
      createdAt: Date
      isActive: boolean
    }, ExtArgs["result"]["announcement"]>
    composites: {}
  }

  type AnnouncementGetPayload<S extends boolean | null | undefined | AnnouncementDefaultArgs> = $Result.GetResult<Prisma.$AnnouncementPayload, S>

  type AnnouncementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnnouncementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnnouncementCountAggregateInputType | true
    }

  export interface AnnouncementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Announcement'], meta: { name: 'Announcement' } }
    /**
     * Find zero or one Announcement that matches the filter.
     * @param {AnnouncementFindUniqueArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnnouncementFindUniqueArgs>(args: SelectSubset<T, AnnouncementFindUniqueArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Announcement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnnouncementFindUniqueOrThrowArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnnouncementFindUniqueOrThrowArgs>(args: SelectSubset<T, AnnouncementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Announcement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindFirstArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnnouncementFindFirstArgs>(args?: SelectSubset<T, AnnouncementFindFirstArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Announcement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindFirstOrThrowArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnnouncementFindFirstOrThrowArgs>(args?: SelectSubset<T, AnnouncementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Announcements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Announcements
     * const announcements = await prisma.announcement.findMany()
     * 
     * // Get first 10 Announcements
     * const announcements = await prisma.announcement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const announcementWithIdOnly = await prisma.announcement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnnouncementFindManyArgs>(args?: SelectSubset<T, AnnouncementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Announcement.
     * @param {AnnouncementCreateArgs} args - Arguments to create a Announcement.
     * @example
     * // Create one Announcement
     * const Announcement = await prisma.announcement.create({
     *   data: {
     *     // ... data to create a Announcement
     *   }
     * })
     * 
     */
    create<T extends AnnouncementCreateArgs>(args: SelectSubset<T, AnnouncementCreateArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Announcements.
     * @param {AnnouncementCreateManyArgs} args - Arguments to create many Announcements.
     * @example
     * // Create many Announcements
     * const announcement = await prisma.announcement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnnouncementCreateManyArgs>(args?: SelectSubset<T, AnnouncementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Announcements and returns the data saved in the database.
     * @param {AnnouncementCreateManyAndReturnArgs} args - Arguments to create many Announcements.
     * @example
     * // Create many Announcements
     * const announcement = await prisma.announcement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Announcements and only return the `id`
     * const announcementWithIdOnly = await prisma.announcement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnnouncementCreateManyAndReturnArgs>(args?: SelectSubset<T, AnnouncementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Announcement.
     * @param {AnnouncementDeleteArgs} args - Arguments to delete one Announcement.
     * @example
     * // Delete one Announcement
     * const Announcement = await prisma.announcement.delete({
     *   where: {
     *     // ... filter to delete one Announcement
     *   }
     * })
     * 
     */
    delete<T extends AnnouncementDeleteArgs>(args: SelectSubset<T, AnnouncementDeleteArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Announcement.
     * @param {AnnouncementUpdateArgs} args - Arguments to update one Announcement.
     * @example
     * // Update one Announcement
     * const announcement = await prisma.announcement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnnouncementUpdateArgs>(args: SelectSubset<T, AnnouncementUpdateArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Announcements.
     * @param {AnnouncementDeleteManyArgs} args - Arguments to filter Announcements to delete.
     * @example
     * // Delete a few Announcements
     * const { count } = await prisma.announcement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnnouncementDeleteManyArgs>(args?: SelectSubset<T, AnnouncementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Announcements
     * const announcement = await prisma.announcement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnnouncementUpdateManyArgs>(args: SelectSubset<T, AnnouncementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Announcements and returns the data updated in the database.
     * @param {AnnouncementUpdateManyAndReturnArgs} args - Arguments to update many Announcements.
     * @example
     * // Update many Announcements
     * const announcement = await prisma.announcement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Announcements and only return the `id`
     * const announcementWithIdOnly = await prisma.announcement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnnouncementUpdateManyAndReturnArgs>(args: SelectSubset<T, AnnouncementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Announcement.
     * @param {AnnouncementUpsertArgs} args - Arguments to update or create a Announcement.
     * @example
     * // Update or create a Announcement
     * const announcement = await prisma.announcement.upsert({
     *   create: {
     *     // ... data to create a Announcement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Announcement we want to update
     *   }
     * })
     */
    upsert<T extends AnnouncementUpsertArgs>(args: SelectSubset<T, AnnouncementUpsertArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementCountArgs} args - Arguments to filter Announcements to count.
     * @example
     * // Count the number of Announcements
     * const count = await prisma.announcement.count({
     *   where: {
     *     // ... the filter for the Announcements we want to count
     *   }
     * })
    **/
    count<T extends AnnouncementCountArgs>(
      args?: Subset<T, AnnouncementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnnouncementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Announcement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnnouncementAggregateArgs>(args: Subset<T, AnnouncementAggregateArgs>): Prisma.PrismaPromise<GetAnnouncementAggregateType<T>>

    /**
     * Group by Announcement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnnouncementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnnouncementGroupByArgs['orderBy'] }
        : { orderBy?: AnnouncementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnnouncementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnnouncementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Announcement model
   */
  readonly fields: AnnouncementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Announcement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnnouncementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    publisher<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reads<T extends Announcement$readsArgs<ExtArgs> = {}>(args?: Subset<T, Announcement$readsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementReadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Announcement model
   */
  interface AnnouncementFieldRefs {
    readonly id: FieldRef<"Announcement", 'String'>
    readonly title: FieldRef<"Announcement", 'String'>
    readonly content: FieldRef<"Announcement", 'String'>
    readonly publisherId: FieldRef<"Announcement", 'String'>
    readonly expiresAt: FieldRef<"Announcement", 'DateTime'>
    readonly createdAt: FieldRef<"Announcement", 'DateTime'>
    readonly isActive: FieldRef<"Announcement", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Announcement findUnique
   */
  export type AnnouncementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement findUniqueOrThrow
   */
  export type AnnouncementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement findFirst
   */
  export type AnnouncementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Announcements.
     */
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Announcement findFirstOrThrow
   */
  export type AnnouncementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Announcements.
     */
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Announcement findMany
   */
  export type AnnouncementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcements to fetch.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Announcement create
   */
  export type AnnouncementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * The data needed to create a Announcement.
     */
    data: XOR<AnnouncementCreateInput, AnnouncementUncheckedCreateInput>
  }

  /**
   * Announcement createMany
   */
  export type AnnouncementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Announcements.
     */
    data: AnnouncementCreateManyInput | AnnouncementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Announcement createManyAndReturn
   */
  export type AnnouncementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * The data used to create many Announcements.
     */
    data: AnnouncementCreateManyInput | AnnouncementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Announcement update
   */
  export type AnnouncementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * The data needed to update a Announcement.
     */
    data: XOR<AnnouncementUpdateInput, AnnouncementUncheckedUpdateInput>
    /**
     * Choose, which Announcement to update.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement updateMany
   */
  export type AnnouncementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Announcements.
     */
    data: XOR<AnnouncementUpdateManyMutationInput, AnnouncementUncheckedUpdateManyInput>
    /**
     * Filter which Announcements to update
     */
    where?: AnnouncementWhereInput
    /**
     * Limit how many Announcements to update.
     */
    limit?: number
  }

  /**
   * Announcement updateManyAndReturn
   */
  export type AnnouncementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * The data used to update Announcements.
     */
    data: XOR<AnnouncementUpdateManyMutationInput, AnnouncementUncheckedUpdateManyInput>
    /**
     * Filter which Announcements to update
     */
    where?: AnnouncementWhereInput
    /**
     * Limit how many Announcements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Announcement upsert
   */
  export type AnnouncementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * The filter to search for the Announcement to update in case it exists.
     */
    where: AnnouncementWhereUniqueInput
    /**
     * In case the Announcement found by the `where` argument doesn't exist, create a new Announcement with this data.
     */
    create: XOR<AnnouncementCreateInput, AnnouncementUncheckedCreateInput>
    /**
     * In case the Announcement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnnouncementUpdateInput, AnnouncementUncheckedUpdateInput>
  }

  /**
   * Announcement delete
   */
  export type AnnouncementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter which Announcement to delete.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement deleteMany
   */
  export type AnnouncementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Announcements to delete
     */
    where?: AnnouncementWhereInput
    /**
     * Limit how many Announcements to delete.
     */
    limit?: number
  }

  /**
   * Announcement.reads
   */
  export type Announcement$readsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnouncementRead
     */
    select?: AnnouncementReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnnouncementRead
     */
    omit?: AnnouncementReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementReadInclude<ExtArgs> | null
    where?: AnnouncementReadWhereInput
    orderBy?: AnnouncementReadOrderByWithRelationInput | AnnouncementReadOrderByWithRelationInput[]
    cursor?: AnnouncementReadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnnouncementReadScalarFieldEnum | AnnouncementReadScalarFieldEnum[]
  }

  /**
   * Announcement without action
   */
  export type AnnouncementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
  }


  /**
   * Model AnnouncementRead
   */

  export type AggregateAnnouncementRead = {
    _count: AnnouncementReadCountAggregateOutputType | null
    _min: AnnouncementReadMinAggregateOutputType | null
    _max: AnnouncementReadMaxAggregateOutputType | null
  }

  export type AnnouncementReadMinAggregateOutputType = {
    id: string | null
    announcementId: string | null
    userId: string | null
    readAt: Date | null
  }

  export type AnnouncementReadMaxAggregateOutputType = {
    id: string | null
    announcementId: string | null
    userId: string | null
    readAt: Date | null
  }

  export type AnnouncementReadCountAggregateOutputType = {
    id: number
    announcementId: number
    userId: number
    readAt: number
    _all: number
  }


  export type AnnouncementReadMinAggregateInputType = {
    id?: true
    announcementId?: true
    userId?: true
    readAt?: true
  }

  export type AnnouncementReadMaxAggregateInputType = {
    id?: true
    announcementId?: true
    userId?: true
    readAt?: true
  }

  export type AnnouncementReadCountAggregateInputType = {
    id?: true
    announcementId?: true
    userId?: true
    readAt?: true
    _all?: true
  }

  export type AnnouncementReadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnnouncementRead to aggregate.
     */
    where?: AnnouncementReadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnnouncementReads to fetch.
     */
    orderBy?: AnnouncementReadOrderByWithRelationInput | AnnouncementReadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnnouncementReadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnnouncementReads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnnouncementReads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnnouncementReads
    **/
    _count?: true | AnnouncementReadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnnouncementReadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnnouncementReadMaxAggregateInputType
  }

  export type GetAnnouncementReadAggregateType<T extends AnnouncementReadAggregateArgs> = {
        [P in keyof T & keyof AggregateAnnouncementRead]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnnouncementRead[P]>
      : GetScalarType<T[P], AggregateAnnouncementRead[P]>
  }




  export type AnnouncementReadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnouncementReadWhereInput
    orderBy?: AnnouncementReadOrderByWithAggregationInput | AnnouncementReadOrderByWithAggregationInput[]
    by: AnnouncementReadScalarFieldEnum[] | AnnouncementReadScalarFieldEnum
    having?: AnnouncementReadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnnouncementReadCountAggregateInputType | true
    _min?: AnnouncementReadMinAggregateInputType
    _max?: AnnouncementReadMaxAggregateInputType
  }

  export type AnnouncementReadGroupByOutputType = {
    id: string
    announcementId: string
    userId: string
    readAt: Date
    _count: AnnouncementReadCountAggregateOutputType | null
    _min: AnnouncementReadMinAggregateOutputType | null
    _max: AnnouncementReadMaxAggregateOutputType | null
  }

  type GetAnnouncementReadGroupByPayload<T extends AnnouncementReadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnnouncementReadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnnouncementReadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnnouncementReadGroupByOutputType[P]>
            : GetScalarType<T[P], AnnouncementReadGroupByOutputType[P]>
        }
      >
    >


  export type AnnouncementReadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    announcementId?: boolean
    userId?: boolean
    readAt?: boolean
    announcement?: boolean | AnnouncementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["announcementRead"]>

  export type AnnouncementReadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    announcementId?: boolean
    userId?: boolean
    readAt?: boolean
    announcement?: boolean | AnnouncementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["announcementRead"]>

  export type AnnouncementReadSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    announcementId?: boolean
    userId?: boolean
    readAt?: boolean
    announcement?: boolean | AnnouncementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["announcementRead"]>

  export type AnnouncementReadSelectScalar = {
    id?: boolean
    announcementId?: boolean
    userId?: boolean
    readAt?: boolean
  }

  export type AnnouncementReadOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "announcementId" | "userId" | "readAt", ExtArgs["result"]["announcementRead"]>
  export type AnnouncementReadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    announcement?: boolean | AnnouncementDefaultArgs<ExtArgs>
  }
  export type AnnouncementReadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    announcement?: boolean | AnnouncementDefaultArgs<ExtArgs>
  }
  export type AnnouncementReadIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    announcement?: boolean | AnnouncementDefaultArgs<ExtArgs>
  }

  export type $AnnouncementReadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnnouncementRead"
    objects: {
      announcement: Prisma.$AnnouncementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      announcementId: string
      userId: string
      readAt: Date
    }, ExtArgs["result"]["announcementRead"]>
    composites: {}
  }

  type AnnouncementReadGetPayload<S extends boolean | null | undefined | AnnouncementReadDefaultArgs> = $Result.GetResult<Prisma.$AnnouncementReadPayload, S>

  type AnnouncementReadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnnouncementReadFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnnouncementReadCountAggregateInputType | true
    }

  export interface AnnouncementReadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnnouncementRead'], meta: { name: 'AnnouncementRead' } }
    /**
     * Find zero or one AnnouncementRead that matches the filter.
     * @param {AnnouncementReadFindUniqueArgs} args - Arguments to find a AnnouncementRead
     * @example
     * // Get one AnnouncementRead
     * const announcementRead = await prisma.announcementRead.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnnouncementReadFindUniqueArgs>(args: SelectSubset<T, AnnouncementReadFindUniqueArgs<ExtArgs>>): Prisma__AnnouncementReadClient<$Result.GetResult<Prisma.$AnnouncementReadPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AnnouncementRead that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnnouncementReadFindUniqueOrThrowArgs} args - Arguments to find a AnnouncementRead
     * @example
     * // Get one AnnouncementRead
     * const announcementRead = await prisma.announcementRead.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnnouncementReadFindUniqueOrThrowArgs>(args: SelectSubset<T, AnnouncementReadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnnouncementReadClient<$Result.GetResult<Prisma.$AnnouncementReadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnnouncementRead that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementReadFindFirstArgs} args - Arguments to find a AnnouncementRead
     * @example
     * // Get one AnnouncementRead
     * const announcementRead = await prisma.announcementRead.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnnouncementReadFindFirstArgs>(args?: SelectSubset<T, AnnouncementReadFindFirstArgs<ExtArgs>>): Prisma__AnnouncementReadClient<$Result.GetResult<Prisma.$AnnouncementReadPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnnouncementRead that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementReadFindFirstOrThrowArgs} args - Arguments to find a AnnouncementRead
     * @example
     * // Get one AnnouncementRead
     * const announcementRead = await prisma.announcementRead.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnnouncementReadFindFirstOrThrowArgs>(args?: SelectSubset<T, AnnouncementReadFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnnouncementReadClient<$Result.GetResult<Prisma.$AnnouncementReadPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AnnouncementReads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementReadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnnouncementReads
     * const announcementReads = await prisma.announcementRead.findMany()
     * 
     * // Get first 10 AnnouncementReads
     * const announcementReads = await prisma.announcementRead.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const announcementReadWithIdOnly = await prisma.announcementRead.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnnouncementReadFindManyArgs>(args?: SelectSubset<T, AnnouncementReadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementReadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AnnouncementRead.
     * @param {AnnouncementReadCreateArgs} args - Arguments to create a AnnouncementRead.
     * @example
     * // Create one AnnouncementRead
     * const AnnouncementRead = await prisma.announcementRead.create({
     *   data: {
     *     // ... data to create a AnnouncementRead
     *   }
     * })
     * 
     */
    create<T extends AnnouncementReadCreateArgs>(args: SelectSubset<T, AnnouncementReadCreateArgs<ExtArgs>>): Prisma__AnnouncementReadClient<$Result.GetResult<Prisma.$AnnouncementReadPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AnnouncementReads.
     * @param {AnnouncementReadCreateManyArgs} args - Arguments to create many AnnouncementReads.
     * @example
     * // Create many AnnouncementReads
     * const announcementRead = await prisma.announcementRead.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnnouncementReadCreateManyArgs>(args?: SelectSubset<T, AnnouncementReadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnnouncementReads and returns the data saved in the database.
     * @param {AnnouncementReadCreateManyAndReturnArgs} args - Arguments to create many AnnouncementReads.
     * @example
     * // Create many AnnouncementReads
     * const announcementRead = await prisma.announcementRead.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnnouncementReads and only return the `id`
     * const announcementReadWithIdOnly = await prisma.announcementRead.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnnouncementReadCreateManyAndReturnArgs>(args?: SelectSubset<T, AnnouncementReadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementReadPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AnnouncementRead.
     * @param {AnnouncementReadDeleteArgs} args - Arguments to delete one AnnouncementRead.
     * @example
     * // Delete one AnnouncementRead
     * const AnnouncementRead = await prisma.announcementRead.delete({
     *   where: {
     *     // ... filter to delete one AnnouncementRead
     *   }
     * })
     * 
     */
    delete<T extends AnnouncementReadDeleteArgs>(args: SelectSubset<T, AnnouncementReadDeleteArgs<ExtArgs>>): Prisma__AnnouncementReadClient<$Result.GetResult<Prisma.$AnnouncementReadPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AnnouncementRead.
     * @param {AnnouncementReadUpdateArgs} args - Arguments to update one AnnouncementRead.
     * @example
     * // Update one AnnouncementRead
     * const announcementRead = await prisma.announcementRead.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnnouncementReadUpdateArgs>(args: SelectSubset<T, AnnouncementReadUpdateArgs<ExtArgs>>): Prisma__AnnouncementReadClient<$Result.GetResult<Prisma.$AnnouncementReadPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AnnouncementReads.
     * @param {AnnouncementReadDeleteManyArgs} args - Arguments to filter AnnouncementReads to delete.
     * @example
     * // Delete a few AnnouncementReads
     * const { count } = await prisma.announcementRead.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnnouncementReadDeleteManyArgs>(args?: SelectSubset<T, AnnouncementReadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnnouncementReads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementReadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnnouncementReads
     * const announcementRead = await prisma.announcementRead.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnnouncementReadUpdateManyArgs>(args: SelectSubset<T, AnnouncementReadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnnouncementReads and returns the data updated in the database.
     * @param {AnnouncementReadUpdateManyAndReturnArgs} args - Arguments to update many AnnouncementReads.
     * @example
     * // Update many AnnouncementReads
     * const announcementRead = await prisma.announcementRead.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AnnouncementReads and only return the `id`
     * const announcementReadWithIdOnly = await prisma.announcementRead.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnnouncementReadUpdateManyAndReturnArgs>(args: SelectSubset<T, AnnouncementReadUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementReadPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AnnouncementRead.
     * @param {AnnouncementReadUpsertArgs} args - Arguments to update or create a AnnouncementRead.
     * @example
     * // Update or create a AnnouncementRead
     * const announcementRead = await prisma.announcementRead.upsert({
     *   create: {
     *     // ... data to create a AnnouncementRead
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnnouncementRead we want to update
     *   }
     * })
     */
    upsert<T extends AnnouncementReadUpsertArgs>(args: SelectSubset<T, AnnouncementReadUpsertArgs<ExtArgs>>): Prisma__AnnouncementReadClient<$Result.GetResult<Prisma.$AnnouncementReadPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AnnouncementReads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementReadCountArgs} args - Arguments to filter AnnouncementReads to count.
     * @example
     * // Count the number of AnnouncementReads
     * const count = await prisma.announcementRead.count({
     *   where: {
     *     // ... the filter for the AnnouncementReads we want to count
     *   }
     * })
    **/
    count<T extends AnnouncementReadCountArgs>(
      args?: Subset<T, AnnouncementReadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnnouncementReadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnnouncementRead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementReadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnnouncementReadAggregateArgs>(args: Subset<T, AnnouncementReadAggregateArgs>): Prisma.PrismaPromise<GetAnnouncementReadAggregateType<T>>

    /**
     * Group by AnnouncementRead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementReadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnnouncementReadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnnouncementReadGroupByArgs['orderBy'] }
        : { orderBy?: AnnouncementReadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnnouncementReadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnnouncementReadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnnouncementRead model
   */
  readonly fields: AnnouncementReadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnnouncementRead.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnnouncementReadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    announcement<T extends AnnouncementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AnnouncementDefaultArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnnouncementRead model
   */
  interface AnnouncementReadFieldRefs {
    readonly id: FieldRef<"AnnouncementRead", 'String'>
    readonly announcementId: FieldRef<"AnnouncementRead", 'String'>
    readonly userId: FieldRef<"AnnouncementRead", 'String'>
    readonly readAt: FieldRef<"AnnouncementRead", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AnnouncementRead findUnique
   */
  export type AnnouncementReadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnouncementRead
     */
    select?: AnnouncementReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnnouncementRead
     */
    omit?: AnnouncementReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementReadInclude<ExtArgs> | null
    /**
     * Filter, which AnnouncementRead to fetch.
     */
    where: AnnouncementReadWhereUniqueInput
  }

  /**
   * AnnouncementRead findUniqueOrThrow
   */
  export type AnnouncementReadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnouncementRead
     */
    select?: AnnouncementReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnnouncementRead
     */
    omit?: AnnouncementReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementReadInclude<ExtArgs> | null
    /**
     * Filter, which AnnouncementRead to fetch.
     */
    where: AnnouncementReadWhereUniqueInput
  }

  /**
   * AnnouncementRead findFirst
   */
  export type AnnouncementReadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnouncementRead
     */
    select?: AnnouncementReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnnouncementRead
     */
    omit?: AnnouncementReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementReadInclude<ExtArgs> | null
    /**
     * Filter, which AnnouncementRead to fetch.
     */
    where?: AnnouncementReadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnnouncementReads to fetch.
     */
    orderBy?: AnnouncementReadOrderByWithRelationInput | AnnouncementReadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnnouncementReads.
     */
    cursor?: AnnouncementReadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnnouncementReads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnnouncementReads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnnouncementReads.
     */
    distinct?: AnnouncementReadScalarFieldEnum | AnnouncementReadScalarFieldEnum[]
  }

  /**
   * AnnouncementRead findFirstOrThrow
   */
  export type AnnouncementReadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnouncementRead
     */
    select?: AnnouncementReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnnouncementRead
     */
    omit?: AnnouncementReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementReadInclude<ExtArgs> | null
    /**
     * Filter, which AnnouncementRead to fetch.
     */
    where?: AnnouncementReadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnnouncementReads to fetch.
     */
    orderBy?: AnnouncementReadOrderByWithRelationInput | AnnouncementReadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnnouncementReads.
     */
    cursor?: AnnouncementReadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnnouncementReads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnnouncementReads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnnouncementReads.
     */
    distinct?: AnnouncementReadScalarFieldEnum | AnnouncementReadScalarFieldEnum[]
  }

  /**
   * AnnouncementRead findMany
   */
  export type AnnouncementReadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnouncementRead
     */
    select?: AnnouncementReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnnouncementRead
     */
    omit?: AnnouncementReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementReadInclude<ExtArgs> | null
    /**
     * Filter, which AnnouncementReads to fetch.
     */
    where?: AnnouncementReadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnnouncementReads to fetch.
     */
    orderBy?: AnnouncementReadOrderByWithRelationInput | AnnouncementReadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnnouncementReads.
     */
    cursor?: AnnouncementReadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnnouncementReads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnnouncementReads.
     */
    skip?: number
    distinct?: AnnouncementReadScalarFieldEnum | AnnouncementReadScalarFieldEnum[]
  }

  /**
   * AnnouncementRead create
   */
  export type AnnouncementReadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnouncementRead
     */
    select?: AnnouncementReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnnouncementRead
     */
    omit?: AnnouncementReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementReadInclude<ExtArgs> | null
    /**
     * The data needed to create a AnnouncementRead.
     */
    data: XOR<AnnouncementReadCreateInput, AnnouncementReadUncheckedCreateInput>
  }

  /**
   * AnnouncementRead createMany
   */
  export type AnnouncementReadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnnouncementReads.
     */
    data: AnnouncementReadCreateManyInput | AnnouncementReadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnnouncementRead createManyAndReturn
   */
  export type AnnouncementReadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnouncementRead
     */
    select?: AnnouncementReadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnnouncementRead
     */
    omit?: AnnouncementReadOmit<ExtArgs> | null
    /**
     * The data used to create many AnnouncementReads.
     */
    data: AnnouncementReadCreateManyInput | AnnouncementReadCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementReadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AnnouncementRead update
   */
  export type AnnouncementReadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnouncementRead
     */
    select?: AnnouncementReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnnouncementRead
     */
    omit?: AnnouncementReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementReadInclude<ExtArgs> | null
    /**
     * The data needed to update a AnnouncementRead.
     */
    data: XOR<AnnouncementReadUpdateInput, AnnouncementReadUncheckedUpdateInput>
    /**
     * Choose, which AnnouncementRead to update.
     */
    where: AnnouncementReadWhereUniqueInput
  }

  /**
   * AnnouncementRead updateMany
   */
  export type AnnouncementReadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnnouncementReads.
     */
    data: XOR<AnnouncementReadUpdateManyMutationInput, AnnouncementReadUncheckedUpdateManyInput>
    /**
     * Filter which AnnouncementReads to update
     */
    where?: AnnouncementReadWhereInput
    /**
     * Limit how many AnnouncementReads to update.
     */
    limit?: number
  }

  /**
   * AnnouncementRead updateManyAndReturn
   */
  export type AnnouncementReadUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnouncementRead
     */
    select?: AnnouncementReadSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnnouncementRead
     */
    omit?: AnnouncementReadOmit<ExtArgs> | null
    /**
     * The data used to update AnnouncementReads.
     */
    data: XOR<AnnouncementReadUpdateManyMutationInput, AnnouncementReadUncheckedUpdateManyInput>
    /**
     * Filter which AnnouncementReads to update
     */
    where?: AnnouncementReadWhereInput
    /**
     * Limit how many AnnouncementReads to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementReadIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AnnouncementRead upsert
   */
  export type AnnouncementReadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnouncementRead
     */
    select?: AnnouncementReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnnouncementRead
     */
    omit?: AnnouncementReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementReadInclude<ExtArgs> | null
    /**
     * The filter to search for the AnnouncementRead to update in case it exists.
     */
    where: AnnouncementReadWhereUniqueInput
    /**
     * In case the AnnouncementRead found by the `where` argument doesn't exist, create a new AnnouncementRead with this data.
     */
    create: XOR<AnnouncementReadCreateInput, AnnouncementReadUncheckedCreateInput>
    /**
     * In case the AnnouncementRead was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnnouncementReadUpdateInput, AnnouncementReadUncheckedUpdateInput>
  }

  /**
   * AnnouncementRead delete
   */
  export type AnnouncementReadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnouncementRead
     */
    select?: AnnouncementReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnnouncementRead
     */
    omit?: AnnouncementReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementReadInclude<ExtArgs> | null
    /**
     * Filter which AnnouncementRead to delete.
     */
    where: AnnouncementReadWhereUniqueInput
  }

  /**
   * AnnouncementRead deleteMany
   */
  export type AnnouncementReadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnnouncementReads to delete
     */
    where?: AnnouncementReadWhereInput
    /**
     * Limit how many AnnouncementReads to delete.
     */
    limit?: number
  }

  /**
   * AnnouncementRead without action
   */
  export type AnnouncementReadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnouncementRead
     */
    select?: AnnouncementReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnnouncementRead
     */
    omit?: AnnouncementReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementReadInclude<ExtArgs> | null
  }


  /**
   * Model OrganizationRequest
   */

  export type AggregateOrganizationRequest = {
    _count: OrganizationRequestCountAggregateOutputType | null
    _min: OrganizationRequestMinAggregateOutputType | null
    _max: OrganizationRequestMaxAggregateOutputType | null
  }

  export type OrganizationRequestMinAggregateOutputType = {
    id: string | null
    userId: string | null
    cardCode: string | null
    status: $Enums.RequestStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    reviewedBy: string | null
    reviewedAt: Date | null
    orgId: string | null
  }

  export type OrganizationRequestMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    cardCode: string | null
    status: $Enums.RequestStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    reviewedBy: string | null
    reviewedAt: Date | null
    orgId: string | null
  }

  export type OrganizationRequestCountAggregateOutputType = {
    id: number
    userId: number
    cardCode: number
    status: number
    createdAt: number
    updatedAt: number
    reviewedBy: number
    reviewedAt: number
    orgId: number
    _all: number
  }


  export type OrganizationRequestMinAggregateInputType = {
    id?: true
    userId?: true
    cardCode?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    reviewedBy?: true
    reviewedAt?: true
    orgId?: true
  }

  export type OrganizationRequestMaxAggregateInputType = {
    id?: true
    userId?: true
    cardCode?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    reviewedBy?: true
    reviewedAt?: true
    orgId?: true
  }

  export type OrganizationRequestCountAggregateInputType = {
    id?: true
    userId?: true
    cardCode?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    reviewedBy?: true
    reviewedAt?: true
    orgId?: true
    _all?: true
  }

  export type OrganizationRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganizationRequest to aggregate.
     */
    where?: OrganizationRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationRequests to fetch.
     */
    orderBy?: OrganizationRequestOrderByWithRelationInput | OrganizationRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrganizationRequests
    **/
    _count?: true | OrganizationRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationRequestMaxAggregateInputType
  }

  export type GetOrganizationRequestAggregateType<T extends OrganizationRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganizationRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganizationRequest[P]>
      : GetScalarType<T[P], AggregateOrganizationRequest[P]>
  }




  export type OrganizationRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationRequestWhereInput
    orderBy?: OrganizationRequestOrderByWithAggregationInput | OrganizationRequestOrderByWithAggregationInput[]
    by: OrganizationRequestScalarFieldEnum[] | OrganizationRequestScalarFieldEnum
    having?: OrganizationRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationRequestCountAggregateInputType | true
    _min?: OrganizationRequestMinAggregateInputType
    _max?: OrganizationRequestMaxAggregateInputType
  }

  export type OrganizationRequestGroupByOutputType = {
    id: string
    userId: string
    cardCode: string
    status: $Enums.RequestStatus
    createdAt: Date
    updatedAt: Date
    reviewedBy: string | null
    reviewedAt: Date | null
    orgId: string | null
    _count: OrganizationRequestCountAggregateOutputType | null
    _min: OrganizationRequestMinAggregateOutputType | null
    _max: OrganizationRequestMaxAggregateOutputType | null
  }

  type GetOrganizationRequestGroupByPayload<T extends OrganizationRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationRequestGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationRequestGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    cardCode?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    orgId?: boolean
  }, ExtArgs["result"]["organizationRequest"]>

  export type OrganizationRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    cardCode?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    orgId?: boolean
  }, ExtArgs["result"]["organizationRequest"]>

  export type OrganizationRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    cardCode?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    orgId?: boolean
  }, ExtArgs["result"]["organizationRequest"]>

  export type OrganizationRequestSelectScalar = {
    id?: boolean
    userId?: boolean
    cardCode?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    orgId?: boolean
  }

  export type OrganizationRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "cardCode" | "status" | "createdAt" | "updatedAt" | "reviewedBy" | "reviewedAt" | "orgId", ExtArgs["result"]["organizationRequest"]>

  export type $OrganizationRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrganizationRequest"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      cardCode: string
      status: $Enums.RequestStatus
      createdAt: Date
      updatedAt: Date
      reviewedBy: string | null
      reviewedAt: Date | null
      orgId: string | null
    }, ExtArgs["result"]["organizationRequest"]>
    composites: {}
  }

  type OrganizationRequestGetPayload<S extends boolean | null | undefined | OrganizationRequestDefaultArgs> = $Result.GetResult<Prisma.$OrganizationRequestPayload, S>

  type OrganizationRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrganizationRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizationRequestCountAggregateInputType | true
    }

  export interface OrganizationRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrganizationRequest'], meta: { name: 'OrganizationRequest' } }
    /**
     * Find zero or one OrganizationRequest that matches the filter.
     * @param {OrganizationRequestFindUniqueArgs} args - Arguments to find a OrganizationRequest
     * @example
     * // Get one OrganizationRequest
     * const organizationRequest = await prisma.organizationRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationRequestFindUniqueArgs>(args: SelectSubset<T, OrganizationRequestFindUniqueArgs<ExtArgs>>): Prisma__OrganizationRequestClient<$Result.GetResult<Prisma.$OrganizationRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrganizationRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganizationRequestFindUniqueOrThrowArgs} args - Arguments to find a OrganizationRequest
     * @example
     * // Get one OrganizationRequest
     * const organizationRequest = await prisma.organizationRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationRequestClient<$Result.GetResult<Prisma.$OrganizationRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrganizationRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationRequestFindFirstArgs} args - Arguments to find a OrganizationRequest
     * @example
     * // Get one OrganizationRequest
     * const organizationRequest = await prisma.organizationRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationRequestFindFirstArgs>(args?: SelectSubset<T, OrganizationRequestFindFirstArgs<ExtArgs>>): Prisma__OrganizationRequestClient<$Result.GetResult<Prisma.$OrganizationRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrganizationRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationRequestFindFirstOrThrowArgs} args - Arguments to find a OrganizationRequest
     * @example
     * // Get one OrganizationRequest
     * const organizationRequest = await prisma.organizationRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationRequestClient<$Result.GetResult<Prisma.$OrganizationRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrganizationRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrganizationRequests
     * const organizationRequests = await prisma.organizationRequest.findMany()
     * 
     * // Get first 10 OrganizationRequests
     * const organizationRequests = await prisma.organizationRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationRequestWithIdOnly = await prisma.organizationRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationRequestFindManyArgs>(args?: SelectSubset<T, OrganizationRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrganizationRequest.
     * @param {OrganizationRequestCreateArgs} args - Arguments to create a OrganizationRequest.
     * @example
     * // Create one OrganizationRequest
     * const OrganizationRequest = await prisma.organizationRequest.create({
     *   data: {
     *     // ... data to create a OrganizationRequest
     *   }
     * })
     * 
     */
    create<T extends OrganizationRequestCreateArgs>(args: SelectSubset<T, OrganizationRequestCreateArgs<ExtArgs>>): Prisma__OrganizationRequestClient<$Result.GetResult<Prisma.$OrganizationRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrganizationRequests.
     * @param {OrganizationRequestCreateManyArgs} args - Arguments to create many OrganizationRequests.
     * @example
     * // Create many OrganizationRequests
     * const organizationRequest = await prisma.organizationRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationRequestCreateManyArgs>(args?: SelectSubset<T, OrganizationRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrganizationRequests and returns the data saved in the database.
     * @param {OrganizationRequestCreateManyAndReturnArgs} args - Arguments to create many OrganizationRequests.
     * @example
     * // Create many OrganizationRequests
     * const organizationRequest = await prisma.organizationRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrganizationRequests and only return the `id`
     * const organizationRequestWithIdOnly = await prisma.organizationRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrganizationRequest.
     * @param {OrganizationRequestDeleteArgs} args - Arguments to delete one OrganizationRequest.
     * @example
     * // Delete one OrganizationRequest
     * const OrganizationRequest = await prisma.organizationRequest.delete({
     *   where: {
     *     // ... filter to delete one OrganizationRequest
     *   }
     * })
     * 
     */
    delete<T extends OrganizationRequestDeleteArgs>(args: SelectSubset<T, OrganizationRequestDeleteArgs<ExtArgs>>): Prisma__OrganizationRequestClient<$Result.GetResult<Prisma.$OrganizationRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrganizationRequest.
     * @param {OrganizationRequestUpdateArgs} args - Arguments to update one OrganizationRequest.
     * @example
     * // Update one OrganizationRequest
     * const organizationRequest = await prisma.organizationRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationRequestUpdateArgs>(args: SelectSubset<T, OrganizationRequestUpdateArgs<ExtArgs>>): Prisma__OrganizationRequestClient<$Result.GetResult<Prisma.$OrganizationRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrganizationRequests.
     * @param {OrganizationRequestDeleteManyArgs} args - Arguments to filter OrganizationRequests to delete.
     * @example
     * // Delete a few OrganizationRequests
     * const { count } = await prisma.organizationRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationRequestDeleteManyArgs>(args?: SelectSubset<T, OrganizationRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganizationRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrganizationRequests
     * const organizationRequest = await prisma.organizationRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationRequestUpdateManyArgs>(args: SelectSubset<T, OrganizationRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganizationRequests and returns the data updated in the database.
     * @param {OrganizationRequestUpdateManyAndReturnArgs} args - Arguments to update many OrganizationRequests.
     * @example
     * // Update many OrganizationRequests
     * const organizationRequest = await prisma.organizationRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrganizationRequests and only return the `id`
     * const organizationRequestWithIdOnly = await prisma.organizationRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrganizationRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, OrganizationRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrganizationRequest.
     * @param {OrganizationRequestUpsertArgs} args - Arguments to update or create a OrganizationRequest.
     * @example
     * // Update or create a OrganizationRequest
     * const organizationRequest = await prisma.organizationRequest.upsert({
     *   create: {
     *     // ... data to create a OrganizationRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrganizationRequest we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationRequestUpsertArgs>(args: SelectSubset<T, OrganizationRequestUpsertArgs<ExtArgs>>): Prisma__OrganizationRequestClient<$Result.GetResult<Prisma.$OrganizationRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrganizationRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationRequestCountArgs} args - Arguments to filter OrganizationRequests to count.
     * @example
     * // Count the number of OrganizationRequests
     * const count = await prisma.organizationRequest.count({
     *   where: {
     *     // ... the filter for the OrganizationRequests we want to count
     *   }
     * })
    **/
    count<T extends OrganizationRequestCountArgs>(
      args?: Subset<T, OrganizationRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrganizationRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationRequestAggregateArgs>(args: Subset<T, OrganizationRequestAggregateArgs>): Prisma.PrismaPromise<GetOrganizationRequestAggregateType<T>>

    /**
     * Group by OrganizationRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationRequestGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrganizationRequest model
   */
  readonly fields: OrganizationRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrganizationRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrganizationRequest model
   */
  interface OrganizationRequestFieldRefs {
    readonly id: FieldRef<"OrganizationRequest", 'String'>
    readonly userId: FieldRef<"OrganizationRequest", 'String'>
    readonly cardCode: FieldRef<"OrganizationRequest", 'String'>
    readonly status: FieldRef<"OrganizationRequest", 'RequestStatus'>
    readonly createdAt: FieldRef<"OrganizationRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"OrganizationRequest", 'DateTime'>
    readonly reviewedBy: FieldRef<"OrganizationRequest", 'String'>
    readonly reviewedAt: FieldRef<"OrganizationRequest", 'DateTime'>
    readonly orgId: FieldRef<"OrganizationRequest", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OrganizationRequest findUnique
   */
  export type OrganizationRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationRequest
     */
    select?: OrganizationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationRequest
     */
    omit?: OrganizationRequestOmit<ExtArgs> | null
    /**
     * Filter, which OrganizationRequest to fetch.
     */
    where: OrganizationRequestWhereUniqueInput
  }

  /**
   * OrganizationRequest findUniqueOrThrow
   */
  export type OrganizationRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationRequest
     */
    select?: OrganizationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationRequest
     */
    omit?: OrganizationRequestOmit<ExtArgs> | null
    /**
     * Filter, which OrganizationRequest to fetch.
     */
    where: OrganizationRequestWhereUniqueInput
  }

  /**
   * OrganizationRequest findFirst
   */
  export type OrganizationRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationRequest
     */
    select?: OrganizationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationRequest
     */
    omit?: OrganizationRequestOmit<ExtArgs> | null
    /**
     * Filter, which OrganizationRequest to fetch.
     */
    where?: OrganizationRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationRequests to fetch.
     */
    orderBy?: OrganizationRequestOrderByWithRelationInput | OrganizationRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationRequests.
     */
    cursor?: OrganizationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationRequests.
     */
    distinct?: OrganizationRequestScalarFieldEnum | OrganizationRequestScalarFieldEnum[]
  }

  /**
   * OrganizationRequest findFirstOrThrow
   */
  export type OrganizationRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationRequest
     */
    select?: OrganizationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationRequest
     */
    omit?: OrganizationRequestOmit<ExtArgs> | null
    /**
     * Filter, which OrganizationRequest to fetch.
     */
    where?: OrganizationRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationRequests to fetch.
     */
    orderBy?: OrganizationRequestOrderByWithRelationInput | OrganizationRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationRequests.
     */
    cursor?: OrganizationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationRequests.
     */
    distinct?: OrganizationRequestScalarFieldEnum | OrganizationRequestScalarFieldEnum[]
  }

  /**
   * OrganizationRequest findMany
   */
  export type OrganizationRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationRequest
     */
    select?: OrganizationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationRequest
     */
    omit?: OrganizationRequestOmit<ExtArgs> | null
    /**
     * Filter, which OrganizationRequests to fetch.
     */
    where?: OrganizationRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationRequests to fetch.
     */
    orderBy?: OrganizationRequestOrderByWithRelationInput | OrganizationRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrganizationRequests.
     */
    cursor?: OrganizationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationRequests.
     */
    skip?: number
    distinct?: OrganizationRequestScalarFieldEnum | OrganizationRequestScalarFieldEnum[]
  }

  /**
   * OrganizationRequest create
   */
  export type OrganizationRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationRequest
     */
    select?: OrganizationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationRequest
     */
    omit?: OrganizationRequestOmit<ExtArgs> | null
    /**
     * The data needed to create a OrganizationRequest.
     */
    data: XOR<OrganizationRequestCreateInput, OrganizationRequestUncheckedCreateInput>
  }

  /**
   * OrganizationRequest createMany
   */
  export type OrganizationRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrganizationRequests.
     */
    data: OrganizationRequestCreateManyInput | OrganizationRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrganizationRequest createManyAndReturn
   */
  export type OrganizationRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationRequest
     */
    select?: OrganizationRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationRequest
     */
    omit?: OrganizationRequestOmit<ExtArgs> | null
    /**
     * The data used to create many OrganizationRequests.
     */
    data: OrganizationRequestCreateManyInput | OrganizationRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrganizationRequest update
   */
  export type OrganizationRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationRequest
     */
    select?: OrganizationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationRequest
     */
    omit?: OrganizationRequestOmit<ExtArgs> | null
    /**
     * The data needed to update a OrganizationRequest.
     */
    data: XOR<OrganizationRequestUpdateInput, OrganizationRequestUncheckedUpdateInput>
    /**
     * Choose, which OrganizationRequest to update.
     */
    where: OrganizationRequestWhereUniqueInput
  }

  /**
   * OrganizationRequest updateMany
   */
  export type OrganizationRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrganizationRequests.
     */
    data: XOR<OrganizationRequestUpdateManyMutationInput, OrganizationRequestUncheckedUpdateManyInput>
    /**
     * Filter which OrganizationRequests to update
     */
    where?: OrganizationRequestWhereInput
    /**
     * Limit how many OrganizationRequests to update.
     */
    limit?: number
  }

  /**
   * OrganizationRequest updateManyAndReturn
   */
  export type OrganizationRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationRequest
     */
    select?: OrganizationRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationRequest
     */
    omit?: OrganizationRequestOmit<ExtArgs> | null
    /**
     * The data used to update OrganizationRequests.
     */
    data: XOR<OrganizationRequestUpdateManyMutationInput, OrganizationRequestUncheckedUpdateManyInput>
    /**
     * Filter which OrganizationRequests to update
     */
    where?: OrganizationRequestWhereInput
    /**
     * Limit how many OrganizationRequests to update.
     */
    limit?: number
  }

  /**
   * OrganizationRequest upsert
   */
  export type OrganizationRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationRequest
     */
    select?: OrganizationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationRequest
     */
    omit?: OrganizationRequestOmit<ExtArgs> | null
    /**
     * The filter to search for the OrganizationRequest to update in case it exists.
     */
    where: OrganizationRequestWhereUniqueInput
    /**
     * In case the OrganizationRequest found by the `where` argument doesn't exist, create a new OrganizationRequest with this data.
     */
    create: XOR<OrganizationRequestCreateInput, OrganizationRequestUncheckedCreateInput>
    /**
     * In case the OrganizationRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationRequestUpdateInput, OrganizationRequestUncheckedUpdateInput>
  }

  /**
   * OrganizationRequest delete
   */
  export type OrganizationRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationRequest
     */
    select?: OrganizationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationRequest
     */
    omit?: OrganizationRequestOmit<ExtArgs> | null
    /**
     * Filter which OrganizationRequest to delete.
     */
    where: OrganizationRequestWhereUniqueInput
  }

  /**
   * OrganizationRequest deleteMany
   */
  export type OrganizationRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganizationRequests to delete
     */
    where?: OrganizationRequestWhereInput
    /**
     * Limit how many OrganizationRequests to delete.
     */
    limit?: number
  }

  /**
   * OrganizationRequest without action
   */
  export type OrganizationRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationRequest
     */
    select?: OrganizationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationRequest
     */
    omit?: OrganizationRequestOmit<ExtArgs> | null
  }


  /**
   * Model PendingSubscriptionPayment
   */

  export type AggregatePendingSubscriptionPayment = {
    _count: PendingSubscriptionPaymentCountAggregateOutputType | null
    _min: PendingSubscriptionPaymentMinAggregateOutputType | null
    _max: PendingSubscriptionPaymentMaxAggregateOutputType | null
  }

  export type PendingSubscriptionPaymentMinAggregateOutputType = {
    id: string | null
    transactionId: string | null
    userId: string | null
    plan: string | null
    name: string | null
    logo: string | null
    address: string | null
    requestId: string | null
    orgId: string | null
    type: string | null
    createdAt: Date | null
  }

  export type PendingSubscriptionPaymentMaxAggregateOutputType = {
    id: string | null
    transactionId: string | null
    userId: string | null
    plan: string | null
    name: string | null
    logo: string | null
    address: string | null
    requestId: string | null
    orgId: string | null
    type: string | null
    createdAt: Date | null
  }

  export type PendingSubscriptionPaymentCountAggregateOutputType = {
    id: number
    transactionId: number
    userId: number
    plan: number
    name: number
    logo: number
    address: number
    requestId: number
    orgId: number
    type: number
    createdAt: number
    _all: number
  }


  export type PendingSubscriptionPaymentMinAggregateInputType = {
    id?: true
    transactionId?: true
    userId?: true
    plan?: true
    name?: true
    logo?: true
    address?: true
    requestId?: true
    orgId?: true
    type?: true
    createdAt?: true
  }

  export type PendingSubscriptionPaymentMaxAggregateInputType = {
    id?: true
    transactionId?: true
    userId?: true
    plan?: true
    name?: true
    logo?: true
    address?: true
    requestId?: true
    orgId?: true
    type?: true
    createdAt?: true
  }

  export type PendingSubscriptionPaymentCountAggregateInputType = {
    id?: true
    transactionId?: true
    userId?: true
    plan?: true
    name?: true
    logo?: true
    address?: true
    requestId?: true
    orgId?: true
    type?: true
    createdAt?: true
    _all?: true
  }

  export type PendingSubscriptionPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PendingSubscriptionPayment to aggregate.
     */
    where?: PendingSubscriptionPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingSubscriptionPayments to fetch.
     */
    orderBy?: PendingSubscriptionPaymentOrderByWithRelationInput | PendingSubscriptionPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PendingSubscriptionPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingSubscriptionPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingSubscriptionPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PendingSubscriptionPayments
    **/
    _count?: true | PendingSubscriptionPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PendingSubscriptionPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PendingSubscriptionPaymentMaxAggregateInputType
  }

  export type GetPendingSubscriptionPaymentAggregateType<T extends PendingSubscriptionPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePendingSubscriptionPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePendingSubscriptionPayment[P]>
      : GetScalarType<T[P], AggregatePendingSubscriptionPayment[P]>
  }




  export type PendingSubscriptionPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PendingSubscriptionPaymentWhereInput
    orderBy?: PendingSubscriptionPaymentOrderByWithAggregationInput | PendingSubscriptionPaymentOrderByWithAggregationInput[]
    by: PendingSubscriptionPaymentScalarFieldEnum[] | PendingSubscriptionPaymentScalarFieldEnum
    having?: PendingSubscriptionPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PendingSubscriptionPaymentCountAggregateInputType | true
    _min?: PendingSubscriptionPaymentMinAggregateInputType
    _max?: PendingSubscriptionPaymentMaxAggregateInputType
  }

  export type PendingSubscriptionPaymentGroupByOutputType = {
    id: string
    transactionId: string
    userId: string
    plan: string
    name: string
    logo: string | null
    address: string | null
    requestId: string | null
    orgId: string | null
    type: string
    createdAt: Date
    _count: PendingSubscriptionPaymentCountAggregateOutputType | null
    _min: PendingSubscriptionPaymentMinAggregateOutputType | null
    _max: PendingSubscriptionPaymentMaxAggregateOutputType | null
  }

  type GetPendingSubscriptionPaymentGroupByPayload<T extends PendingSubscriptionPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PendingSubscriptionPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PendingSubscriptionPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PendingSubscriptionPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PendingSubscriptionPaymentGroupByOutputType[P]>
        }
      >
    >


  export type PendingSubscriptionPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    userId?: boolean
    plan?: boolean
    name?: boolean
    logo?: boolean
    address?: boolean
    requestId?: boolean
    orgId?: boolean
    type?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["pendingSubscriptionPayment"]>

  export type PendingSubscriptionPaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    userId?: boolean
    plan?: boolean
    name?: boolean
    logo?: boolean
    address?: boolean
    requestId?: boolean
    orgId?: boolean
    type?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["pendingSubscriptionPayment"]>

  export type PendingSubscriptionPaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    userId?: boolean
    plan?: boolean
    name?: boolean
    logo?: boolean
    address?: boolean
    requestId?: boolean
    orgId?: boolean
    type?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["pendingSubscriptionPayment"]>

  export type PendingSubscriptionPaymentSelectScalar = {
    id?: boolean
    transactionId?: boolean
    userId?: boolean
    plan?: boolean
    name?: boolean
    logo?: boolean
    address?: boolean
    requestId?: boolean
    orgId?: boolean
    type?: boolean
    createdAt?: boolean
  }

  export type PendingSubscriptionPaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionId" | "userId" | "plan" | "name" | "logo" | "address" | "requestId" | "orgId" | "type" | "createdAt", ExtArgs["result"]["pendingSubscriptionPayment"]>

  export type $PendingSubscriptionPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PendingSubscriptionPayment"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transactionId: string
      userId: string
      plan: string
      name: string
      logo: string | null
      address: string | null
      requestId: string | null
      orgId: string | null
      type: string
      createdAt: Date
    }, ExtArgs["result"]["pendingSubscriptionPayment"]>
    composites: {}
  }

  type PendingSubscriptionPaymentGetPayload<S extends boolean | null | undefined | PendingSubscriptionPaymentDefaultArgs> = $Result.GetResult<Prisma.$PendingSubscriptionPaymentPayload, S>

  type PendingSubscriptionPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PendingSubscriptionPaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PendingSubscriptionPaymentCountAggregateInputType | true
    }

  export interface PendingSubscriptionPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PendingSubscriptionPayment'], meta: { name: 'PendingSubscriptionPayment' } }
    /**
     * Find zero or one PendingSubscriptionPayment that matches the filter.
     * @param {PendingSubscriptionPaymentFindUniqueArgs} args - Arguments to find a PendingSubscriptionPayment
     * @example
     * // Get one PendingSubscriptionPayment
     * const pendingSubscriptionPayment = await prisma.pendingSubscriptionPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PendingSubscriptionPaymentFindUniqueArgs>(args: SelectSubset<T, PendingSubscriptionPaymentFindUniqueArgs<ExtArgs>>): Prisma__PendingSubscriptionPaymentClient<$Result.GetResult<Prisma.$PendingSubscriptionPaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PendingSubscriptionPayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PendingSubscriptionPaymentFindUniqueOrThrowArgs} args - Arguments to find a PendingSubscriptionPayment
     * @example
     * // Get one PendingSubscriptionPayment
     * const pendingSubscriptionPayment = await prisma.pendingSubscriptionPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PendingSubscriptionPaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PendingSubscriptionPaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PendingSubscriptionPaymentClient<$Result.GetResult<Prisma.$PendingSubscriptionPaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PendingSubscriptionPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingSubscriptionPaymentFindFirstArgs} args - Arguments to find a PendingSubscriptionPayment
     * @example
     * // Get one PendingSubscriptionPayment
     * const pendingSubscriptionPayment = await prisma.pendingSubscriptionPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PendingSubscriptionPaymentFindFirstArgs>(args?: SelectSubset<T, PendingSubscriptionPaymentFindFirstArgs<ExtArgs>>): Prisma__PendingSubscriptionPaymentClient<$Result.GetResult<Prisma.$PendingSubscriptionPaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PendingSubscriptionPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingSubscriptionPaymentFindFirstOrThrowArgs} args - Arguments to find a PendingSubscriptionPayment
     * @example
     * // Get one PendingSubscriptionPayment
     * const pendingSubscriptionPayment = await prisma.pendingSubscriptionPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PendingSubscriptionPaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PendingSubscriptionPaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PendingSubscriptionPaymentClient<$Result.GetResult<Prisma.$PendingSubscriptionPaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PendingSubscriptionPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingSubscriptionPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PendingSubscriptionPayments
     * const pendingSubscriptionPayments = await prisma.pendingSubscriptionPayment.findMany()
     * 
     * // Get first 10 PendingSubscriptionPayments
     * const pendingSubscriptionPayments = await prisma.pendingSubscriptionPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pendingSubscriptionPaymentWithIdOnly = await prisma.pendingSubscriptionPayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PendingSubscriptionPaymentFindManyArgs>(args?: SelectSubset<T, PendingSubscriptionPaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingSubscriptionPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PendingSubscriptionPayment.
     * @param {PendingSubscriptionPaymentCreateArgs} args - Arguments to create a PendingSubscriptionPayment.
     * @example
     * // Create one PendingSubscriptionPayment
     * const PendingSubscriptionPayment = await prisma.pendingSubscriptionPayment.create({
     *   data: {
     *     // ... data to create a PendingSubscriptionPayment
     *   }
     * })
     * 
     */
    create<T extends PendingSubscriptionPaymentCreateArgs>(args: SelectSubset<T, PendingSubscriptionPaymentCreateArgs<ExtArgs>>): Prisma__PendingSubscriptionPaymentClient<$Result.GetResult<Prisma.$PendingSubscriptionPaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PendingSubscriptionPayments.
     * @param {PendingSubscriptionPaymentCreateManyArgs} args - Arguments to create many PendingSubscriptionPayments.
     * @example
     * // Create many PendingSubscriptionPayments
     * const pendingSubscriptionPayment = await prisma.pendingSubscriptionPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PendingSubscriptionPaymentCreateManyArgs>(args?: SelectSubset<T, PendingSubscriptionPaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PendingSubscriptionPayments and returns the data saved in the database.
     * @param {PendingSubscriptionPaymentCreateManyAndReturnArgs} args - Arguments to create many PendingSubscriptionPayments.
     * @example
     * // Create many PendingSubscriptionPayments
     * const pendingSubscriptionPayment = await prisma.pendingSubscriptionPayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PendingSubscriptionPayments and only return the `id`
     * const pendingSubscriptionPaymentWithIdOnly = await prisma.pendingSubscriptionPayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PendingSubscriptionPaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PendingSubscriptionPaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingSubscriptionPaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PendingSubscriptionPayment.
     * @param {PendingSubscriptionPaymentDeleteArgs} args - Arguments to delete one PendingSubscriptionPayment.
     * @example
     * // Delete one PendingSubscriptionPayment
     * const PendingSubscriptionPayment = await prisma.pendingSubscriptionPayment.delete({
     *   where: {
     *     // ... filter to delete one PendingSubscriptionPayment
     *   }
     * })
     * 
     */
    delete<T extends PendingSubscriptionPaymentDeleteArgs>(args: SelectSubset<T, PendingSubscriptionPaymentDeleteArgs<ExtArgs>>): Prisma__PendingSubscriptionPaymentClient<$Result.GetResult<Prisma.$PendingSubscriptionPaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PendingSubscriptionPayment.
     * @param {PendingSubscriptionPaymentUpdateArgs} args - Arguments to update one PendingSubscriptionPayment.
     * @example
     * // Update one PendingSubscriptionPayment
     * const pendingSubscriptionPayment = await prisma.pendingSubscriptionPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PendingSubscriptionPaymentUpdateArgs>(args: SelectSubset<T, PendingSubscriptionPaymentUpdateArgs<ExtArgs>>): Prisma__PendingSubscriptionPaymentClient<$Result.GetResult<Prisma.$PendingSubscriptionPaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PendingSubscriptionPayments.
     * @param {PendingSubscriptionPaymentDeleteManyArgs} args - Arguments to filter PendingSubscriptionPayments to delete.
     * @example
     * // Delete a few PendingSubscriptionPayments
     * const { count } = await prisma.pendingSubscriptionPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PendingSubscriptionPaymentDeleteManyArgs>(args?: SelectSubset<T, PendingSubscriptionPaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PendingSubscriptionPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingSubscriptionPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PendingSubscriptionPayments
     * const pendingSubscriptionPayment = await prisma.pendingSubscriptionPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PendingSubscriptionPaymentUpdateManyArgs>(args: SelectSubset<T, PendingSubscriptionPaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PendingSubscriptionPayments and returns the data updated in the database.
     * @param {PendingSubscriptionPaymentUpdateManyAndReturnArgs} args - Arguments to update many PendingSubscriptionPayments.
     * @example
     * // Update many PendingSubscriptionPayments
     * const pendingSubscriptionPayment = await prisma.pendingSubscriptionPayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PendingSubscriptionPayments and only return the `id`
     * const pendingSubscriptionPaymentWithIdOnly = await prisma.pendingSubscriptionPayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PendingSubscriptionPaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PendingSubscriptionPaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingSubscriptionPaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PendingSubscriptionPayment.
     * @param {PendingSubscriptionPaymentUpsertArgs} args - Arguments to update or create a PendingSubscriptionPayment.
     * @example
     * // Update or create a PendingSubscriptionPayment
     * const pendingSubscriptionPayment = await prisma.pendingSubscriptionPayment.upsert({
     *   create: {
     *     // ... data to create a PendingSubscriptionPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PendingSubscriptionPayment we want to update
     *   }
     * })
     */
    upsert<T extends PendingSubscriptionPaymentUpsertArgs>(args: SelectSubset<T, PendingSubscriptionPaymentUpsertArgs<ExtArgs>>): Prisma__PendingSubscriptionPaymentClient<$Result.GetResult<Prisma.$PendingSubscriptionPaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PendingSubscriptionPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingSubscriptionPaymentCountArgs} args - Arguments to filter PendingSubscriptionPayments to count.
     * @example
     * // Count the number of PendingSubscriptionPayments
     * const count = await prisma.pendingSubscriptionPayment.count({
     *   where: {
     *     // ... the filter for the PendingSubscriptionPayments we want to count
     *   }
     * })
    **/
    count<T extends PendingSubscriptionPaymentCountArgs>(
      args?: Subset<T, PendingSubscriptionPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PendingSubscriptionPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PendingSubscriptionPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingSubscriptionPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PendingSubscriptionPaymentAggregateArgs>(args: Subset<T, PendingSubscriptionPaymentAggregateArgs>): Prisma.PrismaPromise<GetPendingSubscriptionPaymentAggregateType<T>>

    /**
     * Group by PendingSubscriptionPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingSubscriptionPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PendingSubscriptionPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PendingSubscriptionPaymentGroupByArgs['orderBy'] }
        : { orderBy?: PendingSubscriptionPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PendingSubscriptionPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPendingSubscriptionPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PendingSubscriptionPayment model
   */
  readonly fields: PendingSubscriptionPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PendingSubscriptionPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PendingSubscriptionPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PendingSubscriptionPayment model
   */
  interface PendingSubscriptionPaymentFieldRefs {
    readonly id: FieldRef<"PendingSubscriptionPayment", 'String'>
    readonly transactionId: FieldRef<"PendingSubscriptionPayment", 'String'>
    readonly userId: FieldRef<"PendingSubscriptionPayment", 'String'>
    readonly plan: FieldRef<"PendingSubscriptionPayment", 'String'>
    readonly name: FieldRef<"PendingSubscriptionPayment", 'String'>
    readonly logo: FieldRef<"PendingSubscriptionPayment", 'String'>
    readonly address: FieldRef<"PendingSubscriptionPayment", 'String'>
    readonly requestId: FieldRef<"PendingSubscriptionPayment", 'String'>
    readonly orgId: FieldRef<"PendingSubscriptionPayment", 'String'>
    readonly type: FieldRef<"PendingSubscriptionPayment", 'String'>
    readonly createdAt: FieldRef<"PendingSubscriptionPayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PendingSubscriptionPayment findUnique
   */
  export type PendingSubscriptionPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingSubscriptionPayment
     */
    select?: PendingSubscriptionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingSubscriptionPayment
     */
    omit?: PendingSubscriptionPaymentOmit<ExtArgs> | null
    /**
     * Filter, which PendingSubscriptionPayment to fetch.
     */
    where: PendingSubscriptionPaymentWhereUniqueInput
  }

  /**
   * PendingSubscriptionPayment findUniqueOrThrow
   */
  export type PendingSubscriptionPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingSubscriptionPayment
     */
    select?: PendingSubscriptionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingSubscriptionPayment
     */
    omit?: PendingSubscriptionPaymentOmit<ExtArgs> | null
    /**
     * Filter, which PendingSubscriptionPayment to fetch.
     */
    where: PendingSubscriptionPaymentWhereUniqueInput
  }

  /**
   * PendingSubscriptionPayment findFirst
   */
  export type PendingSubscriptionPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingSubscriptionPayment
     */
    select?: PendingSubscriptionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingSubscriptionPayment
     */
    omit?: PendingSubscriptionPaymentOmit<ExtArgs> | null
    /**
     * Filter, which PendingSubscriptionPayment to fetch.
     */
    where?: PendingSubscriptionPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingSubscriptionPayments to fetch.
     */
    orderBy?: PendingSubscriptionPaymentOrderByWithRelationInput | PendingSubscriptionPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PendingSubscriptionPayments.
     */
    cursor?: PendingSubscriptionPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingSubscriptionPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingSubscriptionPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PendingSubscriptionPayments.
     */
    distinct?: PendingSubscriptionPaymentScalarFieldEnum | PendingSubscriptionPaymentScalarFieldEnum[]
  }

  /**
   * PendingSubscriptionPayment findFirstOrThrow
   */
  export type PendingSubscriptionPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingSubscriptionPayment
     */
    select?: PendingSubscriptionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingSubscriptionPayment
     */
    omit?: PendingSubscriptionPaymentOmit<ExtArgs> | null
    /**
     * Filter, which PendingSubscriptionPayment to fetch.
     */
    where?: PendingSubscriptionPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingSubscriptionPayments to fetch.
     */
    orderBy?: PendingSubscriptionPaymentOrderByWithRelationInput | PendingSubscriptionPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PendingSubscriptionPayments.
     */
    cursor?: PendingSubscriptionPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingSubscriptionPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingSubscriptionPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PendingSubscriptionPayments.
     */
    distinct?: PendingSubscriptionPaymentScalarFieldEnum | PendingSubscriptionPaymentScalarFieldEnum[]
  }

  /**
   * PendingSubscriptionPayment findMany
   */
  export type PendingSubscriptionPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingSubscriptionPayment
     */
    select?: PendingSubscriptionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingSubscriptionPayment
     */
    omit?: PendingSubscriptionPaymentOmit<ExtArgs> | null
    /**
     * Filter, which PendingSubscriptionPayments to fetch.
     */
    where?: PendingSubscriptionPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingSubscriptionPayments to fetch.
     */
    orderBy?: PendingSubscriptionPaymentOrderByWithRelationInput | PendingSubscriptionPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PendingSubscriptionPayments.
     */
    cursor?: PendingSubscriptionPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingSubscriptionPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingSubscriptionPayments.
     */
    skip?: number
    distinct?: PendingSubscriptionPaymentScalarFieldEnum | PendingSubscriptionPaymentScalarFieldEnum[]
  }

  /**
   * PendingSubscriptionPayment create
   */
  export type PendingSubscriptionPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingSubscriptionPayment
     */
    select?: PendingSubscriptionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingSubscriptionPayment
     */
    omit?: PendingSubscriptionPaymentOmit<ExtArgs> | null
    /**
     * The data needed to create a PendingSubscriptionPayment.
     */
    data: XOR<PendingSubscriptionPaymentCreateInput, PendingSubscriptionPaymentUncheckedCreateInput>
  }

  /**
   * PendingSubscriptionPayment createMany
   */
  export type PendingSubscriptionPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PendingSubscriptionPayments.
     */
    data: PendingSubscriptionPaymentCreateManyInput | PendingSubscriptionPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PendingSubscriptionPayment createManyAndReturn
   */
  export type PendingSubscriptionPaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingSubscriptionPayment
     */
    select?: PendingSubscriptionPaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PendingSubscriptionPayment
     */
    omit?: PendingSubscriptionPaymentOmit<ExtArgs> | null
    /**
     * The data used to create many PendingSubscriptionPayments.
     */
    data: PendingSubscriptionPaymentCreateManyInput | PendingSubscriptionPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PendingSubscriptionPayment update
   */
  export type PendingSubscriptionPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingSubscriptionPayment
     */
    select?: PendingSubscriptionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingSubscriptionPayment
     */
    omit?: PendingSubscriptionPaymentOmit<ExtArgs> | null
    /**
     * The data needed to update a PendingSubscriptionPayment.
     */
    data: XOR<PendingSubscriptionPaymentUpdateInput, PendingSubscriptionPaymentUncheckedUpdateInput>
    /**
     * Choose, which PendingSubscriptionPayment to update.
     */
    where: PendingSubscriptionPaymentWhereUniqueInput
  }

  /**
   * PendingSubscriptionPayment updateMany
   */
  export type PendingSubscriptionPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PendingSubscriptionPayments.
     */
    data: XOR<PendingSubscriptionPaymentUpdateManyMutationInput, PendingSubscriptionPaymentUncheckedUpdateManyInput>
    /**
     * Filter which PendingSubscriptionPayments to update
     */
    where?: PendingSubscriptionPaymentWhereInput
    /**
     * Limit how many PendingSubscriptionPayments to update.
     */
    limit?: number
  }

  /**
   * PendingSubscriptionPayment updateManyAndReturn
   */
  export type PendingSubscriptionPaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingSubscriptionPayment
     */
    select?: PendingSubscriptionPaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PendingSubscriptionPayment
     */
    omit?: PendingSubscriptionPaymentOmit<ExtArgs> | null
    /**
     * The data used to update PendingSubscriptionPayments.
     */
    data: XOR<PendingSubscriptionPaymentUpdateManyMutationInput, PendingSubscriptionPaymentUncheckedUpdateManyInput>
    /**
     * Filter which PendingSubscriptionPayments to update
     */
    where?: PendingSubscriptionPaymentWhereInput
    /**
     * Limit how many PendingSubscriptionPayments to update.
     */
    limit?: number
  }

  /**
   * PendingSubscriptionPayment upsert
   */
  export type PendingSubscriptionPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingSubscriptionPayment
     */
    select?: PendingSubscriptionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingSubscriptionPayment
     */
    omit?: PendingSubscriptionPaymentOmit<ExtArgs> | null
    /**
     * The filter to search for the PendingSubscriptionPayment to update in case it exists.
     */
    where: PendingSubscriptionPaymentWhereUniqueInput
    /**
     * In case the PendingSubscriptionPayment found by the `where` argument doesn't exist, create a new PendingSubscriptionPayment with this data.
     */
    create: XOR<PendingSubscriptionPaymentCreateInput, PendingSubscriptionPaymentUncheckedCreateInput>
    /**
     * In case the PendingSubscriptionPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PendingSubscriptionPaymentUpdateInput, PendingSubscriptionPaymentUncheckedUpdateInput>
  }

  /**
   * PendingSubscriptionPayment delete
   */
  export type PendingSubscriptionPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingSubscriptionPayment
     */
    select?: PendingSubscriptionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingSubscriptionPayment
     */
    omit?: PendingSubscriptionPaymentOmit<ExtArgs> | null
    /**
     * Filter which PendingSubscriptionPayment to delete.
     */
    where: PendingSubscriptionPaymentWhereUniqueInput
  }

  /**
   * PendingSubscriptionPayment deleteMany
   */
  export type PendingSubscriptionPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PendingSubscriptionPayments to delete
     */
    where?: PendingSubscriptionPaymentWhereInput
    /**
     * Limit how many PendingSubscriptionPayments to delete.
     */
    limit?: number
  }

  /**
   * PendingSubscriptionPayment without action
   */
  export type PendingSubscriptionPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingSubscriptionPayment
     */
    select?: PendingSubscriptionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingSubscriptionPayment
     */
    omit?: PendingSubscriptionPaymentOmit<ExtArgs> | null
  }


  /**
   * Model PaymentOrder
   */

  export type AggregatePaymentOrder = {
    _count: PaymentOrderCountAggregateOutputType | null
    _avg: PaymentOrderAvgAggregateOutputType | null
    _sum: PaymentOrderSumAggregateOutputType | null
    _min: PaymentOrderMinAggregateOutputType | null
    _max: PaymentOrderMaxAggregateOutputType | null
  }

  export type PaymentOrderAvgAggregateOutputType = {
    amountFcfa: number | null
  }

  export type PaymentOrderSumAggregateOutputType = {
    amountFcfa: number | null
  }

  export type PaymentOrderMinAggregateOutputType = {
    id: string | null
    userId: string | null
    plan: string | null
    name: string | null
    logo: string | null
    address: string | null
    requestId: string | null
    orgId: string | null
    type: string | null
    amountFcfa: number | null
    status: $Enums.PaymentOrderStatus | null
    approvedBy: string | null
    approvedAt: Date | null
    rejectedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentOrderMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    plan: string | null
    name: string | null
    logo: string | null
    address: string | null
    requestId: string | null
    orgId: string | null
    type: string | null
    amountFcfa: number | null
    status: $Enums.PaymentOrderStatus | null
    approvedBy: string | null
    approvedAt: Date | null
    rejectedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentOrderCountAggregateOutputType = {
    id: number
    userId: number
    plan: number
    name: number
    logo: number
    address: number
    requestId: number
    orgId: number
    type: number
    amountFcfa: number
    status: number
    approvedBy: number
    approvedAt: number
    rejectedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentOrderAvgAggregateInputType = {
    amountFcfa?: true
  }

  export type PaymentOrderSumAggregateInputType = {
    amountFcfa?: true
  }

  export type PaymentOrderMinAggregateInputType = {
    id?: true
    userId?: true
    plan?: true
    name?: true
    logo?: true
    address?: true
    requestId?: true
    orgId?: true
    type?: true
    amountFcfa?: true
    status?: true
    approvedBy?: true
    approvedAt?: true
    rejectedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentOrderMaxAggregateInputType = {
    id?: true
    userId?: true
    plan?: true
    name?: true
    logo?: true
    address?: true
    requestId?: true
    orgId?: true
    type?: true
    amountFcfa?: true
    status?: true
    approvedBy?: true
    approvedAt?: true
    rejectedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentOrderCountAggregateInputType = {
    id?: true
    userId?: true
    plan?: true
    name?: true
    logo?: true
    address?: true
    requestId?: true
    orgId?: true
    type?: true
    amountFcfa?: true
    status?: true
    approvedBy?: true
    approvedAt?: true
    rejectedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentOrder to aggregate.
     */
    where?: PaymentOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentOrders to fetch.
     */
    orderBy?: PaymentOrderOrderByWithRelationInput | PaymentOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentOrders
    **/
    _count?: true | PaymentOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentOrderMaxAggregateInputType
  }

  export type GetPaymentOrderAggregateType<T extends PaymentOrderAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentOrder[P]>
      : GetScalarType<T[P], AggregatePaymentOrder[P]>
  }




  export type PaymentOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentOrderWhereInput
    orderBy?: PaymentOrderOrderByWithAggregationInput | PaymentOrderOrderByWithAggregationInput[]
    by: PaymentOrderScalarFieldEnum[] | PaymentOrderScalarFieldEnum
    having?: PaymentOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentOrderCountAggregateInputType | true
    _avg?: PaymentOrderAvgAggregateInputType
    _sum?: PaymentOrderSumAggregateInputType
    _min?: PaymentOrderMinAggregateInputType
    _max?: PaymentOrderMaxAggregateInputType
  }

  export type PaymentOrderGroupByOutputType = {
    id: string
    userId: string
    plan: string
    name: string
    logo: string | null
    address: string | null
    requestId: string | null
    orgId: string | null
    type: string
    amountFcfa: number
    status: $Enums.PaymentOrderStatus
    approvedBy: string | null
    approvedAt: Date | null
    rejectedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentOrderCountAggregateOutputType | null
    _avg: PaymentOrderAvgAggregateOutputType | null
    _sum: PaymentOrderSumAggregateOutputType | null
    _min: PaymentOrderMinAggregateOutputType | null
    _max: PaymentOrderMaxAggregateOutputType | null
  }

  type GetPaymentOrderGroupByPayload<T extends PaymentOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentOrderGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentOrderGroupByOutputType[P]>
        }
      >
    >


  export type PaymentOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    plan?: boolean
    name?: boolean
    logo?: boolean
    address?: boolean
    requestId?: boolean
    orgId?: boolean
    type?: boolean
    amountFcfa?: boolean
    status?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paymentOrder"]>

  export type PaymentOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    plan?: boolean
    name?: boolean
    logo?: boolean
    address?: boolean
    requestId?: boolean
    orgId?: boolean
    type?: boolean
    amountFcfa?: boolean
    status?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paymentOrder"]>

  export type PaymentOrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    plan?: boolean
    name?: boolean
    logo?: boolean
    address?: boolean
    requestId?: boolean
    orgId?: boolean
    type?: boolean
    amountFcfa?: boolean
    status?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paymentOrder"]>

  export type PaymentOrderSelectScalar = {
    id?: boolean
    userId?: boolean
    plan?: boolean
    name?: boolean
    logo?: boolean
    address?: boolean
    requestId?: boolean
    orgId?: boolean
    type?: boolean
    amountFcfa?: boolean
    status?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "plan" | "name" | "logo" | "address" | "requestId" | "orgId" | "type" | "amountFcfa" | "status" | "approvedBy" | "approvedAt" | "rejectedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["paymentOrder"]>

  export type $PaymentOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentOrder"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      plan: string
      name: string
      logo: string | null
      address: string | null
      requestId: string | null
      orgId: string | null
      type: string
      amountFcfa: number
      status: $Enums.PaymentOrderStatus
      approvedBy: string | null
      approvedAt: Date | null
      rejectedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["paymentOrder"]>
    composites: {}
  }

  type PaymentOrderGetPayload<S extends boolean | null | undefined | PaymentOrderDefaultArgs> = $Result.GetResult<Prisma.$PaymentOrderPayload, S>

  type PaymentOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentOrderCountAggregateInputType | true
    }

  export interface PaymentOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentOrder'], meta: { name: 'PaymentOrder' } }
    /**
     * Find zero or one PaymentOrder that matches the filter.
     * @param {PaymentOrderFindUniqueArgs} args - Arguments to find a PaymentOrder
     * @example
     * // Get one PaymentOrder
     * const paymentOrder = await prisma.paymentOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentOrderFindUniqueArgs>(args: SelectSubset<T, PaymentOrderFindUniqueArgs<ExtArgs>>): Prisma__PaymentOrderClient<$Result.GetResult<Prisma.$PaymentOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentOrderFindUniqueOrThrowArgs} args - Arguments to find a PaymentOrder
     * @example
     * // Get one PaymentOrder
     * const paymentOrder = await prisma.paymentOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentOrderClient<$Result.GetResult<Prisma.$PaymentOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentOrderFindFirstArgs} args - Arguments to find a PaymentOrder
     * @example
     * // Get one PaymentOrder
     * const paymentOrder = await prisma.paymentOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentOrderFindFirstArgs>(args?: SelectSubset<T, PaymentOrderFindFirstArgs<ExtArgs>>): Prisma__PaymentOrderClient<$Result.GetResult<Prisma.$PaymentOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentOrderFindFirstOrThrowArgs} args - Arguments to find a PaymentOrder
     * @example
     * // Get one PaymentOrder
     * const paymentOrder = await prisma.paymentOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentOrderClient<$Result.GetResult<Prisma.$PaymentOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentOrders
     * const paymentOrders = await prisma.paymentOrder.findMany()
     * 
     * // Get first 10 PaymentOrders
     * const paymentOrders = await prisma.paymentOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentOrderWithIdOnly = await prisma.paymentOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentOrderFindManyArgs>(args?: SelectSubset<T, PaymentOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentOrder.
     * @param {PaymentOrderCreateArgs} args - Arguments to create a PaymentOrder.
     * @example
     * // Create one PaymentOrder
     * const PaymentOrder = await prisma.paymentOrder.create({
     *   data: {
     *     // ... data to create a PaymentOrder
     *   }
     * })
     * 
     */
    create<T extends PaymentOrderCreateArgs>(args: SelectSubset<T, PaymentOrderCreateArgs<ExtArgs>>): Prisma__PaymentOrderClient<$Result.GetResult<Prisma.$PaymentOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentOrders.
     * @param {PaymentOrderCreateManyArgs} args - Arguments to create many PaymentOrders.
     * @example
     * // Create many PaymentOrders
     * const paymentOrder = await prisma.paymentOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentOrderCreateManyArgs>(args?: SelectSubset<T, PaymentOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentOrders and returns the data saved in the database.
     * @param {PaymentOrderCreateManyAndReturnArgs} args - Arguments to create many PaymentOrders.
     * @example
     * // Create many PaymentOrders
     * const paymentOrder = await prisma.paymentOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentOrders and only return the `id`
     * const paymentOrderWithIdOnly = await prisma.paymentOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentOrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentOrder.
     * @param {PaymentOrderDeleteArgs} args - Arguments to delete one PaymentOrder.
     * @example
     * // Delete one PaymentOrder
     * const PaymentOrder = await prisma.paymentOrder.delete({
     *   where: {
     *     // ... filter to delete one PaymentOrder
     *   }
     * })
     * 
     */
    delete<T extends PaymentOrderDeleteArgs>(args: SelectSubset<T, PaymentOrderDeleteArgs<ExtArgs>>): Prisma__PaymentOrderClient<$Result.GetResult<Prisma.$PaymentOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentOrder.
     * @param {PaymentOrderUpdateArgs} args - Arguments to update one PaymentOrder.
     * @example
     * // Update one PaymentOrder
     * const paymentOrder = await prisma.paymentOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentOrderUpdateArgs>(args: SelectSubset<T, PaymentOrderUpdateArgs<ExtArgs>>): Prisma__PaymentOrderClient<$Result.GetResult<Prisma.$PaymentOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentOrders.
     * @param {PaymentOrderDeleteManyArgs} args - Arguments to filter PaymentOrders to delete.
     * @example
     * // Delete a few PaymentOrders
     * const { count } = await prisma.paymentOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentOrderDeleteManyArgs>(args?: SelectSubset<T, PaymentOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentOrders
     * const paymentOrder = await prisma.paymentOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentOrderUpdateManyArgs>(args: SelectSubset<T, PaymentOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentOrders and returns the data updated in the database.
     * @param {PaymentOrderUpdateManyAndReturnArgs} args - Arguments to update many PaymentOrders.
     * @example
     * // Update many PaymentOrders
     * const paymentOrder = await prisma.paymentOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentOrders and only return the `id`
     * const paymentOrderWithIdOnly = await prisma.paymentOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentOrderUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentOrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentOrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentOrder.
     * @param {PaymentOrderUpsertArgs} args - Arguments to update or create a PaymentOrder.
     * @example
     * // Update or create a PaymentOrder
     * const paymentOrder = await prisma.paymentOrder.upsert({
     *   create: {
     *     // ... data to create a PaymentOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentOrder we want to update
     *   }
     * })
     */
    upsert<T extends PaymentOrderUpsertArgs>(args: SelectSubset<T, PaymentOrderUpsertArgs<ExtArgs>>): Prisma__PaymentOrderClient<$Result.GetResult<Prisma.$PaymentOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentOrderCountArgs} args - Arguments to filter PaymentOrders to count.
     * @example
     * // Count the number of PaymentOrders
     * const count = await prisma.paymentOrder.count({
     *   where: {
     *     // ... the filter for the PaymentOrders we want to count
     *   }
     * })
    **/
    count<T extends PaymentOrderCountArgs>(
      args?: Subset<T, PaymentOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentOrderAggregateArgs>(args: Subset<T, PaymentOrderAggregateArgs>): Prisma.PrismaPromise<GetPaymentOrderAggregateType<T>>

    /**
     * Group by PaymentOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentOrderGroupByArgs['orderBy'] }
        : { orderBy?: PaymentOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentOrder model
   */
  readonly fields: PaymentOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentOrder model
   */
  interface PaymentOrderFieldRefs {
    readonly id: FieldRef<"PaymentOrder", 'String'>
    readonly userId: FieldRef<"PaymentOrder", 'String'>
    readonly plan: FieldRef<"PaymentOrder", 'String'>
    readonly name: FieldRef<"PaymentOrder", 'String'>
    readonly logo: FieldRef<"PaymentOrder", 'String'>
    readonly address: FieldRef<"PaymentOrder", 'String'>
    readonly requestId: FieldRef<"PaymentOrder", 'String'>
    readonly orgId: FieldRef<"PaymentOrder", 'String'>
    readonly type: FieldRef<"PaymentOrder", 'String'>
    readonly amountFcfa: FieldRef<"PaymentOrder", 'Int'>
    readonly status: FieldRef<"PaymentOrder", 'PaymentOrderStatus'>
    readonly approvedBy: FieldRef<"PaymentOrder", 'String'>
    readonly approvedAt: FieldRef<"PaymentOrder", 'DateTime'>
    readonly rejectedAt: FieldRef<"PaymentOrder", 'DateTime'>
    readonly createdAt: FieldRef<"PaymentOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentOrder findUnique
   */
  export type PaymentOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentOrder
     */
    select?: PaymentOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentOrder
     */
    omit?: PaymentOrderOmit<ExtArgs> | null
    /**
     * Filter, which PaymentOrder to fetch.
     */
    where: PaymentOrderWhereUniqueInput
  }

  /**
   * PaymentOrder findUniqueOrThrow
   */
  export type PaymentOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentOrder
     */
    select?: PaymentOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentOrder
     */
    omit?: PaymentOrderOmit<ExtArgs> | null
    /**
     * Filter, which PaymentOrder to fetch.
     */
    where: PaymentOrderWhereUniqueInput
  }

  /**
   * PaymentOrder findFirst
   */
  export type PaymentOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentOrder
     */
    select?: PaymentOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentOrder
     */
    omit?: PaymentOrderOmit<ExtArgs> | null
    /**
     * Filter, which PaymentOrder to fetch.
     */
    where?: PaymentOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentOrders to fetch.
     */
    orderBy?: PaymentOrderOrderByWithRelationInput | PaymentOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentOrders.
     */
    cursor?: PaymentOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentOrders.
     */
    distinct?: PaymentOrderScalarFieldEnum | PaymentOrderScalarFieldEnum[]
  }

  /**
   * PaymentOrder findFirstOrThrow
   */
  export type PaymentOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentOrder
     */
    select?: PaymentOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentOrder
     */
    omit?: PaymentOrderOmit<ExtArgs> | null
    /**
     * Filter, which PaymentOrder to fetch.
     */
    where?: PaymentOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentOrders to fetch.
     */
    orderBy?: PaymentOrderOrderByWithRelationInput | PaymentOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentOrders.
     */
    cursor?: PaymentOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentOrders.
     */
    distinct?: PaymentOrderScalarFieldEnum | PaymentOrderScalarFieldEnum[]
  }

  /**
   * PaymentOrder findMany
   */
  export type PaymentOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentOrder
     */
    select?: PaymentOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentOrder
     */
    omit?: PaymentOrderOmit<ExtArgs> | null
    /**
     * Filter, which PaymentOrders to fetch.
     */
    where?: PaymentOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentOrders to fetch.
     */
    orderBy?: PaymentOrderOrderByWithRelationInput | PaymentOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentOrders.
     */
    cursor?: PaymentOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentOrders.
     */
    skip?: number
    distinct?: PaymentOrderScalarFieldEnum | PaymentOrderScalarFieldEnum[]
  }

  /**
   * PaymentOrder create
   */
  export type PaymentOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentOrder
     */
    select?: PaymentOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentOrder
     */
    omit?: PaymentOrderOmit<ExtArgs> | null
    /**
     * The data needed to create a PaymentOrder.
     */
    data: XOR<PaymentOrderCreateInput, PaymentOrderUncheckedCreateInput>
  }

  /**
   * PaymentOrder createMany
   */
  export type PaymentOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentOrders.
     */
    data: PaymentOrderCreateManyInput | PaymentOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentOrder createManyAndReturn
   */
  export type PaymentOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentOrder
     */
    select?: PaymentOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentOrder
     */
    omit?: PaymentOrderOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentOrders.
     */
    data: PaymentOrderCreateManyInput | PaymentOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentOrder update
   */
  export type PaymentOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentOrder
     */
    select?: PaymentOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentOrder
     */
    omit?: PaymentOrderOmit<ExtArgs> | null
    /**
     * The data needed to update a PaymentOrder.
     */
    data: XOR<PaymentOrderUpdateInput, PaymentOrderUncheckedUpdateInput>
    /**
     * Choose, which PaymentOrder to update.
     */
    where: PaymentOrderWhereUniqueInput
  }

  /**
   * PaymentOrder updateMany
   */
  export type PaymentOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentOrders.
     */
    data: XOR<PaymentOrderUpdateManyMutationInput, PaymentOrderUncheckedUpdateManyInput>
    /**
     * Filter which PaymentOrders to update
     */
    where?: PaymentOrderWhereInput
    /**
     * Limit how many PaymentOrders to update.
     */
    limit?: number
  }

  /**
   * PaymentOrder updateManyAndReturn
   */
  export type PaymentOrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentOrder
     */
    select?: PaymentOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentOrder
     */
    omit?: PaymentOrderOmit<ExtArgs> | null
    /**
     * The data used to update PaymentOrders.
     */
    data: XOR<PaymentOrderUpdateManyMutationInput, PaymentOrderUncheckedUpdateManyInput>
    /**
     * Filter which PaymentOrders to update
     */
    where?: PaymentOrderWhereInput
    /**
     * Limit how many PaymentOrders to update.
     */
    limit?: number
  }

  /**
   * PaymentOrder upsert
   */
  export type PaymentOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentOrder
     */
    select?: PaymentOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentOrder
     */
    omit?: PaymentOrderOmit<ExtArgs> | null
    /**
     * The filter to search for the PaymentOrder to update in case it exists.
     */
    where: PaymentOrderWhereUniqueInput
    /**
     * In case the PaymentOrder found by the `where` argument doesn't exist, create a new PaymentOrder with this data.
     */
    create: XOR<PaymentOrderCreateInput, PaymentOrderUncheckedCreateInput>
    /**
     * In case the PaymentOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentOrderUpdateInput, PaymentOrderUncheckedUpdateInput>
  }

  /**
   * PaymentOrder delete
   */
  export type PaymentOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentOrder
     */
    select?: PaymentOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentOrder
     */
    omit?: PaymentOrderOmit<ExtArgs> | null
    /**
     * Filter which PaymentOrder to delete.
     */
    where: PaymentOrderWhereUniqueInput
  }

  /**
   * PaymentOrder deleteMany
   */
  export type PaymentOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentOrders to delete
     */
    where?: PaymentOrderWhereInput
    /**
     * Limit how many PaymentOrders to delete.
     */
    limit?: number
  }

  /**
   * PaymentOrder without action
   */
  export type PaymentOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentOrder
     */
    select?: PaymentOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentOrder
     */
    omit?: PaymentOrderOmit<ExtArgs> | null
  }


  /**
   * Model PaymentSetting
   */

  export type AggregatePaymentSetting = {
    _count: PaymentSettingCountAggregateOutputType | null
    _min: PaymentSettingMinAggregateOutputType | null
    _max: PaymentSettingMaxAggregateOutputType | null
  }

  export type PaymentSettingMinAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
  }

  export type PaymentSettingMaxAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
  }

  export type PaymentSettingCountAggregateOutputType = {
    id: number
    key: number
    value: number
    _all: number
  }


  export type PaymentSettingMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
  }

  export type PaymentSettingMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
  }

  export type PaymentSettingCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    _all?: true
  }

  export type PaymentSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentSetting to aggregate.
     */
    where?: PaymentSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentSettings to fetch.
     */
    orderBy?: PaymentSettingOrderByWithRelationInput | PaymentSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentSettings
    **/
    _count?: true | PaymentSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentSettingMaxAggregateInputType
  }

  export type GetPaymentSettingAggregateType<T extends PaymentSettingAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentSetting[P]>
      : GetScalarType<T[P], AggregatePaymentSetting[P]>
  }




  export type PaymentSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentSettingWhereInput
    orderBy?: PaymentSettingOrderByWithAggregationInput | PaymentSettingOrderByWithAggregationInput[]
    by: PaymentSettingScalarFieldEnum[] | PaymentSettingScalarFieldEnum
    having?: PaymentSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentSettingCountAggregateInputType | true
    _min?: PaymentSettingMinAggregateInputType
    _max?: PaymentSettingMaxAggregateInputType
  }

  export type PaymentSettingGroupByOutputType = {
    id: string
    key: string
    value: string
    _count: PaymentSettingCountAggregateOutputType | null
    _min: PaymentSettingMinAggregateOutputType | null
    _max: PaymentSettingMaxAggregateOutputType | null
  }

  type GetPaymentSettingGroupByPayload<T extends PaymentSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentSettingGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentSettingGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
  }, ExtArgs["result"]["paymentSetting"]>

  export type PaymentSettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
  }, ExtArgs["result"]["paymentSetting"]>

  export type PaymentSettingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
  }, ExtArgs["result"]["paymentSetting"]>

  export type PaymentSettingSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
  }

  export type PaymentSettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value", ExtArgs["result"]["paymentSetting"]>

  export type $PaymentSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentSetting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: string
    }, ExtArgs["result"]["paymentSetting"]>
    composites: {}
  }

  type PaymentSettingGetPayload<S extends boolean | null | undefined | PaymentSettingDefaultArgs> = $Result.GetResult<Prisma.$PaymentSettingPayload, S>

  type PaymentSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentSettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentSettingCountAggregateInputType | true
    }

  export interface PaymentSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentSetting'], meta: { name: 'PaymentSetting' } }
    /**
     * Find zero or one PaymentSetting that matches the filter.
     * @param {PaymentSettingFindUniqueArgs} args - Arguments to find a PaymentSetting
     * @example
     * // Get one PaymentSetting
     * const paymentSetting = await prisma.paymentSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentSettingFindUniqueArgs>(args: SelectSubset<T, PaymentSettingFindUniqueArgs<ExtArgs>>): Prisma__PaymentSettingClient<$Result.GetResult<Prisma.$PaymentSettingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentSetting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentSettingFindUniqueOrThrowArgs} args - Arguments to find a PaymentSetting
     * @example
     * // Get one PaymentSetting
     * const paymentSetting = await prisma.paymentSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentSettingClient<$Result.GetResult<Prisma.$PaymentSettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentSettingFindFirstArgs} args - Arguments to find a PaymentSetting
     * @example
     * // Get one PaymentSetting
     * const paymentSetting = await prisma.paymentSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentSettingFindFirstArgs>(args?: SelectSubset<T, PaymentSettingFindFirstArgs<ExtArgs>>): Prisma__PaymentSettingClient<$Result.GetResult<Prisma.$PaymentSettingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentSettingFindFirstOrThrowArgs} args - Arguments to find a PaymentSetting
     * @example
     * // Get one PaymentSetting
     * const paymentSetting = await prisma.paymentSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentSettingClient<$Result.GetResult<Prisma.$PaymentSettingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentSettings
     * const paymentSettings = await prisma.paymentSetting.findMany()
     * 
     * // Get first 10 PaymentSettings
     * const paymentSettings = await prisma.paymentSetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentSettingWithIdOnly = await prisma.paymentSetting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentSettingFindManyArgs>(args?: SelectSubset<T, PaymentSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentSettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentSetting.
     * @param {PaymentSettingCreateArgs} args - Arguments to create a PaymentSetting.
     * @example
     * // Create one PaymentSetting
     * const PaymentSetting = await prisma.paymentSetting.create({
     *   data: {
     *     // ... data to create a PaymentSetting
     *   }
     * })
     * 
     */
    create<T extends PaymentSettingCreateArgs>(args: SelectSubset<T, PaymentSettingCreateArgs<ExtArgs>>): Prisma__PaymentSettingClient<$Result.GetResult<Prisma.$PaymentSettingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentSettings.
     * @param {PaymentSettingCreateManyArgs} args - Arguments to create many PaymentSettings.
     * @example
     * // Create many PaymentSettings
     * const paymentSetting = await prisma.paymentSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentSettingCreateManyArgs>(args?: SelectSubset<T, PaymentSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentSettings and returns the data saved in the database.
     * @param {PaymentSettingCreateManyAndReturnArgs} args - Arguments to create many PaymentSettings.
     * @example
     * // Create many PaymentSettings
     * const paymentSetting = await prisma.paymentSetting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentSettings and only return the `id`
     * const paymentSettingWithIdOnly = await prisma.paymentSetting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentSettingCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentSettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentSettingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentSetting.
     * @param {PaymentSettingDeleteArgs} args - Arguments to delete one PaymentSetting.
     * @example
     * // Delete one PaymentSetting
     * const PaymentSetting = await prisma.paymentSetting.delete({
     *   where: {
     *     // ... filter to delete one PaymentSetting
     *   }
     * })
     * 
     */
    delete<T extends PaymentSettingDeleteArgs>(args: SelectSubset<T, PaymentSettingDeleteArgs<ExtArgs>>): Prisma__PaymentSettingClient<$Result.GetResult<Prisma.$PaymentSettingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentSetting.
     * @param {PaymentSettingUpdateArgs} args - Arguments to update one PaymentSetting.
     * @example
     * // Update one PaymentSetting
     * const paymentSetting = await prisma.paymentSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentSettingUpdateArgs>(args: SelectSubset<T, PaymentSettingUpdateArgs<ExtArgs>>): Prisma__PaymentSettingClient<$Result.GetResult<Prisma.$PaymentSettingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentSettings.
     * @param {PaymentSettingDeleteManyArgs} args - Arguments to filter PaymentSettings to delete.
     * @example
     * // Delete a few PaymentSettings
     * const { count } = await prisma.paymentSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentSettingDeleteManyArgs>(args?: SelectSubset<T, PaymentSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentSettings
     * const paymentSetting = await prisma.paymentSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentSettingUpdateManyArgs>(args: SelectSubset<T, PaymentSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentSettings and returns the data updated in the database.
     * @param {PaymentSettingUpdateManyAndReturnArgs} args - Arguments to update many PaymentSettings.
     * @example
     * // Update many PaymentSettings
     * const paymentSetting = await prisma.paymentSetting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentSettings and only return the `id`
     * const paymentSettingWithIdOnly = await prisma.paymentSetting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentSettingUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentSettingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentSettingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentSetting.
     * @param {PaymentSettingUpsertArgs} args - Arguments to update or create a PaymentSetting.
     * @example
     * // Update or create a PaymentSetting
     * const paymentSetting = await prisma.paymentSetting.upsert({
     *   create: {
     *     // ... data to create a PaymentSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentSetting we want to update
     *   }
     * })
     */
    upsert<T extends PaymentSettingUpsertArgs>(args: SelectSubset<T, PaymentSettingUpsertArgs<ExtArgs>>): Prisma__PaymentSettingClient<$Result.GetResult<Prisma.$PaymentSettingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentSettingCountArgs} args - Arguments to filter PaymentSettings to count.
     * @example
     * // Count the number of PaymentSettings
     * const count = await prisma.paymentSetting.count({
     *   where: {
     *     // ... the filter for the PaymentSettings we want to count
     *   }
     * })
    **/
    count<T extends PaymentSettingCountArgs>(
      args?: Subset<T, PaymentSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentSettingAggregateArgs>(args: Subset<T, PaymentSettingAggregateArgs>): Prisma.PrismaPromise<GetPaymentSettingAggregateType<T>>

    /**
     * Group by PaymentSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentSettingGroupByArgs['orderBy'] }
        : { orderBy?: PaymentSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentSetting model
   */
  readonly fields: PaymentSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentSetting model
   */
  interface PaymentSettingFieldRefs {
    readonly id: FieldRef<"PaymentSetting", 'String'>
    readonly key: FieldRef<"PaymentSetting", 'String'>
    readonly value: FieldRef<"PaymentSetting", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PaymentSetting findUnique
   */
  export type PaymentSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentSetting
     */
    select?: PaymentSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentSetting
     */
    omit?: PaymentSettingOmit<ExtArgs> | null
    /**
     * Filter, which PaymentSetting to fetch.
     */
    where: PaymentSettingWhereUniqueInput
  }

  /**
   * PaymentSetting findUniqueOrThrow
   */
  export type PaymentSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentSetting
     */
    select?: PaymentSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentSetting
     */
    omit?: PaymentSettingOmit<ExtArgs> | null
    /**
     * Filter, which PaymentSetting to fetch.
     */
    where: PaymentSettingWhereUniqueInput
  }

  /**
   * PaymentSetting findFirst
   */
  export type PaymentSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentSetting
     */
    select?: PaymentSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentSetting
     */
    omit?: PaymentSettingOmit<ExtArgs> | null
    /**
     * Filter, which PaymentSetting to fetch.
     */
    where?: PaymentSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentSettings to fetch.
     */
    orderBy?: PaymentSettingOrderByWithRelationInput | PaymentSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentSettings.
     */
    cursor?: PaymentSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentSettings.
     */
    distinct?: PaymentSettingScalarFieldEnum | PaymentSettingScalarFieldEnum[]
  }

  /**
   * PaymentSetting findFirstOrThrow
   */
  export type PaymentSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentSetting
     */
    select?: PaymentSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentSetting
     */
    omit?: PaymentSettingOmit<ExtArgs> | null
    /**
     * Filter, which PaymentSetting to fetch.
     */
    where?: PaymentSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentSettings to fetch.
     */
    orderBy?: PaymentSettingOrderByWithRelationInput | PaymentSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentSettings.
     */
    cursor?: PaymentSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentSettings.
     */
    distinct?: PaymentSettingScalarFieldEnum | PaymentSettingScalarFieldEnum[]
  }

  /**
   * PaymentSetting findMany
   */
  export type PaymentSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentSetting
     */
    select?: PaymentSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentSetting
     */
    omit?: PaymentSettingOmit<ExtArgs> | null
    /**
     * Filter, which PaymentSettings to fetch.
     */
    where?: PaymentSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentSettings to fetch.
     */
    orderBy?: PaymentSettingOrderByWithRelationInput | PaymentSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentSettings.
     */
    cursor?: PaymentSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentSettings.
     */
    skip?: number
    distinct?: PaymentSettingScalarFieldEnum | PaymentSettingScalarFieldEnum[]
  }

  /**
   * PaymentSetting create
   */
  export type PaymentSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentSetting
     */
    select?: PaymentSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentSetting
     */
    omit?: PaymentSettingOmit<ExtArgs> | null
    /**
     * The data needed to create a PaymentSetting.
     */
    data: XOR<PaymentSettingCreateInput, PaymentSettingUncheckedCreateInput>
  }

  /**
   * PaymentSetting createMany
   */
  export type PaymentSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentSettings.
     */
    data: PaymentSettingCreateManyInput | PaymentSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentSetting createManyAndReturn
   */
  export type PaymentSettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentSetting
     */
    select?: PaymentSettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentSetting
     */
    omit?: PaymentSettingOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentSettings.
     */
    data: PaymentSettingCreateManyInput | PaymentSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentSetting update
   */
  export type PaymentSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentSetting
     */
    select?: PaymentSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentSetting
     */
    omit?: PaymentSettingOmit<ExtArgs> | null
    /**
     * The data needed to update a PaymentSetting.
     */
    data: XOR<PaymentSettingUpdateInput, PaymentSettingUncheckedUpdateInput>
    /**
     * Choose, which PaymentSetting to update.
     */
    where: PaymentSettingWhereUniqueInput
  }

  /**
   * PaymentSetting updateMany
   */
  export type PaymentSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentSettings.
     */
    data: XOR<PaymentSettingUpdateManyMutationInput, PaymentSettingUncheckedUpdateManyInput>
    /**
     * Filter which PaymentSettings to update
     */
    where?: PaymentSettingWhereInput
    /**
     * Limit how many PaymentSettings to update.
     */
    limit?: number
  }

  /**
   * PaymentSetting updateManyAndReturn
   */
  export type PaymentSettingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentSetting
     */
    select?: PaymentSettingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentSetting
     */
    omit?: PaymentSettingOmit<ExtArgs> | null
    /**
     * The data used to update PaymentSettings.
     */
    data: XOR<PaymentSettingUpdateManyMutationInput, PaymentSettingUncheckedUpdateManyInput>
    /**
     * Filter which PaymentSettings to update
     */
    where?: PaymentSettingWhereInput
    /**
     * Limit how many PaymentSettings to update.
     */
    limit?: number
  }

  /**
   * PaymentSetting upsert
   */
  export type PaymentSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentSetting
     */
    select?: PaymentSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentSetting
     */
    omit?: PaymentSettingOmit<ExtArgs> | null
    /**
     * The filter to search for the PaymentSetting to update in case it exists.
     */
    where: PaymentSettingWhereUniqueInput
    /**
     * In case the PaymentSetting found by the `where` argument doesn't exist, create a new PaymentSetting with this data.
     */
    create: XOR<PaymentSettingCreateInput, PaymentSettingUncheckedCreateInput>
    /**
     * In case the PaymentSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentSettingUpdateInput, PaymentSettingUncheckedUpdateInput>
  }

  /**
   * PaymentSetting delete
   */
  export type PaymentSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentSetting
     */
    select?: PaymentSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentSetting
     */
    omit?: PaymentSettingOmit<ExtArgs> | null
    /**
     * Filter which PaymentSetting to delete.
     */
    where: PaymentSettingWhereUniqueInput
  }

  /**
   * PaymentSetting deleteMany
   */
  export type PaymentSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentSettings to delete
     */
    where?: PaymentSettingWhereInput
    /**
     * Limit how many PaymentSettings to delete.
     */
    limit?: number
  }

  /**
   * PaymentSetting without action
   */
  export type PaymentSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentSetting
     */
    select?: PaymentSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentSetting
     */
    omit?: PaymentSettingOmit<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionAvgAggregateOutputType = {
    maxDepartments: number | null
    maxMembersPerDept: number | null
  }

  export type SubscriptionSumAggregateOutputType = {
    maxDepartments: number | null
    maxMembersPerDept: number | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    plan: $Enums.SubscriptionPlan | null
    startDate: Date | null
    endDate: Date | null
    maxDepartments: number | null
    maxMembersPerDept: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    plan: $Enums.SubscriptionPlan | null
    startDate: Date | null
    endDate: Date | null
    maxDepartments: number | null
    maxMembersPerDept: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    orgId: number
    plan: number
    startDate: number
    endDate: number
    maxDepartments: number
    maxMembersPerDept: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionAvgAggregateInputType = {
    maxDepartments?: true
    maxMembersPerDept?: true
  }

  export type SubscriptionSumAggregateInputType = {
    maxDepartments?: true
    maxMembersPerDept?: true
  }

  export type SubscriptionMinAggregateInputType = {
    id?: true
    orgId?: true
    plan?: true
    startDate?: true
    endDate?: true
    maxDepartments?: true
    maxMembersPerDept?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    orgId?: true
    plan?: true
    startDate?: true
    endDate?: true
    maxDepartments?: true
    maxMembersPerDept?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    orgId?: true
    plan?: true
    startDate?: true
    endDate?: true
    maxDepartments?: true
    maxMembersPerDept?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _avg?: SubscriptionAvgAggregateInputType
    _sum?: SubscriptionSumAggregateInputType
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    orgId: string
    plan: $Enums.SubscriptionPlan
    startDate: Date
    endDate: Date | null
    maxDepartments: number
    maxMembersPerDept: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    plan?: boolean
    startDate?: boolean
    endDate?: boolean
    maxDepartments?: boolean
    maxMembersPerDept?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    plan?: boolean
    startDate?: boolean
    endDate?: boolean
    maxDepartments?: boolean
    maxMembersPerDept?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    plan?: boolean
    startDate?: boolean
    endDate?: boolean
    maxDepartments?: boolean
    maxMembersPerDept?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    orgId?: boolean
    plan?: boolean
    startDate?: boolean
    endDate?: boolean
    maxDepartments?: boolean
    maxMembersPerDept?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "plan" | "startDate" | "endDate" | "maxDepartments" | "maxMembersPerDept" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["subscription"]>
  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      plan: $Enums.SubscriptionPlan
      startDate: Date
      endDate: Date | null
      maxDepartments: number
      maxMembersPerDept: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions and returns the data updated in the database.
     * @param {SubscriptionUpdateManyAndReturnArgs} args - Arguments to update many Subscriptions.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly orgId: FieldRef<"Subscription", 'String'>
    readonly plan: FieldRef<"Subscription", 'SubscriptionPlan'>
    readonly startDate: FieldRef<"Subscription", 'DateTime'>
    readonly endDate: FieldRef<"Subscription", 'DateTime'>
    readonly maxDepartments: FieldRef<"Subscription", 'Int'>
    readonly maxMembersPerDept: FieldRef<"Subscription", 'Int'>
    readonly isActive: FieldRef<"Subscription", 'Boolean'>
    readonly createdAt: FieldRef<"Subscription", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
  }

  /**
   * Subscription updateManyAndReturn
   */
  export type SubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to delete.
     */
    limit?: number
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model EventInvitation
   */

  export type AggregateEventInvitation = {
    _count: EventInvitationCountAggregateOutputType | null
    _avg: EventInvitationAvgAggregateOutputType | null
    _sum: EventInvitationSumAggregateOutputType | null
    _min: EventInvitationMinAggregateOutputType | null
    _max: EventInvitationMaxAggregateOutputType | null
  }

  export type EventInvitationAvgAggregateOutputType = {
    maxAttendees: number | null
  }

  export type EventInvitationSumAggregateOutputType = {
    maxAttendees: number | null
  }

  export type EventInvitationMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    title: string | null
    description: string | null
    eventType: $Enums.EventType | null
    eventDate: Date | null
    maxAttendees: number | null
    imageUrl: string | null
    token: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventInvitationMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    title: string | null
    description: string | null
    eventType: $Enums.EventType | null
    eventDate: Date | null
    maxAttendees: number | null
    imageUrl: string | null
    token: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventInvitationCountAggregateOutputType = {
    id: number
    orgId: number
    title: number
    description: number
    eventType: number
    eventDate: number
    maxAttendees: number
    imageUrl: number
    token: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EventInvitationAvgAggregateInputType = {
    maxAttendees?: true
  }

  export type EventInvitationSumAggregateInputType = {
    maxAttendees?: true
  }

  export type EventInvitationMinAggregateInputType = {
    id?: true
    orgId?: true
    title?: true
    description?: true
    eventType?: true
    eventDate?: true
    maxAttendees?: true
    imageUrl?: true
    token?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventInvitationMaxAggregateInputType = {
    id?: true
    orgId?: true
    title?: true
    description?: true
    eventType?: true
    eventDate?: true
    maxAttendees?: true
    imageUrl?: true
    token?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventInvitationCountAggregateInputType = {
    id?: true
    orgId?: true
    title?: true
    description?: true
    eventType?: true
    eventDate?: true
    maxAttendees?: true
    imageUrl?: true
    token?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EventInvitationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventInvitation to aggregate.
     */
    where?: EventInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventInvitations to fetch.
     */
    orderBy?: EventInvitationOrderByWithRelationInput | EventInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventInvitations
    **/
    _count?: true | EventInvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventInvitationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventInvitationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventInvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventInvitationMaxAggregateInputType
  }

  export type GetEventInvitationAggregateType<T extends EventInvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateEventInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventInvitation[P]>
      : GetScalarType<T[P], AggregateEventInvitation[P]>
  }




  export type EventInvitationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventInvitationWhereInput
    orderBy?: EventInvitationOrderByWithAggregationInput | EventInvitationOrderByWithAggregationInput[]
    by: EventInvitationScalarFieldEnum[] | EventInvitationScalarFieldEnum
    having?: EventInvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventInvitationCountAggregateInputType | true
    _avg?: EventInvitationAvgAggregateInputType
    _sum?: EventInvitationSumAggregateInputType
    _min?: EventInvitationMinAggregateInputType
    _max?: EventInvitationMaxAggregateInputType
  }

  export type EventInvitationGroupByOutputType = {
    id: string
    orgId: string
    title: string
    description: string | null
    eventType: $Enums.EventType
    eventDate: Date
    maxAttendees: number
    imageUrl: string | null
    token: string
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: EventInvitationCountAggregateOutputType | null
    _avg: EventInvitationAvgAggregateOutputType | null
    _sum: EventInvitationSumAggregateOutputType | null
    _min: EventInvitationMinAggregateOutputType | null
    _max: EventInvitationMaxAggregateOutputType | null
  }

  type GetEventInvitationGroupByPayload<T extends EventInvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventInvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventInvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventInvitationGroupByOutputType[P]>
            : GetScalarType<T[P], EventInvitationGroupByOutputType[P]>
        }
      >
    >


  export type EventInvitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    title?: boolean
    description?: boolean
    eventType?: boolean
    eventDate?: boolean
    maxAttendees?: boolean
    imageUrl?: boolean
    token?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    rsvps?: boolean | EventInvitation$rsvpsArgs<ExtArgs>
    departmentBroadcasts?: boolean | EventInvitation$departmentBroadcastsArgs<ExtArgs>
    _count?: boolean | EventInvitationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventInvitation"]>

  export type EventInvitationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    title?: boolean
    description?: boolean
    eventType?: boolean
    eventDate?: boolean
    maxAttendees?: boolean
    imageUrl?: boolean
    token?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventInvitation"]>

  export type EventInvitationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    title?: boolean
    description?: boolean
    eventType?: boolean
    eventDate?: boolean
    maxAttendees?: boolean
    imageUrl?: boolean
    token?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventInvitation"]>

  export type EventInvitationSelectScalar = {
    id?: boolean
    orgId?: boolean
    title?: boolean
    description?: boolean
    eventType?: boolean
    eventDate?: boolean
    maxAttendees?: boolean
    imageUrl?: boolean
    token?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EventInvitationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "title" | "description" | "eventType" | "eventDate" | "maxAttendees" | "imageUrl" | "token" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["eventInvitation"]>
  export type EventInvitationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    rsvps?: boolean | EventInvitation$rsvpsArgs<ExtArgs>
    departmentBroadcasts?: boolean | EventInvitation$departmentBroadcastsArgs<ExtArgs>
    _count?: boolean | EventInvitationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EventInvitationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type EventInvitationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $EventInvitationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventInvitation"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      rsvps: Prisma.$InvitationRSVPPayload<ExtArgs>[]
      departmentBroadcasts: Prisma.$EventDepartmentBroadcastPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      title: string
      description: string | null
      eventType: $Enums.EventType
      eventDate: Date
      maxAttendees: number
      imageUrl: string | null
      token: string
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["eventInvitation"]>
    composites: {}
  }

  type EventInvitationGetPayload<S extends boolean | null | undefined | EventInvitationDefaultArgs> = $Result.GetResult<Prisma.$EventInvitationPayload, S>

  type EventInvitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventInvitationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventInvitationCountAggregateInputType | true
    }

  export interface EventInvitationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventInvitation'], meta: { name: 'EventInvitation' } }
    /**
     * Find zero or one EventInvitation that matches the filter.
     * @param {EventInvitationFindUniqueArgs} args - Arguments to find a EventInvitation
     * @example
     * // Get one EventInvitation
     * const eventInvitation = await prisma.eventInvitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventInvitationFindUniqueArgs>(args: SelectSubset<T, EventInvitationFindUniqueArgs<ExtArgs>>): Prisma__EventInvitationClient<$Result.GetResult<Prisma.$EventInvitationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EventInvitation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventInvitationFindUniqueOrThrowArgs} args - Arguments to find a EventInvitation
     * @example
     * // Get one EventInvitation
     * const eventInvitation = await prisma.eventInvitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventInvitationFindUniqueOrThrowArgs>(args: SelectSubset<T, EventInvitationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventInvitationClient<$Result.GetResult<Prisma.$EventInvitationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EventInvitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventInvitationFindFirstArgs} args - Arguments to find a EventInvitation
     * @example
     * // Get one EventInvitation
     * const eventInvitation = await prisma.eventInvitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventInvitationFindFirstArgs>(args?: SelectSubset<T, EventInvitationFindFirstArgs<ExtArgs>>): Prisma__EventInvitationClient<$Result.GetResult<Prisma.$EventInvitationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EventInvitation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventInvitationFindFirstOrThrowArgs} args - Arguments to find a EventInvitation
     * @example
     * // Get one EventInvitation
     * const eventInvitation = await prisma.eventInvitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventInvitationFindFirstOrThrowArgs>(args?: SelectSubset<T, EventInvitationFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventInvitationClient<$Result.GetResult<Prisma.$EventInvitationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EventInvitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventInvitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventInvitations
     * const eventInvitations = await prisma.eventInvitation.findMany()
     * 
     * // Get first 10 EventInvitations
     * const eventInvitations = await prisma.eventInvitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventInvitationWithIdOnly = await prisma.eventInvitation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventInvitationFindManyArgs>(args?: SelectSubset<T, EventInvitationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EventInvitation.
     * @param {EventInvitationCreateArgs} args - Arguments to create a EventInvitation.
     * @example
     * // Create one EventInvitation
     * const EventInvitation = await prisma.eventInvitation.create({
     *   data: {
     *     // ... data to create a EventInvitation
     *   }
     * })
     * 
     */
    create<T extends EventInvitationCreateArgs>(args: SelectSubset<T, EventInvitationCreateArgs<ExtArgs>>): Prisma__EventInvitationClient<$Result.GetResult<Prisma.$EventInvitationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EventInvitations.
     * @param {EventInvitationCreateManyArgs} args - Arguments to create many EventInvitations.
     * @example
     * // Create many EventInvitations
     * const eventInvitation = await prisma.eventInvitation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventInvitationCreateManyArgs>(args?: SelectSubset<T, EventInvitationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EventInvitations and returns the data saved in the database.
     * @param {EventInvitationCreateManyAndReturnArgs} args - Arguments to create many EventInvitations.
     * @example
     * // Create many EventInvitations
     * const eventInvitation = await prisma.eventInvitation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EventInvitations and only return the `id`
     * const eventInvitationWithIdOnly = await prisma.eventInvitation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventInvitationCreateManyAndReturnArgs>(args?: SelectSubset<T, EventInvitationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventInvitationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EventInvitation.
     * @param {EventInvitationDeleteArgs} args - Arguments to delete one EventInvitation.
     * @example
     * // Delete one EventInvitation
     * const EventInvitation = await prisma.eventInvitation.delete({
     *   where: {
     *     // ... filter to delete one EventInvitation
     *   }
     * })
     * 
     */
    delete<T extends EventInvitationDeleteArgs>(args: SelectSubset<T, EventInvitationDeleteArgs<ExtArgs>>): Prisma__EventInvitationClient<$Result.GetResult<Prisma.$EventInvitationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EventInvitation.
     * @param {EventInvitationUpdateArgs} args - Arguments to update one EventInvitation.
     * @example
     * // Update one EventInvitation
     * const eventInvitation = await prisma.eventInvitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventInvitationUpdateArgs>(args: SelectSubset<T, EventInvitationUpdateArgs<ExtArgs>>): Prisma__EventInvitationClient<$Result.GetResult<Prisma.$EventInvitationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EventInvitations.
     * @param {EventInvitationDeleteManyArgs} args - Arguments to filter EventInvitations to delete.
     * @example
     * // Delete a few EventInvitations
     * const { count } = await prisma.eventInvitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventInvitationDeleteManyArgs>(args?: SelectSubset<T, EventInvitationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventInvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventInvitations
     * const eventInvitation = await prisma.eventInvitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventInvitationUpdateManyArgs>(args: SelectSubset<T, EventInvitationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventInvitations and returns the data updated in the database.
     * @param {EventInvitationUpdateManyAndReturnArgs} args - Arguments to update many EventInvitations.
     * @example
     * // Update many EventInvitations
     * const eventInvitation = await prisma.eventInvitation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EventInvitations and only return the `id`
     * const eventInvitationWithIdOnly = await prisma.eventInvitation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventInvitationUpdateManyAndReturnArgs>(args: SelectSubset<T, EventInvitationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventInvitationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EventInvitation.
     * @param {EventInvitationUpsertArgs} args - Arguments to update or create a EventInvitation.
     * @example
     * // Update or create a EventInvitation
     * const eventInvitation = await prisma.eventInvitation.upsert({
     *   create: {
     *     // ... data to create a EventInvitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventInvitation we want to update
     *   }
     * })
     */
    upsert<T extends EventInvitationUpsertArgs>(args: SelectSubset<T, EventInvitationUpsertArgs<ExtArgs>>): Prisma__EventInvitationClient<$Result.GetResult<Prisma.$EventInvitationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EventInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventInvitationCountArgs} args - Arguments to filter EventInvitations to count.
     * @example
     * // Count the number of EventInvitations
     * const count = await prisma.eventInvitation.count({
     *   where: {
     *     // ... the filter for the EventInvitations we want to count
     *   }
     * })
    **/
    count<T extends EventInvitationCountArgs>(
      args?: Subset<T, EventInvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventInvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventInvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventInvitationAggregateArgs>(args: Subset<T, EventInvitationAggregateArgs>): Prisma.PrismaPromise<GetEventInvitationAggregateType<T>>

    /**
     * Group by EventInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventInvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventInvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventInvitationGroupByArgs['orderBy'] }
        : { orderBy?: EventInvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventInvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventInvitation model
   */
  readonly fields: EventInvitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventInvitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventInvitationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    rsvps<T extends EventInvitation$rsvpsArgs<ExtArgs> = {}>(args?: Subset<T, EventInvitation$rsvpsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationRSVPPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    departmentBroadcasts<T extends EventInvitation$departmentBroadcastsArgs<ExtArgs> = {}>(args?: Subset<T, EventInvitation$departmentBroadcastsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventDepartmentBroadcastPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventInvitation model
   */
  interface EventInvitationFieldRefs {
    readonly id: FieldRef<"EventInvitation", 'String'>
    readonly orgId: FieldRef<"EventInvitation", 'String'>
    readonly title: FieldRef<"EventInvitation", 'String'>
    readonly description: FieldRef<"EventInvitation", 'String'>
    readonly eventType: FieldRef<"EventInvitation", 'EventType'>
    readonly eventDate: FieldRef<"EventInvitation", 'DateTime'>
    readonly maxAttendees: FieldRef<"EventInvitation", 'Int'>
    readonly imageUrl: FieldRef<"EventInvitation", 'String'>
    readonly token: FieldRef<"EventInvitation", 'String'>
    readonly createdBy: FieldRef<"EventInvitation", 'String'>
    readonly createdAt: FieldRef<"EventInvitation", 'DateTime'>
    readonly updatedAt: FieldRef<"EventInvitation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EventInvitation findUnique
   */
  export type EventInvitationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventInvitation
     */
    select?: EventInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventInvitation
     */
    omit?: EventInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInvitationInclude<ExtArgs> | null
    /**
     * Filter, which EventInvitation to fetch.
     */
    where: EventInvitationWhereUniqueInput
  }

  /**
   * EventInvitation findUniqueOrThrow
   */
  export type EventInvitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventInvitation
     */
    select?: EventInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventInvitation
     */
    omit?: EventInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInvitationInclude<ExtArgs> | null
    /**
     * Filter, which EventInvitation to fetch.
     */
    where: EventInvitationWhereUniqueInput
  }

  /**
   * EventInvitation findFirst
   */
  export type EventInvitationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventInvitation
     */
    select?: EventInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventInvitation
     */
    omit?: EventInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInvitationInclude<ExtArgs> | null
    /**
     * Filter, which EventInvitation to fetch.
     */
    where?: EventInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventInvitations to fetch.
     */
    orderBy?: EventInvitationOrderByWithRelationInput | EventInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventInvitations.
     */
    cursor?: EventInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventInvitations.
     */
    distinct?: EventInvitationScalarFieldEnum | EventInvitationScalarFieldEnum[]
  }

  /**
   * EventInvitation findFirstOrThrow
   */
  export type EventInvitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventInvitation
     */
    select?: EventInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventInvitation
     */
    omit?: EventInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInvitationInclude<ExtArgs> | null
    /**
     * Filter, which EventInvitation to fetch.
     */
    where?: EventInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventInvitations to fetch.
     */
    orderBy?: EventInvitationOrderByWithRelationInput | EventInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventInvitations.
     */
    cursor?: EventInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventInvitations.
     */
    distinct?: EventInvitationScalarFieldEnum | EventInvitationScalarFieldEnum[]
  }

  /**
   * EventInvitation findMany
   */
  export type EventInvitationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventInvitation
     */
    select?: EventInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventInvitation
     */
    omit?: EventInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInvitationInclude<ExtArgs> | null
    /**
     * Filter, which EventInvitations to fetch.
     */
    where?: EventInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventInvitations to fetch.
     */
    orderBy?: EventInvitationOrderByWithRelationInput | EventInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventInvitations.
     */
    cursor?: EventInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventInvitations.
     */
    skip?: number
    distinct?: EventInvitationScalarFieldEnum | EventInvitationScalarFieldEnum[]
  }

  /**
   * EventInvitation create
   */
  export type EventInvitationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventInvitation
     */
    select?: EventInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventInvitation
     */
    omit?: EventInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInvitationInclude<ExtArgs> | null
    /**
     * The data needed to create a EventInvitation.
     */
    data: XOR<EventInvitationCreateInput, EventInvitationUncheckedCreateInput>
  }

  /**
   * EventInvitation createMany
   */
  export type EventInvitationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventInvitations.
     */
    data: EventInvitationCreateManyInput | EventInvitationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventInvitation createManyAndReturn
   */
  export type EventInvitationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventInvitation
     */
    select?: EventInvitationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EventInvitation
     */
    omit?: EventInvitationOmit<ExtArgs> | null
    /**
     * The data used to create many EventInvitations.
     */
    data: EventInvitationCreateManyInput | EventInvitationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInvitationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventInvitation update
   */
  export type EventInvitationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventInvitation
     */
    select?: EventInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventInvitation
     */
    omit?: EventInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInvitationInclude<ExtArgs> | null
    /**
     * The data needed to update a EventInvitation.
     */
    data: XOR<EventInvitationUpdateInput, EventInvitationUncheckedUpdateInput>
    /**
     * Choose, which EventInvitation to update.
     */
    where: EventInvitationWhereUniqueInput
  }

  /**
   * EventInvitation updateMany
   */
  export type EventInvitationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventInvitations.
     */
    data: XOR<EventInvitationUpdateManyMutationInput, EventInvitationUncheckedUpdateManyInput>
    /**
     * Filter which EventInvitations to update
     */
    where?: EventInvitationWhereInput
    /**
     * Limit how many EventInvitations to update.
     */
    limit?: number
  }

  /**
   * EventInvitation updateManyAndReturn
   */
  export type EventInvitationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventInvitation
     */
    select?: EventInvitationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EventInvitation
     */
    omit?: EventInvitationOmit<ExtArgs> | null
    /**
     * The data used to update EventInvitations.
     */
    data: XOR<EventInvitationUpdateManyMutationInput, EventInvitationUncheckedUpdateManyInput>
    /**
     * Filter which EventInvitations to update
     */
    where?: EventInvitationWhereInput
    /**
     * Limit how many EventInvitations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInvitationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventInvitation upsert
   */
  export type EventInvitationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventInvitation
     */
    select?: EventInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventInvitation
     */
    omit?: EventInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInvitationInclude<ExtArgs> | null
    /**
     * The filter to search for the EventInvitation to update in case it exists.
     */
    where: EventInvitationWhereUniqueInput
    /**
     * In case the EventInvitation found by the `where` argument doesn't exist, create a new EventInvitation with this data.
     */
    create: XOR<EventInvitationCreateInput, EventInvitationUncheckedCreateInput>
    /**
     * In case the EventInvitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventInvitationUpdateInput, EventInvitationUncheckedUpdateInput>
  }

  /**
   * EventInvitation delete
   */
  export type EventInvitationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventInvitation
     */
    select?: EventInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventInvitation
     */
    omit?: EventInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInvitationInclude<ExtArgs> | null
    /**
     * Filter which EventInvitation to delete.
     */
    where: EventInvitationWhereUniqueInput
  }

  /**
   * EventInvitation deleteMany
   */
  export type EventInvitationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventInvitations to delete
     */
    where?: EventInvitationWhereInput
    /**
     * Limit how many EventInvitations to delete.
     */
    limit?: number
  }

  /**
   * EventInvitation.rsvps
   */
  export type EventInvitation$rsvpsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationRSVP
     */
    select?: InvitationRSVPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationRSVP
     */
    omit?: InvitationRSVPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationRSVPInclude<ExtArgs> | null
    where?: InvitationRSVPWhereInput
    orderBy?: InvitationRSVPOrderByWithRelationInput | InvitationRSVPOrderByWithRelationInput[]
    cursor?: InvitationRSVPWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvitationRSVPScalarFieldEnum | InvitationRSVPScalarFieldEnum[]
  }

  /**
   * EventInvitation.departmentBroadcasts
   */
  export type EventInvitation$departmentBroadcastsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventDepartmentBroadcast
     */
    select?: EventDepartmentBroadcastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventDepartmentBroadcast
     */
    omit?: EventDepartmentBroadcastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventDepartmentBroadcastInclude<ExtArgs> | null
    where?: EventDepartmentBroadcastWhereInput
    orderBy?: EventDepartmentBroadcastOrderByWithRelationInput | EventDepartmentBroadcastOrderByWithRelationInput[]
    cursor?: EventDepartmentBroadcastWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventDepartmentBroadcastScalarFieldEnum | EventDepartmentBroadcastScalarFieldEnum[]
  }

  /**
   * EventInvitation without action
   */
  export type EventInvitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventInvitation
     */
    select?: EventInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventInvitation
     */
    omit?: EventInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInvitationInclude<ExtArgs> | null
  }


  /**
   * Model EventDepartmentBroadcast
   */

  export type AggregateEventDepartmentBroadcast = {
    _count: EventDepartmentBroadcastCountAggregateOutputType | null
    _min: EventDepartmentBroadcastMinAggregateOutputType | null
    _max: EventDepartmentBroadcastMaxAggregateOutputType | null
  }

  export type EventDepartmentBroadcastMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    deptId: string | null
    createdAt: Date | null
  }

  export type EventDepartmentBroadcastMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    deptId: string | null
    createdAt: Date | null
  }

  export type EventDepartmentBroadcastCountAggregateOutputType = {
    id: number
    eventId: number
    deptId: number
    createdAt: number
    _all: number
  }


  export type EventDepartmentBroadcastMinAggregateInputType = {
    id?: true
    eventId?: true
    deptId?: true
    createdAt?: true
  }

  export type EventDepartmentBroadcastMaxAggregateInputType = {
    id?: true
    eventId?: true
    deptId?: true
    createdAt?: true
  }

  export type EventDepartmentBroadcastCountAggregateInputType = {
    id?: true
    eventId?: true
    deptId?: true
    createdAt?: true
    _all?: true
  }

  export type EventDepartmentBroadcastAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventDepartmentBroadcast to aggregate.
     */
    where?: EventDepartmentBroadcastWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventDepartmentBroadcasts to fetch.
     */
    orderBy?: EventDepartmentBroadcastOrderByWithRelationInput | EventDepartmentBroadcastOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventDepartmentBroadcastWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventDepartmentBroadcasts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventDepartmentBroadcasts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventDepartmentBroadcasts
    **/
    _count?: true | EventDepartmentBroadcastCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventDepartmentBroadcastMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventDepartmentBroadcastMaxAggregateInputType
  }

  export type GetEventDepartmentBroadcastAggregateType<T extends EventDepartmentBroadcastAggregateArgs> = {
        [P in keyof T & keyof AggregateEventDepartmentBroadcast]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventDepartmentBroadcast[P]>
      : GetScalarType<T[P], AggregateEventDepartmentBroadcast[P]>
  }




  export type EventDepartmentBroadcastGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventDepartmentBroadcastWhereInput
    orderBy?: EventDepartmentBroadcastOrderByWithAggregationInput | EventDepartmentBroadcastOrderByWithAggregationInput[]
    by: EventDepartmentBroadcastScalarFieldEnum[] | EventDepartmentBroadcastScalarFieldEnum
    having?: EventDepartmentBroadcastScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventDepartmentBroadcastCountAggregateInputType | true
    _min?: EventDepartmentBroadcastMinAggregateInputType
    _max?: EventDepartmentBroadcastMaxAggregateInputType
  }

  export type EventDepartmentBroadcastGroupByOutputType = {
    id: string
    eventId: string
    deptId: string
    createdAt: Date
    _count: EventDepartmentBroadcastCountAggregateOutputType | null
    _min: EventDepartmentBroadcastMinAggregateOutputType | null
    _max: EventDepartmentBroadcastMaxAggregateOutputType | null
  }

  type GetEventDepartmentBroadcastGroupByPayload<T extends EventDepartmentBroadcastGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventDepartmentBroadcastGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventDepartmentBroadcastGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventDepartmentBroadcastGroupByOutputType[P]>
            : GetScalarType<T[P], EventDepartmentBroadcastGroupByOutputType[P]>
        }
      >
    >


  export type EventDepartmentBroadcastSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    deptId?: boolean
    createdAt?: boolean
    event?: boolean | EventInvitationDefaultArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventDepartmentBroadcast"]>

  export type EventDepartmentBroadcastSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    deptId?: boolean
    createdAt?: boolean
    event?: boolean | EventInvitationDefaultArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventDepartmentBroadcast"]>

  export type EventDepartmentBroadcastSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    deptId?: boolean
    createdAt?: boolean
    event?: boolean | EventInvitationDefaultArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventDepartmentBroadcast"]>

  export type EventDepartmentBroadcastSelectScalar = {
    id?: boolean
    eventId?: boolean
    deptId?: boolean
    createdAt?: boolean
  }

  export type EventDepartmentBroadcastOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eventId" | "deptId" | "createdAt", ExtArgs["result"]["eventDepartmentBroadcast"]>
  export type EventDepartmentBroadcastInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventInvitationDefaultArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }
  export type EventDepartmentBroadcastIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventInvitationDefaultArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }
  export type EventDepartmentBroadcastIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventInvitationDefaultArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }

  export type $EventDepartmentBroadcastPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventDepartmentBroadcast"
    objects: {
      event: Prisma.$EventInvitationPayload<ExtArgs>
      department: Prisma.$DepartmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string
      deptId: string
      createdAt: Date
    }, ExtArgs["result"]["eventDepartmentBroadcast"]>
    composites: {}
  }

  type EventDepartmentBroadcastGetPayload<S extends boolean | null | undefined | EventDepartmentBroadcastDefaultArgs> = $Result.GetResult<Prisma.$EventDepartmentBroadcastPayload, S>

  type EventDepartmentBroadcastCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventDepartmentBroadcastFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventDepartmentBroadcastCountAggregateInputType | true
    }

  export interface EventDepartmentBroadcastDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventDepartmentBroadcast'], meta: { name: 'EventDepartmentBroadcast' } }
    /**
     * Find zero or one EventDepartmentBroadcast that matches the filter.
     * @param {EventDepartmentBroadcastFindUniqueArgs} args - Arguments to find a EventDepartmentBroadcast
     * @example
     * // Get one EventDepartmentBroadcast
     * const eventDepartmentBroadcast = await prisma.eventDepartmentBroadcast.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventDepartmentBroadcastFindUniqueArgs>(args: SelectSubset<T, EventDepartmentBroadcastFindUniqueArgs<ExtArgs>>): Prisma__EventDepartmentBroadcastClient<$Result.GetResult<Prisma.$EventDepartmentBroadcastPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EventDepartmentBroadcast that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventDepartmentBroadcastFindUniqueOrThrowArgs} args - Arguments to find a EventDepartmentBroadcast
     * @example
     * // Get one EventDepartmentBroadcast
     * const eventDepartmentBroadcast = await prisma.eventDepartmentBroadcast.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventDepartmentBroadcastFindUniqueOrThrowArgs>(args: SelectSubset<T, EventDepartmentBroadcastFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventDepartmentBroadcastClient<$Result.GetResult<Prisma.$EventDepartmentBroadcastPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EventDepartmentBroadcast that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventDepartmentBroadcastFindFirstArgs} args - Arguments to find a EventDepartmentBroadcast
     * @example
     * // Get one EventDepartmentBroadcast
     * const eventDepartmentBroadcast = await prisma.eventDepartmentBroadcast.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventDepartmentBroadcastFindFirstArgs>(args?: SelectSubset<T, EventDepartmentBroadcastFindFirstArgs<ExtArgs>>): Prisma__EventDepartmentBroadcastClient<$Result.GetResult<Prisma.$EventDepartmentBroadcastPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EventDepartmentBroadcast that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventDepartmentBroadcastFindFirstOrThrowArgs} args - Arguments to find a EventDepartmentBroadcast
     * @example
     * // Get one EventDepartmentBroadcast
     * const eventDepartmentBroadcast = await prisma.eventDepartmentBroadcast.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventDepartmentBroadcastFindFirstOrThrowArgs>(args?: SelectSubset<T, EventDepartmentBroadcastFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventDepartmentBroadcastClient<$Result.GetResult<Prisma.$EventDepartmentBroadcastPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EventDepartmentBroadcasts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventDepartmentBroadcastFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventDepartmentBroadcasts
     * const eventDepartmentBroadcasts = await prisma.eventDepartmentBroadcast.findMany()
     * 
     * // Get first 10 EventDepartmentBroadcasts
     * const eventDepartmentBroadcasts = await prisma.eventDepartmentBroadcast.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventDepartmentBroadcastWithIdOnly = await prisma.eventDepartmentBroadcast.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventDepartmentBroadcastFindManyArgs>(args?: SelectSubset<T, EventDepartmentBroadcastFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventDepartmentBroadcastPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EventDepartmentBroadcast.
     * @param {EventDepartmentBroadcastCreateArgs} args - Arguments to create a EventDepartmentBroadcast.
     * @example
     * // Create one EventDepartmentBroadcast
     * const EventDepartmentBroadcast = await prisma.eventDepartmentBroadcast.create({
     *   data: {
     *     // ... data to create a EventDepartmentBroadcast
     *   }
     * })
     * 
     */
    create<T extends EventDepartmentBroadcastCreateArgs>(args: SelectSubset<T, EventDepartmentBroadcastCreateArgs<ExtArgs>>): Prisma__EventDepartmentBroadcastClient<$Result.GetResult<Prisma.$EventDepartmentBroadcastPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EventDepartmentBroadcasts.
     * @param {EventDepartmentBroadcastCreateManyArgs} args - Arguments to create many EventDepartmentBroadcasts.
     * @example
     * // Create many EventDepartmentBroadcasts
     * const eventDepartmentBroadcast = await prisma.eventDepartmentBroadcast.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventDepartmentBroadcastCreateManyArgs>(args?: SelectSubset<T, EventDepartmentBroadcastCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EventDepartmentBroadcasts and returns the data saved in the database.
     * @param {EventDepartmentBroadcastCreateManyAndReturnArgs} args - Arguments to create many EventDepartmentBroadcasts.
     * @example
     * // Create many EventDepartmentBroadcasts
     * const eventDepartmentBroadcast = await prisma.eventDepartmentBroadcast.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EventDepartmentBroadcasts and only return the `id`
     * const eventDepartmentBroadcastWithIdOnly = await prisma.eventDepartmentBroadcast.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventDepartmentBroadcastCreateManyAndReturnArgs>(args?: SelectSubset<T, EventDepartmentBroadcastCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventDepartmentBroadcastPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EventDepartmentBroadcast.
     * @param {EventDepartmentBroadcastDeleteArgs} args - Arguments to delete one EventDepartmentBroadcast.
     * @example
     * // Delete one EventDepartmentBroadcast
     * const EventDepartmentBroadcast = await prisma.eventDepartmentBroadcast.delete({
     *   where: {
     *     // ... filter to delete one EventDepartmentBroadcast
     *   }
     * })
     * 
     */
    delete<T extends EventDepartmentBroadcastDeleteArgs>(args: SelectSubset<T, EventDepartmentBroadcastDeleteArgs<ExtArgs>>): Prisma__EventDepartmentBroadcastClient<$Result.GetResult<Prisma.$EventDepartmentBroadcastPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EventDepartmentBroadcast.
     * @param {EventDepartmentBroadcastUpdateArgs} args - Arguments to update one EventDepartmentBroadcast.
     * @example
     * // Update one EventDepartmentBroadcast
     * const eventDepartmentBroadcast = await prisma.eventDepartmentBroadcast.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventDepartmentBroadcastUpdateArgs>(args: SelectSubset<T, EventDepartmentBroadcastUpdateArgs<ExtArgs>>): Prisma__EventDepartmentBroadcastClient<$Result.GetResult<Prisma.$EventDepartmentBroadcastPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EventDepartmentBroadcasts.
     * @param {EventDepartmentBroadcastDeleteManyArgs} args - Arguments to filter EventDepartmentBroadcasts to delete.
     * @example
     * // Delete a few EventDepartmentBroadcasts
     * const { count } = await prisma.eventDepartmentBroadcast.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventDepartmentBroadcastDeleteManyArgs>(args?: SelectSubset<T, EventDepartmentBroadcastDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventDepartmentBroadcasts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventDepartmentBroadcastUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventDepartmentBroadcasts
     * const eventDepartmentBroadcast = await prisma.eventDepartmentBroadcast.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventDepartmentBroadcastUpdateManyArgs>(args: SelectSubset<T, EventDepartmentBroadcastUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventDepartmentBroadcasts and returns the data updated in the database.
     * @param {EventDepartmentBroadcastUpdateManyAndReturnArgs} args - Arguments to update many EventDepartmentBroadcasts.
     * @example
     * // Update many EventDepartmentBroadcasts
     * const eventDepartmentBroadcast = await prisma.eventDepartmentBroadcast.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EventDepartmentBroadcasts and only return the `id`
     * const eventDepartmentBroadcastWithIdOnly = await prisma.eventDepartmentBroadcast.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventDepartmentBroadcastUpdateManyAndReturnArgs>(args: SelectSubset<T, EventDepartmentBroadcastUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventDepartmentBroadcastPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EventDepartmentBroadcast.
     * @param {EventDepartmentBroadcastUpsertArgs} args - Arguments to update or create a EventDepartmentBroadcast.
     * @example
     * // Update or create a EventDepartmentBroadcast
     * const eventDepartmentBroadcast = await prisma.eventDepartmentBroadcast.upsert({
     *   create: {
     *     // ... data to create a EventDepartmentBroadcast
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventDepartmentBroadcast we want to update
     *   }
     * })
     */
    upsert<T extends EventDepartmentBroadcastUpsertArgs>(args: SelectSubset<T, EventDepartmentBroadcastUpsertArgs<ExtArgs>>): Prisma__EventDepartmentBroadcastClient<$Result.GetResult<Prisma.$EventDepartmentBroadcastPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EventDepartmentBroadcasts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventDepartmentBroadcastCountArgs} args - Arguments to filter EventDepartmentBroadcasts to count.
     * @example
     * // Count the number of EventDepartmentBroadcasts
     * const count = await prisma.eventDepartmentBroadcast.count({
     *   where: {
     *     // ... the filter for the EventDepartmentBroadcasts we want to count
     *   }
     * })
    **/
    count<T extends EventDepartmentBroadcastCountArgs>(
      args?: Subset<T, EventDepartmentBroadcastCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventDepartmentBroadcastCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventDepartmentBroadcast.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventDepartmentBroadcastAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventDepartmentBroadcastAggregateArgs>(args: Subset<T, EventDepartmentBroadcastAggregateArgs>): Prisma.PrismaPromise<GetEventDepartmentBroadcastAggregateType<T>>

    /**
     * Group by EventDepartmentBroadcast.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventDepartmentBroadcastGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventDepartmentBroadcastGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventDepartmentBroadcastGroupByArgs['orderBy'] }
        : { orderBy?: EventDepartmentBroadcastGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventDepartmentBroadcastGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventDepartmentBroadcastGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventDepartmentBroadcast model
   */
  readonly fields: EventDepartmentBroadcastFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventDepartmentBroadcast.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventDepartmentBroadcastClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends EventInvitationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventInvitationDefaultArgs<ExtArgs>>): Prisma__EventInvitationClient<$Result.GetResult<Prisma.$EventInvitationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    department<T extends DepartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DepartmentDefaultArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventDepartmentBroadcast model
   */
  interface EventDepartmentBroadcastFieldRefs {
    readonly id: FieldRef<"EventDepartmentBroadcast", 'String'>
    readonly eventId: FieldRef<"EventDepartmentBroadcast", 'String'>
    readonly deptId: FieldRef<"EventDepartmentBroadcast", 'String'>
    readonly createdAt: FieldRef<"EventDepartmentBroadcast", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EventDepartmentBroadcast findUnique
   */
  export type EventDepartmentBroadcastFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventDepartmentBroadcast
     */
    select?: EventDepartmentBroadcastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventDepartmentBroadcast
     */
    omit?: EventDepartmentBroadcastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventDepartmentBroadcastInclude<ExtArgs> | null
    /**
     * Filter, which EventDepartmentBroadcast to fetch.
     */
    where: EventDepartmentBroadcastWhereUniqueInput
  }

  /**
   * EventDepartmentBroadcast findUniqueOrThrow
   */
  export type EventDepartmentBroadcastFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventDepartmentBroadcast
     */
    select?: EventDepartmentBroadcastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventDepartmentBroadcast
     */
    omit?: EventDepartmentBroadcastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventDepartmentBroadcastInclude<ExtArgs> | null
    /**
     * Filter, which EventDepartmentBroadcast to fetch.
     */
    where: EventDepartmentBroadcastWhereUniqueInput
  }

  /**
   * EventDepartmentBroadcast findFirst
   */
  export type EventDepartmentBroadcastFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventDepartmentBroadcast
     */
    select?: EventDepartmentBroadcastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventDepartmentBroadcast
     */
    omit?: EventDepartmentBroadcastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventDepartmentBroadcastInclude<ExtArgs> | null
    /**
     * Filter, which EventDepartmentBroadcast to fetch.
     */
    where?: EventDepartmentBroadcastWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventDepartmentBroadcasts to fetch.
     */
    orderBy?: EventDepartmentBroadcastOrderByWithRelationInput | EventDepartmentBroadcastOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventDepartmentBroadcasts.
     */
    cursor?: EventDepartmentBroadcastWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventDepartmentBroadcasts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventDepartmentBroadcasts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventDepartmentBroadcasts.
     */
    distinct?: EventDepartmentBroadcastScalarFieldEnum | EventDepartmentBroadcastScalarFieldEnum[]
  }

  /**
   * EventDepartmentBroadcast findFirstOrThrow
   */
  export type EventDepartmentBroadcastFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventDepartmentBroadcast
     */
    select?: EventDepartmentBroadcastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventDepartmentBroadcast
     */
    omit?: EventDepartmentBroadcastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventDepartmentBroadcastInclude<ExtArgs> | null
    /**
     * Filter, which EventDepartmentBroadcast to fetch.
     */
    where?: EventDepartmentBroadcastWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventDepartmentBroadcasts to fetch.
     */
    orderBy?: EventDepartmentBroadcastOrderByWithRelationInput | EventDepartmentBroadcastOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventDepartmentBroadcasts.
     */
    cursor?: EventDepartmentBroadcastWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventDepartmentBroadcasts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventDepartmentBroadcasts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventDepartmentBroadcasts.
     */
    distinct?: EventDepartmentBroadcastScalarFieldEnum | EventDepartmentBroadcastScalarFieldEnum[]
  }

  /**
   * EventDepartmentBroadcast findMany
   */
  export type EventDepartmentBroadcastFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventDepartmentBroadcast
     */
    select?: EventDepartmentBroadcastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventDepartmentBroadcast
     */
    omit?: EventDepartmentBroadcastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventDepartmentBroadcastInclude<ExtArgs> | null
    /**
     * Filter, which EventDepartmentBroadcasts to fetch.
     */
    where?: EventDepartmentBroadcastWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventDepartmentBroadcasts to fetch.
     */
    orderBy?: EventDepartmentBroadcastOrderByWithRelationInput | EventDepartmentBroadcastOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventDepartmentBroadcasts.
     */
    cursor?: EventDepartmentBroadcastWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventDepartmentBroadcasts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventDepartmentBroadcasts.
     */
    skip?: number
    distinct?: EventDepartmentBroadcastScalarFieldEnum | EventDepartmentBroadcastScalarFieldEnum[]
  }

  /**
   * EventDepartmentBroadcast create
   */
  export type EventDepartmentBroadcastCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventDepartmentBroadcast
     */
    select?: EventDepartmentBroadcastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventDepartmentBroadcast
     */
    omit?: EventDepartmentBroadcastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventDepartmentBroadcastInclude<ExtArgs> | null
    /**
     * The data needed to create a EventDepartmentBroadcast.
     */
    data: XOR<EventDepartmentBroadcastCreateInput, EventDepartmentBroadcastUncheckedCreateInput>
  }

  /**
   * EventDepartmentBroadcast createMany
   */
  export type EventDepartmentBroadcastCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventDepartmentBroadcasts.
     */
    data: EventDepartmentBroadcastCreateManyInput | EventDepartmentBroadcastCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventDepartmentBroadcast createManyAndReturn
   */
  export type EventDepartmentBroadcastCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventDepartmentBroadcast
     */
    select?: EventDepartmentBroadcastSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EventDepartmentBroadcast
     */
    omit?: EventDepartmentBroadcastOmit<ExtArgs> | null
    /**
     * The data used to create many EventDepartmentBroadcasts.
     */
    data: EventDepartmentBroadcastCreateManyInput | EventDepartmentBroadcastCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventDepartmentBroadcastIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventDepartmentBroadcast update
   */
  export type EventDepartmentBroadcastUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventDepartmentBroadcast
     */
    select?: EventDepartmentBroadcastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventDepartmentBroadcast
     */
    omit?: EventDepartmentBroadcastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventDepartmentBroadcastInclude<ExtArgs> | null
    /**
     * The data needed to update a EventDepartmentBroadcast.
     */
    data: XOR<EventDepartmentBroadcastUpdateInput, EventDepartmentBroadcastUncheckedUpdateInput>
    /**
     * Choose, which EventDepartmentBroadcast to update.
     */
    where: EventDepartmentBroadcastWhereUniqueInput
  }

  /**
   * EventDepartmentBroadcast updateMany
   */
  export type EventDepartmentBroadcastUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventDepartmentBroadcasts.
     */
    data: XOR<EventDepartmentBroadcastUpdateManyMutationInput, EventDepartmentBroadcastUncheckedUpdateManyInput>
    /**
     * Filter which EventDepartmentBroadcasts to update
     */
    where?: EventDepartmentBroadcastWhereInput
    /**
     * Limit how many EventDepartmentBroadcasts to update.
     */
    limit?: number
  }

  /**
   * EventDepartmentBroadcast updateManyAndReturn
   */
  export type EventDepartmentBroadcastUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventDepartmentBroadcast
     */
    select?: EventDepartmentBroadcastSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EventDepartmentBroadcast
     */
    omit?: EventDepartmentBroadcastOmit<ExtArgs> | null
    /**
     * The data used to update EventDepartmentBroadcasts.
     */
    data: XOR<EventDepartmentBroadcastUpdateManyMutationInput, EventDepartmentBroadcastUncheckedUpdateManyInput>
    /**
     * Filter which EventDepartmentBroadcasts to update
     */
    where?: EventDepartmentBroadcastWhereInput
    /**
     * Limit how many EventDepartmentBroadcasts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventDepartmentBroadcastIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventDepartmentBroadcast upsert
   */
  export type EventDepartmentBroadcastUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventDepartmentBroadcast
     */
    select?: EventDepartmentBroadcastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventDepartmentBroadcast
     */
    omit?: EventDepartmentBroadcastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventDepartmentBroadcastInclude<ExtArgs> | null
    /**
     * The filter to search for the EventDepartmentBroadcast to update in case it exists.
     */
    where: EventDepartmentBroadcastWhereUniqueInput
    /**
     * In case the EventDepartmentBroadcast found by the `where` argument doesn't exist, create a new EventDepartmentBroadcast with this data.
     */
    create: XOR<EventDepartmentBroadcastCreateInput, EventDepartmentBroadcastUncheckedCreateInput>
    /**
     * In case the EventDepartmentBroadcast was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventDepartmentBroadcastUpdateInput, EventDepartmentBroadcastUncheckedUpdateInput>
  }

  /**
   * EventDepartmentBroadcast delete
   */
  export type EventDepartmentBroadcastDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventDepartmentBroadcast
     */
    select?: EventDepartmentBroadcastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventDepartmentBroadcast
     */
    omit?: EventDepartmentBroadcastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventDepartmentBroadcastInclude<ExtArgs> | null
    /**
     * Filter which EventDepartmentBroadcast to delete.
     */
    where: EventDepartmentBroadcastWhereUniqueInput
  }

  /**
   * EventDepartmentBroadcast deleteMany
   */
  export type EventDepartmentBroadcastDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventDepartmentBroadcasts to delete
     */
    where?: EventDepartmentBroadcastWhereInput
    /**
     * Limit how many EventDepartmentBroadcasts to delete.
     */
    limit?: number
  }

  /**
   * EventDepartmentBroadcast without action
   */
  export type EventDepartmentBroadcastDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventDepartmentBroadcast
     */
    select?: EventDepartmentBroadcastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventDepartmentBroadcast
     */
    omit?: EventDepartmentBroadcastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventDepartmentBroadcastInclude<ExtArgs> | null
  }


  /**
   * Model InvitationRSVP
   */

  export type AggregateInvitationRSVP = {
    _count: InvitationRSVPCountAggregateOutputType | null
    _min: InvitationRSVPMinAggregateOutputType | null
    _max: InvitationRSVPMaxAggregateOutputType | null
  }

  export type InvitationRSVPMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    name: string | null
    phone: string | null
    createdAt: Date | null
  }

  export type InvitationRSVPMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    name: string | null
    phone: string | null
    createdAt: Date | null
  }

  export type InvitationRSVPCountAggregateOutputType = {
    id: number
    eventId: number
    name: number
    phone: number
    createdAt: number
    _all: number
  }


  export type InvitationRSVPMinAggregateInputType = {
    id?: true
    eventId?: true
    name?: true
    phone?: true
    createdAt?: true
  }

  export type InvitationRSVPMaxAggregateInputType = {
    id?: true
    eventId?: true
    name?: true
    phone?: true
    createdAt?: true
  }

  export type InvitationRSVPCountAggregateInputType = {
    id?: true
    eventId?: true
    name?: true
    phone?: true
    createdAt?: true
    _all?: true
  }

  export type InvitationRSVPAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvitationRSVP to aggregate.
     */
    where?: InvitationRSVPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvitationRSVPS to fetch.
     */
    orderBy?: InvitationRSVPOrderByWithRelationInput | InvitationRSVPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvitationRSVPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvitationRSVPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvitationRSVPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvitationRSVPS
    **/
    _count?: true | InvitationRSVPCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvitationRSVPMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvitationRSVPMaxAggregateInputType
  }

  export type GetInvitationRSVPAggregateType<T extends InvitationRSVPAggregateArgs> = {
        [P in keyof T & keyof AggregateInvitationRSVP]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvitationRSVP[P]>
      : GetScalarType<T[P], AggregateInvitationRSVP[P]>
  }




  export type InvitationRSVPGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationRSVPWhereInput
    orderBy?: InvitationRSVPOrderByWithAggregationInput | InvitationRSVPOrderByWithAggregationInput[]
    by: InvitationRSVPScalarFieldEnum[] | InvitationRSVPScalarFieldEnum
    having?: InvitationRSVPScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvitationRSVPCountAggregateInputType | true
    _min?: InvitationRSVPMinAggregateInputType
    _max?: InvitationRSVPMaxAggregateInputType
  }

  export type InvitationRSVPGroupByOutputType = {
    id: string
    eventId: string
    name: string
    phone: string
    createdAt: Date
    _count: InvitationRSVPCountAggregateOutputType | null
    _min: InvitationRSVPMinAggregateOutputType | null
    _max: InvitationRSVPMaxAggregateOutputType | null
  }

  type GetInvitationRSVPGroupByPayload<T extends InvitationRSVPGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvitationRSVPGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvitationRSVPGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvitationRSVPGroupByOutputType[P]>
            : GetScalarType<T[P], InvitationRSVPGroupByOutputType[P]>
        }
      >
    >


  export type InvitationRSVPSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    name?: boolean
    phone?: boolean
    createdAt?: boolean
    event?: boolean | EventInvitationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitationRSVP"]>

  export type InvitationRSVPSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    name?: boolean
    phone?: boolean
    createdAt?: boolean
    event?: boolean | EventInvitationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitationRSVP"]>

  export type InvitationRSVPSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    name?: boolean
    phone?: boolean
    createdAt?: boolean
    event?: boolean | EventInvitationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitationRSVP"]>

  export type InvitationRSVPSelectScalar = {
    id?: boolean
    eventId?: boolean
    name?: boolean
    phone?: boolean
    createdAt?: boolean
  }

  export type InvitationRSVPOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eventId" | "name" | "phone" | "createdAt", ExtArgs["result"]["invitationRSVP"]>
  export type InvitationRSVPInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventInvitationDefaultArgs<ExtArgs>
  }
  export type InvitationRSVPIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventInvitationDefaultArgs<ExtArgs>
  }
  export type InvitationRSVPIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventInvitationDefaultArgs<ExtArgs>
  }

  export type $InvitationRSVPPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvitationRSVP"
    objects: {
      event: Prisma.$EventInvitationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string
      name: string
      phone: string
      createdAt: Date
    }, ExtArgs["result"]["invitationRSVP"]>
    composites: {}
  }

  type InvitationRSVPGetPayload<S extends boolean | null | undefined | InvitationRSVPDefaultArgs> = $Result.GetResult<Prisma.$InvitationRSVPPayload, S>

  type InvitationRSVPCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvitationRSVPFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvitationRSVPCountAggregateInputType | true
    }

  export interface InvitationRSVPDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvitationRSVP'], meta: { name: 'InvitationRSVP' } }
    /**
     * Find zero or one InvitationRSVP that matches the filter.
     * @param {InvitationRSVPFindUniqueArgs} args - Arguments to find a InvitationRSVP
     * @example
     * // Get one InvitationRSVP
     * const invitationRSVP = await prisma.invitationRSVP.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvitationRSVPFindUniqueArgs>(args: SelectSubset<T, InvitationRSVPFindUniqueArgs<ExtArgs>>): Prisma__InvitationRSVPClient<$Result.GetResult<Prisma.$InvitationRSVPPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InvitationRSVP that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvitationRSVPFindUniqueOrThrowArgs} args - Arguments to find a InvitationRSVP
     * @example
     * // Get one InvitationRSVP
     * const invitationRSVP = await prisma.invitationRSVP.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvitationRSVPFindUniqueOrThrowArgs>(args: SelectSubset<T, InvitationRSVPFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvitationRSVPClient<$Result.GetResult<Prisma.$InvitationRSVPPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvitationRSVP that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationRSVPFindFirstArgs} args - Arguments to find a InvitationRSVP
     * @example
     * // Get one InvitationRSVP
     * const invitationRSVP = await prisma.invitationRSVP.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvitationRSVPFindFirstArgs>(args?: SelectSubset<T, InvitationRSVPFindFirstArgs<ExtArgs>>): Prisma__InvitationRSVPClient<$Result.GetResult<Prisma.$InvitationRSVPPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvitationRSVP that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationRSVPFindFirstOrThrowArgs} args - Arguments to find a InvitationRSVP
     * @example
     * // Get one InvitationRSVP
     * const invitationRSVP = await prisma.invitationRSVP.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvitationRSVPFindFirstOrThrowArgs>(args?: SelectSubset<T, InvitationRSVPFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvitationRSVPClient<$Result.GetResult<Prisma.$InvitationRSVPPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InvitationRSVPS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationRSVPFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvitationRSVPS
     * const invitationRSVPS = await prisma.invitationRSVP.findMany()
     * 
     * // Get first 10 InvitationRSVPS
     * const invitationRSVPS = await prisma.invitationRSVP.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invitationRSVPWithIdOnly = await prisma.invitationRSVP.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvitationRSVPFindManyArgs>(args?: SelectSubset<T, InvitationRSVPFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationRSVPPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InvitationRSVP.
     * @param {InvitationRSVPCreateArgs} args - Arguments to create a InvitationRSVP.
     * @example
     * // Create one InvitationRSVP
     * const InvitationRSVP = await prisma.invitationRSVP.create({
     *   data: {
     *     // ... data to create a InvitationRSVP
     *   }
     * })
     * 
     */
    create<T extends InvitationRSVPCreateArgs>(args: SelectSubset<T, InvitationRSVPCreateArgs<ExtArgs>>): Prisma__InvitationRSVPClient<$Result.GetResult<Prisma.$InvitationRSVPPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InvitationRSVPS.
     * @param {InvitationRSVPCreateManyArgs} args - Arguments to create many InvitationRSVPS.
     * @example
     * // Create many InvitationRSVPS
     * const invitationRSVP = await prisma.invitationRSVP.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvitationRSVPCreateManyArgs>(args?: SelectSubset<T, InvitationRSVPCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvitationRSVPS and returns the data saved in the database.
     * @param {InvitationRSVPCreateManyAndReturnArgs} args - Arguments to create many InvitationRSVPS.
     * @example
     * // Create many InvitationRSVPS
     * const invitationRSVP = await prisma.invitationRSVP.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvitationRSVPS and only return the `id`
     * const invitationRSVPWithIdOnly = await prisma.invitationRSVP.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvitationRSVPCreateManyAndReturnArgs>(args?: SelectSubset<T, InvitationRSVPCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationRSVPPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InvitationRSVP.
     * @param {InvitationRSVPDeleteArgs} args - Arguments to delete one InvitationRSVP.
     * @example
     * // Delete one InvitationRSVP
     * const InvitationRSVP = await prisma.invitationRSVP.delete({
     *   where: {
     *     // ... filter to delete one InvitationRSVP
     *   }
     * })
     * 
     */
    delete<T extends InvitationRSVPDeleteArgs>(args: SelectSubset<T, InvitationRSVPDeleteArgs<ExtArgs>>): Prisma__InvitationRSVPClient<$Result.GetResult<Prisma.$InvitationRSVPPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InvitationRSVP.
     * @param {InvitationRSVPUpdateArgs} args - Arguments to update one InvitationRSVP.
     * @example
     * // Update one InvitationRSVP
     * const invitationRSVP = await prisma.invitationRSVP.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvitationRSVPUpdateArgs>(args: SelectSubset<T, InvitationRSVPUpdateArgs<ExtArgs>>): Prisma__InvitationRSVPClient<$Result.GetResult<Prisma.$InvitationRSVPPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InvitationRSVPS.
     * @param {InvitationRSVPDeleteManyArgs} args - Arguments to filter InvitationRSVPS to delete.
     * @example
     * // Delete a few InvitationRSVPS
     * const { count } = await prisma.invitationRSVP.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvitationRSVPDeleteManyArgs>(args?: SelectSubset<T, InvitationRSVPDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvitationRSVPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationRSVPUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvitationRSVPS
     * const invitationRSVP = await prisma.invitationRSVP.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvitationRSVPUpdateManyArgs>(args: SelectSubset<T, InvitationRSVPUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvitationRSVPS and returns the data updated in the database.
     * @param {InvitationRSVPUpdateManyAndReturnArgs} args - Arguments to update many InvitationRSVPS.
     * @example
     * // Update many InvitationRSVPS
     * const invitationRSVP = await prisma.invitationRSVP.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InvitationRSVPS and only return the `id`
     * const invitationRSVPWithIdOnly = await prisma.invitationRSVP.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvitationRSVPUpdateManyAndReturnArgs>(args: SelectSubset<T, InvitationRSVPUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationRSVPPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InvitationRSVP.
     * @param {InvitationRSVPUpsertArgs} args - Arguments to update or create a InvitationRSVP.
     * @example
     * // Update or create a InvitationRSVP
     * const invitationRSVP = await prisma.invitationRSVP.upsert({
     *   create: {
     *     // ... data to create a InvitationRSVP
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvitationRSVP we want to update
     *   }
     * })
     */
    upsert<T extends InvitationRSVPUpsertArgs>(args: SelectSubset<T, InvitationRSVPUpsertArgs<ExtArgs>>): Prisma__InvitationRSVPClient<$Result.GetResult<Prisma.$InvitationRSVPPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InvitationRSVPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationRSVPCountArgs} args - Arguments to filter InvitationRSVPS to count.
     * @example
     * // Count the number of InvitationRSVPS
     * const count = await prisma.invitationRSVP.count({
     *   where: {
     *     // ... the filter for the InvitationRSVPS we want to count
     *   }
     * })
    **/
    count<T extends InvitationRSVPCountArgs>(
      args?: Subset<T, InvitationRSVPCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvitationRSVPCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvitationRSVP.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationRSVPAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvitationRSVPAggregateArgs>(args: Subset<T, InvitationRSVPAggregateArgs>): Prisma.PrismaPromise<GetInvitationRSVPAggregateType<T>>

    /**
     * Group by InvitationRSVP.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationRSVPGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvitationRSVPGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvitationRSVPGroupByArgs['orderBy'] }
        : { orderBy?: InvitationRSVPGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvitationRSVPGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvitationRSVPGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvitationRSVP model
   */
  readonly fields: InvitationRSVPFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvitationRSVP.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvitationRSVPClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends EventInvitationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventInvitationDefaultArgs<ExtArgs>>): Prisma__EventInvitationClient<$Result.GetResult<Prisma.$EventInvitationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvitationRSVP model
   */
  interface InvitationRSVPFieldRefs {
    readonly id: FieldRef<"InvitationRSVP", 'String'>
    readonly eventId: FieldRef<"InvitationRSVP", 'String'>
    readonly name: FieldRef<"InvitationRSVP", 'String'>
    readonly phone: FieldRef<"InvitationRSVP", 'String'>
    readonly createdAt: FieldRef<"InvitationRSVP", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InvitationRSVP findUnique
   */
  export type InvitationRSVPFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationRSVP
     */
    select?: InvitationRSVPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationRSVP
     */
    omit?: InvitationRSVPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationRSVPInclude<ExtArgs> | null
    /**
     * Filter, which InvitationRSVP to fetch.
     */
    where: InvitationRSVPWhereUniqueInput
  }

  /**
   * InvitationRSVP findUniqueOrThrow
   */
  export type InvitationRSVPFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationRSVP
     */
    select?: InvitationRSVPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationRSVP
     */
    omit?: InvitationRSVPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationRSVPInclude<ExtArgs> | null
    /**
     * Filter, which InvitationRSVP to fetch.
     */
    where: InvitationRSVPWhereUniqueInput
  }

  /**
   * InvitationRSVP findFirst
   */
  export type InvitationRSVPFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationRSVP
     */
    select?: InvitationRSVPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationRSVP
     */
    omit?: InvitationRSVPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationRSVPInclude<ExtArgs> | null
    /**
     * Filter, which InvitationRSVP to fetch.
     */
    where?: InvitationRSVPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvitationRSVPS to fetch.
     */
    orderBy?: InvitationRSVPOrderByWithRelationInput | InvitationRSVPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvitationRSVPS.
     */
    cursor?: InvitationRSVPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvitationRSVPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvitationRSVPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvitationRSVPS.
     */
    distinct?: InvitationRSVPScalarFieldEnum | InvitationRSVPScalarFieldEnum[]
  }

  /**
   * InvitationRSVP findFirstOrThrow
   */
  export type InvitationRSVPFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationRSVP
     */
    select?: InvitationRSVPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationRSVP
     */
    omit?: InvitationRSVPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationRSVPInclude<ExtArgs> | null
    /**
     * Filter, which InvitationRSVP to fetch.
     */
    where?: InvitationRSVPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvitationRSVPS to fetch.
     */
    orderBy?: InvitationRSVPOrderByWithRelationInput | InvitationRSVPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvitationRSVPS.
     */
    cursor?: InvitationRSVPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvitationRSVPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvitationRSVPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvitationRSVPS.
     */
    distinct?: InvitationRSVPScalarFieldEnum | InvitationRSVPScalarFieldEnum[]
  }

  /**
   * InvitationRSVP findMany
   */
  export type InvitationRSVPFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationRSVP
     */
    select?: InvitationRSVPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationRSVP
     */
    omit?: InvitationRSVPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationRSVPInclude<ExtArgs> | null
    /**
     * Filter, which InvitationRSVPS to fetch.
     */
    where?: InvitationRSVPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvitationRSVPS to fetch.
     */
    orderBy?: InvitationRSVPOrderByWithRelationInput | InvitationRSVPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvitationRSVPS.
     */
    cursor?: InvitationRSVPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvitationRSVPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvitationRSVPS.
     */
    skip?: number
    distinct?: InvitationRSVPScalarFieldEnum | InvitationRSVPScalarFieldEnum[]
  }

  /**
   * InvitationRSVP create
   */
  export type InvitationRSVPCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationRSVP
     */
    select?: InvitationRSVPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationRSVP
     */
    omit?: InvitationRSVPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationRSVPInclude<ExtArgs> | null
    /**
     * The data needed to create a InvitationRSVP.
     */
    data: XOR<InvitationRSVPCreateInput, InvitationRSVPUncheckedCreateInput>
  }

  /**
   * InvitationRSVP createMany
   */
  export type InvitationRSVPCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvitationRSVPS.
     */
    data: InvitationRSVPCreateManyInput | InvitationRSVPCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvitationRSVP createManyAndReturn
   */
  export type InvitationRSVPCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationRSVP
     */
    select?: InvitationRSVPSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationRSVP
     */
    omit?: InvitationRSVPOmit<ExtArgs> | null
    /**
     * The data used to create many InvitationRSVPS.
     */
    data: InvitationRSVPCreateManyInput | InvitationRSVPCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationRSVPIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvitationRSVP update
   */
  export type InvitationRSVPUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationRSVP
     */
    select?: InvitationRSVPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationRSVP
     */
    omit?: InvitationRSVPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationRSVPInclude<ExtArgs> | null
    /**
     * The data needed to update a InvitationRSVP.
     */
    data: XOR<InvitationRSVPUpdateInput, InvitationRSVPUncheckedUpdateInput>
    /**
     * Choose, which InvitationRSVP to update.
     */
    where: InvitationRSVPWhereUniqueInput
  }

  /**
   * InvitationRSVP updateMany
   */
  export type InvitationRSVPUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvitationRSVPS.
     */
    data: XOR<InvitationRSVPUpdateManyMutationInput, InvitationRSVPUncheckedUpdateManyInput>
    /**
     * Filter which InvitationRSVPS to update
     */
    where?: InvitationRSVPWhereInput
    /**
     * Limit how many InvitationRSVPS to update.
     */
    limit?: number
  }

  /**
   * InvitationRSVP updateManyAndReturn
   */
  export type InvitationRSVPUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationRSVP
     */
    select?: InvitationRSVPSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationRSVP
     */
    omit?: InvitationRSVPOmit<ExtArgs> | null
    /**
     * The data used to update InvitationRSVPS.
     */
    data: XOR<InvitationRSVPUpdateManyMutationInput, InvitationRSVPUncheckedUpdateManyInput>
    /**
     * Filter which InvitationRSVPS to update
     */
    where?: InvitationRSVPWhereInput
    /**
     * Limit how many InvitationRSVPS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationRSVPIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvitationRSVP upsert
   */
  export type InvitationRSVPUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationRSVP
     */
    select?: InvitationRSVPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationRSVP
     */
    omit?: InvitationRSVPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationRSVPInclude<ExtArgs> | null
    /**
     * The filter to search for the InvitationRSVP to update in case it exists.
     */
    where: InvitationRSVPWhereUniqueInput
    /**
     * In case the InvitationRSVP found by the `where` argument doesn't exist, create a new InvitationRSVP with this data.
     */
    create: XOR<InvitationRSVPCreateInput, InvitationRSVPUncheckedCreateInput>
    /**
     * In case the InvitationRSVP was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvitationRSVPUpdateInput, InvitationRSVPUncheckedUpdateInput>
  }

  /**
   * InvitationRSVP delete
   */
  export type InvitationRSVPDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationRSVP
     */
    select?: InvitationRSVPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationRSVP
     */
    omit?: InvitationRSVPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationRSVPInclude<ExtArgs> | null
    /**
     * Filter which InvitationRSVP to delete.
     */
    where: InvitationRSVPWhereUniqueInput
  }

  /**
   * InvitationRSVP deleteMany
   */
  export type InvitationRSVPDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvitationRSVPS to delete
     */
    where?: InvitationRSVPWhereInput
    /**
     * Limit how many InvitationRSVPS to delete.
     */
    limit?: number
  }

  /**
   * InvitationRSVP without action
   */
  export type InvitationRSVPDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationRSVP
     */
    select?: InvitationRSVPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvitationRSVP
     */
    omit?: InvitationRSVPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationRSVPInclude<ExtArgs> | null
  }


  /**
   * Model UserPage
   */

  export type AggregateUserPage = {
    _count: UserPageCountAggregateOutputType | null
    _min: UserPageMinAggregateOutputType | null
    _max: UserPageMaxAggregateOutputType | null
  }

  export type UserPageMinAggregateOutputType = {
    id: string | null
    userId: string | null
    handle: string | null
    bio: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPageMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    handle: string | null
    bio: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPageCountAggregateOutputType = {
    id: number
    userId: number
    handle: number
    bio: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserPageMinAggregateInputType = {
    id?: true
    userId?: true
    handle?: true
    bio?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPageMaxAggregateInputType = {
    id?: true
    userId?: true
    handle?: true
    bio?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPageCountAggregateInputType = {
    id?: true
    userId?: true
    handle?: true
    bio?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserPageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPage to aggregate.
     */
    where?: UserPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPages to fetch.
     */
    orderBy?: UserPageOrderByWithRelationInput | UserPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPages
    **/
    _count?: true | UserPageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPageMaxAggregateInputType
  }

  export type GetUserPageAggregateType<T extends UserPageAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPage[P]>
      : GetScalarType<T[P], AggregateUserPage[P]>
  }




  export type UserPageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPageWhereInput
    orderBy?: UserPageOrderByWithAggregationInput | UserPageOrderByWithAggregationInput[]
    by: UserPageScalarFieldEnum[] | UserPageScalarFieldEnum
    having?: UserPageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPageCountAggregateInputType | true
    _min?: UserPageMinAggregateInputType
    _max?: UserPageMaxAggregateInputType
  }

  export type UserPageGroupByOutputType = {
    id: string
    userId: string
    handle: string
    bio: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserPageCountAggregateOutputType | null
    _min: UserPageMinAggregateOutputType | null
    _max: UserPageMaxAggregateOutputType | null
  }

  type GetUserPageGroupByPayload<T extends UserPageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPageGroupByOutputType[P]>
            : GetScalarType<T[P], UserPageGroupByOutputType[P]>
        }
      >
    >


  export type UserPageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    handle?: boolean
    bio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    posts?: boolean | UserPage$postsArgs<ExtArgs>
    _count?: boolean | UserPageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPage"]>

  export type UserPageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    handle?: boolean
    bio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPage"]>

  export type UserPageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    handle?: boolean
    bio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPage"]>

  export type UserPageSelectScalar = {
    id?: boolean
    userId?: boolean
    handle?: boolean
    bio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserPageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "handle" | "bio" | "createdAt" | "updatedAt", ExtArgs["result"]["userPage"]>
  export type UserPageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    posts?: boolean | UserPage$postsArgs<ExtArgs>
    _count?: boolean | UserPageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserPageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserPagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPage"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      posts: Prisma.$PostPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      handle: string
      bio: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userPage"]>
    composites: {}
  }

  type UserPageGetPayload<S extends boolean | null | undefined | UserPageDefaultArgs> = $Result.GetResult<Prisma.$UserPagePayload, S>

  type UserPageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPageCountAggregateInputType | true
    }

  export interface UserPageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPage'], meta: { name: 'UserPage' } }
    /**
     * Find zero or one UserPage that matches the filter.
     * @param {UserPageFindUniqueArgs} args - Arguments to find a UserPage
     * @example
     * // Get one UserPage
     * const userPage = await prisma.userPage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPageFindUniqueArgs>(args: SelectSubset<T, UserPageFindUniqueArgs<ExtArgs>>): Prisma__UserPageClient<$Result.GetResult<Prisma.$UserPagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserPage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPageFindUniqueOrThrowArgs} args - Arguments to find a UserPage
     * @example
     * // Get one UserPage
     * const userPage = await prisma.userPage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPageFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPageClient<$Result.GetResult<Prisma.$UserPagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPageFindFirstArgs} args - Arguments to find a UserPage
     * @example
     * // Get one UserPage
     * const userPage = await prisma.userPage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPageFindFirstArgs>(args?: SelectSubset<T, UserPageFindFirstArgs<ExtArgs>>): Prisma__UserPageClient<$Result.GetResult<Prisma.$UserPagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPageFindFirstOrThrowArgs} args - Arguments to find a UserPage
     * @example
     * // Get one UserPage
     * const userPage = await prisma.userPage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPageFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPageFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPageClient<$Result.GetResult<Prisma.$UserPagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserPages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPages
     * const userPages = await prisma.userPage.findMany()
     * 
     * // Get first 10 UserPages
     * const userPages = await prisma.userPage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPageWithIdOnly = await prisma.userPage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserPageFindManyArgs>(args?: SelectSubset<T, UserPageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserPage.
     * @param {UserPageCreateArgs} args - Arguments to create a UserPage.
     * @example
     * // Create one UserPage
     * const UserPage = await prisma.userPage.create({
     *   data: {
     *     // ... data to create a UserPage
     *   }
     * })
     * 
     */
    create<T extends UserPageCreateArgs>(args: SelectSubset<T, UserPageCreateArgs<ExtArgs>>): Prisma__UserPageClient<$Result.GetResult<Prisma.$UserPagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserPages.
     * @param {UserPageCreateManyArgs} args - Arguments to create many UserPages.
     * @example
     * // Create many UserPages
     * const userPage = await prisma.userPage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPageCreateManyArgs>(args?: SelectSubset<T, UserPageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserPages and returns the data saved in the database.
     * @param {UserPageCreateManyAndReturnArgs} args - Arguments to create many UserPages.
     * @example
     * // Create many UserPages
     * const userPage = await prisma.userPage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserPages and only return the `id`
     * const userPageWithIdOnly = await prisma.userPage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserPageCreateManyAndReturnArgs>(args?: SelectSubset<T, UserPageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserPage.
     * @param {UserPageDeleteArgs} args - Arguments to delete one UserPage.
     * @example
     * // Delete one UserPage
     * const UserPage = await prisma.userPage.delete({
     *   where: {
     *     // ... filter to delete one UserPage
     *   }
     * })
     * 
     */
    delete<T extends UserPageDeleteArgs>(args: SelectSubset<T, UserPageDeleteArgs<ExtArgs>>): Prisma__UserPageClient<$Result.GetResult<Prisma.$UserPagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserPage.
     * @param {UserPageUpdateArgs} args - Arguments to update one UserPage.
     * @example
     * // Update one UserPage
     * const userPage = await prisma.userPage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPageUpdateArgs>(args: SelectSubset<T, UserPageUpdateArgs<ExtArgs>>): Prisma__UserPageClient<$Result.GetResult<Prisma.$UserPagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserPages.
     * @param {UserPageDeleteManyArgs} args - Arguments to filter UserPages to delete.
     * @example
     * // Delete a few UserPages
     * const { count } = await prisma.userPage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPageDeleteManyArgs>(args?: SelectSubset<T, UserPageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPages
     * const userPage = await prisma.userPage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPageUpdateManyArgs>(args: SelectSubset<T, UserPageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPages and returns the data updated in the database.
     * @param {UserPageUpdateManyAndReturnArgs} args - Arguments to update many UserPages.
     * @example
     * // Update many UserPages
     * const userPage = await prisma.userPage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserPages and only return the `id`
     * const userPageWithIdOnly = await prisma.userPage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserPageUpdateManyAndReturnArgs>(args: SelectSubset<T, UserPageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserPage.
     * @param {UserPageUpsertArgs} args - Arguments to update or create a UserPage.
     * @example
     * // Update or create a UserPage
     * const userPage = await prisma.userPage.upsert({
     *   create: {
     *     // ... data to create a UserPage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPage we want to update
     *   }
     * })
     */
    upsert<T extends UserPageUpsertArgs>(args: SelectSubset<T, UserPageUpsertArgs<ExtArgs>>): Prisma__UserPageClient<$Result.GetResult<Prisma.$UserPagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPageCountArgs} args - Arguments to filter UserPages to count.
     * @example
     * // Count the number of UserPages
     * const count = await prisma.userPage.count({
     *   where: {
     *     // ... the filter for the UserPages we want to count
     *   }
     * })
    **/
    count<T extends UserPageCountArgs>(
      args?: Subset<T, UserPageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPageAggregateArgs>(args: Subset<T, UserPageAggregateArgs>): Prisma.PrismaPromise<GetUserPageAggregateType<T>>

    /**
     * Group by UserPage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPageGroupByArgs['orderBy'] }
        : { orderBy?: UserPageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPage model
   */
  readonly fields: UserPageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    posts<T extends UserPage$postsArgs<ExtArgs> = {}>(args?: Subset<T, UserPage$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPage model
   */
  interface UserPageFieldRefs {
    readonly id: FieldRef<"UserPage", 'String'>
    readonly userId: FieldRef<"UserPage", 'String'>
    readonly handle: FieldRef<"UserPage", 'String'>
    readonly bio: FieldRef<"UserPage", 'String'>
    readonly createdAt: FieldRef<"UserPage", 'DateTime'>
    readonly updatedAt: FieldRef<"UserPage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserPage findUnique
   */
  export type UserPageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPage
     */
    select?: UserPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPage
     */
    omit?: UserPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPageInclude<ExtArgs> | null
    /**
     * Filter, which UserPage to fetch.
     */
    where: UserPageWhereUniqueInput
  }

  /**
   * UserPage findUniqueOrThrow
   */
  export type UserPageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPage
     */
    select?: UserPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPage
     */
    omit?: UserPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPageInclude<ExtArgs> | null
    /**
     * Filter, which UserPage to fetch.
     */
    where: UserPageWhereUniqueInput
  }

  /**
   * UserPage findFirst
   */
  export type UserPageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPage
     */
    select?: UserPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPage
     */
    omit?: UserPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPageInclude<ExtArgs> | null
    /**
     * Filter, which UserPage to fetch.
     */
    where?: UserPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPages to fetch.
     */
    orderBy?: UserPageOrderByWithRelationInput | UserPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPages.
     */
    cursor?: UserPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPages.
     */
    distinct?: UserPageScalarFieldEnum | UserPageScalarFieldEnum[]
  }

  /**
   * UserPage findFirstOrThrow
   */
  export type UserPageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPage
     */
    select?: UserPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPage
     */
    omit?: UserPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPageInclude<ExtArgs> | null
    /**
     * Filter, which UserPage to fetch.
     */
    where?: UserPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPages to fetch.
     */
    orderBy?: UserPageOrderByWithRelationInput | UserPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPages.
     */
    cursor?: UserPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPages.
     */
    distinct?: UserPageScalarFieldEnum | UserPageScalarFieldEnum[]
  }

  /**
   * UserPage findMany
   */
  export type UserPageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPage
     */
    select?: UserPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPage
     */
    omit?: UserPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPageInclude<ExtArgs> | null
    /**
     * Filter, which UserPages to fetch.
     */
    where?: UserPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPages to fetch.
     */
    orderBy?: UserPageOrderByWithRelationInput | UserPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPages.
     */
    cursor?: UserPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPages.
     */
    skip?: number
    distinct?: UserPageScalarFieldEnum | UserPageScalarFieldEnum[]
  }

  /**
   * UserPage create
   */
  export type UserPageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPage
     */
    select?: UserPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPage
     */
    omit?: UserPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPageInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPage.
     */
    data: XOR<UserPageCreateInput, UserPageUncheckedCreateInput>
  }

  /**
   * UserPage createMany
   */
  export type UserPageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPages.
     */
    data: UserPageCreateManyInput | UserPageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPage createManyAndReturn
   */
  export type UserPageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPage
     */
    select?: UserPageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPage
     */
    omit?: UserPageOmit<ExtArgs> | null
    /**
     * The data used to create many UserPages.
     */
    data: UserPageCreateManyInput | UserPageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPage update
   */
  export type UserPageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPage
     */
    select?: UserPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPage
     */
    omit?: UserPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPageInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPage.
     */
    data: XOR<UserPageUpdateInput, UserPageUncheckedUpdateInput>
    /**
     * Choose, which UserPage to update.
     */
    where: UserPageWhereUniqueInput
  }

  /**
   * UserPage updateMany
   */
  export type UserPageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPages.
     */
    data: XOR<UserPageUpdateManyMutationInput, UserPageUncheckedUpdateManyInput>
    /**
     * Filter which UserPages to update
     */
    where?: UserPageWhereInput
    /**
     * Limit how many UserPages to update.
     */
    limit?: number
  }

  /**
   * UserPage updateManyAndReturn
   */
  export type UserPageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPage
     */
    select?: UserPageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPage
     */
    omit?: UserPageOmit<ExtArgs> | null
    /**
     * The data used to update UserPages.
     */
    data: XOR<UserPageUpdateManyMutationInput, UserPageUncheckedUpdateManyInput>
    /**
     * Filter which UserPages to update
     */
    where?: UserPageWhereInput
    /**
     * Limit how many UserPages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPage upsert
   */
  export type UserPageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPage
     */
    select?: UserPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPage
     */
    omit?: UserPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPageInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPage to update in case it exists.
     */
    where: UserPageWhereUniqueInput
    /**
     * In case the UserPage found by the `where` argument doesn't exist, create a new UserPage with this data.
     */
    create: XOR<UserPageCreateInput, UserPageUncheckedCreateInput>
    /**
     * In case the UserPage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPageUpdateInput, UserPageUncheckedUpdateInput>
  }

  /**
   * UserPage delete
   */
  export type UserPageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPage
     */
    select?: UserPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPage
     */
    omit?: UserPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPageInclude<ExtArgs> | null
    /**
     * Filter which UserPage to delete.
     */
    where: UserPageWhereUniqueInput
  }

  /**
   * UserPage deleteMany
   */
  export type UserPageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPages to delete
     */
    where?: UserPageWhereInput
    /**
     * Limit how many UserPages to delete.
     */
    limit?: number
  }

  /**
   * UserPage.posts
   */
  export type UserPage$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * UserPage without action
   */
  export type UserPageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPage
     */
    select?: UserPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPage
     */
    omit?: UserPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPageInclude<ExtArgs> | null
  }


  /**
   * Model Post
   */

  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostMinAggregateOutputType = {
    id: string | null
    pageId: string | null
    type: $Enums.PostType | null
    content: string | null
    imageUrl: string | null
    caption: string | null
    reference: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostMaxAggregateOutputType = {
    id: string | null
    pageId: string | null
    type: $Enums.PostType | null
    content: string | null
    imageUrl: string | null
    caption: string | null
    reference: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    pageId: number
    type: number
    content: number
    imageUrl: number
    caption: number
    reference: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PostMinAggregateInputType = {
    id?: true
    pageId?: true
    type?: true
    content?: true
    imageUrl?: true
    caption?: true
    reference?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    pageId?: true
    type?: true
    content?: true
    imageUrl?: true
    caption?: true
    reference?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    pageId?: true
    type?: true
    content?: true
    imageUrl?: true
    caption?: true
    reference?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Post to aggregate.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
    orderBy?: PostOrderByWithAggregationInput | PostOrderByWithAggregationInput[]
    by: PostScalarFieldEnum[] | PostScalarFieldEnum
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }

  export type PostGroupByOutputType = {
    id: string
    pageId: string
    type: $Enums.PostType
    content: string
    imageUrl: string | null
    caption: string | null
    reference: string | null
    createdAt: Date
    updatedAt: Date
    _count: PostCountAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pageId?: boolean
    type?: boolean
    content?: boolean
    imageUrl?: boolean
    caption?: boolean
    reference?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    page?: boolean | UserPageDefaultArgs<ExtArgs>
    likes?: boolean | Post$likesArgs<ExtArgs>
    comments?: boolean | Post$commentsArgs<ExtArgs>
    postReads?: boolean | Post$postReadsArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pageId?: boolean
    type?: boolean
    content?: boolean
    imageUrl?: boolean
    caption?: boolean
    reference?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    page?: boolean | UserPageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pageId?: boolean
    type?: boolean
    content?: boolean
    imageUrl?: boolean
    caption?: boolean
    reference?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    page?: boolean | UserPageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectScalar = {
    id?: boolean
    pageId?: boolean
    type?: boolean
    content?: boolean
    imageUrl?: boolean
    caption?: boolean
    reference?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pageId" | "type" | "content" | "imageUrl" | "caption" | "reference" | "createdAt" | "updatedAt", ExtArgs["result"]["post"]>
  export type PostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    page?: boolean | UserPageDefaultArgs<ExtArgs>
    likes?: boolean | Post$likesArgs<ExtArgs>
    comments?: boolean | Post$commentsArgs<ExtArgs>
    postReads?: boolean | Post$postReadsArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    page?: boolean | UserPageDefaultArgs<ExtArgs>
  }
  export type PostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    page?: boolean | UserPageDefaultArgs<ExtArgs>
  }

  export type $PostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Post"
    objects: {
      page: Prisma.$UserPagePayload<ExtArgs>
      likes: Prisma.$LikePayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      postReads: Prisma.$PostReadPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      pageId: string
      type: $Enums.PostType
      content: string
      imageUrl: string | null
      caption: string | null
      reference: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["post"]>
    composites: {}
  }

  type PostGetPayload<S extends boolean | null | undefined | PostDefaultArgs> = $Result.GetResult<Prisma.$PostPayload, S>

  type PostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface PostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Post'], meta: { name: 'Post' } }
    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostFindUniqueArgs>(args: SelectSubset<T, PostFindUniqueArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Post that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs>(args: SelectSubset<T, PostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostFindFirstArgs>(args?: SelectSubset<T, PostFindFirstArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostFindFirstOrThrowArgs>(args?: SelectSubset<T, PostFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostFindManyArgs>(args?: SelectSubset<T, PostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
     */
    create<T extends PostCreateArgs>(args: SelectSubset<T, PostCreateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Posts.
     * @param {PostCreateManyArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostCreateManyArgs>(args?: SelectSubset<T, PostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Posts and returns the data saved in the database.
     * @param {PostCreateManyAndReturnArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostCreateManyAndReturnArgs>(args?: SelectSubset<T, PostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
     */
    delete<T extends PostDeleteArgs>(args: SelectSubset<T, PostDeleteArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostUpdateArgs>(args: SelectSubset<T, PostUpdateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostDeleteManyArgs>(args?: SelectSubset<T, PostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostUpdateManyArgs>(args: SelectSubset<T, PostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts and returns the data updated in the database.
     * @param {PostUpdateManyAndReturnArgs} args - Arguments to update many Posts.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostUpdateManyAndReturnArgs>(args: SelectSubset<T, PostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
     */
    upsert<T extends PostUpsertArgs>(args: SelectSubset<T, PostUpsertArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Post model
   */
  readonly fields: PostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    page<T extends UserPageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserPageDefaultArgs<ExtArgs>>): Prisma__UserPageClient<$Result.GetResult<Prisma.$UserPagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    likes<T extends Post$likesArgs<ExtArgs> = {}>(args?: Subset<T, Post$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends Post$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Post$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    postReads<T extends Post$postReadsArgs<ExtArgs> = {}>(args?: Subset<T, Post$postReadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostReadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Post model
   */
  interface PostFieldRefs {
    readonly id: FieldRef<"Post", 'String'>
    readonly pageId: FieldRef<"Post", 'String'>
    readonly type: FieldRef<"Post", 'PostType'>
    readonly content: FieldRef<"Post", 'String'>
    readonly imageUrl: FieldRef<"Post", 'String'>
    readonly caption: FieldRef<"Post", 'String'>
    readonly reference: FieldRef<"Post", 'String'>
    readonly createdAt: FieldRef<"Post", 'DateTime'>
    readonly updatedAt: FieldRef<"Post", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Post findUnique
   */
  export type PostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findUniqueOrThrow
   */
  export type PostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findFirst
   */
  export type PostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findFirstOrThrow
   */
  export type PostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findMany
   */
  export type PostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post create
   */
  export type PostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to create a Post.
     */
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
  }

  /**
   * Post createMany
   */
  export type PostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Post createManyAndReturn
   */
  export type PostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Post update
   */
  export type PostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to update a Post.
     */
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
  }

  /**
   * Post updateManyAndReturn
   */
  export type PostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Post upsert
   */
  export type PostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The filter to search for the Post to update in case it exists.
     */
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
     */
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }

  /**
   * Post delete
   */
  export type PostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter which Post to delete.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posts to delete
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to delete.
     */
    limit?: number
  }

  /**
   * Post.likes
   */
  export type Post$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    where?: LikeWhereInput
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    cursor?: LikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Post.comments
   */
  export type Post$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Post.postReads
   */
  export type Post$postReadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostRead
     */
    select?: PostReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostRead
     */
    omit?: PostReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostReadInclude<ExtArgs> | null
    where?: PostReadWhereInput
    orderBy?: PostReadOrderByWithRelationInput | PostReadOrderByWithRelationInput[]
    cursor?: PostReadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostReadScalarFieldEnum | PostReadScalarFieldEnum[]
  }

  /**
   * Post without action
   */
  export type PostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
  }


  /**
   * Model Like
   */

  export type AggregateLike = {
    _count: LikeCountAggregateOutputType | null
    _min: LikeMinAggregateOutputType | null
    _max: LikeMaxAggregateOutputType | null
  }

  export type LikeMinAggregateOutputType = {
    id: string | null
    postId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type LikeMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type LikeCountAggregateOutputType = {
    id: number
    postId: number
    userId: number
    createdAt: number
    _all: number
  }


  export type LikeMinAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    createdAt?: true
  }

  export type LikeMaxAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    createdAt?: true
  }

  export type LikeCountAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type LikeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Like to aggregate.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Likes
    **/
    _count?: true | LikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LikeMaxAggregateInputType
  }

  export type GetLikeAggregateType<T extends LikeAggregateArgs> = {
        [P in keyof T & keyof AggregateLike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLike[P]>
      : GetScalarType<T[P], AggregateLike[P]>
  }




  export type LikeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeWhereInput
    orderBy?: LikeOrderByWithAggregationInput | LikeOrderByWithAggregationInput[]
    by: LikeScalarFieldEnum[] | LikeScalarFieldEnum
    having?: LikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LikeCountAggregateInputType | true
    _min?: LikeMinAggregateInputType
    _max?: LikeMaxAggregateInputType
  }

  export type LikeGroupByOutputType = {
    id: string
    postId: string
    userId: string
    createdAt: Date
    _count: LikeCountAggregateOutputType | null
    _min: LikeMinAggregateOutputType | null
    _max: LikeMaxAggregateOutputType | null
  }

  type GetLikeGroupByPayload<T extends LikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LikeGroupByOutputType[P]>
            : GetScalarType<T[P], LikeGroupByOutputType[P]>
        }
      >
    >


  export type LikeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    createdAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["like"]>

  export type LikeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    createdAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["like"]>

  export type LikeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    createdAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["like"]>

  export type LikeSelectScalar = {
    id?: boolean
    postId?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type LikeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "postId" | "userId" | "createdAt", ExtArgs["result"]["like"]>
  export type LikeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LikeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LikeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LikePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Like"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["like"]>
    composites: {}
  }

  type LikeGetPayload<S extends boolean | null | undefined | LikeDefaultArgs> = $Result.GetResult<Prisma.$LikePayload, S>

  type LikeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LikeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LikeCountAggregateInputType | true
    }

  export interface LikeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Like'], meta: { name: 'Like' } }
    /**
     * Find zero or one Like that matches the filter.
     * @param {LikeFindUniqueArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LikeFindUniqueArgs>(args: SelectSubset<T, LikeFindUniqueArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Like that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LikeFindUniqueOrThrowArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LikeFindUniqueOrThrowArgs>(args: SelectSubset<T, LikeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Like that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindFirstArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LikeFindFirstArgs>(args?: SelectSubset<T, LikeFindFirstArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Like that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindFirstOrThrowArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LikeFindFirstOrThrowArgs>(args?: SelectSubset<T, LikeFindFirstOrThrowArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Likes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Likes
     * const likes = await prisma.like.findMany()
     * 
     * // Get first 10 Likes
     * const likes = await prisma.like.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const likeWithIdOnly = await prisma.like.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LikeFindManyArgs>(args?: SelectSubset<T, LikeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Like.
     * @param {LikeCreateArgs} args - Arguments to create a Like.
     * @example
     * // Create one Like
     * const Like = await prisma.like.create({
     *   data: {
     *     // ... data to create a Like
     *   }
     * })
     * 
     */
    create<T extends LikeCreateArgs>(args: SelectSubset<T, LikeCreateArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Likes.
     * @param {LikeCreateManyArgs} args - Arguments to create many Likes.
     * @example
     * // Create many Likes
     * const like = await prisma.like.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LikeCreateManyArgs>(args?: SelectSubset<T, LikeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Likes and returns the data saved in the database.
     * @param {LikeCreateManyAndReturnArgs} args - Arguments to create many Likes.
     * @example
     * // Create many Likes
     * const like = await prisma.like.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Likes and only return the `id`
     * const likeWithIdOnly = await prisma.like.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LikeCreateManyAndReturnArgs>(args?: SelectSubset<T, LikeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Like.
     * @param {LikeDeleteArgs} args - Arguments to delete one Like.
     * @example
     * // Delete one Like
     * const Like = await prisma.like.delete({
     *   where: {
     *     // ... filter to delete one Like
     *   }
     * })
     * 
     */
    delete<T extends LikeDeleteArgs>(args: SelectSubset<T, LikeDeleteArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Like.
     * @param {LikeUpdateArgs} args - Arguments to update one Like.
     * @example
     * // Update one Like
     * const like = await prisma.like.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LikeUpdateArgs>(args: SelectSubset<T, LikeUpdateArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Likes.
     * @param {LikeDeleteManyArgs} args - Arguments to filter Likes to delete.
     * @example
     * // Delete a few Likes
     * const { count } = await prisma.like.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LikeDeleteManyArgs>(args?: SelectSubset<T, LikeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Likes
     * const like = await prisma.like.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LikeUpdateManyArgs>(args: SelectSubset<T, LikeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Likes and returns the data updated in the database.
     * @param {LikeUpdateManyAndReturnArgs} args - Arguments to update many Likes.
     * @example
     * // Update many Likes
     * const like = await prisma.like.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Likes and only return the `id`
     * const likeWithIdOnly = await prisma.like.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LikeUpdateManyAndReturnArgs>(args: SelectSubset<T, LikeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Like.
     * @param {LikeUpsertArgs} args - Arguments to update or create a Like.
     * @example
     * // Update or create a Like
     * const like = await prisma.like.upsert({
     *   create: {
     *     // ... data to create a Like
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Like we want to update
     *   }
     * })
     */
    upsert<T extends LikeUpsertArgs>(args: SelectSubset<T, LikeUpsertArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeCountArgs} args - Arguments to filter Likes to count.
     * @example
     * // Count the number of Likes
     * const count = await prisma.like.count({
     *   where: {
     *     // ... the filter for the Likes we want to count
     *   }
     * })
    **/
    count<T extends LikeCountArgs>(
      args?: Subset<T, LikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Like.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LikeAggregateArgs>(args: Subset<T, LikeAggregateArgs>): Prisma.PrismaPromise<GetLikeAggregateType<T>>

    /**
     * Group by Like.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LikeGroupByArgs['orderBy'] }
        : { orderBy?: LikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Like model
   */
  readonly fields: LikeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Like.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LikeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Like model
   */
  interface LikeFieldRefs {
    readonly id: FieldRef<"Like", 'String'>
    readonly postId: FieldRef<"Like", 'String'>
    readonly userId: FieldRef<"Like", 'String'>
    readonly createdAt: FieldRef<"Like", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Like findUnique
   */
  export type LikeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like findUniqueOrThrow
   */
  export type LikeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like findFirst
   */
  export type LikeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Likes.
     */
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Like findFirstOrThrow
   */
  export type LikeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Likes.
     */
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Like findMany
   */
  export type LikeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Likes to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Like create
   */
  export type LikeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * The data needed to create a Like.
     */
    data: XOR<LikeCreateInput, LikeUncheckedCreateInput>
  }

  /**
   * Like createMany
   */
  export type LikeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Likes.
     */
    data: LikeCreateManyInput | LikeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Like createManyAndReturn
   */
  export type LikeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * The data used to create many Likes.
     */
    data: LikeCreateManyInput | LikeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Like update
   */
  export type LikeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * The data needed to update a Like.
     */
    data: XOR<LikeUpdateInput, LikeUncheckedUpdateInput>
    /**
     * Choose, which Like to update.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like updateMany
   */
  export type LikeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Likes.
     */
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyInput>
    /**
     * Filter which Likes to update
     */
    where?: LikeWhereInput
    /**
     * Limit how many Likes to update.
     */
    limit?: number
  }

  /**
   * Like updateManyAndReturn
   */
  export type LikeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * The data used to update Likes.
     */
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyInput>
    /**
     * Filter which Likes to update
     */
    where?: LikeWhereInput
    /**
     * Limit how many Likes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Like upsert
   */
  export type LikeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * The filter to search for the Like to update in case it exists.
     */
    where: LikeWhereUniqueInput
    /**
     * In case the Like found by the `where` argument doesn't exist, create a new Like with this data.
     */
    create: XOR<LikeCreateInput, LikeUncheckedCreateInput>
    /**
     * In case the Like was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LikeUpdateInput, LikeUncheckedUpdateInput>
  }

  /**
   * Like delete
   */
  export type LikeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter which Like to delete.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like deleteMany
   */
  export type LikeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Likes to delete
     */
    where?: LikeWhereInput
    /**
     * Limit how many Likes to delete.
     */
    limit?: number
  }

  /**
   * Like without action
   */
  export type LikeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    postId: string | null
    userId: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    parentId: string | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    userId: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    parentId: string | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    postId: number
    userId: number
    content: number
    createdAt: number
    updatedAt: number
    parentId: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    parentId?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    parentId?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    parentId?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    postId: string
    userId: string
    content: string
    createdAt: Date
    updatedAt: Date
    parentId: string | null
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentId?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
    replies?: boolean | Comment$repliesArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentId?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentId?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    postId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentId?: boolean
  }

  export type CommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "postId" | "userId" | "content" | "createdAt" | "updatedAt" | "parentId", ExtArgs["result"]["comment"]>
  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
    replies?: boolean | Comment$repliesArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
  }
  export type CommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      parent: Prisma.$CommentPayload<ExtArgs> | null
      replies: Prisma.$CommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      userId: string
      content: string
      createdAt: Date
      updatedAt: Date
      parentId: string | null
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {CommentUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parent<T extends Comment$parentArgs<ExtArgs> = {}>(args?: Subset<T, Comment$parentArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    replies<T extends Comment$repliesArgs<ExtArgs> = {}>(args?: Subset<T, Comment$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly postId: FieldRef<"Comment", 'String'>
    readonly userId: FieldRef<"Comment", 'String'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
    readonly parentId: FieldRef<"Comment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
  }

  /**
   * Comment updateManyAndReturn
   */
  export type CommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to delete.
     */
    limit?: number
  }

  /**
   * Comment.parent
   */
  export type Comment$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
  }

  /**
   * Comment.replies
   */
  export type Comment$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model PostRead
   */

  export type AggregatePostRead = {
    _count: PostReadCountAggregateOutputType | null
    _min: PostReadMinAggregateOutputType | null
    _max: PostReadMaxAggregateOutputType | null
  }

  export type PostReadMinAggregateOutputType = {
    id: string | null
    userId: string | null
    postId: string | null
    readAt: Date | null
  }

  export type PostReadMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    postId: string | null
    readAt: Date | null
  }

  export type PostReadCountAggregateOutputType = {
    id: number
    userId: number
    postId: number
    readAt: number
    _all: number
  }


  export type PostReadMinAggregateInputType = {
    id?: true
    userId?: true
    postId?: true
    readAt?: true
  }

  export type PostReadMaxAggregateInputType = {
    id?: true
    userId?: true
    postId?: true
    readAt?: true
  }

  export type PostReadCountAggregateInputType = {
    id?: true
    userId?: true
    postId?: true
    readAt?: true
    _all?: true
  }

  export type PostReadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostRead to aggregate.
     */
    where?: PostReadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostReads to fetch.
     */
    orderBy?: PostReadOrderByWithRelationInput | PostReadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostReadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostReads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostReads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostReads
    **/
    _count?: true | PostReadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostReadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostReadMaxAggregateInputType
  }

  export type GetPostReadAggregateType<T extends PostReadAggregateArgs> = {
        [P in keyof T & keyof AggregatePostRead]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostRead[P]>
      : GetScalarType<T[P], AggregatePostRead[P]>
  }




  export type PostReadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostReadWhereInput
    orderBy?: PostReadOrderByWithAggregationInput | PostReadOrderByWithAggregationInput[]
    by: PostReadScalarFieldEnum[] | PostReadScalarFieldEnum
    having?: PostReadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostReadCountAggregateInputType | true
    _min?: PostReadMinAggregateInputType
    _max?: PostReadMaxAggregateInputType
  }

  export type PostReadGroupByOutputType = {
    id: string
    userId: string
    postId: string
    readAt: Date
    _count: PostReadCountAggregateOutputType | null
    _min: PostReadMinAggregateOutputType | null
    _max: PostReadMaxAggregateOutputType | null
  }

  type GetPostReadGroupByPayload<T extends PostReadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostReadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostReadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostReadGroupByOutputType[P]>
            : GetScalarType<T[P], PostReadGroupByOutputType[P]>
        }
      >
    >


  export type PostReadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    postId?: boolean
    readAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postRead"]>

  export type PostReadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    postId?: boolean
    readAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postRead"]>

  export type PostReadSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    postId?: boolean
    readAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postRead"]>

  export type PostReadSelectScalar = {
    id?: boolean
    userId?: boolean
    postId?: boolean
    readAt?: boolean
  }

  export type PostReadOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "postId" | "readAt", ExtArgs["result"]["postRead"]>
  export type PostReadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
  }
  export type PostReadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
  }
  export type PostReadIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
  }

  export type $PostReadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostRead"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      post: Prisma.$PostPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      postId: string
      readAt: Date
    }, ExtArgs["result"]["postRead"]>
    composites: {}
  }

  type PostReadGetPayload<S extends boolean | null | undefined | PostReadDefaultArgs> = $Result.GetResult<Prisma.$PostReadPayload, S>

  type PostReadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostReadFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostReadCountAggregateInputType | true
    }

  export interface PostReadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostRead'], meta: { name: 'PostRead' } }
    /**
     * Find zero or one PostRead that matches the filter.
     * @param {PostReadFindUniqueArgs} args - Arguments to find a PostRead
     * @example
     * // Get one PostRead
     * const postRead = await prisma.postRead.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostReadFindUniqueArgs>(args: SelectSubset<T, PostReadFindUniqueArgs<ExtArgs>>): Prisma__PostReadClient<$Result.GetResult<Prisma.$PostReadPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PostRead that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostReadFindUniqueOrThrowArgs} args - Arguments to find a PostRead
     * @example
     * // Get one PostRead
     * const postRead = await prisma.postRead.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostReadFindUniqueOrThrowArgs>(args: SelectSubset<T, PostReadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostReadClient<$Result.GetResult<Prisma.$PostReadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostRead that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostReadFindFirstArgs} args - Arguments to find a PostRead
     * @example
     * // Get one PostRead
     * const postRead = await prisma.postRead.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostReadFindFirstArgs>(args?: SelectSubset<T, PostReadFindFirstArgs<ExtArgs>>): Prisma__PostReadClient<$Result.GetResult<Prisma.$PostReadPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostRead that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostReadFindFirstOrThrowArgs} args - Arguments to find a PostRead
     * @example
     * // Get one PostRead
     * const postRead = await prisma.postRead.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostReadFindFirstOrThrowArgs>(args?: SelectSubset<T, PostReadFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostReadClient<$Result.GetResult<Prisma.$PostReadPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PostReads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostReadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostReads
     * const postReads = await prisma.postRead.findMany()
     * 
     * // Get first 10 PostReads
     * const postReads = await prisma.postRead.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postReadWithIdOnly = await prisma.postRead.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostReadFindManyArgs>(args?: SelectSubset<T, PostReadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostReadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PostRead.
     * @param {PostReadCreateArgs} args - Arguments to create a PostRead.
     * @example
     * // Create one PostRead
     * const PostRead = await prisma.postRead.create({
     *   data: {
     *     // ... data to create a PostRead
     *   }
     * })
     * 
     */
    create<T extends PostReadCreateArgs>(args: SelectSubset<T, PostReadCreateArgs<ExtArgs>>): Prisma__PostReadClient<$Result.GetResult<Prisma.$PostReadPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PostReads.
     * @param {PostReadCreateManyArgs} args - Arguments to create many PostReads.
     * @example
     * // Create many PostReads
     * const postRead = await prisma.postRead.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostReadCreateManyArgs>(args?: SelectSubset<T, PostReadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostReads and returns the data saved in the database.
     * @param {PostReadCreateManyAndReturnArgs} args - Arguments to create many PostReads.
     * @example
     * // Create many PostReads
     * const postRead = await prisma.postRead.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostReads and only return the `id`
     * const postReadWithIdOnly = await prisma.postRead.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostReadCreateManyAndReturnArgs>(args?: SelectSubset<T, PostReadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostReadPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PostRead.
     * @param {PostReadDeleteArgs} args - Arguments to delete one PostRead.
     * @example
     * // Delete one PostRead
     * const PostRead = await prisma.postRead.delete({
     *   where: {
     *     // ... filter to delete one PostRead
     *   }
     * })
     * 
     */
    delete<T extends PostReadDeleteArgs>(args: SelectSubset<T, PostReadDeleteArgs<ExtArgs>>): Prisma__PostReadClient<$Result.GetResult<Prisma.$PostReadPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PostRead.
     * @param {PostReadUpdateArgs} args - Arguments to update one PostRead.
     * @example
     * // Update one PostRead
     * const postRead = await prisma.postRead.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostReadUpdateArgs>(args: SelectSubset<T, PostReadUpdateArgs<ExtArgs>>): Prisma__PostReadClient<$Result.GetResult<Prisma.$PostReadPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PostReads.
     * @param {PostReadDeleteManyArgs} args - Arguments to filter PostReads to delete.
     * @example
     * // Delete a few PostReads
     * const { count } = await prisma.postRead.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostReadDeleteManyArgs>(args?: SelectSubset<T, PostReadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostReads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostReadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostReads
     * const postRead = await prisma.postRead.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostReadUpdateManyArgs>(args: SelectSubset<T, PostReadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostReads and returns the data updated in the database.
     * @param {PostReadUpdateManyAndReturnArgs} args - Arguments to update many PostReads.
     * @example
     * // Update many PostReads
     * const postRead = await prisma.postRead.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PostReads and only return the `id`
     * const postReadWithIdOnly = await prisma.postRead.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostReadUpdateManyAndReturnArgs>(args: SelectSubset<T, PostReadUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostReadPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PostRead.
     * @param {PostReadUpsertArgs} args - Arguments to update or create a PostRead.
     * @example
     * // Update or create a PostRead
     * const postRead = await prisma.postRead.upsert({
     *   create: {
     *     // ... data to create a PostRead
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostRead we want to update
     *   }
     * })
     */
    upsert<T extends PostReadUpsertArgs>(args: SelectSubset<T, PostReadUpsertArgs<ExtArgs>>): Prisma__PostReadClient<$Result.GetResult<Prisma.$PostReadPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PostReads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostReadCountArgs} args - Arguments to filter PostReads to count.
     * @example
     * // Count the number of PostReads
     * const count = await prisma.postRead.count({
     *   where: {
     *     // ... the filter for the PostReads we want to count
     *   }
     * })
    **/
    count<T extends PostReadCountArgs>(
      args?: Subset<T, PostReadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostReadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostRead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostReadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostReadAggregateArgs>(args: Subset<T, PostReadAggregateArgs>): Prisma.PrismaPromise<GetPostReadAggregateType<T>>

    /**
     * Group by PostRead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostReadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostReadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostReadGroupByArgs['orderBy'] }
        : { orderBy?: PostReadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostReadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostReadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostRead model
   */
  readonly fields: PostReadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostRead.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostReadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostRead model
   */
  interface PostReadFieldRefs {
    readonly id: FieldRef<"PostRead", 'String'>
    readonly userId: FieldRef<"PostRead", 'String'>
    readonly postId: FieldRef<"PostRead", 'String'>
    readonly readAt: FieldRef<"PostRead", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PostRead findUnique
   */
  export type PostReadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostRead
     */
    select?: PostReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostRead
     */
    omit?: PostReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostReadInclude<ExtArgs> | null
    /**
     * Filter, which PostRead to fetch.
     */
    where: PostReadWhereUniqueInput
  }

  /**
   * PostRead findUniqueOrThrow
   */
  export type PostReadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostRead
     */
    select?: PostReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostRead
     */
    omit?: PostReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostReadInclude<ExtArgs> | null
    /**
     * Filter, which PostRead to fetch.
     */
    where: PostReadWhereUniqueInput
  }

  /**
   * PostRead findFirst
   */
  export type PostReadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostRead
     */
    select?: PostReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostRead
     */
    omit?: PostReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostReadInclude<ExtArgs> | null
    /**
     * Filter, which PostRead to fetch.
     */
    where?: PostReadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostReads to fetch.
     */
    orderBy?: PostReadOrderByWithRelationInput | PostReadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostReads.
     */
    cursor?: PostReadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostReads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostReads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostReads.
     */
    distinct?: PostReadScalarFieldEnum | PostReadScalarFieldEnum[]
  }

  /**
   * PostRead findFirstOrThrow
   */
  export type PostReadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostRead
     */
    select?: PostReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostRead
     */
    omit?: PostReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostReadInclude<ExtArgs> | null
    /**
     * Filter, which PostRead to fetch.
     */
    where?: PostReadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostReads to fetch.
     */
    orderBy?: PostReadOrderByWithRelationInput | PostReadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostReads.
     */
    cursor?: PostReadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostReads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostReads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostReads.
     */
    distinct?: PostReadScalarFieldEnum | PostReadScalarFieldEnum[]
  }

  /**
   * PostRead findMany
   */
  export type PostReadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostRead
     */
    select?: PostReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostRead
     */
    omit?: PostReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostReadInclude<ExtArgs> | null
    /**
     * Filter, which PostReads to fetch.
     */
    where?: PostReadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostReads to fetch.
     */
    orderBy?: PostReadOrderByWithRelationInput | PostReadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostReads.
     */
    cursor?: PostReadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostReads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostReads.
     */
    skip?: number
    distinct?: PostReadScalarFieldEnum | PostReadScalarFieldEnum[]
  }

  /**
   * PostRead create
   */
  export type PostReadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostRead
     */
    select?: PostReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostRead
     */
    omit?: PostReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostReadInclude<ExtArgs> | null
    /**
     * The data needed to create a PostRead.
     */
    data: XOR<PostReadCreateInput, PostReadUncheckedCreateInput>
  }

  /**
   * PostRead createMany
   */
  export type PostReadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostReads.
     */
    data: PostReadCreateManyInput | PostReadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostRead createManyAndReturn
   */
  export type PostReadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostRead
     */
    select?: PostReadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostRead
     */
    omit?: PostReadOmit<ExtArgs> | null
    /**
     * The data used to create many PostReads.
     */
    data: PostReadCreateManyInput | PostReadCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostReadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostRead update
   */
  export type PostReadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostRead
     */
    select?: PostReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostRead
     */
    omit?: PostReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostReadInclude<ExtArgs> | null
    /**
     * The data needed to update a PostRead.
     */
    data: XOR<PostReadUpdateInput, PostReadUncheckedUpdateInput>
    /**
     * Choose, which PostRead to update.
     */
    where: PostReadWhereUniqueInput
  }

  /**
   * PostRead updateMany
   */
  export type PostReadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostReads.
     */
    data: XOR<PostReadUpdateManyMutationInput, PostReadUncheckedUpdateManyInput>
    /**
     * Filter which PostReads to update
     */
    where?: PostReadWhereInput
    /**
     * Limit how many PostReads to update.
     */
    limit?: number
  }

  /**
   * PostRead updateManyAndReturn
   */
  export type PostReadUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostRead
     */
    select?: PostReadSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostRead
     */
    omit?: PostReadOmit<ExtArgs> | null
    /**
     * The data used to update PostReads.
     */
    data: XOR<PostReadUpdateManyMutationInput, PostReadUncheckedUpdateManyInput>
    /**
     * Filter which PostReads to update
     */
    where?: PostReadWhereInput
    /**
     * Limit how many PostReads to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostReadIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostRead upsert
   */
  export type PostReadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostRead
     */
    select?: PostReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostRead
     */
    omit?: PostReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostReadInclude<ExtArgs> | null
    /**
     * The filter to search for the PostRead to update in case it exists.
     */
    where: PostReadWhereUniqueInput
    /**
     * In case the PostRead found by the `where` argument doesn't exist, create a new PostRead with this data.
     */
    create: XOR<PostReadCreateInput, PostReadUncheckedCreateInput>
    /**
     * In case the PostRead was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostReadUpdateInput, PostReadUncheckedUpdateInput>
  }

  /**
   * PostRead delete
   */
  export type PostReadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostRead
     */
    select?: PostReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostRead
     */
    omit?: PostReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostReadInclude<ExtArgs> | null
    /**
     * Filter which PostRead to delete.
     */
    where: PostReadWhereUniqueInput
  }

  /**
   * PostRead deleteMany
   */
  export type PostReadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostReads to delete
     */
    where?: PostReadWhereInput
    /**
     * Limit how many PostReads to delete.
     */
    limit?: number
  }

  /**
   * PostRead without action
   */
  export type PostReadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostRead
     */
    select?: PostReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostRead
     */
    omit?: PostReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostReadInclude<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.TaskStatus | null
    priority: $Enums.TaskPriority | null
    startDate: Date | null
    dueDate: Date | null
    completedAt: Date | null
    deptId: string | null
    creatorId: string | null
    assigneeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.TaskStatus | null
    priority: $Enums.TaskPriority | null
    startDate: Date | null
    dueDate: Date | null
    completedAt: Date | null
    deptId: string | null
    creatorId: string | null
    assigneeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    title: number
    description: number
    status: number
    priority: number
    startDate: number
    dueDate: number
    completedAt: number
    deptId: number
    creatorId: number
    assigneeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TaskMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    startDate?: true
    dueDate?: true
    completedAt?: true
    deptId?: true
    creatorId?: true
    assigneeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    startDate?: true
    dueDate?: true
    completedAt?: true
    deptId?: true
    creatorId?: true
    assigneeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    startDate?: true
    dueDate?: true
    completedAt?: true
    deptId?: true
    creatorId?: true
    assigneeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: string
    title: string
    description: string | null
    status: $Enums.TaskStatus
    priority: $Enums.TaskPriority
    startDate: Date | null
    dueDate: Date | null
    completedAt: Date | null
    deptId: string
    creatorId: string
    assigneeId: string
    createdAt: Date
    updatedAt: Date
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    startDate?: boolean
    dueDate?: boolean
    completedAt?: boolean
    deptId?: boolean
    creatorId?: boolean
    assigneeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    assignee?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | Task$messagesArgs<ExtArgs>
    attachments?: boolean | Task$attachmentsArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    startDate?: boolean
    dueDate?: boolean
    completedAt?: boolean
    deptId?: boolean
    creatorId?: boolean
    assigneeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    assignee?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    startDate?: boolean
    dueDate?: boolean
    completedAt?: boolean
    deptId?: boolean
    creatorId?: boolean
    assigneeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    assignee?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    startDate?: boolean
    dueDate?: boolean
    completedAt?: boolean
    deptId?: boolean
    creatorId?: boolean
    assigneeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "status" | "priority" | "startDate" | "dueDate" | "completedAt" | "deptId" | "creatorId" | "assigneeId" | "createdAt" | "updatedAt", ExtArgs["result"]["task"]>
  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    assignee?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | Task$messagesArgs<ExtArgs>
    attachments?: boolean | Task$attachmentsArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    assignee?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    assignee?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      department: Prisma.$DepartmentPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
      assignee: Prisma.$UserPayload<ExtArgs>
      messages: Prisma.$TaskMessagePayload<ExtArgs>[]
      attachments: Prisma.$TaskAttachmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      status: $Enums.TaskStatus
      priority: $Enums.TaskPriority
      startDate: Date | null
      dueDate: Date | null
      completedAt: Date | null
      deptId: string
      creatorId: string
      assigneeId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tasks and returns the data saved in the database.
     * @param {TaskCreateManyAndReturnArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks and returns the data updated in the database.
     * @param {TaskUpdateManyAndReturnArgs} args - Arguments to update many Tasks.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    department<T extends DepartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DepartmentDefaultArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assignee<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    messages<T extends Task$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Task$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attachments<T extends Task$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Task$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'String'>
    readonly title: FieldRef<"Task", 'String'>
    readonly description: FieldRef<"Task", 'String'>
    readonly status: FieldRef<"Task", 'TaskStatus'>
    readonly priority: FieldRef<"Task", 'TaskPriority'>
    readonly startDate: FieldRef<"Task", 'DateTime'>
    readonly dueDate: FieldRef<"Task", 'DateTime'>
    readonly completedAt: FieldRef<"Task", 'DateTime'>
    readonly deptId: FieldRef<"Task", 'String'>
    readonly creatorId: FieldRef<"Task", 'String'>
    readonly assigneeId: FieldRef<"Task", 'String'>
    readonly createdAt: FieldRef<"Task", 'DateTime'>
    readonly updatedAt: FieldRef<"Task", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Task createManyAndReturn
   */
  export type TaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
  }

  /**
   * Task updateManyAndReturn
   */
  export type TaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to delete.
     */
    limit?: number
  }

  /**
   * Task.messages
   */
  export type Task$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskMessage
     */
    select?: TaskMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskMessage
     */
    omit?: TaskMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskMessageInclude<ExtArgs> | null
    where?: TaskMessageWhereInput
    orderBy?: TaskMessageOrderByWithRelationInput | TaskMessageOrderByWithRelationInput[]
    cursor?: TaskMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskMessageScalarFieldEnum | TaskMessageScalarFieldEnum[]
  }

  /**
   * Task.attachments
   */
  export type Task$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAttachment
     */
    omit?: TaskAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null
    where?: TaskAttachmentWhereInput
    orderBy?: TaskAttachmentOrderByWithRelationInput | TaskAttachmentOrderByWithRelationInput[]
    cursor?: TaskAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskAttachmentScalarFieldEnum | TaskAttachmentScalarFieldEnum[]
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
  }


  /**
   * Model TaskMessage
   */

  export type AggregateTaskMessage = {
    _count: TaskMessageCountAggregateOutputType | null
    _min: TaskMessageMinAggregateOutputType | null
    _max: TaskMessageMaxAggregateOutputType | null
  }

  export type TaskMessageMinAggregateOutputType = {
    id: string | null
    taskId: string | null
    senderId: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskMessageMaxAggregateOutputType = {
    id: string | null
    taskId: string | null
    senderId: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskMessageCountAggregateOutputType = {
    id: number
    taskId: number
    senderId: number
    content: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TaskMessageMinAggregateInputType = {
    id?: true
    taskId?: true
    senderId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskMessageMaxAggregateInputType = {
    id?: true
    taskId?: true
    senderId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskMessageCountAggregateInputType = {
    id?: true
    taskId?: true
    senderId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TaskMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskMessage to aggregate.
     */
    where?: TaskMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskMessages to fetch.
     */
    orderBy?: TaskMessageOrderByWithRelationInput | TaskMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskMessages
    **/
    _count?: true | TaskMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMessageMaxAggregateInputType
  }

  export type GetTaskMessageAggregateType<T extends TaskMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskMessage[P]>
      : GetScalarType<T[P], AggregateTaskMessage[P]>
  }




  export type TaskMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskMessageWhereInput
    orderBy?: TaskMessageOrderByWithAggregationInput | TaskMessageOrderByWithAggregationInput[]
    by: TaskMessageScalarFieldEnum[] | TaskMessageScalarFieldEnum
    having?: TaskMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskMessageCountAggregateInputType | true
    _min?: TaskMessageMinAggregateInputType
    _max?: TaskMessageMaxAggregateInputType
  }

  export type TaskMessageGroupByOutputType = {
    id: string
    taskId: string
    senderId: string
    content: string
    createdAt: Date
    updatedAt: Date
    _count: TaskMessageCountAggregateOutputType | null
    _min: TaskMessageMinAggregateOutputType | null
    _max: TaskMessageMaxAggregateOutputType | null
  }

  type GetTaskMessageGroupByPayload<T extends TaskMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskMessageGroupByOutputType[P]>
            : GetScalarType<T[P], TaskMessageGroupByOutputType[P]>
        }
      >
    >


  export type TaskMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    senderId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
    attachments?: boolean | TaskMessage$attachmentsArgs<ExtArgs>
    _count?: boolean | TaskMessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskMessage"]>

  export type TaskMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    senderId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskMessage"]>

  export type TaskMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    senderId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskMessage"]>

  export type TaskMessageSelectScalar = {
    id?: boolean
    taskId?: boolean
    senderId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TaskMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskId" | "senderId" | "content" | "createdAt" | "updatedAt", ExtArgs["result"]["taskMessage"]>
  export type TaskMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
    attachments?: boolean | TaskMessage$attachmentsArgs<ExtArgs>
    _count?: boolean | TaskMessageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TaskMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TaskMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TaskMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskMessage"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs>
      attachments: Prisma.$TaskAttachmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      taskId: string
      senderId: string
      content: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["taskMessage"]>
    composites: {}
  }

  type TaskMessageGetPayload<S extends boolean | null | undefined | TaskMessageDefaultArgs> = $Result.GetResult<Prisma.$TaskMessagePayload, S>

  type TaskMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskMessageCountAggregateInputType | true
    }

  export interface TaskMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskMessage'], meta: { name: 'TaskMessage' } }
    /**
     * Find zero or one TaskMessage that matches the filter.
     * @param {TaskMessageFindUniqueArgs} args - Arguments to find a TaskMessage
     * @example
     * // Get one TaskMessage
     * const taskMessage = await prisma.taskMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskMessageFindUniqueArgs>(args: SelectSubset<T, TaskMessageFindUniqueArgs<ExtArgs>>): Prisma__TaskMessageClient<$Result.GetResult<Prisma.$TaskMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskMessageFindUniqueOrThrowArgs} args - Arguments to find a TaskMessage
     * @example
     * // Get one TaskMessage
     * const taskMessage = await prisma.taskMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskMessageClient<$Result.GetResult<Prisma.$TaskMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskMessageFindFirstArgs} args - Arguments to find a TaskMessage
     * @example
     * // Get one TaskMessage
     * const taskMessage = await prisma.taskMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskMessageFindFirstArgs>(args?: SelectSubset<T, TaskMessageFindFirstArgs<ExtArgs>>): Prisma__TaskMessageClient<$Result.GetResult<Prisma.$TaskMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskMessageFindFirstOrThrowArgs} args - Arguments to find a TaskMessage
     * @example
     * // Get one TaskMessage
     * const taskMessage = await prisma.taskMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskMessageClient<$Result.GetResult<Prisma.$TaskMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskMessages
     * const taskMessages = await prisma.taskMessage.findMany()
     * 
     * // Get first 10 TaskMessages
     * const taskMessages = await prisma.taskMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskMessageWithIdOnly = await prisma.taskMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskMessageFindManyArgs>(args?: SelectSubset<T, TaskMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskMessage.
     * @param {TaskMessageCreateArgs} args - Arguments to create a TaskMessage.
     * @example
     * // Create one TaskMessage
     * const TaskMessage = await prisma.taskMessage.create({
     *   data: {
     *     // ... data to create a TaskMessage
     *   }
     * })
     * 
     */
    create<T extends TaskMessageCreateArgs>(args: SelectSubset<T, TaskMessageCreateArgs<ExtArgs>>): Prisma__TaskMessageClient<$Result.GetResult<Prisma.$TaskMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskMessages.
     * @param {TaskMessageCreateManyArgs} args - Arguments to create many TaskMessages.
     * @example
     * // Create many TaskMessages
     * const taskMessage = await prisma.taskMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskMessageCreateManyArgs>(args?: SelectSubset<T, TaskMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskMessages and returns the data saved in the database.
     * @param {TaskMessageCreateManyAndReturnArgs} args - Arguments to create many TaskMessages.
     * @example
     * // Create many TaskMessages
     * const taskMessage = await prisma.taskMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskMessages and only return the `id`
     * const taskMessageWithIdOnly = await prisma.taskMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaskMessage.
     * @param {TaskMessageDeleteArgs} args - Arguments to delete one TaskMessage.
     * @example
     * // Delete one TaskMessage
     * const TaskMessage = await prisma.taskMessage.delete({
     *   where: {
     *     // ... filter to delete one TaskMessage
     *   }
     * })
     * 
     */
    delete<T extends TaskMessageDeleteArgs>(args: SelectSubset<T, TaskMessageDeleteArgs<ExtArgs>>): Prisma__TaskMessageClient<$Result.GetResult<Prisma.$TaskMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskMessage.
     * @param {TaskMessageUpdateArgs} args - Arguments to update one TaskMessage.
     * @example
     * // Update one TaskMessage
     * const taskMessage = await prisma.taskMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskMessageUpdateArgs>(args: SelectSubset<T, TaskMessageUpdateArgs<ExtArgs>>): Prisma__TaskMessageClient<$Result.GetResult<Prisma.$TaskMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskMessages.
     * @param {TaskMessageDeleteManyArgs} args - Arguments to filter TaskMessages to delete.
     * @example
     * // Delete a few TaskMessages
     * const { count } = await prisma.taskMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskMessageDeleteManyArgs>(args?: SelectSubset<T, TaskMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskMessages
     * const taskMessage = await prisma.taskMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskMessageUpdateManyArgs>(args: SelectSubset<T, TaskMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskMessages and returns the data updated in the database.
     * @param {TaskMessageUpdateManyAndReturnArgs} args - Arguments to update many TaskMessages.
     * @example
     * // Update many TaskMessages
     * const taskMessage = await prisma.taskMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaskMessages and only return the `id`
     * const taskMessageWithIdOnly = await prisma.taskMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaskMessage.
     * @param {TaskMessageUpsertArgs} args - Arguments to update or create a TaskMessage.
     * @example
     * // Update or create a TaskMessage
     * const taskMessage = await prisma.taskMessage.upsert({
     *   create: {
     *     // ... data to create a TaskMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskMessage we want to update
     *   }
     * })
     */
    upsert<T extends TaskMessageUpsertArgs>(args: SelectSubset<T, TaskMessageUpsertArgs<ExtArgs>>): Prisma__TaskMessageClient<$Result.GetResult<Prisma.$TaskMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaskMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskMessageCountArgs} args - Arguments to filter TaskMessages to count.
     * @example
     * // Count the number of TaskMessages
     * const count = await prisma.taskMessage.count({
     *   where: {
     *     // ... the filter for the TaskMessages we want to count
     *   }
     * })
    **/
    count<T extends TaskMessageCountArgs>(
      args?: Subset<T, TaskMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskMessageAggregateArgs>(args: Subset<T, TaskMessageAggregateArgs>): Prisma.PrismaPromise<GetTaskMessageAggregateType<T>>

    /**
     * Group by TaskMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskMessageGroupByArgs['orderBy'] }
        : { orderBy?: TaskMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskMessage model
   */
  readonly fields: TaskMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    attachments<T extends TaskMessage$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, TaskMessage$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskMessage model
   */
  interface TaskMessageFieldRefs {
    readonly id: FieldRef<"TaskMessage", 'String'>
    readonly taskId: FieldRef<"TaskMessage", 'String'>
    readonly senderId: FieldRef<"TaskMessage", 'String'>
    readonly content: FieldRef<"TaskMessage", 'String'>
    readonly createdAt: FieldRef<"TaskMessage", 'DateTime'>
    readonly updatedAt: FieldRef<"TaskMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaskMessage findUnique
   */
  export type TaskMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskMessage
     */
    select?: TaskMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskMessage
     */
    omit?: TaskMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskMessageInclude<ExtArgs> | null
    /**
     * Filter, which TaskMessage to fetch.
     */
    where: TaskMessageWhereUniqueInput
  }

  /**
   * TaskMessage findUniqueOrThrow
   */
  export type TaskMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskMessage
     */
    select?: TaskMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskMessage
     */
    omit?: TaskMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskMessageInclude<ExtArgs> | null
    /**
     * Filter, which TaskMessage to fetch.
     */
    where: TaskMessageWhereUniqueInput
  }

  /**
   * TaskMessage findFirst
   */
  export type TaskMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskMessage
     */
    select?: TaskMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskMessage
     */
    omit?: TaskMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskMessageInclude<ExtArgs> | null
    /**
     * Filter, which TaskMessage to fetch.
     */
    where?: TaskMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskMessages to fetch.
     */
    orderBy?: TaskMessageOrderByWithRelationInput | TaskMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskMessages.
     */
    cursor?: TaskMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskMessages.
     */
    distinct?: TaskMessageScalarFieldEnum | TaskMessageScalarFieldEnum[]
  }

  /**
   * TaskMessage findFirstOrThrow
   */
  export type TaskMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskMessage
     */
    select?: TaskMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskMessage
     */
    omit?: TaskMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskMessageInclude<ExtArgs> | null
    /**
     * Filter, which TaskMessage to fetch.
     */
    where?: TaskMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskMessages to fetch.
     */
    orderBy?: TaskMessageOrderByWithRelationInput | TaskMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskMessages.
     */
    cursor?: TaskMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskMessages.
     */
    distinct?: TaskMessageScalarFieldEnum | TaskMessageScalarFieldEnum[]
  }

  /**
   * TaskMessage findMany
   */
  export type TaskMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskMessage
     */
    select?: TaskMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskMessage
     */
    omit?: TaskMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskMessageInclude<ExtArgs> | null
    /**
     * Filter, which TaskMessages to fetch.
     */
    where?: TaskMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskMessages to fetch.
     */
    orderBy?: TaskMessageOrderByWithRelationInput | TaskMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskMessages.
     */
    cursor?: TaskMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskMessages.
     */
    skip?: number
    distinct?: TaskMessageScalarFieldEnum | TaskMessageScalarFieldEnum[]
  }

  /**
   * TaskMessage create
   */
  export type TaskMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskMessage
     */
    select?: TaskMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskMessage
     */
    omit?: TaskMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskMessage.
     */
    data: XOR<TaskMessageCreateInput, TaskMessageUncheckedCreateInput>
  }

  /**
   * TaskMessage createMany
   */
  export type TaskMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskMessages.
     */
    data: TaskMessageCreateManyInput | TaskMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskMessage createManyAndReturn
   */
  export type TaskMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskMessage
     */
    select?: TaskMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskMessage
     */
    omit?: TaskMessageOmit<ExtArgs> | null
    /**
     * The data used to create many TaskMessages.
     */
    data: TaskMessageCreateManyInput | TaskMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskMessage update
   */
  export type TaskMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskMessage
     */
    select?: TaskMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskMessage
     */
    omit?: TaskMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskMessage.
     */
    data: XOR<TaskMessageUpdateInput, TaskMessageUncheckedUpdateInput>
    /**
     * Choose, which TaskMessage to update.
     */
    where: TaskMessageWhereUniqueInput
  }

  /**
   * TaskMessage updateMany
   */
  export type TaskMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskMessages.
     */
    data: XOR<TaskMessageUpdateManyMutationInput, TaskMessageUncheckedUpdateManyInput>
    /**
     * Filter which TaskMessages to update
     */
    where?: TaskMessageWhereInput
    /**
     * Limit how many TaskMessages to update.
     */
    limit?: number
  }

  /**
   * TaskMessage updateManyAndReturn
   */
  export type TaskMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskMessage
     */
    select?: TaskMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskMessage
     */
    omit?: TaskMessageOmit<ExtArgs> | null
    /**
     * The data used to update TaskMessages.
     */
    data: XOR<TaskMessageUpdateManyMutationInput, TaskMessageUncheckedUpdateManyInput>
    /**
     * Filter which TaskMessages to update
     */
    where?: TaskMessageWhereInput
    /**
     * Limit how many TaskMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskMessage upsert
   */
  export type TaskMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskMessage
     */
    select?: TaskMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskMessage
     */
    omit?: TaskMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskMessage to update in case it exists.
     */
    where: TaskMessageWhereUniqueInput
    /**
     * In case the TaskMessage found by the `where` argument doesn't exist, create a new TaskMessage with this data.
     */
    create: XOR<TaskMessageCreateInput, TaskMessageUncheckedCreateInput>
    /**
     * In case the TaskMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskMessageUpdateInput, TaskMessageUncheckedUpdateInput>
  }

  /**
   * TaskMessage delete
   */
  export type TaskMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskMessage
     */
    select?: TaskMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskMessage
     */
    omit?: TaskMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskMessageInclude<ExtArgs> | null
    /**
     * Filter which TaskMessage to delete.
     */
    where: TaskMessageWhereUniqueInput
  }

  /**
   * TaskMessage deleteMany
   */
  export type TaskMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskMessages to delete
     */
    where?: TaskMessageWhereInput
    /**
     * Limit how many TaskMessages to delete.
     */
    limit?: number
  }

  /**
   * TaskMessage.attachments
   */
  export type TaskMessage$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAttachment
     */
    omit?: TaskAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null
    where?: TaskAttachmentWhereInput
    orderBy?: TaskAttachmentOrderByWithRelationInput | TaskAttachmentOrderByWithRelationInput[]
    cursor?: TaskAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskAttachmentScalarFieldEnum | TaskAttachmentScalarFieldEnum[]
  }

  /**
   * TaskMessage without action
   */
  export type TaskMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskMessage
     */
    select?: TaskMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskMessage
     */
    omit?: TaskMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskMessageInclude<ExtArgs> | null
  }


  /**
   * Model TaskAttachment
   */

  export type AggregateTaskAttachment = {
    _count: TaskAttachmentCountAggregateOutputType | null
    _avg: TaskAttachmentAvgAggregateOutputType | null
    _sum: TaskAttachmentSumAggregateOutputType | null
    _min: TaskAttachmentMinAggregateOutputType | null
    _max: TaskAttachmentMaxAggregateOutputType | null
  }

  export type TaskAttachmentAvgAggregateOutputType = {
    size: number | null
  }

  export type TaskAttachmentSumAggregateOutputType = {
    size: number | null
  }

  export type TaskAttachmentMinAggregateOutputType = {
    id: string | null
    taskId: string | null
    messageId: string | null
    uploaderId: string | null
    filename: string | null
    url: string | null
    fileType: string | null
    size: number | null
    createdAt: Date | null
  }

  export type TaskAttachmentMaxAggregateOutputType = {
    id: string | null
    taskId: string | null
    messageId: string | null
    uploaderId: string | null
    filename: string | null
    url: string | null
    fileType: string | null
    size: number | null
    createdAt: Date | null
  }

  export type TaskAttachmentCountAggregateOutputType = {
    id: number
    taskId: number
    messageId: number
    uploaderId: number
    filename: number
    url: number
    fileType: number
    size: number
    createdAt: number
    _all: number
  }


  export type TaskAttachmentAvgAggregateInputType = {
    size?: true
  }

  export type TaskAttachmentSumAggregateInputType = {
    size?: true
  }

  export type TaskAttachmentMinAggregateInputType = {
    id?: true
    taskId?: true
    messageId?: true
    uploaderId?: true
    filename?: true
    url?: true
    fileType?: true
    size?: true
    createdAt?: true
  }

  export type TaskAttachmentMaxAggregateInputType = {
    id?: true
    taskId?: true
    messageId?: true
    uploaderId?: true
    filename?: true
    url?: true
    fileType?: true
    size?: true
    createdAt?: true
  }

  export type TaskAttachmentCountAggregateInputType = {
    id?: true
    taskId?: true
    messageId?: true
    uploaderId?: true
    filename?: true
    url?: true
    fileType?: true
    size?: true
    createdAt?: true
    _all?: true
  }

  export type TaskAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskAttachment to aggregate.
     */
    where?: TaskAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAttachments to fetch.
     */
    orderBy?: TaskAttachmentOrderByWithRelationInput | TaskAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskAttachments
    **/
    _count?: true | TaskAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskAttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskAttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskAttachmentMaxAggregateInputType
  }

  export type GetTaskAttachmentAggregateType<T extends TaskAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskAttachment[P]>
      : GetScalarType<T[P], AggregateTaskAttachment[P]>
  }




  export type TaskAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskAttachmentWhereInput
    orderBy?: TaskAttachmentOrderByWithAggregationInput | TaskAttachmentOrderByWithAggregationInput[]
    by: TaskAttachmentScalarFieldEnum[] | TaskAttachmentScalarFieldEnum
    having?: TaskAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskAttachmentCountAggregateInputType | true
    _avg?: TaskAttachmentAvgAggregateInputType
    _sum?: TaskAttachmentSumAggregateInputType
    _min?: TaskAttachmentMinAggregateInputType
    _max?: TaskAttachmentMaxAggregateInputType
  }

  export type TaskAttachmentGroupByOutputType = {
    id: string
    taskId: string
    messageId: string | null
    uploaderId: string
    filename: string
    url: string
    fileType: string | null
    size: number | null
    createdAt: Date
    _count: TaskAttachmentCountAggregateOutputType | null
    _avg: TaskAttachmentAvgAggregateOutputType | null
    _sum: TaskAttachmentSumAggregateOutputType | null
    _min: TaskAttachmentMinAggregateOutputType | null
    _max: TaskAttachmentMaxAggregateOutputType | null
  }

  type GetTaskAttachmentGroupByPayload<T extends TaskAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], TaskAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type TaskAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    messageId?: boolean
    uploaderId?: boolean
    filename?: boolean
    url?: boolean
    fileType?: boolean
    size?: boolean
    createdAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    message?: boolean | TaskAttachment$messageArgs<ExtArgs>
  }, ExtArgs["result"]["taskAttachment"]>

  export type TaskAttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    messageId?: boolean
    uploaderId?: boolean
    filename?: boolean
    url?: boolean
    fileType?: boolean
    size?: boolean
    createdAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    message?: boolean | TaskAttachment$messageArgs<ExtArgs>
  }, ExtArgs["result"]["taskAttachment"]>

  export type TaskAttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    messageId?: boolean
    uploaderId?: boolean
    filename?: boolean
    url?: boolean
    fileType?: boolean
    size?: boolean
    createdAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    message?: boolean | TaskAttachment$messageArgs<ExtArgs>
  }, ExtArgs["result"]["taskAttachment"]>

  export type TaskAttachmentSelectScalar = {
    id?: boolean
    taskId?: boolean
    messageId?: boolean
    uploaderId?: boolean
    filename?: boolean
    url?: boolean
    fileType?: boolean
    size?: boolean
    createdAt?: boolean
  }

  export type TaskAttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskId" | "messageId" | "uploaderId" | "filename" | "url" | "fileType" | "size" | "createdAt", ExtArgs["result"]["taskAttachment"]>
  export type TaskAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    message?: boolean | TaskAttachment$messageArgs<ExtArgs>
  }
  export type TaskAttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    message?: boolean | TaskAttachment$messageArgs<ExtArgs>
  }
  export type TaskAttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    message?: boolean | TaskAttachment$messageArgs<ExtArgs>
  }

  export type $TaskAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskAttachment"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
      message: Prisma.$TaskMessagePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      taskId: string
      messageId: string | null
      uploaderId: string
      filename: string
      url: string
      fileType: string | null
      size: number | null
      createdAt: Date
    }, ExtArgs["result"]["taskAttachment"]>
    composites: {}
  }

  type TaskAttachmentGetPayload<S extends boolean | null | undefined | TaskAttachmentDefaultArgs> = $Result.GetResult<Prisma.$TaskAttachmentPayload, S>

  type TaskAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskAttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskAttachmentCountAggregateInputType | true
    }

  export interface TaskAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskAttachment'], meta: { name: 'TaskAttachment' } }
    /**
     * Find zero or one TaskAttachment that matches the filter.
     * @param {TaskAttachmentFindUniqueArgs} args - Arguments to find a TaskAttachment
     * @example
     * // Get one TaskAttachment
     * const taskAttachment = await prisma.taskAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskAttachmentFindUniqueArgs>(args: SelectSubset<T, TaskAttachmentFindUniqueArgs<ExtArgs>>): Prisma__TaskAttachmentClient<$Result.GetResult<Prisma.$TaskAttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskAttachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskAttachmentFindUniqueOrThrowArgs} args - Arguments to find a TaskAttachment
     * @example
     * // Get one TaskAttachment
     * const taskAttachment = await prisma.taskAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskAttachmentClient<$Result.GetResult<Prisma.$TaskAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAttachmentFindFirstArgs} args - Arguments to find a TaskAttachment
     * @example
     * // Get one TaskAttachment
     * const taskAttachment = await prisma.taskAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskAttachmentFindFirstArgs>(args?: SelectSubset<T, TaskAttachmentFindFirstArgs<ExtArgs>>): Prisma__TaskAttachmentClient<$Result.GetResult<Prisma.$TaskAttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAttachmentFindFirstOrThrowArgs} args - Arguments to find a TaskAttachment
     * @example
     * // Get one TaskAttachment
     * const taskAttachment = await prisma.taskAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskAttachmentClient<$Result.GetResult<Prisma.$TaskAttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskAttachments
     * const taskAttachments = await prisma.taskAttachment.findMany()
     * 
     * // Get first 10 TaskAttachments
     * const taskAttachments = await prisma.taskAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskAttachmentWithIdOnly = await prisma.taskAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskAttachmentFindManyArgs>(args?: SelectSubset<T, TaskAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskAttachment.
     * @param {TaskAttachmentCreateArgs} args - Arguments to create a TaskAttachment.
     * @example
     * // Create one TaskAttachment
     * const TaskAttachment = await prisma.taskAttachment.create({
     *   data: {
     *     // ... data to create a TaskAttachment
     *   }
     * })
     * 
     */
    create<T extends TaskAttachmentCreateArgs>(args: SelectSubset<T, TaskAttachmentCreateArgs<ExtArgs>>): Prisma__TaskAttachmentClient<$Result.GetResult<Prisma.$TaskAttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskAttachments.
     * @param {TaskAttachmentCreateManyArgs} args - Arguments to create many TaskAttachments.
     * @example
     * // Create many TaskAttachments
     * const taskAttachment = await prisma.taskAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskAttachmentCreateManyArgs>(args?: SelectSubset<T, TaskAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskAttachments and returns the data saved in the database.
     * @param {TaskAttachmentCreateManyAndReturnArgs} args - Arguments to create many TaskAttachments.
     * @example
     * // Create many TaskAttachments
     * const taskAttachment = await prisma.taskAttachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskAttachments and only return the `id`
     * const taskAttachmentWithIdOnly = await prisma.taskAttachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskAttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskAttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaskAttachment.
     * @param {TaskAttachmentDeleteArgs} args - Arguments to delete one TaskAttachment.
     * @example
     * // Delete one TaskAttachment
     * const TaskAttachment = await prisma.taskAttachment.delete({
     *   where: {
     *     // ... filter to delete one TaskAttachment
     *   }
     * })
     * 
     */
    delete<T extends TaskAttachmentDeleteArgs>(args: SelectSubset<T, TaskAttachmentDeleteArgs<ExtArgs>>): Prisma__TaskAttachmentClient<$Result.GetResult<Prisma.$TaskAttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskAttachment.
     * @param {TaskAttachmentUpdateArgs} args - Arguments to update one TaskAttachment.
     * @example
     * // Update one TaskAttachment
     * const taskAttachment = await prisma.taskAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskAttachmentUpdateArgs>(args: SelectSubset<T, TaskAttachmentUpdateArgs<ExtArgs>>): Prisma__TaskAttachmentClient<$Result.GetResult<Prisma.$TaskAttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskAttachments.
     * @param {TaskAttachmentDeleteManyArgs} args - Arguments to filter TaskAttachments to delete.
     * @example
     * // Delete a few TaskAttachments
     * const { count } = await prisma.taskAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskAttachmentDeleteManyArgs>(args?: SelectSubset<T, TaskAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskAttachments
     * const taskAttachment = await prisma.taskAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskAttachmentUpdateManyArgs>(args: SelectSubset<T, TaskAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskAttachments and returns the data updated in the database.
     * @param {TaskAttachmentUpdateManyAndReturnArgs} args - Arguments to update many TaskAttachments.
     * @example
     * // Update many TaskAttachments
     * const taskAttachment = await prisma.taskAttachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaskAttachments and only return the `id`
     * const taskAttachmentWithIdOnly = await prisma.taskAttachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskAttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskAttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaskAttachment.
     * @param {TaskAttachmentUpsertArgs} args - Arguments to update or create a TaskAttachment.
     * @example
     * // Update or create a TaskAttachment
     * const taskAttachment = await prisma.taskAttachment.upsert({
     *   create: {
     *     // ... data to create a TaskAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskAttachment we want to update
     *   }
     * })
     */
    upsert<T extends TaskAttachmentUpsertArgs>(args: SelectSubset<T, TaskAttachmentUpsertArgs<ExtArgs>>): Prisma__TaskAttachmentClient<$Result.GetResult<Prisma.$TaskAttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaskAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAttachmentCountArgs} args - Arguments to filter TaskAttachments to count.
     * @example
     * // Count the number of TaskAttachments
     * const count = await prisma.taskAttachment.count({
     *   where: {
     *     // ... the filter for the TaskAttachments we want to count
     *   }
     * })
    **/
    count<T extends TaskAttachmentCountArgs>(
      args?: Subset<T, TaskAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAttachmentAggregateArgs>(args: Subset<T, TaskAttachmentAggregateArgs>): Prisma.PrismaPromise<GetTaskAttachmentAggregateType<T>>

    /**
     * Group by TaskAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: TaskAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskAttachment model
   */
  readonly fields: TaskAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    message<T extends TaskAttachment$messageArgs<ExtArgs> = {}>(args?: Subset<T, TaskAttachment$messageArgs<ExtArgs>>): Prisma__TaskMessageClient<$Result.GetResult<Prisma.$TaskMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskAttachment model
   */
  interface TaskAttachmentFieldRefs {
    readonly id: FieldRef<"TaskAttachment", 'String'>
    readonly taskId: FieldRef<"TaskAttachment", 'String'>
    readonly messageId: FieldRef<"TaskAttachment", 'String'>
    readonly uploaderId: FieldRef<"TaskAttachment", 'String'>
    readonly filename: FieldRef<"TaskAttachment", 'String'>
    readonly url: FieldRef<"TaskAttachment", 'String'>
    readonly fileType: FieldRef<"TaskAttachment", 'String'>
    readonly size: FieldRef<"TaskAttachment", 'Int'>
    readonly createdAt: FieldRef<"TaskAttachment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaskAttachment findUnique
   */
  export type TaskAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAttachment
     */
    omit?: TaskAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TaskAttachment to fetch.
     */
    where: TaskAttachmentWhereUniqueInput
  }

  /**
   * TaskAttachment findUniqueOrThrow
   */
  export type TaskAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAttachment
     */
    omit?: TaskAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TaskAttachment to fetch.
     */
    where: TaskAttachmentWhereUniqueInput
  }

  /**
   * TaskAttachment findFirst
   */
  export type TaskAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAttachment
     */
    omit?: TaskAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TaskAttachment to fetch.
     */
    where?: TaskAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAttachments to fetch.
     */
    orderBy?: TaskAttachmentOrderByWithRelationInput | TaskAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskAttachments.
     */
    cursor?: TaskAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskAttachments.
     */
    distinct?: TaskAttachmentScalarFieldEnum | TaskAttachmentScalarFieldEnum[]
  }

  /**
   * TaskAttachment findFirstOrThrow
   */
  export type TaskAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAttachment
     */
    omit?: TaskAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TaskAttachment to fetch.
     */
    where?: TaskAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAttachments to fetch.
     */
    orderBy?: TaskAttachmentOrderByWithRelationInput | TaskAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskAttachments.
     */
    cursor?: TaskAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskAttachments.
     */
    distinct?: TaskAttachmentScalarFieldEnum | TaskAttachmentScalarFieldEnum[]
  }

  /**
   * TaskAttachment findMany
   */
  export type TaskAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAttachment
     */
    omit?: TaskAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TaskAttachments to fetch.
     */
    where?: TaskAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAttachments to fetch.
     */
    orderBy?: TaskAttachmentOrderByWithRelationInput | TaskAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskAttachments.
     */
    cursor?: TaskAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAttachments.
     */
    skip?: number
    distinct?: TaskAttachmentScalarFieldEnum | TaskAttachmentScalarFieldEnum[]
  }

  /**
   * TaskAttachment create
   */
  export type TaskAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAttachment
     */
    omit?: TaskAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskAttachment.
     */
    data: XOR<TaskAttachmentCreateInput, TaskAttachmentUncheckedCreateInput>
  }

  /**
   * TaskAttachment createMany
   */
  export type TaskAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskAttachments.
     */
    data: TaskAttachmentCreateManyInput | TaskAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskAttachment createManyAndReturn
   */
  export type TaskAttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAttachment
     */
    omit?: TaskAttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many TaskAttachments.
     */
    data: TaskAttachmentCreateManyInput | TaskAttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskAttachment update
   */
  export type TaskAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAttachment
     */
    omit?: TaskAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskAttachment.
     */
    data: XOR<TaskAttachmentUpdateInput, TaskAttachmentUncheckedUpdateInput>
    /**
     * Choose, which TaskAttachment to update.
     */
    where: TaskAttachmentWhereUniqueInput
  }

  /**
   * TaskAttachment updateMany
   */
  export type TaskAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskAttachments.
     */
    data: XOR<TaskAttachmentUpdateManyMutationInput, TaskAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which TaskAttachments to update
     */
    where?: TaskAttachmentWhereInput
    /**
     * Limit how many TaskAttachments to update.
     */
    limit?: number
  }

  /**
   * TaskAttachment updateManyAndReturn
   */
  export type TaskAttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAttachment
     */
    omit?: TaskAttachmentOmit<ExtArgs> | null
    /**
     * The data used to update TaskAttachments.
     */
    data: XOR<TaskAttachmentUpdateManyMutationInput, TaskAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which TaskAttachments to update
     */
    where?: TaskAttachmentWhereInput
    /**
     * Limit how many TaskAttachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskAttachment upsert
   */
  export type TaskAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAttachment
     */
    omit?: TaskAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskAttachment to update in case it exists.
     */
    where: TaskAttachmentWhereUniqueInput
    /**
     * In case the TaskAttachment found by the `where` argument doesn't exist, create a new TaskAttachment with this data.
     */
    create: XOR<TaskAttachmentCreateInput, TaskAttachmentUncheckedCreateInput>
    /**
     * In case the TaskAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskAttachmentUpdateInput, TaskAttachmentUncheckedUpdateInput>
  }

  /**
   * TaskAttachment delete
   */
  export type TaskAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAttachment
     */
    omit?: TaskAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null
    /**
     * Filter which TaskAttachment to delete.
     */
    where: TaskAttachmentWhereUniqueInput
  }

  /**
   * TaskAttachment deleteMany
   */
  export type TaskAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskAttachments to delete
     */
    where?: TaskAttachmentWhereInput
    /**
     * Limit how many TaskAttachments to delete.
     */
    limit?: number
  }

  /**
   * TaskAttachment.message
   */
  export type TaskAttachment$messageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskMessage
     */
    select?: TaskMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskMessage
     */
    omit?: TaskMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskMessageInclude<ExtArgs> | null
    where?: TaskMessageWhereInput
  }

  /**
   * TaskAttachment without action
   */
  export type TaskAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAttachment
     */
    omit?: TaskAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model DepartmentMonthlyReport
   */

  export type AggregateDepartmentMonthlyReport = {
    _count: DepartmentMonthlyReportCountAggregateOutputType | null
    _min: DepartmentMonthlyReportMinAggregateOutputType | null
    _max: DepartmentMonthlyReportMaxAggregateOutputType | null
  }

  export type DepartmentMonthlyReportMinAggregateOutputType = {
    id: string | null
    deptId: string | null
    userId: string | null
    month: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentMonthlyReportMaxAggregateOutputType = {
    id: string | null
    deptId: string | null
    userId: string | null
    month: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentMonthlyReportCountAggregateOutputType = {
    id: number
    deptId: number
    userId: number
    month: number
    content: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DepartmentMonthlyReportMinAggregateInputType = {
    id?: true
    deptId?: true
    userId?: true
    month?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentMonthlyReportMaxAggregateInputType = {
    id?: true
    deptId?: true
    userId?: true
    month?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentMonthlyReportCountAggregateInputType = {
    id?: true
    deptId?: true
    userId?: true
    month?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepartmentMonthlyReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DepartmentMonthlyReport to aggregate.
     */
    where?: DepartmentMonthlyReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentMonthlyReports to fetch.
     */
    orderBy?: DepartmentMonthlyReportOrderByWithRelationInput | DepartmentMonthlyReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentMonthlyReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentMonthlyReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentMonthlyReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DepartmentMonthlyReports
    **/
    _count?: true | DepartmentMonthlyReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMonthlyReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMonthlyReportMaxAggregateInputType
  }

  export type GetDepartmentMonthlyReportAggregateType<T extends DepartmentMonthlyReportAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartmentMonthlyReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartmentMonthlyReport[P]>
      : GetScalarType<T[P], AggregateDepartmentMonthlyReport[P]>
  }




  export type DepartmentMonthlyReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentMonthlyReportWhereInput
    orderBy?: DepartmentMonthlyReportOrderByWithAggregationInput | DepartmentMonthlyReportOrderByWithAggregationInput[]
    by: DepartmentMonthlyReportScalarFieldEnum[] | DepartmentMonthlyReportScalarFieldEnum
    having?: DepartmentMonthlyReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentMonthlyReportCountAggregateInputType | true
    _min?: DepartmentMonthlyReportMinAggregateInputType
    _max?: DepartmentMonthlyReportMaxAggregateInputType
  }

  export type DepartmentMonthlyReportGroupByOutputType = {
    id: string
    deptId: string
    userId: string
    month: string
    content: string
    createdAt: Date
    updatedAt: Date
    _count: DepartmentMonthlyReportCountAggregateOutputType | null
    _min: DepartmentMonthlyReportMinAggregateOutputType | null
    _max: DepartmentMonthlyReportMaxAggregateOutputType | null
  }

  type GetDepartmentMonthlyReportGroupByPayload<T extends DepartmentMonthlyReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentMonthlyReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentMonthlyReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentMonthlyReportGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentMonthlyReportGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentMonthlyReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deptId?: boolean
    userId?: boolean
    month?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["departmentMonthlyReport"]>

  export type DepartmentMonthlyReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deptId?: boolean
    userId?: boolean
    month?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["departmentMonthlyReport"]>

  export type DepartmentMonthlyReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deptId?: boolean
    userId?: boolean
    month?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["departmentMonthlyReport"]>

  export type DepartmentMonthlyReportSelectScalar = {
    id?: boolean
    deptId?: boolean
    userId?: boolean
    month?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DepartmentMonthlyReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "deptId" | "userId" | "month" | "content" | "createdAt" | "updatedAt", ExtArgs["result"]["departmentMonthlyReport"]>
  export type DepartmentMonthlyReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DepartmentMonthlyReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DepartmentMonthlyReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DepartmentMonthlyReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DepartmentMonthlyReport"
    objects: {
      department: Prisma.$DepartmentPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      deptId: string
      userId: string
      month: string
      content: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["departmentMonthlyReport"]>
    composites: {}
  }

  type DepartmentMonthlyReportGetPayload<S extends boolean | null | undefined | DepartmentMonthlyReportDefaultArgs> = $Result.GetResult<Prisma.$DepartmentMonthlyReportPayload, S>

  type DepartmentMonthlyReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DepartmentMonthlyReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepartmentMonthlyReportCountAggregateInputType | true
    }

  export interface DepartmentMonthlyReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DepartmentMonthlyReport'], meta: { name: 'DepartmentMonthlyReport' } }
    /**
     * Find zero or one DepartmentMonthlyReport that matches the filter.
     * @param {DepartmentMonthlyReportFindUniqueArgs} args - Arguments to find a DepartmentMonthlyReport
     * @example
     * // Get one DepartmentMonthlyReport
     * const departmentMonthlyReport = await prisma.departmentMonthlyReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentMonthlyReportFindUniqueArgs>(args: SelectSubset<T, DepartmentMonthlyReportFindUniqueArgs<ExtArgs>>): Prisma__DepartmentMonthlyReportClient<$Result.GetResult<Prisma.$DepartmentMonthlyReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DepartmentMonthlyReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DepartmentMonthlyReportFindUniqueOrThrowArgs} args - Arguments to find a DepartmentMonthlyReport
     * @example
     * // Get one DepartmentMonthlyReport
     * const departmentMonthlyReport = await prisma.departmentMonthlyReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentMonthlyReportFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentMonthlyReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentMonthlyReportClient<$Result.GetResult<Prisma.$DepartmentMonthlyReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DepartmentMonthlyReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentMonthlyReportFindFirstArgs} args - Arguments to find a DepartmentMonthlyReport
     * @example
     * // Get one DepartmentMonthlyReport
     * const departmentMonthlyReport = await prisma.departmentMonthlyReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentMonthlyReportFindFirstArgs>(args?: SelectSubset<T, DepartmentMonthlyReportFindFirstArgs<ExtArgs>>): Prisma__DepartmentMonthlyReportClient<$Result.GetResult<Prisma.$DepartmentMonthlyReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DepartmentMonthlyReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentMonthlyReportFindFirstOrThrowArgs} args - Arguments to find a DepartmentMonthlyReport
     * @example
     * // Get one DepartmentMonthlyReport
     * const departmentMonthlyReport = await prisma.departmentMonthlyReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentMonthlyReportFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentMonthlyReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentMonthlyReportClient<$Result.GetResult<Prisma.$DepartmentMonthlyReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DepartmentMonthlyReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentMonthlyReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DepartmentMonthlyReports
     * const departmentMonthlyReports = await prisma.departmentMonthlyReport.findMany()
     * 
     * // Get first 10 DepartmentMonthlyReports
     * const departmentMonthlyReports = await prisma.departmentMonthlyReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentMonthlyReportWithIdOnly = await prisma.departmentMonthlyReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentMonthlyReportFindManyArgs>(args?: SelectSubset<T, DepartmentMonthlyReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentMonthlyReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DepartmentMonthlyReport.
     * @param {DepartmentMonthlyReportCreateArgs} args - Arguments to create a DepartmentMonthlyReport.
     * @example
     * // Create one DepartmentMonthlyReport
     * const DepartmentMonthlyReport = await prisma.departmentMonthlyReport.create({
     *   data: {
     *     // ... data to create a DepartmentMonthlyReport
     *   }
     * })
     * 
     */
    create<T extends DepartmentMonthlyReportCreateArgs>(args: SelectSubset<T, DepartmentMonthlyReportCreateArgs<ExtArgs>>): Prisma__DepartmentMonthlyReportClient<$Result.GetResult<Prisma.$DepartmentMonthlyReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DepartmentMonthlyReports.
     * @param {DepartmentMonthlyReportCreateManyArgs} args - Arguments to create many DepartmentMonthlyReports.
     * @example
     * // Create many DepartmentMonthlyReports
     * const departmentMonthlyReport = await prisma.departmentMonthlyReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentMonthlyReportCreateManyArgs>(args?: SelectSubset<T, DepartmentMonthlyReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DepartmentMonthlyReports and returns the data saved in the database.
     * @param {DepartmentMonthlyReportCreateManyAndReturnArgs} args - Arguments to create many DepartmentMonthlyReports.
     * @example
     * // Create many DepartmentMonthlyReports
     * const departmentMonthlyReport = await prisma.departmentMonthlyReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DepartmentMonthlyReports and only return the `id`
     * const departmentMonthlyReportWithIdOnly = await prisma.departmentMonthlyReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepartmentMonthlyReportCreateManyAndReturnArgs>(args?: SelectSubset<T, DepartmentMonthlyReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentMonthlyReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DepartmentMonthlyReport.
     * @param {DepartmentMonthlyReportDeleteArgs} args - Arguments to delete one DepartmentMonthlyReport.
     * @example
     * // Delete one DepartmentMonthlyReport
     * const DepartmentMonthlyReport = await prisma.departmentMonthlyReport.delete({
     *   where: {
     *     // ... filter to delete one DepartmentMonthlyReport
     *   }
     * })
     * 
     */
    delete<T extends DepartmentMonthlyReportDeleteArgs>(args: SelectSubset<T, DepartmentMonthlyReportDeleteArgs<ExtArgs>>): Prisma__DepartmentMonthlyReportClient<$Result.GetResult<Prisma.$DepartmentMonthlyReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DepartmentMonthlyReport.
     * @param {DepartmentMonthlyReportUpdateArgs} args - Arguments to update one DepartmentMonthlyReport.
     * @example
     * // Update one DepartmentMonthlyReport
     * const departmentMonthlyReport = await prisma.departmentMonthlyReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentMonthlyReportUpdateArgs>(args: SelectSubset<T, DepartmentMonthlyReportUpdateArgs<ExtArgs>>): Prisma__DepartmentMonthlyReportClient<$Result.GetResult<Prisma.$DepartmentMonthlyReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DepartmentMonthlyReports.
     * @param {DepartmentMonthlyReportDeleteManyArgs} args - Arguments to filter DepartmentMonthlyReports to delete.
     * @example
     * // Delete a few DepartmentMonthlyReports
     * const { count } = await prisma.departmentMonthlyReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentMonthlyReportDeleteManyArgs>(args?: SelectSubset<T, DepartmentMonthlyReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DepartmentMonthlyReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentMonthlyReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DepartmentMonthlyReports
     * const departmentMonthlyReport = await prisma.departmentMonthlyReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentMonthlyReportUpdateManyArgs>(args: SelectSubset<T, DepartmentMonthlyReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DepartmentMonthlyReports and returns the data updated in the database.
     * @param {DepartmentMonthlyReportUpdateManyAndReturnArgs} args - Arguments to update many DepartmentMonthlyReports.
     * @example
     * // Update many DepartmentMonthlyReports
     * const departmentMonthlyReport = await prisma.departmentMonthlyReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DepartmentMonthlyReports and only return the `id`
     * const departmentMonthlyReportWithIdOnly = await prisma.departmentMonthlyReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DepartmentMonthlyReportUpdateManyAndReturnArgs>(args: SelectSubset<T, DepartmentMonthlyReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentMonthlyReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DepartmentMonthlyReport.
     * @param {DepartmentMonthlyReportUpsertArgs} args - Arguments to update or create a DepartmentMonthlyReport.
     * @example
     * // Update or create a DepartmentMonthlyReport
     * const departmentMonthlyReport = await prisma.departmentMonthlyReport.upsert({
     *   create: {
     *     // ... data to create a DepartmentMonthlyReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DepartmentMonthlyReport we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentMonthlyReportUpsertArgs>(args: SelectSubset<T, DepartmentMonthlyReportUpsertArgs<ExtArgs>>): Prisma__DepartmentMonthlyReportClient<$Result.GetResult<Prisma.$DepartmentMonthlyReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DepartmentMonthlyReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentMonthlyReportCountArgs} args - Arguments to filter DepartmentMonthlyReports to count.
     * @example
     * // Count the number of DepartmentMonthlyReports
     * const count = await prisma.departmentMonthlyReport.count({
     *   where: {
     *     // ... the filter for the DepartmentMonthlyReports we want to count
     *   }
     * })
    **/
    count<T extends DepartmentMonthlyReportCountArgs>(
      args?: Subset<T, DepartmentMonthlyReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentMonthlyReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DepartmentMonthlyReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentMonthlyReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentMonthlyReportAggregateArgs>(args: Subset<T, DepartmentMonthlyReportAggregateArgs>): Prisma.PrismaPromise<GetDepartmentMonthlyReportAggregateType<T>>

    /**
     * Group by DepartmentMonthlyReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentMonthlyReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentMonthlyReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentMonthlyReportGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentMonthlyReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentMonthlyReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentMonthlyReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DepartmentMonthlyReport model
   */
  readonly fields: DepartmentMonthlyReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DepartmentMonthlyReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentMonthlyReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    department<T extends DepartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DepartmentDefaultArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DepartmentMonthlyReport model
   */
  interface DepartmentMonthlyReportFieldRefs {
    readonly id: FieldRef<"DepartmentMonthlyReport", 'String'>
    readonly deptId: FieldRef<"DepartmentMonthlyReport", 'String'>
    readonly userId: FieldRef<"DepartmentMonthlyReport", 'String'>
    readonly month: FieldRef<"DepartmentMonthlyReport", 'String'>
    readonly content: FieldRef<"DepartmentMonthlyReport", 'String'>
    readonly createdAt: FieldRef<"DepartmentMonthlyReport", 'DateTime'>
    readonly updatedAt: FieldRef<"DepartmentMonthlyReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DepartmentMonthlyReport findUnique
   */
  export type DepartmentMonthlyReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentMonthlyReport
     */
    select?: DepartmentMonthlyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentMonthlyReport
     */
    omit?: DepartmentMonthlyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentMonthlyReportInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentMonthlyReport to fetch.
     */
    where: DepartmentMonthlyReportWhereUniqueInput
  }

  /**
   * DepartmentMonthlyReport findUniqueOrThrow
   */
  export type DepartmentMonthlyReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentMonthlyReport
     */
    select?: DepartmentMonthlyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentMonthlyReport
     */
    omit?: DepartmentMonthlyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentMonthlyReportInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentMonthlyReport to fetch.
     */
    where: DepartmentMonthlyReportWhereUniqueInput
  }

  /**
   * DepartmentMonthlyReport findFirst
   */
  export type DepartmentMonthlyReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentMonthlyReport
     */
    select?: DepartmentMonthlyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentMonthlyReport
     */
    omit?: DepartmentMonthlyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentMonthlyReportInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentMonthlyReport to fetch.
     */
    where?: DepartmentMonthlyReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentMonthlyReports to fetch.
     */
    orderBy?: DepartmentMonthlyReportOrderByWithRelationInput | DepartmentMonthlyReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DepartmentMonthlyReports.
     */
    cursor?: DepartmentMonthlyReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentMonthlyReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentMonthlyReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DepartmentMonthlyReports.
     */
    distinct?: DepartmentMonthlyReportScalarFieldEnum | DepartmentMonthlyReportScalarFieldEnum[]
  }

  /**
   * DepartmentMonthlyReport findFirstOrThrow
   */
  export type DepartmentMonthlyReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentMonthlyReport
     */
    select?: DepartmentMonthlyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentMonthlyReport
     */
    omit?: DepartmentMonthlyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentMonthlyReportInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentMonthlyReport to fetch.
     */
    where?: DepartmentMonthlyReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentMonthlyReports to fetch.
     */
    orderBy?: DepartmentMonthlyReportOrderByWithRelationInput | DepartmentMonthlyReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DepartmentMonthlyReports.
     */
    cursor?: DepartmentMonthlyReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentMonthlyReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentMonthlyReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DepartmentMonthlyReports.
     */
    distinct?: DepartmentMonthlyReportScalarFieldEnum | DepartmentMonthlyReportScalarFieldEnum[]
  }

  /**
   * DepartmentMonthlyReport findMany
   */
  export type DepartmentMonthlyReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentMonthlyReport
     */
    select?: DepartmentMonthlyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentMonthlyReport
     */
    omit?: DepartmentMonthlyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentMonthlyReportInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentMonthlyReports to fetch.
     */
    where?: DepartmentMonthlyReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentMonthlyReports to fetch.
     */
    orderBy?: DepartmentMonthlyReportOrderByWithRelationInput | DepartmentMonthlyReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DepartmentMonthlyReports.
     */
    cursor?: DepartmentMonthlyReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentMonthlyReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentMonthlyReports.
     */
    skip?: number
    distinct?: DepartmentMonthlyReportScalarFieldEnum | DepartmentMonthlyReportScalarFieldEnum[]
  }

  /**
   * DepartmentMonthlyReport create
   */
  export type DepartmentMonthlyReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentMonthlyReport
     */
    select?: DepartmentMonthlyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentMonthlyReport
     */
    omit?: DepartmentMonthlyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentMonthlyReportInclude<ExtArgs> | null
    /**
     * The data needed to create a DepartmentMonthlyReport.
     */
    data: XOR<DepartmentMonthlyReportCreateInput, DepartmentMonthlyReportUncheckedCreateInput>
  }

  /**
   * DepartmentMonthlyReport createMany
   */
  export type DepartmentMonthlyReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DepartmentMonthlyReports.
     */
    data: DepartmentMonthlyReportCreateManyInput | DepartmentMonthlyReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DepartmentMonthlyReport createManyAndReturn
   */
  export type DepartmentMonthlyReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentMonthlyReport
     */
    select?: DepartmentMonthlyReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentMonthlyReport
     */
    omit?: DepartmentMonthlyReportOmit<ExtArgs> | null
    /**
     * The data used to create many DepartmentMonthlyReports.
     */
    data: DepartmentMonthlyReportCreateManyInput | DepartmentMonthlyReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentMonthlyReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DepartmentMonthlyReport update
   */
  export type DepartmentMonthlyReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentMonthlyReport
     */
    select?: DepartmentMonthlyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentMonthlyReport
     */
    omit?: DepartmentMonthlyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentMonthlyReportInclude<ExtArgs> | null
    /**
     * The data needed to update a DepartmentMonthlyReport.
     */
    data: XOR<DepartmentMonthlyReportUpdateInput, DepartmentMonthlyReportUncheckedUpdateInput>
    /**
     * Choose, which DepartmentMonthlyReport to update.
     */
    where: DepartmentMonthlyReportWhereUniqueInput
  }

  /**
   * DepartmentMonthlyReport updateMany
   */
  export type DepartmentMonthlyReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DepartmentMonthlyReports.
     */
    data: XOR<DepartmentMonthlyReportUpdateManyMutationInput, DepartmentMonthlyReportUncheckedUpdateManyInput>
    /**
     * Filter which DepartmentMonthlyReports to update
     */
    where?: DepartmentMonthlyReportWhereInput
    /**
     * Limit how many DepartmentMonthlyReports to update.
     */
    limit?: number
  }

  /**
   * DepartmentMonthlyReport updateManyAndReturn
   */
  export type DepartmentMonthlyReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentMonthlyReport
     */
    select?: DepartmentMonthlyReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentMonthlyReport
     */
    omit?: DepartmentMonthlyReportOmit<ExtArgs> | null
    /**
     * The data used to update DepartmentMonthlyReports.
     */
    data: XOR<DepartmentMonthlyReportUpdateManyMutationInput, DepartmentMonthlyReportUncheckedUpdateManyInput>
    /**
     * Filter which DepartmentMonthlyReports to update
     */
    where?: DepartmentMonthlyReportWhereInput
    /**
     * Limit how many DepartmentMonthlyReports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentMonthlyReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DepartmentMonthlyReport upsert
   */
  export type DepartmentMonthlyReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentMonthlyReport
     */
    select?: DepartmentMonthlyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentMonthlyReport
     */
    omit?: DepartmentMonthlyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentMonthlyReportInclude<ExtArgs> | null
    /**
     * The filter to search for the DepartmentMonthlyReport to update in case it exists.
     */
    where: DepartmentMonthlyReportWhereUniqueInput
    /**
     * In case the DepartmentMonthlyReport found by the `where` argument doesn't exist, create a new DepartmentMonthlyReport with this data.
     */
    create: XOR<DepartmentMonthlyReportCreateInput, DepartmentMonthlyReportUncheckedCreateInput>
    /**
     * In case the DepartmentMonthlyReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentMonthlyReportUpdateInput, DepartmentMonthlyReportUncheckedUpdateInput>
  }

  /**
   * DepartmentMonthlyReport delete
   */
  export type DepartmentMonthlyReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentMonthlyReport
     */
    select?: DepartmentMonthlyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentMonthlyReport
     */
    omit?: DepartmentMonthlyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentMonthlyReportInclude<ExtArgs> | null
    /**
     * Filter which DepartmentMonthlyReport to delete.
     */
    where: DepartmentMonthlyReportWhereUniqueInput
  }

  /**
   * DepartmentMonthlyReport deleteMany
   */
  export type DepartmentMonthlyReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DepartmentMonthlyReports to delete
     */
    where?: DepartmentMonthlyReportWhereInput
    /**
     * Limit how many DepartmentMonthlyReports to delete.
     */
    limit?: number
  }

  /**
   * DepartmentMonthlyReport without action
   */
  export type DepartmentMonthlyReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentMonthlyReport
     */
    select?: DepartmentMonthlyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentMonthlyReport
     */
    omit?: DepartmentMonthlyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentMonthlyReportInclude<ExtArgs> | null
  }


  /**
   * Model PushSubscription
   */

  export type AggregatePushSubscription = {
    _count: PushSubscriptionCountAggregateOutputType | null
    _min: PushSubscriptionMinAggregateOutputType | null
    _max: PushSubscriptionMaxAggregateOutputType | null
  }

  export type PushSubscriptionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    endpoint: string | null
    p256dh: string | null
    auth: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PushSubscriptionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    endpoint: string | null
    p256dh: string | null
    auth: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PushSubscriptionCountAggregateOutputType = {
    id: number
    userId: number
    endpoint: number
    p256dh: number
    auth: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PushSubscriptionMinAggregateInputType = {
    id?: true
    userId?: true
    endpoint?: true
    p256dh?: true
    auth?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PushSubscriptionMaxAggregateInputType = {
    id?: true
    userId?: true
    endpoint?: true
    p256dh?: true
    auth?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PushSubscriptionCountAggregateInputType = {
    id?: true
    userId?: true
    endpoint?: true
    p256dh?: true
    auth?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PushSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PushSubscription to aggregate.
     */
    where?: PushSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushSubscriptions to fetch.
     */
    orderBy?: PushSubscriptionOrderByWithRelationInput | PushSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PushSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PushSubscriptions
    **/
    _count?: true | PushSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PushSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PushSubscriptionMaxAggregateInputType
  }

  export type GetPushSubscriptionAggregateType<T extends PushSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregatePushSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePushSubscription[P]>
      : GetScalarType<T[P], AggregatePushSubscription[P]>
  }




  export type PushSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PushSubscriptionWhereInput
    orderBy?: PushSubscriptionOrderByWithAggregationInput | PushSubscriptionOrderByWithAggregationInput[]
    by: PushSubscriptionScalarFieldEnum[] | PushSubscriptionScalarFieldEnum
    having?: PushSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PushSubscriptionCountAggregateInputType | true
    _min?: PushSubscriptionMinAggregateInputType
    _max?: PushSubscriptionMaxAggregateInputType
  }

  export type PushSubscriptionGroupByOutputType = {
    id: string
    userId: string
    endpoint: string
    p256dh: string
    auth: string
    createdAt: Date
    updatedAt: Date
    _count: PushSubscriptionCountAggregateOutputType | null
    _min: PushSubscriptionMinAggregateOutputType | null
    _max: PushSubscriptionMaxAggregateOutputType | null
  }

  type GetPushSubscriptionGroupByPayload<T extends PushSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PushSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PushSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PushSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], PushSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type PushSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    endpoint?: boolean
    p256dh?: boolean
    auth?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pushSubscription"]>

  export type PushSubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    endpoint?: boolean
    p256dh?: boolean
    auth?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pushSubscription"]>

  export type PushSubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    endpoint?: boolean
    p256dh?: boolean
    auth?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pushSubscription"]>

  export type PushSubscriptionSelectScalar = {
    id?: boolean
    userId?: boolean
    endpoint?: boolean
    p256dh?: boolean
    auth?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PushSubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "endpoint" | "p256dh" | "auth" | "createdAt" | "updatedAt", ExtArgs["result"]["pushSubscription"]>
  export type PushSubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PushSubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PushSubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PushSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PushSubscription"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      endpoint: string
      p256dh: string
      auth: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pushSubscription"]>
    composites: {}
  }

  type PushSubscriptionGetPayload<S extends boolean | null | undefined | PushSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$PushSubscriptionPayload, S>

  type PushSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PushSubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PushSubscriptionCountAggregateInputType | true
    }

  export interface PushSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PushSubscription'], meta: { name: 'PushSubscription' } }
    /**
     * Find zero or one PushSubscription that matches the filter.
     * @param {PushSubscriptionFindUniqueArgs} args - Arguments to find a PushSubscription
     * @example
     * // Get one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PushSubscriptionFindUniqueArgs>(args: SelectSubset<T, PushSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PushSubscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PushSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a PushSubscription
     * @example
     * // Get one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PushSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, PushSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PushSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionFindFirstArgs} args - Arguments to find a PushSubscription
     * @example
     * // Get one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PushSubscriptionFindFirstArgs>(args?: SelectSubset<T, PushSubscriptionFindFirstArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PushSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionFindFirstOrThrowArgs} args - Arguments to find a PushSubscription
     * @example
     * // Get one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PushSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, PushSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PushSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PushSubscriptions
     * const pushSubscriptions = await prisma.pushSubscription.findMany()
     * 
     * // Get first 10 PushSubscriptions
     * const pushSubscriptions = await prisma.pushSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pushSubscriptionWithIdOnly = await prisma.pushSubscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PushSubscriptionFindManyArgs>(args?: SelectSubset<T, PushSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PushSubscription.
     * @param {PushSubscriptionCreateArgs} args - Arguments to create a PushSubscription.
     * @example
     * // Create one PushSubscription
     * const PushSubscription = await prisma.pushSubscription.create({
     *   data: {
     *     // ... data to create a PushSubscription
     *   }
     * })
     * 
     */
    create<T extends PushSubscriptionCreateArgs>(args: SelectSubset<T, PushSubscriptionCreateArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PushSubscriptions.
     * @param {PushSubscriptionCreateManyArgs} args - Arguments to create many PushSubscriptions.
     * @example
     * // Create many PushSubscriptions
     * const pushSubscription = await prisma.pushSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PushSubscriptionCreateManyArgs>(args?: SelectSubset<T, PushSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PushSubscriptions and returns the data saved in the database.
     * @param {PushSubscriptionCreateManyAndReturnArgs} args - Arguments to create many PushSubscriptions.
     * @example
     * // Create many PushSubscriptions
     * const pushSubscription = await prisma.pushSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PushSubscriptions and only return the `id`
     * const pushSubscriptionWithIdOnly = await prisma.pushSubscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PushSubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, PushSubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PushSubscription.
     * @param {PushSubscriptionDeleteArgs} args - Arguments to delete one PushSubscription.
     * @example
     * // Delete one PushSubscription
     * const PushSubscription = await prisma.pushSubscription.delete({
     *   where: {
     *     // ... filter to delete one PushSubscription
     *   }
     * })
     * 
     */
    delete<T extends PushSubscriptionDeleteArgs>(args: SelectSubset<T, PushSubscriptionDeleteArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PushSubscription.
     * @param {PushSubscriptionUpdateArgs} args - Arguments to update one PushSubscription.
     * @example
     * // Update one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PushSubscriptionUpdateArgs>(args: SelectSubset<T, PushSubscriptionUpdateArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PushSubscriptions.
     * @param {PushSubscriptionDeleteManyArgs} args - Arguments to filter PushSubscriptions to delete.
     * @example
     * // Delete a few PushSubscriptions
     * const { count } = await prisma.pushSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PushSubscriptionDeleteManyArgs>(args?: SelectSubset<T, PushSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PushSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PushSubscriptions
     * const pushSubscription = await prisma.pushSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PushSubscriptionUpdateManyArgs>(args: SelectSubset<T, PushSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PushSubscriptions and returns the data updated in the database.
     * @param {PushSubscriptionUpdateManyAndReturnArgs} args - Arguments to update many PushSubscriptions.
     * @example
     * // Update many PushSubscriptions
     * const pushSubscription = await prisma.pushSubscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PushSubscriptions and only return the `id`
     * const pushSubscriptionWithIdOnly = await prisma.pushSubscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PushSubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, PushSubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PushSubscription.
     * @param {PushSubscriptionUpsertArgs} args - Arguments to update or create a PushSubscription.
     * @example
     * // Update or create a PushSubscription
     * const pushSubscription = await prisma.pushSubscription.upsert({
     *   create: {
     *     // ... data to create a PushSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PushSubscription we want to update
     *   }
     * })
     */
    upsert<T extends PushSubscriptionUpsertArgs>(args: SelectSubset<T, PushSubscriptionUpsertArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PushSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionCountArgs} args - Arguments to filter PushSubscriptions to count.
     * @example
     * // Count the number of PushSubscriptions
     * const count = await prisma.pushSubscription.count({
     *   where: {
     *     // ... the filter for the PushSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends PushSubscriptionCountArgs>(
      args?: Subset<T, PushSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PushSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PushSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PushSubscriptionAggregateArgs>(args: Subset<T, PushSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetPushSubscriptionAggregateType<T>>

    /**
     * Group by PushSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PushSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PushSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: PushSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PushSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPushSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PushSubscription model
   */
  readonly fields: PushSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PushSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PushSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PushSubscription model
   */
  interface PushSubscriptionFieldRefs {
    readonly id: FieldRef<"PushSubscription", 'String'>
    readonly userId: FieldRef<"PushSubscription", 'String'>
    readonly endpoint: FieldRef<"PushSubscription", 'String'>
    readonly p256dh: FieldRef<"PushSubscription", 'String'>
    readonly auth: FieldRef<"PushSubscription", 'String'>
    readonly createdAt: FieldRef<"PushSubscription", 'DateTime'>
    readonly updatedAt: FieldRef<"PushSubscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PushSubscription findUnique
   */
  export type PushSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which PushSubscription to fetch.
     */
    where: PushSubscriptionWhereUniqueInput
  }

  /**
   * PushSubscription findUniqueOrThrow
   */
  export type PushSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which PushSubscription to fetch.
     */
    where: PushSubscriptionWhereUniqueInput
  }

  /**
   * PushSubscription findFirst
   */
  export type PushSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which PushSubscription to fetch.
     */
    where?: PushSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushSubscriptions to fetch.
     */
    orderBy?: PushSubscriptionOrderByWithRelationInput | PushSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PushSubscriptions.
     */
    cursor?: PushSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PushSubscriptions.
     */
    distinct?: PushSubscriptionScalarFieldEnum | PushSubscriptionScalarFieldEnum[]
  }

  /**
   * PushSubscription findFirstOrThrow
   */
  export type PushSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which PushSubscription to fetch.
     */
    where?: PushSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushSubscriptions to fetch.
     */
    orderBy?: PushSubscriptionOrderByWithRelationInput | PushSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PushSubscriptions.
     */
    cursor?: PushSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PushSubscriptions.
     */
    distinct?: PushSubscriptionScalarFieldEnum | PushSubscriptionScalarFieldEnum[]
  }

  /**
   * PushSubscription findMany
   */
  export type PushSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which PushSubscriptions to fetch.
     */
    where?: PushSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushSubscriptions to fetch.
     */
    orderBy?: PushSubscriptionOrderByWithRelationInput | PushSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PushSubscriptions.
     */
    cursor?: PushSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushSubscriptions.
     */
    skip?: number
    distinct?: PushSubscriptionScalarFieldEnum | PushSubscriptionScalarFieldEnum[]
  }

  /**
   * PushSubscription create
   */
  export type PushSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a PushSubscription.
     */
    data: XOR<PushSubscriptionCreateInput, PushSubscriptionUncheckedCreateInput>
  }

  /**
   * PushSubscription createMany
   */
  export type PushSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PushSubscriptions.
     */
    data: PushSubscriptionCreateManyInput | PushSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PushSubscription createManyAndReturn
   */
  export type PushSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many PushSubscriptions.
     */
    data: PushSubscriptionCreateManyInput | PushSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PushSubscription update
   */
  export type PushSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a PushSubscription.
     */
    data: XOR<PushSubscriptionUpdateInput, PushSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which PushSubscription to update.
     */
    where: PushSubscriptionWhereUniqueInput
  }

  /**
   * PushSubscription updateMany
   */
  export type PushSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PushSubscriptions.
     */
    data: XOR<PushSubscriptionUpdateManyMutationInput, PushSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which PushSubscriptions to update
     */
    where?: PushSubscriptionWhereInput
    /**
     * Limit how many PushSubscriptions to update.
     */
    limit?: number
  }

  /**
   * PushSubscription updateManyAndReturn
   */
  export type PushSubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update PushSubscriptions.
     */
    data: XOR<PushSubscriptionUpdateManyMutationInput, PushSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which PushSubscriptions to update
     */
    where?: PushSubscriptionWhereInput
    /**
     * Limit how many PushSubscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PushSubscription upsert
   */
  export type PushSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the PushSubscription to update in case it exists.
     */
    where: PushSubscriptionWhereUniqueInput
    /**
     * In case the PushSubscription found by the `where` argument doesn't exist, create a new PushSubscription with this data.
     */
    create: XOR<PushSubscriptionCreateInput, PushSubscriptionUncheckedCreateInput>
    /**
     * In case the PushSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PushSubscriptionUpdateInput, PushSubscriptionUncheckedUpdateInput>
  }

  /**
   * PushSubscription delete
   */
  export type PushSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter which PushSubscription to delete.
     */
    where: PushSubscriptionWhereUniqueInput
  }

  /**
   * PushSubscription deleteMany
   */
  export type PushSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PushSubscriptions to delete
     */
    where?: PushSubscriptionWhereInput
    /**
     * Limit how many PushSubscriptions to delete.
     */
    limit?: number
  }

  /**
   * PushSubscription without action
   */
  export type PushSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model UserPersonalTask
   */

  export type AggregateUserPersonalTask = {
    _count: UserPersonalTaskCountAggregateOutputType | null
    _min: UserPersonalTaskMinAggregateOutputType | null
    _max: UserPersonalTaskMaxAggregateOutputType | null
  }

  export type UserPersonalTaskMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    description: string | null
    status: $Enums.PersonalTaskStatus | null
    priority: $Enums.PersonalTaskPriority | null
    dueDate: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPersonalTaskMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    description: string | null
    status: $Enums.PersonalTaskStatus | null
    priority: $Enums.PersonalTaskPriority | null
    dueDate: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPersonalTaskCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    description: number
    status: number
    priority: number
    dueDate: number
    completedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserPersonalTaskMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    dueDate?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPersonalTaskMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    dueDate?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPersonalTaskCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    dueDate?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserPersonalTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPersonalTask to aggregate.
     */
    where?: UserPersonalTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPersonalTasks to fetch.
     */
    orderBy?: UserPersonalTaskOrderByWithRelationInput | UserPersonalTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPersonalTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPersonalTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPersonalTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPersonalTasks
    **/
    _count?: true | UserPersonalTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPersonalTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPersonalTaskMaxAggregateInputType
  }

  export type GetUserPersonalTaskAggregateType<T extends UserPersonalTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPersonalTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPersonalTask[P]>
      : GetScalarType<T[P], AggregateUserPersonalTask[P]>
  }




  export type UserPersonalTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPersonalTaskWhereInput
    orderBy?: UserPersonalTaskOrderByWithAggregationInput | UserPersonalTaskOrderByWithAggregationInput[]
    by: UserPersonalTaskScalarFieldEnum[] | UserPersonalTaskScalarFieldEnum
    having?: UserPersonalTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPersonalTaskCountAggregateInputType | true
    _min?: UserPersonalTaskMinAggregateInputType
    _max?: UserPersonalTaskMaxAggregateInputType
  }

  export type UserPersonalTaskGroupByOutputType = {
    id: string
    userId: string
    title: string
    description: string | null
    status: $Enums.PersonalTaskStatus
    priority: $Enums.PersonalTaskPriority
    dueDate: Date | null
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserPersonalTaskCountAggregateOutputType | null
    _min: UserPersonalTaskMinAggregateOutputType | null
    _max: UserPersonalTaskMaxAggregateOutputType | null
  }

  type GetUserPersonalTaskGroupByPayload<T extends UserPersonalTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPersonalTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPersonalTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPersonalTaskGroupByOutputType[P]>
            : GetScalarType<T[P], UserPersonalTaskGroupByOutputType[P]>
        }
      >
    >


  export type UserPersonalTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPersonalTask"]>

  export type UserPersonalTaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPersonalTask"]>

  export type UserPersonalTaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPersonalTask"]>

  export type UserPersonalTaskSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserPersonalTaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "description" | "status" | "priority" | "dueDate" | "completedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["userPersonalTask"]>
  export type UserPersonalTaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPersonalTaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPersonalTaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserPersonalTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPersonalTask"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      description: string | null
      status: $Enums.PersonalTaskStatus
      priority: $Enums.PersonalTaskPriority
      dueDate: Date | null
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userPersonalTask"]>
    composites: {}
  }

  type UserPersonalTaskGetPayload<S extends boolean | null | undefined | UserPersonalTaskDefaultArgs> = $Result.GetResult<Prisma.$UserPersonalTaskPayload, S>

  type UserPersonalTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPersonalTaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPersonalTaskCountAggregateInputType | true
    }

  export interface UserPersonalTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPersonalTask'], meta: { name: 'UserPersonalTask' } }
    /**
     * Find zero or one UserPersonalTask that matches the filter.
     * @param {UserPersonalTaskFindUniqueArgs} args - Arguments to find a UserPersonalTask
     * @example
     * // Get one UserPersonalTask
     * const userPersonalTask = await prisma.userPersonalTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPersonalTaskFindUniqueArgs>(args: SelectSubset<T, UserPersonalTaskFindUniqueArgs<ExtArgs>>): Prisma__UserPersonalTaskClient<$Result.GetResult<Prisma.$UserPersonalTaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserPersonalTask that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPersonalTaskFindUniqueOrThrowArgs} args - Arguments to find a UserPersonalTask
     * @example
     * // Get one UserPersonalTask
     * const userPersonalTask = await prisma.userPersonalTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPersonalTaskFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPersonalTaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPersonalTaskClient<$Result.GetResult<Prisma.$UserPersonalTaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPersonalTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPersonalTaskFindFirstArgs} args - Arguments to find a UserPersonalTask
     * @example
     * // Get one UserPersonalTask
     * const userPersonalTask = await prisma.userPersonalTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPersonalTaskFindFirstArgs>(args?: SelectSubset<T, UserPersonalTaskFindFirstArgs<ExtArgs>>): Prisma__UserPersonalTaskClient<$Result.GetResult<Prisma.$UserPersonalTaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPersonalTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPersonalTaskFindFirstOrThrowArgs} args - Arguments to find a UserPersonalTask
     * @example
     * // Get one UserPersonalTask
     * const userPersonalTask = await prisma.userPersonalTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPersonalTaskFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPersonalTaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPersonalTaskClient<$Result.GetResult<Prisma.$UserPersonalTaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserPersonalTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPersonalTaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPersonalTasks
     * const userPersonalTasks = await prisma.userPersonalTask.findMany()
     * 
     * // Get first 10 UserPersonalTasks
     * const userPersonalTasks = await prisma.userPersonalTask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPersonalTaskWithIdOnly = await prisma.userPersonalTask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserPersonalTaskFindManyArgs>(args?: SelectSubset<T, UserPersonalTaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPersonalTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserPersonalTask.
     * @param {UserPersonalTaskCreateArgs} args - Arguments to create a UserPersonalTask.
     * @example
     * // Create one UserPersonalTask
     * const UserPersonalTask = await prisma.userPersonalTask.create({
     *   data: {
     *     // ... data to create a UserPersonalTask
     *   }
     * })
     * 
     */
    create<T extends UserPersonalTaskCreateArgs>(args: SelectSubset<T, UserPersonalTaskCreateArgs<ExtArgs>>): Prisma__UserPersonalTaskClient<$Result.GetResult<Prisma.$UserPersonalTaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserPersonalTasks.
     * @param {UserPersonalTaskCreateManyArgs} args - Arguments to create many UserPersonalTasks.
     * @example
     * // Create many UserPersonalTasks
     * const userPersonalTask = await prisma.userPersonalTask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPersonalTaskCreateManyArgs>(args?: SelectSubset<T, UserPersonalTaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserPersonalTasks and returns the data saved in the database.
     * @param {UserPersonalTaskCreateManyAndReturnArgs} args - Arguments to create many UserPersonalTasks.
     * @example
     * // Create many UserPersonalTasks
     * const userPersonalTask = await prisma.userPersonalTask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserPersonalTasks and only return the `id`
     * const userPersonalTaskWithIdOnly = await prisma.userPersonalTask.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserPersonalTaskCreateManyAndReturnArgs>(args?: SelectSubset<T, UserPersonalTaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPersonalTaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserPersonalTask.
     * @param {UserPersonalTaskDeleteArgs} args - Arguments to delete one UserPersonalTask.
     * @example
     * // Delete one UserPersonalTask
     * const UserPersonalTask = await prisma.userPersonalTask.delete({
     *   where: {
     *     // ... filter to delete one UserPersonalTask
     *   }
     * })
     * 
     */
    delete<T extends UserPersonalTaskDeleteArgs>(args: SelectSubset<T, UserPersonalTaskDeleteArgs<ExtArgs>>): Prisma__UserPersonalTaskClient<$Result.GetResult<Prisma.$UserPersonalTaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserPersonalTask.
     * @param {UserPersonalTaskUpdateArgs} args - Arguments to update one UserPersonalTask.
     * @example
     * // Update one UserPersonalTask
     * const userPersonalTask = await prisma.userPersonalTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPersonalTaskUpdateArgs>(args: SelectSubset<T, UserPersonalTaskUpdateArgs<ExtArgs>>): Prisma__UserPersonalTaskClient<$Result.GetResult<Prisma.$UserPersonalTaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserPersonalTasks.
     * @param {UserPersonalTaskDeleteManyArgs} args - Arguments to filter UserPersonalTasks to delete.
     * @example
     * // Delete a few UserPersonalTasks
     * const { count } = await prisma.userPersonalTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPersonalTaskDeleteManyArgs>(args?: SelectSubset<T, UserPersonalTaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPersonalTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPersonalTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPersonalTasks
     * const userPersonalTask = await prisma.userPersonalTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPersonalTaskUpdateManyArgs>(args: SelectSubset<T, UserPersonalTaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPersonalTasks and returns the data updated in the database.
     * @param {UserPersonalTaskUpdateManyAndReturnArgs} args - Arguments to update many UserPersonalTasks.
     * @example
     * // Update many UserPersonalTasks
     * const userPersonalTask = await prisma.userPersonalTask.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserPersonalTasks and only return the `id`
     * const userPersonalTaskWithIdOnly = await prisma.userPersonalTask.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserPersonalTaskUpdateManyAndReturnArgs>(args: SelectSubset<T, UserPersonalTaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPersonalTaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserPersonalTask.
     * @param {UserPersonalTaskUpsertArgs} args - Arguments to update or create a UserPersonalTask.
     * @example
     * // Update or create a UserPersonalTask
     * const userPersonalTask = await prisma.userPersonalTask.upsert({
     *   create: {
     *     // ... data to create a UserPersonalTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPersonalTask we want to update
     *   }
     * })
     */
    upsert<T extends UserPersonalTaskUpsertArgs>(args: SelectSubset<T, UserPersonalTaskUpsertArgs<ExtArgs>>): Prisma__UserPersonalTaskClient<$Result.GetResult<Prisma.$UserPersonalTaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserPersonalTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPersonalTaskCountArgs} args - Arguments to filter UserPersonalTasks to count.
     * @example
     * // Count the number of UserPersonalTasks
     * const count = await prisma.userPersonalTask.count({
     *   where: {
     *     // ... the filter for the UserPersonalTasks we want to count
     *   }
     * })
    **/
    count<T extends UserPersonalTaskCountArgs>(
      args?: Subset<T, UserPersonalTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPersonalTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPersonalTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPersonalTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPersonalTaskAggregateArgs>(args: Subset<T, UserPersonalTaskAggregateArgs>): Prisma.PrismaPromise<GetUserPersonalTaskAggregateType<T>>

    /**
     * Group by UserPersonalTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPersonalTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPersonalTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPersonalTaskGroupByArgs['orderBy'] }
        : { orderBy?: UserPersonalTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPersonalTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPersonalTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPersonalTask model
   */
  readonly fields: UserPersonalTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPersonalTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPersonalTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPersonalTask model
   */
  interface UserPersonalTaskFieldRefs {
    readonly id: FieldRef<"UserPersonalTask", 'String'>
    readonly userId: FieldRef<"UserPersonalTask", 'String'>
    readonly title: FieldRef<"UserPersonalTask", 'String'>
    readonly description: FieldRef<"UserPersonalTask", 'String'>
    readonly status: FieldRef<"UserPersonalTask", 'PersonalTaskStatus'>
    readonly priority: FieldRef<"UserPersonalTask", 'PersonalTaskPriority'>
    readonly dueDate: FieldRef<"UserPersonalTask", 'DateTime'>
    readonly completedAt: FieldRef<"UserPersonalTask", 'DateTime'>
    readonly createdAt: FieldRef<"UserPersonalTask", 'DateTime'>
    readonly updatedAt: FieldRef<"UserPersonalTask", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserPersonalTask findUnique
   */
  export type UserPersonalTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPersonalTask
     */
    select?: UserPersonalTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPersonalTask
     */
    omit?: UserPersonalTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPersonalTaskInclude<ExtArgs> | null
    /**
     * Filter, which UserPersonalTask to fetch.
     */
    where: UserPersonalTaskWhereUniqueInput
  }

  /**
   * UserPersonalTask findUniqueOrThrow
   */
  export type UserPersonalTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPersonalTask
     */
    select?: UserPersonalTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPersonalTask
     */
    omit?: UserPersonalTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPersonalTaskInclude<ExtArgs> | null
    /**
     * Filter, which UserPersonalTask to fetch.
     */
    where: UserPersonalTaskWhereUniqueInput
  }

  /**
   * UserPersonalTask findFirst
   */
  export type UserPersonalTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPersonalTask
     */
    select?: UserPersonalTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPersonalTask
     */
    omit?: UserPersonalTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPersonalTaskInclude<ExtArgs> | null
    /**
     * Filter, which UserPersonalTask to fetch.
     */
    where?: UserPersonalTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPersonalTasks to fetch.
     */
    orderBy?: UserPersonalTaskOrderByWithRelationInput | UserPersonalTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPersonalTasks.
     */
    cursor?: UserPersonalTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPersonalTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPersonalTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPersonalTasks.
     */
    distinct?: UserPersonalTaskScalarFieldEnum | UserPersonalTaskScalarFieldEnum[]
  }

  /**
   * UserPersonalTask findFirstOrThrow
   */
  export type UserPersonalTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPersonalTask
     */
    select?: UserPersonalTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPersonalTask
     */
    omit?: UserPersonalTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPersonalTaskInclude<ExtArgs> | null
    /**
     * Filter, which UserPersonalTask to fetch.
     */
    where?: UserPersonalTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPersonalTasks to fetch.
     */
    orderBy?: UserPersonalTaskOrderByWithRelationInput | UserPersonalTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPersonalTasks.
     */
    cursor?: UserPersonalTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPersonalTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPersonalTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPersonalTasks.
     */
    distinct?: UserPersonalTaskScalarFieldEnum | UserPersonalTaskScalarFieldEnum[]
  }

  /**
   * UserPersonalTask findMany
   */
  export type UserPersonalTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPersonalTask
     */
    select?: UserPersonalTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPersonalTask
     */
    omit?: UserPersonalTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPersonalTaskInclude<ExtArgs> | null
    /**
     * Filter, which UserPersonalTasks to fetch.
     */
    where?: UserPersonalTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPersonalTasks to fetch.
     */
    orderBy?: UserPersonalTaskOrderByWithRelationInput | UserPersonalTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPersonalTasks.
     */
    cursor?: UserPersonalTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPersonalTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPersonalTasks.
     */
    skip?: number
    distinct?: UserPersonalTaskScalarFieldEnum | UserPersonalTaskScalarFieldEnum[]
  }

  /**
   * UserPersonalTask create
   */
  export type UserPersonalTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPersonalTask
     */
    select?: UserPersonalTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPersonalTask
     */
    omit?: UserPersonalTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPersonalTaskInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPersonalTask.
     */
    data: XOR<UserPersonalTaskCreateInput, UserPersonalTaskUncheckedCreateInput>
  }

  /**
   * UserPersonalTask createMany
   */
  export type UserPersonalTaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPersonalTasks.
     */
    data: UserPersonalTaskCreateManyInput | UserPersonalTaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPersonalTask createManyAndReturn
   */
  export type UserPersonalTaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPersonalTask
     */
    select?: UserPersonalTaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPersonalTask
     */
    omit?: UserPersonalTaskOmit<ExtArgs> | null
    /**
     * The data used to create many UserPersonalTasks.
     */
    data: UserPersonalTaskCreateManyInput | UserPersonalTaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPersonalTaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPersonalTask update
   */
  export type UserPersonalTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPersonalTask
     */
    select?: UserPersonalTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPersonalTask
     */
    omit?: UserPersonalTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPersonalTaskInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPersonalTask.
     */
    data: XOR<UserPersonalTaskUpdateInput, UserPersonalTaskUncheckedUpdateInput>
    /**
     * Choose, which UserPersonalTask to update.
     */
    where: UserPersonalTaskWhereUniqueInput
  }

  /**
   * UserPersonalTask updateMany
   */
  export type UserPersonalTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPersonalTasks.
     */
    data: XOR<UserPersonalTaskUpdateManyMutationInput, UserPersonalTaskUncheckedUpdateManyInput>
    /**
     * Filter which UserPersonalTasks to update
     */
    where?: UserPersonalTaskWhereInput
    /**
     * Limit how many UserPersonalTasks to update.
     */
    limit?: number
  }

  /**
   * UserPersonalTask updateManyAndReturn
   */
  export type UserPersonalTaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPersonalTask
     */
    select?: UserPersonalTaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPersonalTask
     */
    omit?: UserPersonalTaskOmit<ExtArgs> | null
    /**
     * The data used to update UserPersonalTasks.
     */
    data: XOR<UserPersonalTaskUpdateManyMutationInput, UserPersonalTaskUncheckedUpdateManyInput>
    /**
     * Filter which UserPersonalTasks to update
     */
    where?: UserPersonalTaskWhereInput
    /**
     * Limit how many UserPersonalTasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPersonalTaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPersonalTask upsert
   */
  export type UserPersonalTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPersonalTask
     */
    select?: UserPersonalTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPersonalTask
     */
    omit?: UserPersonalTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPersonalTaskInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPersonalTask to update in case it exists.
     */
    where: UserPersonalTaskWhereUniqueInput
    /**
     * In case the UserPersonalTask found by the `where` argument doesn't exist, create a new UserPersonalTask with this data.
     */
    create: XOR<UserPersonalTaskCreateInput, UserPersonalTaskUncheckedCreateInput>
    /**
     * In case the UserPersonalTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPersonalTaskUpdateInput, UserPersonalTaskUncheckedUpdateInput>
  }

  /**
   * UserPersonalTask delete
   */
  export type UserPersonalTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPersonalTask
     */
    select?: UserPersonalTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPersonalTask
     */
    omit?: UserPersonalTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPersonalTaskInclude<ExtArgs> | null
    /**
     * Filter which UserPersonalTask to delete.
     */
    where: UserPersonalTaskWhereUniqueInput
  }

  /**
   * UserPersonalTask deleteMany
   */
  export type UserPersonalTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPersonalTasks to delete
     */
    where?: UserPersonalTaskWhereInput
    /**
     * Limit how many UserPersonalTasks to delete.
     */
    limit?: number
  }

  /**
   * UserPersonalTask without action
   */
  export type UserPersonalTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPersonalTask
     */
    select?: UserPersonalTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPersonalTask
     */
    omit?: UserPersonalTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPersonalTaskInclude<ExtArgs> | null
  }


  /**
   * Model UserFinancialGoal
   */

  export type AggregateUserFinancialGoal = {
    _count: UserFinancialGoalCountAggregateOutputType | null
    _avg: UserFinancialGoalAvgAggregateOutputType | null
    _sum: UserFinancialGoalSumAggregateOutputType | null
    _min: UserFinancialGoalMinAggregateOutputType | null
    _max: UserFinancialGoalMaxAggregateOutputType | null
  }

  export type UserFinancialGoalAvgAggregateOutputType = {
    year: number | null
    targetAmount: number | null
  }

  export type UserFinancialGoalSumAggregateOutputType = {
    year: number | null
    targetAmount: number | null
  }

  export type UserFinancialGoalMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.FinancialGoalType | null
    year: number | null
    targetItem: string | null
    targetAmount: number | null
    targetDate: Date | null
    label: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserFinancialGoalMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.FinancialGoalType | null
    year: number | null
    targetItem: string | null
    targetAmount: number | null
    targetDate: Date | null
    label: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserFinancialGoalCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    year: number
    targetItem: number
    targetAmount: number
    targetDate: number
    label: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserFinancialGoalAvgAggregateInputType = {
    year?: true
    targetAmount?: true
  }

  export type UserFinancialGoalSumAggregateInputType = {
    year?: true
    targetAmount?: true
  }

  export type UserFinancialGoalMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    year?: true
    targetItem?: true
    targetAmount?: true
    targetDate?: true
    label?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserFinancialGoalMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    year?: true
    targetItem?: true
    targetAmount?: true
    targetDate?: true
    label?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserFinancialGoalCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    year?: true
    targetItem?: true
    targetAmount?: true
    targetDate?: true
    label?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserFinancialGoalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFinancialGoal to aggregate.
     */
    where?: UserFinancialGoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFinancialGoals to fetch.
     */
    orderBy?: UserFinancialGoalOrderByWithRelationInput | UserFinancialGoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserFinancialGoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFinancialGoals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFinancialGoals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserFinancialGoals
    **/
    _count?: true | UserFinancialGoalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserFinancialGoalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserFinancialGoalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserFinancialGoalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserFinancialGoalMaxAggregateInputType
  }

  export type GetUserFinancialGoalAggregateType<T extends UserFinancialGoalAggregateArgs> = {
        [P in keyof T & keyof AggregateUserFinancialGoal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserFinancialGoal[P]>
      : GetScalarType<T[P], AggregateUserFinancialGoal[P]>
  }




  export type UserFinancialGoalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFinancialGoalWhereInput
    orderBy?: UserFinancialGoalOrderByWithAggregationInput | UserFinancialGoalOrderByWithAggregationInput[]
    by: UserFinancialGoalScalarFieldEnum[] | UserFinancialGoalScalarFieldEnum
    having?: UserFinancialGoalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserFinancialGoalCountAggregateInputType | true
    _avg?: UserFinancialGoalAvgAggregateInputType
    _sum?: UserFinancialGoalSumAggregateInputType
    _min?: UserFinancialGoalMinAggregateInputType
    _max?: UserFinancialGoalMaxAggregateInputType
  }

  export type UserFinancialGoalGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.FinancialGoalType
    year: number | null
    targetItem: string | null
    targetAmount: number
    targetDate: Date | null
    label: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserFinancialGoalCountAggregateOutputType | null
    _avg: UserFinancialGoalAvgAggregateOutputType | null
    _sum: UserFinancialGoalSumAggregateOutputType | null
    _min: UserFinancialGoalMinAggregateOutputType | null
    _max: UserFinancialGoalMaxAggregateOutputType | null
  }

  type GetUserFinancialGoalGroupByPayload<T extends UserFinancialGoalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserFinancialGoalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserFinancialGoalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserFinancialGoalGroupByOutputType[P]>
            : GetScalarType<T[P], UserFinancialGoalGroupByOutputType[P]>
        }
      >
    >


  export type UserFinancialGoalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    year?: boolean
    targetItem?: boolean
    targetAmount?: boolean
    targetDate?: boolean
    label?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    progress?: boolean | UserFinancialGoal$progressArgs<ExtArgs>
    _count?: boolean | UserFinancialGoalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFinancialGoal"]>

  export type UserFinancialGoalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    year?: boolean
    targetItem?: boolean
    targetAmount?: boolean
    targetDate?: boolean
    label?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFinancialGoal"]>

  export type UserFinancialGoalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    year?: boolean
    targetItem?: boolean
    targetAmount?: boolean
    targetDate?: boolean
    label?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFinancialGoal"]>

  export type UserFinancialGoalSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    year?: boolean
    targetItem?: boolean
    targetAmount?: boolean
    targetDate?: boolean
    label?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserFinancialGoalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "year" | "targetItem" | "targetAmount" | "targetDate" | "label" | "createdAt" | "updatedAt", ExtArgs["result"]["userFinancialGoal"]>
  export type UserFinancialGoalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    progress?: boolean | UserFinancialGoal$progressArgs<ExtArgs>
    _count?: boolean | UserFinancialGoalCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserFinancialGoalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserFinancialGoalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserFinancialGoalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserFinancialGoal"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      progress: Prisma.$UserMonthlyProgressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.FinancialGoalType
      year: number | null
      targetItem: string | null
      targetAmount: number
      targetDate: Date | null
      label: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userFinancialGoal"]>
    composites: {}
  }

  type UserFinancialGoalGetPayload<S extends boolean | null | undefined | UserFinancialGoalDefaultArgs> = $Result.GetResult<Prisma.$UserFinancialGoalPayload, S>

  type UserFinancialGoalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFinancialGoalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserFinancialGoalCountAggregateInputType | true
    }

  export interface UserFinancialGoalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserFinancialGoal'], meta: { name: 'UserFinancialGoal' } }
    /**
     * Find zero or one UserFinancialGoal that matches the filter.
     * @param {UserFinancialGoalFindUniqueArgs} args - Arguments to find a UserFinancialGoal
     * @example
     * // Get one UserFinancialGoal
     * const userFinancialGoal = await prisma.userFinancialGoal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFinancialGoalFindUniqueArgs>(args: SelectSubset<T, UserFinancialGoalFindUniqueArgs<ExtArgs>>): Prisma__UserFinancialGoalClient<$Result.GetResult<Prisma.$UserFinancialGoalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserFinancialGoal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFinancialGoalFindUniqueOrThrowArgs} args - Arguments to find a UserFinancialGoal
     * @example
     * // Get one UserFinancialGoal
     * const userFinancialGoal = await prisma.userFinancialGoal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFinancialGoalFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFinancialGoalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserFinancialGoalClient<$Result.GetResult<Prisma.$UserFinancialGoalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserFinancialGoal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFinancialGoalFindFirstArgs} args - Arguments to find a UserFinancialGoal
     * @example
     * // Get one UserFinancialGoal
     * const userFinancialGoal = await prisma.userFinancialGoal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFinancialGoalFindFirstArgs>(args?: SelectSubset<T, UserFinancialGoalFindFirstArgs<ExtArgs>>): Prisma__UserFinancialGoalClient<$Result.GetResult<Prisma.$UserFinancialGoalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserFinancialGoal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFinancialGoalFindFirstOrThrowArgs} args - Arguments to find a UserFinancialGoal
     * @example
     * // Get one UserFinancialGoal
     * const userFinancialGoal = await prisma.userFinancialGoal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFinancialGoalFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFinancialGoalFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserFinancialGoalClient<$Result.GetResult<Prisma.$UserFinancialGoalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserFinancialGoals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFinancialGoalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserFinancialGoals
     * const userFinancialGoals = await prisma.userFinancialGoal.findMany()
     * 
     * // Get first 10 UserFinancialGoals
     * const userFinancialGoals = await prisma.userFinancialGoal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userFinancialGoalWithIdOnly = await prisma.userFinancialGoal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFinancialGoalFindManyArgs>(args?: SelectSubset<T, UserFinancialGoalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFinancialGoalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserFinancialGoal.
     * @param {UserFinancialGoalCreateArgs} args - Arguments to create a UserFinancialGoal.
     * @example
     * // Create one UserFinancialGoal
     * const UserFinancialGoal = await prisma.userFinancialGoal.create({
     *   data: {
     *     // ... data to create a UserFinancialGoal
     *   }
     * })
     * 
     */
    create<T extends UserFinancialGoalCreateArgs>(args: SelectSubset<T, UserFinancialGoalCreateArgs<ExtArgs>>): Prisma__UserFinancialGoalClient<$Result.GetResult<Prisma.$UserFinancialGoalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserFinancialGoals.
     * @param {UserFinancialGoalCreateManyArgs} args - Arguments to create many UserFinancialGoals.
     * @example
     * // Create many UserFinancialGoals
     * const userFinancialGoal = await prisma.userFinancialGoal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserFinancialGoalCreateManyArgs>(args?: SelectSubset<T, UserFinancialGoalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserFinancialGoals and returns the data saved in the database.
     * @param {UserFinancialGoalCreateManyAndReturnArgs} args - Arguments to create many UserFinancialGoals.
     * @example
     * // Create many UserFinancialGoals
     * const userFinancialGoal = await prisma.userFinancialGoal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserFinancialGoals and only return the `id`
     * const userFinancialGoalWithIdOnly = await prisma.userFinancialGoal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserFinancialGoalCreateManyAndReturnArgs>(args?: SelectSubset<T, UserFinancialGoalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFinancialGoalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserFinancialGoal.
     * @param {UserFinancialGoalDeleteArgs} args - Arguments to delete one UserFinancialGoal.
     * @example
     * // Delete one UserFinancialGoal
     * const UserFinancialGoal = await prisma.userFinancialGoal.delete({
     *   where: {
     *     // ... filter to delete one UserFinancialGoal
     *   }
     * })
     * 
     */
    delete<T extends UserFinancialGoalDeleteArgs>(args: SelectSubset<T, UserFinancialGoalDeleteArgs<ExtArgs>>): Prisma__UserFinancialGoalClient<$Result.GetResult<Prisma.$UserFinancialGoalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserFinancialGoal.
     * @param {UserFinancialGoalUpdateArgs} args - Arguments to update one UserFinancialGoal.
     * @example
     * // Update one UserFinancialGoal
     * const userFinancialGoal = await prisma.userFinancialGoal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserFinancialGoalUpdateArgs>(args: SelectSubset<T, UserFinancialGoalUpdateArgs<ExtArgs>>): Prisma__UserFinancialGoalClient<$Result.GetResult<Prisma.$UserFinancialGoalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserFinancialGoals.
     * @param {UserFinancialGoalDeleteManyArgs} args - Arguments to filter UserFinancialGoals to delete.
     * @example
     * // Delete a few UserFinancialGoals
     * const { count } = await prisma.userFinancialGoal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserFinancialGoalDeleteManyArgs>(args?: SelectSubset<T, UserFinancialGoalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFinancialGoals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFinancialGoalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserFinancialGoals
     * const userFinancialGoal = await prisma.userFinancialGoal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserFinancialGoalUpdateManyArgs>(args: SelectSubset<T, UserFinancialGoalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFinancialGoals and returns the data updated in the database.
     * @param {UserFinancialGoalUpdateManyAndReturnArgs} args - Arguments to update many UserFinancialGoals.
     * @example
     * // Update many UserFinancialGoals
     * const userFinancialGoal = await prisma.userFinancialGoal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserFinancialGoals and only return the `id`
     * const userFinancialGoalWithIdOnly = await prisma.userFinancialGoal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserFinancialGoalUpdateManyAndReturnArgs>(args: SelectSubset<T, UserFinancialGoalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFinancialGoalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserFinancialGoal.
     * @param {UserFinancialGoalUpsertArgs} args - Arguments to update or create a UserFinancialGoal.
     * @example
     * // Update or create a UserFinancialGoal
     * const userFinancialGoal = await prisma.userFinancialGoal.upsert({
     *   create: {
     *     // ... data to create a UserFinancialGoal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserFinancialGoal we want to update
     *   }
     * })
     */
    upsert<T extends UserFinancialGoalUpsertArgs>(args: SelectSubset<T, UserFinancialGoalUpsertArgs<ExtArgs>>): Prisma__UserFinancialGoalClient<$Result.GetResult<Prisma.$UserFinancialGoalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserFinancialGoals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFinancialGoalCountArgs} args - Arguments to filter UserFinancialGoals to count.
     * @example
     * // Count the number of UserFinancialGoals
     * const count = await prisma.userFinancialGoal.count({
     *   where: {
     *     // ... the filter for the UserFinancialGoals we want to count
     *   }
     * })
    **/
    count<T extends UserFinancialGoalCountArgs>(
      args?: Subset<T, UserFinancialGoalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserFinancialGoalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserFinancialGoal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFinancialGoalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserFinancialGoalAggregateArgs>(args: Subset<T, UserFinancialGoalAggregateArgs>): Prisma.PrismaPromise<GetUserFinancialGoalAggregateType<T>>

    /**
     * Group by UserFinancialGoal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFinancialGoalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserFinancialGoalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserFinancialGoalGroupByArgs['orderBy'] }
        : { orderBy?: UserFinancialGoalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserFinancialGoalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserFinancialGoalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserFinancialGoal model
   */
  readonly fields: UserFinancialGoalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserFinancialGoal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserFinancialGoalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    progress<T extends UserFinancialGoal$progressArgs<ExtArgs> = {}>(args?: Subset<T, UserFinancialGoal$progressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserMonthlyProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserFinancialGoal model
   */
  interface UserFinancialGoalFieldRefs {
    readonly id: FieldRef<"UserFinancialGoal", 'String'>
    readonly userId: FieldRef<"UserFinancialGoal", 'String'>
    readonly type: FieldRef<"UserFinancialGoal", 'FinancialGoalType'>
    readonly year: FieldRef<"UserFinancialGoal", 'Int'>
    readonly targetItem: FieldRef<"UserFinancialGoal", 'String'>
    readonly targetAmount: FieldRef<"UserFinancialGoal", 'Float'>
    readonly targetDate: FieldRef<"UserFinancialGoal", 'DateTime'>
    readonly label: FieldRef<"UserFinancialGoal", 'String'>
    readonly createdAt: FieldRef<"UserFinancialGoal", 'DateTime'>
    readonly updatedAt: FieldRef<"UserFinancialGoal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserFinancialGoal findUnique
   */
  export type UserFinancialGoalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinancialGoal
     */
    select?: UserFinancialGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinancialGoal
     */
    omit?: UserFinancialGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinancialGoalInclude<ExtArgs> | null
    /**
     * Filter, which UserFinancialGoal to fetch.
     */
    where: UserFinancialGoalWhereUniqueInput
  }

  /**
   * UserFinancialGoal findUniqueOrThrow
   */
  export type UserFinancialGoalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinancialGoal
     */
    select?: UserFinancialGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinancialGoal
     */
    omit?: UserFinancialGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinancialGoalInclude<ExtArgs> | null
    /**
     * Filter, which UserFinancialGoal to fetch.
     */
    where: UserFinancialGoalWhereUniqueInput
  }

  /**
   * UserFinancialGoal findFirst
   */
  export type UserFinancialGoalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinancialGoal
     */
    select?: UserFinancialGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinancialGoal
     */
    omit?: UserFinancialGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinancialGoalInclude<ExtArgs> | null
    /**
     * Filter, which UserFinancialGoal to fetch.
     */
    where?: UserFinancialGoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFinancialGoals to fetch.
     */
    orderBy?: UserFinancialGoalOrderByWithRelationInput | UserFinancialGoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFinancialGoals.
     */
    cursor?: UserFinancialGoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFinancialGoals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFinancialGoals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFinancialGoals.
     */
    distinct?: UserFinancialGoalScalarFieldEnum | UserFinancialGoalScalarFieldEnum[]
  }

  /**
   * UserFinancialGoal findFirstOrThrow
   */
  export type UserFinancialGoalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinancialGoal
     */
    select?: UserFinancialGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinancialGoal
     */
    omit?: UserFinancialGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinancialGoalInclude<ExtArgs> | null
    /**
     * Filter, which UserFinancialGoal to fetch.
     */
    where?: UserFinancialGoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFinancialGoals to fetch.
     */
    orderBy?: UserFinancialGoalOrderByWithRelationInput | UserFinancialGoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFinancialGoals.
     */
    cursor?: UserFinancialGoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFinancialGoals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFinancialGoals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFinancialGoals.
     */
    distinct?: UserFinancialGoalScalarFieldEnum | UserFinancialGoalScalarFieldEnum[]
  }

  /**
   * UserFinancialGoal findMany
   */
  export type UserFinancialGoalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinancialGoal
     */
    select?: UserFinancialGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinancialGoal
     */
    omit?: UserFinancialGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinancialGoalInclude<ExtArgs> | null
    /**
     * Filter, which UserFinancialGoals to fetch.
     */
    where?: UserFinancialGoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFinancialGoals to fetch.
     */
    orderBy?: UserFinancialGoalOrderByWithRelationInput | UserFinancialGoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserFinancialGoals.
     */
    cursor?: UserFinancialGoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFinancialGoals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFinancialGoals.
     */
    skip?: number
    distinct?: UserFinancialGoalScalarFieldEnum | UserFinancialGoalScalarFieldEnum[]
  }

  /**
   * UserFinancialGoal create
   */
  export type UserFinancialGoalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinancialGoal
     */
    select?: UserFinancialGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinancialGoal
     */
    omit?: UserFinancialGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinancialGoalInclude<ExtArgs> | null
    /**
     * The data needed to create a UserFinancialGoal.
     */
    data: XOR<UserFinancialGoalCreateInput, UserFinancialGoalUncheckedCreateInput>
  }

  /**
   * UserFinancialGoal createMany
   */
  export type UserFinancialGoalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserFinancialGoals.
     */
    data: UserFinancialGoalCreateManyInput | UserFinancialGoalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserFinancialGoal createManyAndReturn
   */
  export type UserFinancialGoalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinancialGoal
     */
    select?: UserFinancialGoalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinancialGoal
     */
    omit?: UserFinancialGoalOmit<ExtArgs> | null
    /**
     * The data used to create many UserFinancialGoals.
     */
    data: UserFinancialGoalCreateManyInput | UserFinancialGoalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinancialGoalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserFinancialGoal update
   */
  export type UserFinancialGoalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinancialGoal
     */
    select?: UserFinancialGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinancialGoal
     */
    omit?: UserFinancialGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinancialGoalInclude<ExtArgs> | null
    /**
     * The data needed to update a UserFinancialGoal.
     */
    data: XOR<UserFinancialGoalUpdateInput, UserFinancialGoalUncheckedUpdateInput>
    /**
     * Choose, which UserFinancialGoal to update.
     */
    where: UserFinancialGoalWhereUniqueInput
  }

  /**
   * UserFinancialGoal updateMany
   */
  export type UserFinancialGoalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserFinancialGoals.
     */
    data: XOR<UserFinancialGoalUpdateManyMutationInput, UserFinancialGoalUncheckedUpdateManyInput>
    /**
     * Filter which UserFinancialGoals to update
     */
    where?: UserFinancialGoalWhereInput
    /**
     * Limit how many UserFinancialGoals to update.
     */
    limit?: number
  }

  /**
   * UserFinancialGoal updateManyAndReturn
   */
  export type UserFinancialGoalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinancialGoal
     */
    select?: UserFinancialGoalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinancialGoal
     */
    omit?: UserFinancialGoalOmit<ExtArgs> | null
    /**
     * The data used to update UserFinancialGoals.
     */
    data: XOR<UserFinancialGoalUpdateManyMutationInput, UserFinancialGoalUncheckedUpdateManyInput>
    /**
     * Filter which UserFinancialGoals to update
     */
    where?: UserFinancialGoalWhereInput
    /**
     * Limit how many UserFinancialGoals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinancialGoalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserFinancialGoal upsert
   */
  export type UserFinancialGoalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinancialGoal
     */
    select?: UserFinancialGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinancialGoal
     */
    omit?: UserFinancialGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinancialGoalInclude<ExtArgs> | null
    /**
     * The filter to search for the UserFinancialGoal to update in case it exists.
     */
    where: UserFinancialGoalWhereUniqueInput
    /**
     * In case the UserFinancialGoal found by the `where` argument doesn't exist, create a new UserFinancialGoal with this data.
     */
    create: XOR<UserFinancialGoalCreateInput, UserFinancialGoalUncheckedCreateInput>
    /**
     * In case the UserFinancialGoal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserFinancialGoalUpdateInput, UserFinancialGoalUncheckedUpdateInput>
  }

  /**
   * UserFinancialGoal delete
   */
  export type UserFinancialGoalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinancialGoal
     */
    select?: UserFinancialGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinancialGoal
     */
    omit?: UserFinancialGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinancialGoalInclude<ExtArgs> | null
    /**
     * Filter which UserFinancialGoal to delete.
     */
    where: UserFinancialGoalWhereUniqueInput
  }

  /**
   * UserFinancialGoal deleteMany
   */
  export type UserFinancialGoalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFinancialGoals to delete
     */
    where?: UserFinancialGoalWhereInput
    /**
     * Limit how many UserFinancialGoals to delete.
     */
    limit?: number
  }

  /**
   * UserFinancialGoal.progress
   */
  export type UserFinancialGoal$progressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMonthlyProgress
     */
    select?: UserMonthlyProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMonthlyProgress
     */
    omit?: UserMonthlyProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMonthlyProgressInclude<ExtArgs> | null
    where?: UserMonthlyProgressWhereInput
    orderBy?: UserMonthlyProgressOrderByWithRelationInput | UserMonthlyProgressOrderByWithRelationInput[]
    cursor?: UserMonthlyProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserMonthlyProgressScalarFieldEnum | UserMonthlyProgressScalarFieldEnum[]
  }

  /**
   * UserFinancialGoal without action
   */
  export type UserFinancialGoalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinancialGoal
     */
    select?: UserFinancialGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinancialGoal
     */
    omit?: UserFinancialGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinancialGoalInclude<ExtArgs> | null
  }


  /**
   * Model UserFinancialProfile
   */

  export type AggregateUserFinancialProfile = {
    _count: UserFinancialProfileCountAggregateOutputType | null
    _avg: UserFinancialProfileAvgAggregateOutputType | null
    _sum: UserFinancialProfileSumAggregateOutputType | null
    _min: UserFinancialProfileMinAggregateOutputType | null
    _max: UserFinancialProfileMaxAggregateOutputType | null
  }

  export type UserFinancialProfileAvgAggregateOutputType = {
    monthlySalary: number | null
    supplementaryIncome: number | null
    preferredSavingsRate: number | null
  }

  export type UserFinancialProfileSumAggregateOutputType = {
    monthlySalary: number | null
    supplementaryIncome: number | null
    preferredSavingsRate: number | null
  }

  export type UserFinancialProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    monthlySalary: number | null
    supplementaryIncome: number | null
    currency: string | null
    preferredSavingsRate: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserFinancialProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    monthlySalary: number | null
    supplementaryIncome: number | null
    currency: string | null
    preferredSavingsRate: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserFinancialProfileCountAggregateOutputType = {
    id: number
    userId: number
    monthlySalary: number
    supplementaryIncome: number
    currency: number
    preferredSavingsRate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserFinancialProfileAvgAggregateInputType = {
    monthlySalary?: true
    supplementaryIncome?: true
    preferredSavingsRate?: true
  }

  export type UserFinancialProfileSumAggregateInputType = {
    monthlySalary?: true
    supplementaryIncome?: true
    preferredSavingsRate?: true
  }

  export type UserFinancialProfileMinAggregateInputType = {
    id?: true
    userId?: true
    monthlySalary?: true
    supplementaryIncome?: true
    currency?: true
    preferredSavingsRate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserFinancialProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    monthlySalary?: true
    supplementaryIncome?: true
    currency?: true
    preferredSavingsRate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserFinancialProfileCountAggregateInputType = {
    id?: true
    userId?: true
    monthlySalary?: true
    supplementaryIncome?: true
    currency?: true
    preferredSavingsRate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserFinancialProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFinancialProfile to aggregate.
     */
    where?: UserFinancialProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFinancialProfiles to fetch.
     */
    orderBy?: UserFinancialProfileOrderByWithRelationInput | UserFinancialProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserFinancialProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFinancialProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFinancialProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserFinancialProfiles
    **/
    _count?: true | UserFinancialProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserFinancialProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserFinancialProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserFinancialProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserFinancialProfileMaxAggregateInputType
  }

  export type GetUserFinancialProfileAggregateType<T extends UserFinancialProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateUserFinancialProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserFinancialProfile[P]>
      : GetScalarType<T[P], AggregateUserFinancialProfile[P]>
  }




  export type UserFinancialProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFinancialProfileWhereInput
    orderBy?: UserFinancialProfileOrderByWithAggregationInput | UserFinancialProfileOrderByWithAggregationInput[]
    by: UserFinancialProfileScalarFieldEnum[] | UserFinancialProfileScalarFieldEnum
    having?: UserFinancialProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserFinancialProfileCountAggregateInputType | true
    _avg?: UserFinancialProfileAvgAggregateInputType
    _sum?: UserFinancialProfileSumAggregateInputType
    _min?: UserFinancialProfileMinAggregateInputType
    _max?: UserFinancialProfileMaxAggregateInputType
  }

  export type UserFinancialProfileGroupByOutputType = {
    id: string
    userId: string
    monthlySalary: number
    supplementaryIncome: number
    currency: string
    preferredSavingsRate: number | null
    createdAt: Date
    updatedAt: Date
    _count: UserFinancialProfileCountAggregateOutputType | null
    _avg: UserFinancialProfileAvgAggregateOutputType | null
    _sum: UserFinancialProfileSumAggregateOutputType | null
    _min: UserFinancialProfileMinAggregateOutputType | null
    _max: UserFinancialProfileMaxAggregateOutputType | null
  }

  type GetUserFinancialProfileGroupByPayload<T extends UserFinancialProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserFinancialProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserFinancialProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserFinancialProfileGroupByOutputType[P]>
            : GetScalarType<T[P], UserFinancialProfileGroupByOutputType[P]>
        }
      >
    >


  export type UserFinancialProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    monthlySalary?: boolean
    supplementaryIncome?: boolean
    currency?: boolean
    preferredSavingsRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFinancialProfile"]>

  export type UserFinancialProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    monthlySalary?: boolean
    supplementaryIncome?: boolean
    currency?: boolean
    preferredSavingsRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFinancialProfile"]>

  export type UserFinancialProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    monthlySalary?: boolean
    supplementaryIncome?: boolean
    currency?: boolean
    preferredSavingsRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFinancialProfile"]>

  export type UserFinancialProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    monthlySalary?: boolean
    supplementaryIncome?: boolean
    currency?: boolean
    preferredSavingsRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserFinancialProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "monthlySalary" | "supplementaryIncome" | "currency" | "preferredSavingsRate" | "createdAt" | "updatedAt", ExtArgs["result"]["userFinancialProfile"]>
  export type UserFinancialProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserFinancialProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserFinancialProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserFinancialProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserFinancialProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      monthlySalary: number
      supplementaryIncome: number
      currency: string
      preferredSavingsRate: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userFinancialProfile"]>
    composites: {}
  }

  type UserFinancialProfileGetPayload<S extends boolean | null | undefined | UserFinancialProfileDefaultArgs> = $Result.GetResult<Prisma.$UserFinancialProfilePayload, S>

  type UserFinancialProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFinancialProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserFinancialProfileCountAggregateInputType | true
    }

  export interface UserFinancialProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserFinancialProfile'], meta: { name: 'UserFinancialProfile' } }
    /**
     * Find zero or one UserFinancialProfile that matches the filter.
     * @param {UserFinancialProfileFindUniqueArgs} args - Arguments to find a UserFinancialProfile
     * @example
     * // Get one UserFinancialProfile
     * const userFinancialProfile = await prisma.userFinancialProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFinancialProfileFindUniqueArgs>(args: SelectSubset<T, UserFinancialProfileFindUniqueArgs<ExtArgs>>): Prisma__UserFinancialProfileClient<$Result.GetResult<Prisma.$UserFinancialProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserFinancialProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFinancialProfileFindUniqueOrThrowArgs} args - Arguments to find a UserFinancialProfile
     * @example
     * // Get one UserFinancialProfile
     * const userFinancialProfile = await prisma.userFinancialProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFinancialProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFinancialProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserFinancialProfileClient<$Result.GetResult<Prisma.$UserFinancialProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserFinancialProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFinancialProfileFindFirstArgs} args - Arguments to find a UserFinancialProfile
     * @example
     * // Get one UserFinancialProfile
     * const userFinancialProfile = await prisma.userFinancialProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFinancialProfileFindFirstArgs>(args?: SelectSubset<T, UserFinancialProfileFindFirstArgs<ExtArgs>>): Prisma__UserFinancialProfileClient<$Result.GetResult<Prisma.$UserFinancialProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserFinancialProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFinancialProfileFindFirstOrThrowArgs} args - Arguments to find a UserFinancialProfile
     * @example
     * // Get one UserFinancialProfile
     * const userFinancialProfile = await prisma.userFinancialProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFinancialProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFinancialProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserFinancialProfileClient<$Result.GetResult<Prisma.$UserFinancialProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserFinancialProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFinancialProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserFinancialProfiles
     * const userFinancialProfiles = await prisma.userFinancialProfile.findMany()
     * 
     * // Get first 10 UserFinancialProfiles
     * const userFinancialProfiles = await prisma.userFinancialProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userFinancialProfileWithIdOnly = await prisma.userFinancialProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFinancialProfileFindManyArgs>(args?: SelectSubset<T, UserFinancialProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFinancialProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserFinancialProfile.
     * @param {UserFinancialProfileCreateArgs} args - Arguments to create a UserFinancialProfile.
     * @example
     * // Create one UserFinancialProfile
     * const UserFinancialProfile = await prisma.userFinancialProfile.create({
     *   data: {
     *     // ... data to create a UserFinancialProfile
     *   }
     * })
     * 
     */
    create<T extends UserFinancialProfileCreateArgs>(args: SelectSubset<T, UserFinancialProfileCreateArgs<ExtArgs>>): Prisma__UserFinancialProfileClient<$Result.GetResult<Prisma.$UserFinancialProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserFinancialProfiles.
     * @param {UserFinancialProfileCreateManyArgs} args - Arguments to create many UserFinancialProfiles.
     * @example
     * // Create many UserFinancialProfiles
     * const userFinancialProfile = await prisma.userFinancialProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserFinancialProfileCreateManyArgs>(args?: SelectSubset<T, UserFinancialProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserFinancialProfiles and returns the data saved in the database.
     * @param {UserFinancialProfileCreateManyAndReturnArgs} args - Arguments to create many UserFinancialProfiles.
     * @example
     * // Create many UserFinancialProfiles
     * const userFinancialProfile = await prisma.userFinancialProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserFinancialProfiles and only return the `id`
     * const userFinancialProfileWithIdOnly = await prisma.userFinancialProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserFinancialProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, UserFinancialProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFinancialProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserFinancialProfile.
     * @param {UserFinancialProfileDeleteArgs} args - Arguments to delete one UserFinancialProfile.
     * @example
     * // Delete one UserFinancialProfile
     * const UserFinancialProfile = await prisma.userFinancialProfile.delete({
     *   where: {
     *     // ... filter to delete one UserFinancialProfile
     *   }
     * })
     * 
     */
    delete<T extends UserFinancialProfileDeleteArgs>(args: SelectSubset<T, UserFinancialProfileDeleteArgs<ExtArgs>>): Prisma__UserFinancialProfileClient<$Result.GetResult<Prisma.$UserFinancialProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserFinancialProfile.
     * @param {UserFinancialProfileUpdateArgs} args - Arguments to update one UserFinancialProfile.
     * @example
     * // Update one UserFinancialProfile
     * const userFinancialProfile = await prisma.userFinancialProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserFinancialProfileUpdateArgs>(args: SelectSubset<T, UserFinancialProfileUpdateArgs<ExtArgs>>): Prisma__UserFinancialProfileClient<$Result.GetResult<Prisma.$UserFinancialProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserFinancialProfiles.
     * @param {UserFinancialProfileDeleteManyArgs} args - Arguments to filter UserFinancialProfiles to delete.
     * @example
     * // Delete a few UserFinancialProfiles
     * const { count } = await prisma.userFinancialProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserFinancialProfileDeleteManyArgs>(args?: SelectSubset<T, UserFinancialProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFinancialProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFinancialProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserFinancialProfiles
     * const userFinancialProfile = await prisma.userFinancialProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserFinancialProfileUpdateManyArgs>(args: SelectSubset<T, UserFinancialProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFinancialProfiles and returns the data updated in the database.
     * @param {UserFinancialProfileUpdateManyAndReturnArgs} args - Arguments to update many UserFinancialProfiles.
     * @example
     * // Update many UserFinancialProfiles
     * const userFinancialProfile = await prisma.userFinancialProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserFinancialProfiles and only return the `id`
     * const userFinancialProfileWithIdOnly = await prisma.userFinancialProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserFinancialProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, UserFinancialProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFinancialProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserFinancialProfile.
     * @param {UserFinancialProfileUpsertArgs} args - Arguments to update or create a UserFinancialProfile.
     * @example
     * // Update or create a UserFinancialProfile
     * const userFinancialProfile = await prisma.userFinancialProfile.upsert({
     *   create: {
     *     // ... data to create a UserFinancialProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserFinancialProfile we want to update
     *   }
     * })
     */
    upsert<T extends UserFinancialProfileUpsertArgs>(args: SelectSubset<T, UserFinancialProfileUpsertArgs<ExtArgs>>): Prisma__UserFinancialProfileClient<$Result.GetResult<Prisma.$UserFinancialProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserFinancialProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFinancialProfileCountArgs} args - Arguments to filter UserFinancialProfiles to count.
     * @example
     * // Count the number of UserFinancialProfiles
     * const count = await prisma.userFinancialProfile.count({
     *   where: {
     *     // ... the filter for the UserFinancialProfiles we want to count
     *   }
     * })
    **/
    count<T extends UserFinancialProfileCountArgs>(
      args?: Subset<T, UserFinancialProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserFinancialProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserFinancialProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFinancialProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserFinancialProfileAggregateArgs>(args: Subset<T, UserFinancialProfileAggregateArgs>): Prisma.PrismaPromise<GetUserFinancialProfileAggregateType<T>>

    /**
     * Group by UserFinancialProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFinancialProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserFinancialProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserFinancialProfileGroupByArgs['orderBy'] }
        : { orderBy?: UserFinancialProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserFinancialProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserFinancialProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserFinancialProfile model
   */
  readonly fields: UserFinancialProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserFinancialProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserFinancialProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserFinancialProfile model
   */
  interface UserFinancialProfileFieldRefs {
    readonly id: FieldRef<"UserFinancialProfile", 'String'>
    readonly userId: FieldRef<"UserFinancialProfile", 'String'>
    readonly monthlySalary: FieldRef<"UserFinancialProfile", 'Float'>
    readonly supplementaryIncome: FieldRef<"UserFinancialProfile", 'Float'>
    readonly currency: FieldRef<"UserFinancialProfile", 'String'>
    readonly preferredSavingsRate: FieldRef<"UserFinancialProfile", 'Float'>
    readonly createdAt: FieldRef<"UserFinancialProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"UserFinancialProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserFinancialProfile findUnique
   */
  export type UserFinancialProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinancialProfile
     */
    select?: UserFinancialProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinancialProfile
     */
    omit?: UserFinancialProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinancialProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserFinancialProfile to fetch.
     */
    where: UserFinancialProfileWhereUniqueInput
  }

  /**
   * UserFinancialProfile findUniqueOrThrow
   */
  export type UserFinancialProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinancialProfile
     */
    select?: UserFinancialProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinancialProfile
     */
    omit?: UserFinancialProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinancialProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserFinancialProfile to fetch.
     */
    where: UserFinancialProfileWhereUniqueInput
  }

  /**
   * UserFinancialProfile findFirst
   */
  export type UserFinancialProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinancialProfile
     */
    select?: UserFinancialProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinancialProfile
     */
    omit?: UserFinancialProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinancialProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserFinancialProfile to fetch.
     */
    where?: UserFinancialProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFinancialProfiles to fetch.
     */
    orderBy?: UserFinancialProfileOrderByWithRelationInput | UserFinancialProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFinancialProfiles.
     */
    cursor?: UserFinancialProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFinancialProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFinancialProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFinancialProfiles.
     */
    distinct?: UserFinancialProfileScalarFieldEnum | UserFinancialProfileScalarFieldEnum[]
  }

  /**
   * UserFinancialProfile findFirstOrThrow
   */
  export type UserFinancialProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinancialProfile
     */
    select?: UserFinancialProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinancialProfile
     */
    omit?: UserFinancialProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinancialProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserFinancialProfile to fetch.
     */
    where?: UserFinancialProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFinancialProfiles to fetch.
     */
    orderBy?: UserFinancialProfileOrderByWithRelationInput | UserFinancialProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFinancialProfiles.
     */
    cursor?: UserFinancialProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFinancialProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFinancialProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFinancialProfiles.
     */
    distinct?: UserFinancialProfileScalarFieldEnum | UserFinancialProfileScalarFieldEnum[]
  }

  /**
   * UserFinancialProfile findMany
   */
  export type UserFinancialProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinancialProfile
     */
    select?: UserFinancialProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinancialProfile
     */
    omit?: UserFinancialProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinancialProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserFinancialProfiles to fetch.
     */
    where?: UserFinancialProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFinancialProfiles to fetch.
     */
    orderBy?: UserFinancialProfileOrderByWithRelationInput | UserFinancialProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserFinancialProfiles.
     */
    cursor?: UserFinancialProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFinancialProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFinancialProfiles.
     */
    skip?: number
    distinct?: UserFinancialProfileScalarFieldEnum | UserFinancialProfileScalarFieldEnum[]
  }

  /**
   * UserFinancialProfile create
   */
  export type UserFinancialProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinancialProfile
     */
    select?: UserFinancialProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinancialProfile
     */
    omit?: UserFinancialProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinancialProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a UserFinancialProfile.
     */
    data: XOR<UserFinancialProfileCreateInput, UserFinancialProfileUncheckedCreateInput>
  }

  /**
   * UserFinancialProfile createMany
   */
  export type UserFinancialProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserFinancialProfiles.
     */
    data: UserFinancialProfileCreateManyInput | UserFinancialProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserFinancialProfile createManyAndReturn
   */
  export type UserFinancialProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinancialProfile
     */
    select?: UserFinancialProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinancialProfile
     */
    omit?: UserFinancialProfileOmit<ExtArgs> | null
    /**
     * The data used to create many UserFinancialProfiles.
     */
    data: UserFinancialProfileCreateManyInput | UserFinancialProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinancialProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserFinancialProfile update
   */
  export type UserFinancialProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinancialProfile
     */
    select?: UserFinancialProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinancialProfile
     */
    omit?: UserFinancialProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinancialProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a UserFinancialProfile.
     */
    data: XOR<UserFinancialProfileUpdateInput, UserFinancialProfileUncheckedUpdateInput>
    /**
     * Choose, which UserFinancialProfile to update.
     */
    where: UserFinancialProfileWhereUniqueInput
  }

  /**
   * UserFinancialProfile updateMany
   */
  export type UserFinancialProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserFinancialProfiles.
     */
    data: XOR<UserFinancialProfileUpdateManyMutationInput, UserFinancialProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserFinancialProfiles to update
     */
    where?: UserFinancialProfileWhereInput
    /**
     * Limit how many UserFinancialProfiles to update.
     */
    limit?: number
  }

  /**
   * UserFinancialProfile updateManyAndReturn
   */
  export type UserFinancialProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinancialProfile
     */
    select?: UserFinancialProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinancialProfile
     */
    omit?: UserFinancialProfileOmit<ExtArgs> | null
    /**
     * The data used to update UserFinancialProfiles.
     */
    data: XOR<UserFinancialProfileUpdateManyMutationInput, UserFinancialProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserFinancialProfiles to update
     */
    where?: UserFinancialProfileWhereInput
    /**
     * Limit how many UserFinancialProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinancialProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserFinancialProfile upsert
   */
  export type UserFinancialProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinancialProfile
     */
    select?: UserFinancialProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinancialProfile
     */
    omit?: UserFinancialProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinancialProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the UserFinancialProfile to update in case it exists.
     */
    where: UserFinancialProfileWhereUniqueInput
    /**
     * In case the UserFinancialProfile found by the `where` argument doesn't exist, create a new UserFinancialProfile with this data.
     */
    create: XOR<UserFinancialProfileCreateInput, UserFinancialProfileUncheckedCreateInput>
    /**
     * In case the UserFinancialProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserFinancialProfileUpdateInput, UserFinancialProfileUncheckedUpdateInput>
  }

  /**
   * UserFinancialProfile delete
   */
  export type UserFinancialProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinancialProfile
     */
    select?: UserFinancialProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinancialProfile
     */
    omit?: UserFinancialProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinancialProfileInclude<ExtArgs> | null
    /**
     * Filter which UserFinancialProfile to delete.
     */
    where: UserFinancialProfileWhereUniqueInput
  }

  /**
   * UserFinancialProfile deleteMany
   */
  export type UserFinancialProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFinancialProfiles to delete
     */
    where?: UserFinancialProfileWhereInput
    /**
     * Limit how many UserFinancialProfiles to delete.
     */
    limit?: number
  }

  /**
   * UserFinancialProfile without action
   */
  export type UserFinancialProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinancialProfile
     */
    select?: UserFinancialProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinancialProfile
     */
    omit?: UserFinancialProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinancialProfileInclude<ExtArgs> | null
  }


  /**
   * Model UserMonthlyStatement
   */

  export type AggregateUserMonthlyStatement = {
    _count: UserMonthlyStatementCountAggregateOutputType | null
    _avg: UserMonthlyStatementAvgAggregateOutputType | null
    _sum: UserMonthlyStatementSumAggregateOutputType | null
    _min: UserMonthlyStatementMinAggregateOutputType | null
    _max: UserMonthlyStatementMaxAggregateOutputType | null
  }

  export type UserMonthlyStatementAvgAggregateOutputType = {
    year: number | null
    month: number | null
    salaryReceived: number | null
    supplementaryIncome: number | null
    totalExpenses: number | null
  }

  export type UserMonthlyStatementSumAggregateOutputType = {
    year: number | null
    month: number | null
    salaryReceived: number | null
    supplementaryIncome: number | null
    totalExpenses: number | null
  }

  export type UserMonthlyStatementMinAggregateOutputType = {
    id: string | null
    userId: string | null
    year: number | null
    month: number | null
    salaryReceived: number | null
    supplementaryIncome: number | null
    totalExpenses: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMonthlyStatementMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    year: number | null
    month: number | null
    salaryReceived: number | null
    supplementaryIncome: number | null
    totalExpenses: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMonthlyStatementCountAggregateOutputType = {
    id: number
    userId: number
    year: number
    month: number
    salaryReceived: number
    supplementaryIncome: number
    totalExpenses: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMonthlyStatementAvgAggregateInputType = {
    year?: true
    month?: true
    salaryReceived?: true
    supplementaryIncome?: true
    totalExpenses?: true
  }

  export type UserMonthlyStatementSumAggregateInputType = {
    year?: true
    month?: true
    salaryReceived?: true
    supplementaryIncome?: true
    totalExpenses?: true
  }

  export type UserMonthlyStatementMinAggregateInputType = {
    id?: true
    userId?: true
    year?: true
    month?: true
    salaryReceived?: true
    supplementaryIncome?: true
    totalExpenses?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMonthlyStatementMaxAggregateInputType = {
    id?: true
    userId?: true
    year?: true
    month?: true
    salaryReceived?: true
    supplementaryIncome?: true
    totalExpenses?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMonthlyStatementCountAggregateInputType = {
    id?: true
    userId?: true
    year?: true
    month?: true
    salaryReceived?: true
    supplementaryIncome?: true
    totalExpenses?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserMonthlyStatementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserMonthlyStatement to aggregate.
     */
    where?: UserMonthlyStatementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserMonthlyStatements to fetch.
     */
    orderBy?: UserMonthlyStatementOrderByWithRelationInput | UserMonthlyStatementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserMonthlyStatementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserMonthlyStatements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserMonthlyStatements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserMonthlyStatements
    **/
    _count?: true | UserMonthlyStatementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserMonthlyStatementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserMonthlyStatementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMonthlyStatementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMonthlyStatementMaxAggregateInputType
  }

  export type GetUserMonthlyStatementAggregateType<T extends UserMonthlyStatementAggregateArgs> = {
        [P in keyof T & keyof AggregateUserMonthlyStatement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserMonthlyStatement[P]>
      : GetScalarType<T[P], AggregateUserMonthlyStatement[P]>
  }




  export type UserMonthlyStatementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserMonthlyStatementWhereInput
    orderBy?: UserMonthlyStatementOrderByWithAggregationInput | UserMonthlyStatementOrderByWithAggregationInput[]
    by: UserMonthlyStatementScalarFieldEnum[] | UserMonthlyStatementScalarFieldEnum
    having?: UserMonthlyStatementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserMonthlyStatementCountAggregateInputType | true
    _avg?: UserMonthlyStatementAvgAggregateInputType
    _sum?: UserMonthlyStatementSumAggregateInputType
    _min?: UserMonthlyStatementMinAggregateInputType
    _max?: UserMonthlyStatementMaxAggregateInputType
  }

  export type UserMonthlyStatementGroupByOutputType = {
    id: string
    userId: string
    year: number
    month: number
    salaryReceived: number
    supplementaryIncome: number
    totalExpenses: number
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserMonthlyStatementCountAggregateOutputType | null
    _avg: UserMonthlyStatementAvgAggregateOutputType | null
    _sum: UserMonthlyStatementSumAggregateOutputType | null
    _min: UserMonthlyStatementMinAggregateOutputType | null
    _max: UserMonthlyStatementMaxAggregateOutputType | null
  }

  type GetUserMonthlyStatementGroupByPayload<T extends UserMonthlyStatementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserMonthlyStatementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserMonthlyStatementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserMonthlyStatementGroupByOutputType[P]>
            : GetScalarType<T[P], UserMonthlyStatementGroupByOutputType[P]>
        }
      >
    >


  export type UserMonthlyStatementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    year?: boolean
    month?: boolean
    salaryReceived?: boolean
    supplementaryIncome?: boolean
    totalExpenses?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userMonthlyStatement"]>

  export type UserMonthlyStatementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    year?: boolean
    month?: boolean
    salaryReceived?: boolean
    supplementaryIncome?: boolean
    totalExpenses?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userMonthlyStatement"]>

  export type UserMonthlyStatementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    year?: boolean
    month?: boolean
    salaryReceived?: boolean
    supplementaryIncome?: boolean
    totalExpenses?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userMonthlyStatement"]>

  export type UserMonthlyStatementSelectScalar = {
    id?: boolean
    userId?: boolean
    year?: boolean
    month?: boolean
    salaryReceived?: boolean
    supplementaryIncome?: boolean
    totalExpenses?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserMonthlyStatementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "year" | "month" | "salaryReceived" | "supplementaryIncome" | "totalExpenses" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["userMonthlyStatement"]>
  export type UserMonthlyStatementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserMonthlyStatementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserMonthlyStatementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserMonthlyStatementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserMonthlyStatement"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      year: number
      month: number
      salaryReceived: number
      supplementaryIncome: number
      totalExpenses: number
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userMonthlyStatement"]>
    composites: {}
  }

  type UserMonthlyStatementGetPayload<S extends boolean | null | undefined | UserMonthlyStatementDefaultArgs> = $Result.GetResult<Prisma.$UserMonthlyStatementPayload, S>

  type UserMonthlyStatementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserMonthlyStatementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserMonthlyStatementCountAggregateInputType | true
    }

  export interface UserMonthlyStatementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserMonthlyStatement'], meta: { name: 'UserMonthlyStatement' } }
    /**
     * Find zero or one UserMonthlyStatement that matches the filter.
     * @param {UserMonthlyStatementFindUniqueArgs} args - Arguments to find a UserMonthlyStatement
     * @example
     * // Get one UserMonthlyStatement
     * const userMonthlyStatement = await prisma.userMonthlyStatement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserMonthlyStatementFindUniqueArgs>(args: SelectSubset<T, UserMonthlyStatementFindUniqueArgs<ExtArgs>>): Prisma__UserMonthlyStatementClient<$Result.GetResult<Prisma.$UserMonthlyStatementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserMonthlyStatement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserMonthlyStatementFindUniqueOrThrowArgs} args - Arguments to find a UserMonthlyStatement
     * @example
     * // Get one UserMonthlyStatement
     * const userMonthlyStatement = await prisma.userMonthlyStatement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserMonthlyStatementFindUniqueOrThrowArgs>(args: SelectSubset<T, UserMonthlyStatementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserMonthlyStatementClient<$Result.GetResult<Prisma.$UserMonthlyStatementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserMonthlyStatement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMonthlyStatementFindFirstArgs} args - Arguments to find a UserMonthlyStatement
     * @example
     * // Get one UserMonthlyStatement
     * const userMonthlyStatement = await prisma.userMonthlyStatement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserMonthlyStatementFindFirstArgs>(args?: SelectSubset<T, UserMonthlyStatementFindFirstArgs<ExtArgs>>): Prisma__UserMonthlyStatementClient<$Result.GetResult<Prisma.$UserMonthlyStatementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserMonthlyStatement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMonthlyStatementFindFirstOrThrowArgs} args - Arguments to find a UserMonthlyStatement
     * @example
     * // Get one UserMonthlyStatement
     * const userMonthlyStatement = await prisma.userMonthlyStatement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserMonthlyStatementFindFirstOrThrowArgs>(args?: SelectSubset<T, UserMonthlyStatementFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserMonthlyStatementClient<$Result.GetResult<Prisma.$UserMonthlyStatementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserMonthlyStatements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMonthlyStatementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserMonthlyStatements
     * const userMonthlyStatements = await prisma.userMonthlyStatement.findMany()
     * 
     * // Get first 10 UserMonthlyStatements
     * const userMonthlyStatements = await prisma.userMonthlyStatement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userMonthlyStatementWithIdOnly = await prisma.userMonthlyStatement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserMonthlyStatementFindManyArgs>(args?: SelectSubset<T, UserMonthlyStatementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserMonthlyStatementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserMonthlyStatement.
     * @param {UserMonthlyStatementCreateArgs} args - Arguments to create a UserMonthlyStatement.
     * @example
     * // Create one UserMonthlyStatement
     * const UserMonthlyStatement = await prisma.userMonthlyStatement.create({
     *   data: {
     *     // ... data to create a UserMonthlyStatement
     *   }
     * })
     * 
     */
    create<T extends UserMonthlyStatementCreateArgs>(args: SelectSubset<T, UserMonthlyStatementCreateArgs<ExtArgs>>): Prisma__UserMonthlyStatementClient<$Result.GetResult<Prisma.$UserMonthlyStatementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserMonthlyStatements.
     * @param {UserMonthlyStatementCreateManyArgs} args - Arguments to create many UserMonthlyStatements.
     * @example
     * // Create many UserMonthlyStatements
     * const userMonthlyStatement = await prisma.userMonthlyStatement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserMonthlyStatementCreateManyArgs>(args?: SelectSubset<T, UserMonthlyStatementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserMonthlyStatements and returns the data saved in the database.
     * @param {UserMonthlyStatementCreateManyAndReturnArgs} args - Arguments to create many UserMonthlyStatements.
     * @example
     * // Create many UserMonthlyStatements
     * const userMonthlyStatement = await prisma.userMonthlyStatement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserMonthlyStatements and only return the `id`
     * const userMonthlyStatementWithIdOnly = await prisma.userMonthlyStatement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserMonthlyStatementCreateManyAndReturnArgs>(args?: SelectSubset<T, UserMonthlyStatementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserMonthlyStatementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserMonthlyStatement.
     * @param {UserMonthlyStatementDeleteArgs} args - Arguments to delete one UserMonthlyStatement.
     * @example
     * // Delete one UserMonthlyStatement
     * const UserMonthlyStatement = await prisma.userMonthlyStatement.delete({
     *   where: {
     *     // ... filter to delete one UserMonthlyStatement
     *   }
     * })
     * 
     */
    delete<T extends UserMonthlyStatementDeleteArgs>(args: SelectSubset<T, UserMonthlyStatementDeleteArgs<ExtArgs>>): Prisma__UserMonthlyStatementClient<$Result.GetResult<Prisma.$UserMonthlyStatementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserMonthlyStatement.
     * @param {UserMonthlyStatementUpdateArgs} args - Arguments to update one UserMonthlyStatement.
     * @example
     * // Update one UserMonthlyStatement
     * const userMonthlyStatement = await prisma.userMonthlyStatement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserMonthlyStatementUpdateArgs>(args: SelectSubset<T, UserMonthlyStatementUpdateArgs<ExtArgs>>): Prisma__UserMonthlyStatementClient<$Result.GetResult<Prisma.$UserMonthlyStatementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserMonthlyStatements.
     * @param {UserMonthlyStatementDeleteManyArgs} args - Arguments to filter UserMonthlyStatements to delete.
     * @example
     * // Delete a few UserMonthlyStatements
     * const { count } = await prisma.userMonthlyStatement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserMonthlyStatementDeleteManyArgs>(args?: SelectSubset<T, UserMonthlyStatementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserMonthlyStatements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMonthlyStatementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserMonthlyStatements
     * const userMonthlyStatement = await prisma.userMonthlyStatement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserMonthlyStatementUpdateManyArgs>(args: SelectSubset<T, UserMonthlyStatementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserMonthlyStatements and returns the data updated in the database.
     * @param {UserMonthlyStatementUpdateManyAndReturnArgs} args - Arguments to update many UserMonthlyStatements.
     * @example
     * // Update many UserMonthlyStatements
     * const userMonthlyStatement = await prisma.userMonthlyStatement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserMonthlyStatements and only return the `id`
     * const userMonthlyStatementWithIdOnly = await prisma.userMonthlyStatement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserMonthlyStatementUpdateManyAndReturnArgs>(args: SelectSubset<T, UserMonthlyStatementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserMonthlyStatementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserMonthlyStatement.
     * @param {UserMonthlyStatementUpsertArgs} args - Arguments to update or create a UserMonthlyStatement.
     * @example
     * // Update or create a UserMonthlyStatement
     * const userMonthlyStatement = await prisma.userMonthlyStatement.upsert({
     *   create: {
     *     // ... data to create a UserMonthlyStatement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserMonthlyStatement we want to update
     *   }
     * })
     */
    upsert<T extends UserMonthlyStatementUpsertArgs>(args: SelectSubset<T, UserMonthlyStatementUpsertArgs<ExtArgs>>): Prisma__UserMonthlyStatementClient<$Result.GetResult<Prisma.$UserMonthlyStatementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserMonthlyStatements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMonthlyStatementCountArgs} args - Arguments to filter UserMonthlyStatements to count.
     * @example
     * // Count the number of UserMonthlyStatements
     * const count = await prisma.userMonthlyStatement.count({
     *   where: {
     *     // ... the filter for the UserMonthlyStatements we want to count
     *   }
     * })
    **/
    count<T extends UserMonthlyStatementCountArgs>(
      args?: Subset<T, UserMonthlyStatementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserMonthlyStatementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserMonthlyStatement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMonthlyStatementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserMonthlyStatementAggregateArgs>(args: Subset<T, UserMonthlyStatementAggregateArgs>): Prisma.PrismaPromise<GetUserMonthlyStatementAggregateType<T>>

    /**
     * Group by UserMonthlyStatement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMonthlyStatementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserMonthlyStatementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserMonthlyStatementGroupByArgs['orderBy'] }
        : { orderBy?: UserMonthlyStatementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserMonthlyStatementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserMonthlyStatementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserMonthlyStatement model
   */
  readonly fields: UserMonthlyStatementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserMonthlyStatement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserMonthlyStatementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserMonthlyStatement model
   */
  interface UserMonthlyStatementFieldRefs {
    readonly id: FieldRef<"UserMonthlyStatement", 'String'>
    readonly userId: FieldRef<"UserMonthlyStatement", 'String'>
    readonly year: FieldRef<"UserMonthlyStatement", 'Int'>
    readonly month: FieldRef<"UserMonthlyStatement", 'Int'>
    readonly salaryReceived: FieldRef<"UserMonthlyStatement", 'Float'>
    readonly supplementaryIncome: FieldRef<"UserMonthlyStatement", 'Float'>
    readonly totalExpenses: FieldRef<"UserMonthlyStatement", 'Float'>
    readonly notes: FieldRef<"UserMonthlyStatement", 'String'>
    readonly createdAt: FieldRef<"UserMonthlyStatement", 'DateTime'>
    readonly updatedAt: FieldRef<"UserMonthlyStatement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserMonthlyStatement findUnique
   */
  export type UserMonthlyStatementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMonthlyStatement
     */
    select?: UserMonthlyStatementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMonthlyStatement
     */
    omit?: UserMonthlyStatementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMonthlyStatementInclude<ExtArgs> | null
    /**
     * Filter, which UserMonthlyStatement to fetch.
     */
    where: UserMonthlyStatementWhereUniqueInput
  }

  /**
   * UserMonthlyStatement findUniqueOrThrow
   */
  export type UserMonthlyStatementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMonthlyStatement
     */
    select?: UserMonthlyStatementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMonthlyStatement
     */
    omit?: UserMonthlyStatementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMonthlyStatementInclude<ExtArgs> | null
    /**
     * Filter, which UserMonthlyStatement to fetch.
     */
    where: UserMonthlyStatementWhereUniqueInput
  }

  /**
   * UserMonthlyStatement findFirst
   */
  export type UserMonthlyStatementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMonthlyStatement
     */
    select?: UserMonthlyStatementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMonthlyStatement
     */
    omit?: UserMonthlyStatementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMonthlyStatementInclude<ExtArgs> | null
    /**
     * Filter, which UserMonthlyStatement to fetch.
     */
    where?: UserMonthlyStatementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserMonthlyStatements to fetch.
     */
    orderBy?: UserMonthlyStatementOrderByWithRelationInput | UserMonthlyStatementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserMonthlyStatements.
     */
    cursor?: UserMonthlyStatementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserMonthlyStatements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserMonthlyStatements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserMonthlyStatements.
     */
    distinct?: UserMonthlyStatementScalarFieldEnum | UserMonthlyStatementScalarFieldEnum[]
  }

  /**
   * UserMonthlyStatement findFirstOrThrow
   */
  export type UserMonthlyStatementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMonthlyStatement
     */
    select?: UserMonthlyStatementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMonthlyStatement
     */
    omit?: UserMonthlyStatementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMonthlyStatementInclude<ExtArgs> | null
    /**
     * Filter, which UserMonthlyStatement to fetch.
     */
    where?: UserMonthlyStatementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserMonthlyStatements to fetch.
     */
    orderBy?: UserMonthlyStatementOrderByWithRelationInput | UserMonthlyStatementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserMonthlyStatements.
     */
    cursor?: UserMonthlyStatementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserMonthlyStatements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserMonthlyStatements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserMonthlyStatements.
     */
    distinct?: UserMonthlyStatementScalarFieldEnum | UserMonthlyStatementScalarFieldEnum[]
  }

  /**
   * UserMonthlyStatement findMany
   */
  export type UserMonthlyStatementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMonthlyStatement
     */
    select?: UserMonthlyStatementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMonthlyStatement
     */
    omit?: UserMonthlyStatementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMonthlyStatementInclude<ExtArgs> | null
    /**
     * Filter, which UserMonthlyStatements to fetch.
     */
    where?: UserMonthlyStatementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserMonthlyStatements to fetch.
     */
    orderBy?: UserMonthlyStatementOrderByWithRelationInput | UserMonthlyStatementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserMonthlyStatements.
     */
    cursor?: UserMonthlyStatementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserMonthlyStatements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserMonthlyStatements.
     */
    skip?: number
    distinct?: UserMonthlyStatementScalarFieldEnum | UserMonthlyStatementScalarFieldEnum[]
  }

  /**
   * UserMonthlyStatement create
   */
  export type UserMonthlyStatementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMonthlyStatement
     */
    select?: UserMonthlyStatementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMonthlyStatement
     */
    omit?: UserMonthlyStatementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMonthlyStatementInclude<ExtArgs> | null
    /**
     * The data needed to create a UserMonthlyStatement.
     */
    data: XOR<UserMonthlyStatementCreateInput, UserMonthlyStatementUncheckedCreateInput>
  }

  /**
   * UserMonthlyStatement createMany
   */
  export type UserMonthlyStatementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserMonthlyStatements.
     */
    data: UserMonthlyStatementCreateManyInput | UserMonthlyStatementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserMonthlyStatement createManyAndReturn
   */
  export type UserMonthlyStatementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMonthlyStatement
     */
    select?: UserMonthlyStatementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserMonthlyStatement
     */
    omit?: UserMonthlyStatementOmit<ExtArgs> | null
    /**
     * The data used to create many UserMonthlyStatements.
     */
    data: UserMonthlyStatementCreateManyInput | UserMonthlyStatementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMonthlyStatementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserMonthlyStatement update
   */
  export type UserMonthlyStatementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMonthlyStatement
     */
    select?: UserMonthlyStatementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMonthlyStatement
     */
    omit?: UserMonthlyStatementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMonthlyStatementInclude<ExtArgs> | null
    /**
     * The data needed to update a UserMonthlyStatement.
     */
    data: XOR<UserMonthlyStatementUpdateInput, UserMonthlyStatementUncheckedUpdateInput>
    /**
     * Choose, which UserMonthlyStatement to update.
     */
    where: UserMonthlyStatementWhereUniqueInput
  }

  /**
   * UserMonthlyStatement updateMany
   */
  export type UserMonthlyStatementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserMonthlyStatements.
     */
    data: XOR<UserMonthlyStatementUpdateManyMutationInput, UserMonthlyStatementUncheckedUpdateManyInput>
    /**
     * Filter which UserMonthlyStatements to update
     */
    where?: UserMonthlyStatementWhereInput
    /**
     * Limit how many UserMonthlyStatements to update.
     */
    limit?: number
  }

  /**
   * UserMonthlyStatement updateManyAndReturn
   */
  export type UserMonthlyStatementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMonthlyStatement
     */
    select?: UserMonthlyStatementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserMonthlyStatement
     */
    omit?: UserMonthlyStatementOmit<ExtArgs> | null
    /**
     * The data used to update UserMonthlyStatements.
     */
    data: XOR<UserMonthlyStatementUpdateManyMutationInput, UserMonthlyStatementUncheckedUpdateManyInput>
    /**
     * Filter which UserMonthlyStatements to update
     */
    where?: UserMonthlyStatementWhereInput
    /**
     * Limit how many UserMonthlyStatements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMonthlyStatementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserMonthlyStatement upsert
   */
  export type UserMonthlyStatementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMonthlyStatement
     */
    select?: UserMonthlyStatementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMonthlyStatement
     */
    omit?: UserMonthlyStatementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMonthlyStatementInclude<ExtArgs> | null
    /**
     * The filter to search for the UserMonthlyStatement to update in case it exists.
     */
    where: UserMonthlyStatementWhereUniqueInput
    /**
     * In case the UserMonthlyStatement found by the `where` argument doesn't exist, create a new UserMonthlyStatement with this data.
     */
    create: XOR<UserMonthlyStatementCreateInput, UserMonthlyStatementUncheckedCreateInput>
    /**
     * In case the UserMonthlyStatement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserMonthlyStatementUpdateInput, UserMonthlyStatementUncheckedUpdateInput>
  }

  /**
   * UserMonthlyStatement delete
   */
  export type UserMonthlyStatementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMonthlyStatement
     */
    select?: UserMonthlyStatementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMonthlyStatement
     */
    omit?: UserMonthlyStatementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMonthlyStatementInclude<ExtArgs> | null
    /**
     * Filter which UserMonthlyStatement to delete.
     */
    where: UserMonthlyStatementWhereUniqueInput
  }

  /**
   * UserMonthlyStatement deleteMany
   */
  export type UserMonthlyStatementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserMonthlyStatements to delete
     */
    where?: UserMonthlyStatementWhereInput
    /**
     * Limit how many UserMonthlyStatements to delete.
     */
    limit?: number
  }

  /**
   * UserMonthlyStatement without action
   */
  export type UserMonthlyStatementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMonthlyStatement
     */
    select?: UserMonthlyStatementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMonthlyStatement
     */
    omit?: UserMonthlyStatementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMonthlyStatementInclude<ExtArgs> | null
  }


  /**
   * Model UserFinancialEntry
   */

  export type AggregateUserFinancialEntry = {
    _count: UserFinancialEntryCountAggregateOutputType | null
    _avg: UserFinancialEntryAvgAggregateOutputType | null
    _sum: UserFinancialEntrySumAggregateOutputType | null
    _min: UserFinancialEntryMinAggregateOutputType | null
    _max: UserFinancialEntryMaxAggregateOutputType | null
  }

  export type UserFinancialEntryAvgAggregateOutputType = {
    year: number | null
    month: number | null
    amount: number | null
  }

  export type UserFinancialEntrySumAggregateOutputType = {
    year: number | null
    month: number | null
    amount: number | null
  }

  export type UserFinancialEntryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    year: number | null
    month: number | null
    type: $Enums.FinancialEntryType | null
    amount: number | null
    note: string | null
    isConfirmed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserFinancialEntryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    year: number | null
    month: number | null
    type: $Enums.FinancialEntryType | null
    amount: number | null
    note: string | null
    isConfirmed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserFinancialEntryCountAggregateOutputType = {
    id: number
    userId: number
    year: number
    month: number
    type: number
    amount: number
    note: number
    isConfirmed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserFinancialEntryAvgAggregateInputType = {
    year?: true
    month?: true
    amount?: true
  }

  export type UserFinancialEntrySumAggregateInputType = {
    year?: true
    month?: true
    amount?: true
  }

  export type UserFinancialEntryMinAggregateInputType = {
    id?: true
    userId?: true
    year?: true
    month?: true
    type?: true
    amount?: true
    note?: true
    isConfirmed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserFinancialEntryMaxAggregateInputType = {
    id?: true
    userId?: true
    year?: true
    month?: true
    type?: true
    amount?: true
    note?: true
    isConfirmed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserFinancialEntryCountAggregateInputType = {
    id?: true
    userId?: true
    year?: true
    month?: true
    type?: true
    amount?: true
    note?: true
    isConfirmed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserFinancialEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFinancialEntry to aggregate.
     */
    where?: UserFinancialEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFinancialEntries to fetch.
     */
    orderBy?: UserFinancialEntryOrderByWithRelationInput | UserFinancialEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserFinancialEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFinancialEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFinancialEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserFinancialEntries
    **/
    _count?: true | UserFinancialEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserFinancialEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserFinancialEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserFinancialEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserFinancialEntryMaxAggregateInputType
  }

  export type GetUserFinancialEntryAggregateType<T extends UserFinancialEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateUserFinancialEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserFinancialEntry[P]>
      : GetScalarType<T[P], AggregateUserFinancialEntry[P]>
  }




  export type UserFinancialEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFinancialEntryWhereInput
    orderBy?: UserFinancialEntryOrderByWithAggregationInput | UserFinancialEntryOrderByWithAggregationInput[]
    by: UserFinancialEntryScalarFieldEnum[] | UserFinancialEntryScalarFieldEnum
    having?: UserFinancialEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserFinancialEntryCountAggregateInputType | true
    _avg?: UserFinancialEntryAvgAggregateInputType
    _sum?: UserFinancialEntrySumAggregateInputType
    _min?: UserFinancialEntryMinAggregateInputType
    _max?: UserFinancialEntryMaxAggregateInputType
  }

  export type UserFinancialEntryGroupByOutputType = {
    id: string
    userId: string
    year: number
    month: number
    type: $Enums.FinancialEntryType
    amount: number
    note: string | null
    isConfirmed: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserFinancialEntryCountAggregateOutputType | null
    _avg: UserFinancialEntryAvgAggregateOutputType | null
    _sum: UserFinancialEntrySumAggregateOutputType | null
    _min: UserFinancialEntryMinAggregateOutputType | null
    _max: UserFinancialEntryMaxAggregateOutputType | null
  }

  type GetUserFinancialEntryGroupByPayload<T extends UserFinancialEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserFinancialEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserFinancialEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserFinancialEntryGroupByOutputType[P]>
            : GetScalarType<T[P], UserFinancialEntryGroupByOutputType[P]>
        }
      >
    >


  export type UserFinancialEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    year?: boolean
    month?: boolean
    type?: boolean
    amount?: boolean
    note?: boolean
    isConfirmed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFinancialEntry"]>

  export type UserFinancialEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    year?: boolean
    month?: boolean
    type?: boolean
    amount?: boolean
    note?: boolean
    isConfirmed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFinancialEntry"]>

  export type UserFinancialEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    year?: boolean
    month?: boolean
    type?: boolean
    amount?: boolean
    note?: boolean
    isConfirmed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFinancialEntry"]>

  export type UserFinancialEntrySelectScalar = {
    id?: boolean
    userId?: boolean
    year?: boolean
    month?: boolean
    type?: boolean
    amount?: boolean
    note?: boolean
    isConfirmed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserFinancialEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "year" | "month" | "type" | "amount" | "note" | "isConfirmed" | "createdAt" | "updatedAt", ExtArgs["result"]["userFinancialEntry"]>
  export type UserFinancialEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserFinancialEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserFinancialEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserFinancialEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserFinancialEntry"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      year: number
      month: number
      type: $Enums.FinancialEntryType
      amount: number
      note: string | null
      isConfirmed: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userFinancialEntry"]>
    composites: {}
  }

  type UserFinancialEntryGetPayload<S extends boolean | null | undefined | UserFinancialEntryDefaultArgs> = $Result.GetResult<Prisma.$UserFinancialEntryPayload, S>

  type UserFinancialEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFinancialEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserFinancialEntryCountAggregateInputType | true
    }

  export interface UserFinancialEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserFinancialEntry'], meta: { name: 'UserFinancialEntry' } }
    /**
     * Find zero or one UserFinancialEntry that matches the filter.
     * @param {UserFinancialEntryFindUniqueArgs} args - Arguments to find a UserFinancialEntry
     * @example
     * // Get one UserFinancialEntry
     * const userFinancialEntry = await prisma.userFinancialEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFinancialEntryFindUniqueArgs>(args: SelectSubset<T, UserFinancialEntryFindUniqueArgs<ExtArgs>>): Prisma__UserFinancialEntryClient<$Result.GetResult<Prisma.$UserFinancialEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserFinancialEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFinancialEntryFindUniqueOrThrowArgs} args - Arguments to find a UserFinancialEntry
     * @example
     * // Get one UserFinancialEntry
     * const userFinancialEntry = await prisma.userFinancialEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFinancialEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFinancialEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserFinancialEntryClient<$Result.GetResult<Prisma.$UserFinancialEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserFinancialEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFinancialEntryFindFirstArgs} args - Arguments to find a UserFinancialEntry
     * @example
     * // Get one UserFinancialEntry
     * const userFinancialEntry = await prisma.userFinancialEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFinancialEntryFindFirstArgs>(args?: SelectSubset<T, UserFinancialEntryFindFirstArgs<ExtArgs>>): Prisma__UserFinancialEntryClient<$Result.GetResult<Prisma.$UserFinancialEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserFinancialEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFinancialEntryFindFirstOrThrowArgs} args - Arguments to find a UserFinancialEntry
     * @example
     * // Get one UserFinancialEntry
     * const userFinancialEntry = await prisma.userFinancialEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFinancialEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFinancialEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserFinancialEntryClient<$Result.GetResult<Prisma.$UserFinancialEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserFinancialEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFinancialEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserFinancialEntries
     * const userFinancialEntries = await prisma.userFinancialEntry.findMany()
     * 
     * // Get first 10 UserFinancialEntries
     * const userFinancialEntries = await prisma.userFinancialEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userFinancialEntryWithIdOnly = await prisma.userFinancialEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFinancialEntryFindManyArgs>(args?: SelectSubset<T, UserFinancialEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFinancialEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserFinancialEntry.
     * @param {UserFinancialEntryCreateArgs} args - Arguments to create a UserFinancialEntry.
     * @example
     * // Create one UserFinancialEntry
     * const UserFinancialEntry = await prisma.userFinancialEntry.create({
     *   data: {
     *     // ... data to create a UserFinancialEntry
     *   }
     * })
     * 
     */
    create<T extends UserFinancialEntryCreateArgs>(args: SelectSubset<T, UserFinancialEntryCreateArgs<ExtArgs>>): Prisma__UserFinancialEntryClient<$Result.GetResult<Prisma.$UserFinancialEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserFinancialEntries.
     * @param {UserFinancialEntryCreateManyArgs} args - Arguments to create many UserFinancialEntries.
     * @example
     * // Create many UserFinancialEntries
     * const userFinancialEntry = await prisma.userFinancialEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserFinancialEntryCreateManyArgs>(args?: SelectSubset<T, UserFinancialEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserFinancialEntries and returns the data saved in the database.
     * @param {UserFinancialEntryCreateManyAndReturnArgs} args - Arguments to create many UserFinancialEntries.
     * @example
     * // Create many UserFinancialEntries
     * const userFinancialEntry = await prisma.userFinancialEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserFinancialEntries and only return the `id`
     * const userFinancialEntryWithIdOnly = await prisma.userFinancialEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserFinancialEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, UserFinancialEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFinancialEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserFinancialEntry.
     * @param {UserFinancialEntryDeleteArgs} args - Arguments to delete one UserFinancialEntry.
     * @example
     * // Delete one UserFinancialEntry
     * const UserFinancialEntry = await prisma.userFinancialEntry.delete({
     *   where: {
     *     // ... filter to delete one UserFinancialEntry
     *   }
     * })
     * 
     */
    delete<T extends UserFinancialEntryDeleteArgs>(args: SelectSubset<T, UserFinancialEntryDeleteArgs<ExtArgs>>): Prisma__UserFinancialEntryClient<$Result.GetResult<Prisma.$UserFinancialEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserFinancialEntry.
     * @param {UserFinancialEntryUpdateArgs} args - Arguments to update one UserFinancialEntry.
     * @example
     * // Update one UserFinancialEntry
     * const userFinancialEntry = await prisma.userFinancialEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserFinancialEntryUpdateArgs>(args: SelectSubset<T, UserFinancialEntryUpdateArgs<ExtArgs>>): Prisma__UserFinancialEntryClient<$Result.GetResult<Prisma.$UserFinancialEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserFinancialEntries.
     * @param {UserFinancialEntryDeleteManyArgs} args - Arguments to filter UserFinancialEntries to delete.
     * @example
     * // Delete a few UserFinancialEntries
     * const { count } = await prisma.userFinancialEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserFinancialEntryDeleteManyArgs>(args?: SelectSubset<T, UserFinancialEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFinancialEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFinancialEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserFinancialEntries
     * const userFinancialEntry = await prisma.userFinancialEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserFinancialEntryUpdateManyArgs>(args: SelectSubset<T, UserFinancialEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFinancialEntries and returns the data updated in the database.
     * @param {UserFinancialEntryUpdateManyAndReturnArgs} args - Arguments to update many UserFinancialEntries.
     * @example
     * // Update many UserFinancialEntries
     * const userFinancialEntry = await prisma.userFinancialEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserFinancialEntries and only return the `id`
     * const userFinancialEntryWithIdOnly = await prisma.userFinancialEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserFinancialEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, UserFinancialEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFinancialEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserFinancialEntry.
     * @param {UserFinancialEntryUpsertArgs} args - Arguments to update or create a UserFinancialEntry.
     * @example
     * // Update or create a UserFinancialEntry
     * const userFinancialEntry = await prisma.userFinancialEntry.upsert({
     *   create: {
     *     // ... data to create a UserFinancialEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserFinancialEntry we want to update
     *   }
     * })
     */
    upsert<T extends UserFinancialEntryUpsertArgs>(args: SelectSubset<T, UserFinancialEntryUpsertArgs<ExtArgs>>): Prisma__UserFinancialEntryClient<$Result.GetResult<Prisma.$UserFinancialEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserFinancialEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFinancialEntryCountArgs} args - Arguments to filter UserFinancialEntries to count.
     * @example
     * // Count the number of UserFinancialEntries
     * const count = await prisma.userFinancialEntry.count({
     *   where: {
     *     // ... the filter for the UserFinancialEntries we want to count
     *   }
     * })
    **/
    count<T extends UserFinancialEntryCountArgs>(
      args?: Subset<T, UserFinancialEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserFinancialEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserFinancialEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFinancialEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserFinancialEntryAggregateArgs>(args: Subset<T, UserFinancialEntryAggregateArgs>): Prisma.PrismaPromise<GetUserFinancialEntryAggregateType<T>>

    /**
     * Group by UserFinancialEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFinancialEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserFinancialEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserFinancialEntryGroupByArgs['orderBy'] }
        : { orderBy?: UserFinancialEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserFinancialEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserFinancialEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserFinancialEntry model
   */
  readonly fields: UserFinancialEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserFinancialEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserFinancialEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserFinancialEntry model
   */
  interface UserFinancialEntryFieldRefs {
    readonly id: FieldRef<"UserFinancialEntry", 'String'>
    readonly userId: FieldRef<"UserFinancialEntry", 'String'>
    readonly year: FieldRef<"UserFinancialEntry", 'Int'>
    readonly month: FieldRef<"UserFinancialEntry", 'Int'>
    readonly type: FieldRef<"UserFinancialEntry", 'FinancialEntryType'>
    readonly amount: FieldRef<"UserFinancialEntry", 'Float'>
    readonly note: FieldRef<"UserFinancialEntry", 'String'>
    readonly isConfirmed: FieldRef<"UserFinancialEntry", 'Boolean'>
    readonly createdAt: FieldRef<"UserFinancialEntry", 'DateTime'>
    readonly updatedAt: FieldRef<"UserFinancialEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserFinancialEntry findUnique
   */
  export type UserFinancialEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinancialEntry
     */
    select?: UserFinancialEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinancialEntry
     */
    omit?: UserFinancialEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinancialEntryInclude<ExtArgs> | null
    /**
     * Filter, which UserFinancialEntry to fetch.
     */
    where: UserFinancialEntryWhereUniqueInput
  }

  /**
   * UserFinancialEntry findUniqueOrThrow
   */
  export type UserFinancialEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinancialEntry
     */
    select?: UserFinancialEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinancialEntry
     */
    omit?: UserFinancialEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinancialEntryInclude<ExtArgs> | null
    /**
     * Filter, which UserFinancialEntry to fetch.
     */
    where: UserFinancialEntryWhereUniqueInput
  }

  /**
   * UserFinancialEntry findFirst
   */
  export type UserFinancialEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinancialEntry
     */
    select?: UserFinancialEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinancialEntry
     */
    omit?: UserFinancialEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinancialEntryInclude<ExtArgs> | null
    /**
     * Filter, which UserFinancialEntry to fetch.
     */
    where?: UserFinancialEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFinancialEntries to fetch.
     */
    orderBy?: UserFinancialEntryOrderByWithRelationInput | UserFinancialEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFinancialEntries.
     */
    cursor?: UserFinancialEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFinancialEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFinancialEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFinancialEntries.
     */
    distinct?: UserFinancialEntryScalarFieldEnum | UserFinancialEntryScalarFieldEnum[]
  }

  /**
   * UserFinancialEntry findFirstOrThrow
   */
  export type UserFinancialEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinancialEntry
     */
    select?: UserFinancialEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinancialEntry
     */
    omit?: UserFinancialEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinancialEntryInclude<ExtArgs> | null
    /**
     * Filter, which UserFinancialEntry to fetch.
     */
    where?: UserFinancialEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFinancialEntries to fetch.
     */
    orderBy?: UserFinancialEntryOrderByWithRelationInput | UserFinancialEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFinancialEntries.
     */
    cursor?: UserFinancialEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFinancialEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFinancialEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFinancialEntries.
     */
    distinct?: UserFinancialEntryScalarFieldEnum | UserFinancialEntryScalarFieldEnum[]
  }

  /**
   * UserFinancialEntry findMany
   */
  export type UserFinancialEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinancialEntry
     */
    select?: UserFinancialEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinancialEntry
     */
    omit?: UserFinancialEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinancialEntryInclude<ExtArgs> | null
    /**
     * Filter, which UserFinancialEntries to fetch.
     */
    where?: UserFinancialEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFinancialEntries to fetch.
     */
    orderBy?: UserFinancialEntryOrderByWithRelationInput | UserFinancialEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserFinancialEntries.
     */
    cursor?: UserFinancialEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFinancialEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFinancialEntries.
     */
    skip?: number
    distinct?: UserFinancialEntryScalarFieldEnum | UserFinancialEntryScalarFieldEnum[]
  }

  /**
   * UserFinancialEntry create
   */
  export type UserFinancialEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinancialEntry
     */
    select?: UserFinancialEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinancialEntry
     */
    omit?: UserFinancialEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinancialEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a UserFinancialEntry.
     */
    data: XOR<UserFinancialEntryCreateInput, UserFinancialEntryUncheckedCreateInput>
  }

  /**
   * UserFinancialEntry createMany
   */
  export type UserFinancialEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserFinancialEntries.
     */
    data: UserFinancialEntryCreateManyInput | UserFinancialEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserFinancialEntry createManyAndReturn
   */
  export type UserFinancialEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinancialEntry
     */
    select?: UserFinancialEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinancialEntry
     */
    omit?: UserFinancialEntryOmit<ExtArgs> | null
    /**
     * The data used to create many UserFinancialEntries.
     */
    data: UserFinancialEntryCreateManyInput | UserFinancialEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinancialEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserFinancialEntry update
   */
  export type UserFinancialEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinancialEntry
     */
    select?: UserFinancialEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinancialEntry
     */
    omit?: UserFinancialEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinancialEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a UserFinancialEntry.
     */
    data: XOR<UserFinancialEntryUpdateInput, UserFinancialEntryUncheckedUpdateInput>
    /**
     * Choose, which UserFinancialEntry to update.
     */
    where: UserFinancialEntryWhereUniqueInput
  }

  /**
   * UserFinancialEntry updateMany
   */
  export type UserFinancialEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserFinancialEntries.
     */
    data: XOR<UserFinancialEntryUpdateManyMutationInput, UserFinancialEntryUncheckedUpdateManyInput>
    /**
     * Filter which UserFinancialEntries to update
     */
    where?: UserFinancialEntryWhereInput
    /**
     * Limit how many UserFinancialEntries to update.
     */
    limit?: number
  }

  /**
   * UserFinancialEntry updateManyAndReturn
   */
  export type UserFinancialEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinancialEntry
     */
    select?: UserFinancialEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinancialEntry
     */
    omit?: UserFinancialEntryOmit<ExtArgs> | null
    /**
     * The data used to update UserFinancialEntries.
     */
    data: XOR<UserFinancialEntryUpdateManyMutationInput, UserFinancialEntryUncheckedUpdateManyInput>
    /**
     * Filter which UserFinancialEntries to update
     */
    where?: UserFinancialEntryWhereInput
    /**
     * Limit how many UserFinancialEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinancialEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserFinancialEntry upsert
   */
  export type UserFinancialEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinancialEntry
     */
    select?: UserFinancialEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinancialEntry
     */
    omit?: UserFinancialEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinancialEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the UserFinancialEntry to update in case it exists.
     */
    where: UserFinancialEntryWhereUniqueInput
    /**
     * In case the UserFinancialEntry found by the `where` argument doesn't exist, create a new UserFinancialEntry with this data.
     */
    create: XOR<UserFinancialEntryCreateInput, UserFinancialEntryUncheckedCreateInput>
    /**
     * In case the UserFinancialEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserFinancialEntryUpdateInput, UserFinancialEntryUncheckedUpdateInput>
  }

  /**
   * UserFinancialEntry delete
   */
  export type UserFinancialEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinancialEntry
     */
    select?: UserFinancialEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinancialEntry
     */
    omit?: UserFinancialEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinancialEntryInclude<ExtArgs> | null
    /**
     * Filter which UserFinancialEntry to delete.
     */
    where: UserFinancialEntryWhereUniqueInput
  }

  /**
   * UserFinancialEntry deleteMany
   */
  export type UserFinancialEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFinancialEntries to delete
     */
    where?: UserFinancialEntryWhereInput
    /**
     * Limit how many UserFinancialEntries to delete.
     */
    limit?: number
  }

  /**
   * UserFinancialEntry without action
   */
  export type UserFinancialEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinancialEntry
     */
    select?: UserFinancialEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinancialEntry
     */
    omit?: UserFinancialEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinancialEntryInclude<ExtArgs> | null
  }


  /**
   * Model UserMonthlyProgress
   */

  export type AggregateUserMonthlyProgress = {
    _count: UserMonthlyProgressCountAggregateOutputType | null
    _avg: UserMonthlyProgressAvgAggregateOutputType | null
    _sum: UserMonthlyProgressSumAggregateOutputType | null
    _min: UserMonthlyProgressMinAggregateOutputType | null
    _max: UserMonthlyProgressMaxAggregateOutputType | null
  }

  export type UserMonthlyProgressAvgAggregateOutputType = {
    year: number | null
    month: number | null
    amount: number | null
  }

  export type UserMonthlyProgressSumAggregateOutputType = {
    year: number | null
    month: number | null
    amount: number | null
  }

  export type UserMonthlyProgressMinAggregateOutputType = {
    id: string | null
    goalId: string | null
    year: number | null
    month: number | null
    amount: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMonthlyProgressMaxAggregateOutputType = {
    id: string | null
    goalId: string | null
    year: number | null
    month: number | null
    amount: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMonthlyProgressCountAggregateOutputType = {
    id: number
    goalId: number
    year: number
    month: number
    amount: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMonthlyProgressAvgAggregateInputType = {
    year?: true
    month?: true
    amount?: true
  }

  export type UserMonthlyProgressSumAggregateInputType = {
    year?: true
    month?: true
    amount?: true
  }

  export type UserMonthlyProgressMinAggregateInputType = {
    id?: true
    goalId?: true
    year?: true
    month?: true
    amount?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMonthlyProgressMaxAggregateInputType = {
    id?: true
    goalId?: true
    year?: true
    month?: true
    amount?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMonthlyProgressCountAggregateInputType = {
    id?: true
    goalId?: true
    year?: true
    month?: true
    amount?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserMonthlyProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserMonthlyProgress to aggregate.
     */
    where?: UserMonthlyProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserMonthlyProgresses to fetch.
     */
    orderBy?: UserMonthlyProgressOrderByWithRelationInput | UserMonthlyProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserMonthlyProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserMonthlyProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserMonthlyProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserMonthlyProgresses
    **/
    _count?: true | UserMonthlyProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserMonthlyProgressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserMonthlyProgressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMonthlyProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMonthlyProgressMaxAggregateInputType
  }

  export type GetUserMonthlyProgressAggregateType<T extends UserMonthlyProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateUserMonthlyProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserMonthlyProgress[P]>
      : GetScalarType<T[P], AggregateUserMonthlyProgress[P]>
  }




  export type UserMonthlyProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserMonthlyProgressWhereInput
    orderBy?: UserMonthlyProgressOrderByWithAggregationInput | UserMonthlyProgressOrderByWithAggregationInput[]
    by: UserMonthlyProgressScalarFieldEnum[] | UserMonthlyProgressScalarFieldEnum
    having?: UserMonthlyProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserMonthlyProgressCountAggregateInputType | true
    _avg?: UserMonthlyProgressAvgAggregateInputType
    _sum?: UserMonthlyProgressSumAggregateInputType
    _min?: UserMonthlyProgressMinAggregateInputType
    _max?: UserMonthlyProgressMaxAggregateInputType
  }

  export type UserMonthlyProgressGroupByOutputType = {
    id: string
    goalId: string
    year: number
    month: number
    amount: number
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserMonthlyProgressCountAggregateOutputType | null
    _avg: UserMonthlyProgressAvgAggregateOutputType | null
    _sum: UserMonthlyProgressSumAggregateOutputType | null
    _min: UserMonthlyProgressMinAggregateOutputType | null
    _max: UserMonthlyProgressMaxAggregateOutputType | null
  }

  type GetUserMonthlyProgressGroupByPayload<T extends UserMonthlyProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserMonthlyProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserMonthlyProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserMonthlyProgressGroupByOutputType[P]>
            : GetScalarType<T[P], UserMonthlyProgressGroupByOutputType[P]>
        }
      >
    >


  export type UserMonthlyProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    goalId?: boolean
    year?: boolean
    month?: boolean
    amount?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    goal?: boolean | UserFinancialGoalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userMonthlyProgress"]>

  export type UserMonthlyProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    goalId?: boolean
    year?: boolean
    month?: boolean
    amount?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    goal?: boolean | UserFinancialGoalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userMonthlyProgress"]>

  export type UserMonthlyProgressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    goalId?: boolean
    year?: boolean
    month?: boolean
    amount?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    goal?: boolean | UserFinancialGoalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userMonthlyProgress"]>

  export type UserMonthlyProgressSelectScalar = {
    id?: boolean
    goalId?: boolean
    year?: boolean
    month?: boolean
    amount?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserMonthlyProgressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "goalId" | "year" | "month" | "amount" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["userMonthlyProgress"]>
  export type UserMonthlyProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    goal?: boolean | UserFinancialGoalDefaultArgs<ExtArgs>
  }
  export type UserMonthlyProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    goal?: boolean | UserFinancialGoalDefaultArgs<ExtArgs>
  }
  export type UserMonthlyProgressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    goal?: boolean | UserFinancialGoalDefaultArgs<ExtArgs>
  }

  export type $UserMonthlyProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserMonthlyProgress"
    objects: {
      goal: Prisma.$UserFinancialGoalPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      goalId: string
      year: number
      month: number
      amount: number
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userMonthlyProgress"]>
    composites: {}
  }

  type UserMonthlyProgressGetPayload<S extends boolean | null | undefined | UserMonthlyProgressDefaultArgs> = $Result.GetResult<Prisma.$UserMonthlyProgressPayload, S>

  type UserMonthlyProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserMonthlyProgressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserMonthlyProgressCountAggregateInputType | true
    }

  export interface UserMonthlyProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserMonthlyProgress'], meta: { name: 'UserMonthlyProgress' } }
    /**
     * Find zero or one UserMonthlyProgress that matches the filter.
     * @param {UserMonthlyProgressFindUniqueArgs} args - Arguments to find a UserMonthlyProgress
     * @example
     * // Get one UserMonthlyProgress
     * const userMonthlyProgress = await prisma.userMonthlyProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserMonthlyProgressFindUniqueArgs>(args: SelectSubset<T, UserMonthlyProgressFindUniqueArgs<ExtArgs>>): Prisma__UserMonthlyProgressClient<$Result.GetResult<Prisma.$UserMonthlyProgressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserMonthlyProgress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserMonthlyProgressFindUniqueOrThrowArgs} args - Arguments to find a UserMonthlyProgress
     * @example
     * // Get one UserMonthlyProgress
     * const userMonthlyProgress = await prisma.userMonthlyProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserMonthlyProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, UserMonthlyProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserMonthlyProgressClient<$Result.GetResult<Prisma.$UserMonthlyProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserMonthlyProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMonthlyProgressFindFirstArgs} args - Arguments to find a UserMonthlyProgress
     * @example
     * // Get one UserMonthlyProgress
     * const userMonthlyProgress = await prisma.userMonthlyProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserMonthlyProgressFindFirstArgs>(args?: SelectSubset<T, UserMonthlyProgressFindFirstArgs<ExtArgs>>): Prisma__UserMonthlyProgressClient<$Result.GetResult<Prisma.$UserMonthlyProgressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserMonthlyProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMonthlyProgressFindFirstOrThrowArgs} args - Arguments to find a UserMonthlyProgress
     * @example
     * // Get one UserMonthlyProgress
     * const userMonthlyProgress = await prisma.userMonthlyProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserMonthlyProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, UserMonthlyProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserMonthlyProgressClient<$Result.GetResult<Prisma.$UserMonthlyProgressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserMonthlyProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMonthlyProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserMonthlyProgresses
     * const userMonthlyProgresses = await prisma.userMonthlyProgress.findMany()
     * 
     * // Get first 10 UserMonthlyProgresses
     * const userMonthlyProgresses = await prisma.userMonthlyProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userMonthlyProgressWithIdOnly = await prisma.userMonthlyProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserMonthlyProgressFindManyArgs>(args?: SelectSubset<T, UserMonthlyProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserMonthlyProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserMonthlyProgress.
     * @param {UserMonthlyProgressCreateArgs} args - Arguments to create a UserMonthlyProgress.
     * @example
     * // Create one UserMonthlyProgress
     * const UserMonthlyProgress = await prisma.userMonthlyProgress.create({
     *   data: {
     *     // ... data to create a UserMonthlyProgress
     *   }
     * })
     * 
     */
    create<T extends UserMonthlyProgressCreateArgs>(args: SelectSubset<T, UserMonthlyProgressCreateArgs<ExtArgs>>): Prisma__UserMonthlyProgressClient<$Result.GetResult<Prisma.$UserMonthlyProgressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserMonthlyProgresses.
     * @param {UserMonthlyProgressCreateManyArgs} args - Arguments to create many UserMonthlyProgresses.
     * @example
     * // Create many UserMonthlyProgresses
     * const userMonthlyProgress = await prisma.userMonthlyProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserMonthlyProgressCreateManyArgs>(args?: SelectSubset<T, UserMonthlyProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserMonthlyProgresses and returns the data saved in the database.
     * @param {UserMonthlyProgressCreateManyAndReturnArgs} args - Arguments to create many UserMonthlyProgresses.
     * @example
     * // Create many UserMonthlyProgresses
     * const userMonthlyProgress = await prisma.userMonthlyProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserMonthlyProgresses and only return the `id`
     * const userMonthlyProgressWithIdOnly = await prisma.userMonthlyProgress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserMonthlyProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, UserMonthlyProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserMonthlyProgressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserMonthlyProgress.
     * @param {UserMonthlyProgressDeleteArgs} args - Arguments to delete one UserMonthlyProgress.
     * @example
     * // Delete one UserMonthlyProgress
     * const UserMonthlyProgress = await prisma.userMonthlyProgress.delete({
     *   where: {
     *     // ... filter to delete one UserMonthlyProgress
     *   }
     * })
     * 
     */
    delete<T extends UserMonthlyProgressDeleteArgs>(args: SelectSubset<T, UserMonthlyProgressDeleteArgs<ExtArgs>>): Prisma__UserMonthlyProgressClient<$Result.GetResult<Prisma.$UserMonthlyProgressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserMonthlyProgress.
     * @param {UserMonthlyProgressUpdateArgs} args - Arguments to update one UserMonthlyProgress.
     * @example
     * // Update one UserMonthlyProgress
     * const userMonthlyProgress = await prisma.userMonthlyProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserMonthlyProgressUpdateArgs>(args: SelectSubset<T, UserMonthlyProgressUpdateArgs<ExtArgs>>): Prisma__UserMonthlyProgressClient<$Result.GetResult<Prisma.$UserMonthlyProgressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserMonthlyProgresses.
     * @param {UserMonthlyProgressDeleteManyArgs} args - Arguments to filter UserMonthlyProgresses to delete.
     * @example
     * // Delete a few UserMonthlyProgresses
     * const { count } = await prisma.userMonthlyProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserMonthlyProgressDeleteManyArgs>(args?: SelectSubset<T, UserMonthlyProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserMonthlyProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMonthlyProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserMonthlyProgresses
     * const userMonthlyProgress = await prisma.userMonthlyProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserMonthlyProgressUpdateManyArgs>(args: SelectSubset<T, UserMonthlyProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserMonthlyProgresses and returns the data updated in the database.
     * @param {UserMonthlyProgressUpdateManyAndReturnArgs} args - Arguments to update many UserMonthlyProgresses.
     * @example
     * // Update many UserMonthlyProgresses
     * const userMonthlyProgress = await prisma.userMonthlyProgress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserMonthlyProgresses and only return the `id`
     * const userMonthlyProgressWithIdOnly = await prisma.userMonthlyProgress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserMonthlyProgressUpdateManyAndReturnArgs>(args: SelectSubset<T, UserMonthlyProgressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserMonthlyProgressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserMonthlyProgress.
     * @param {UserMonthlyProgressUpsertArgs} args - Arguments to update or create a UserMonthlyProgress.
     * @example
     * // Update or create a UserMonthlyProgress
     * const userMonthlyProgress = await prisma.userMonthlyProgress.upsert({
     *   create: {
     *     // ... data to create a UserMonthlyProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserMonthlyProgress we want to update
     *   }
     * })
     */
    upsert<T extends UserMonthlyProgressUpsertArgs>(args: SelectSubset<T, UserMonthlyProgressUpsertArgs<ExtArgs>>): Prisma__UserMonthlyProgressClient<$Result.GetResult<Prisma.$UserMonthlyProgressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserMonthlyProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMonthlyProgressCountArgs} args - Arguments to filter UserMonthlyProgresses to count.
     * @example
     * // Count the number of UserMonthlyProgresses
     * const count = await prisma.userMonthlyProgress.count({
     *   where: {
     *     // ... the filter for the UserMonthlyProgresses we want to count
     *   }
     * })
    **/
    count<T extends UserMonthlyProgressCountArgs>(
      args?: Subset<T, UserMonthlyProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserMonthlyProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserMonthlyProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMonthlyProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserMonthlyProgressAggregateArgs>(args: Subset<T, UserMonthlyProgressAggregateArgs>): Prisma.PrismaPromise<GetUserMonthlyProgressAggregateType<T>>

    /**
     * Group by UserMonthlyProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMonthlyProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserMonthlyProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserMonthlyProgressGroupByArgs['orderBy'] }
        : { orderBy?: UserMonthlyProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserMonthlyProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserMonthlyProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserMonthlyProgress model
   */
  readonly fields: UserMonthlyProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserMonthlyProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserMonthlyProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    goal<T extends UserFinancialGoalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserFinancialGoalDefaultArgs<ExtArgs>>): Prisma__UserFinancialGoalClient<$Result.GetResult<Prisma.$UserFinancialGoalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserMonthlyProgress model
   */
  interface UserMonthlyProgressFieldRefs {
    readonly id: FieldRef<"UserMonthlyProgress", 'String'>
    readonly goalId: FieldRef<"UserMonthlyProgress", 'String'>
    readonly year: FieldRef<"UserMonthlyProgress", 'Int'>
    readonly month: FieldRef<"UserMonthlyProgress", 'Int'>
    readonly amount: FieldRef<"UserMonthlyProgress", 'Float'>
    readonly notes: FieldRef<"UserMonthlyProgress", 'String'>
    readonly createdAt: FieldRef<"UserMonthlyProgress", 'DateTime'>
    readonly updatedAt: FieldRef<"UserMonthlyProgress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserMonthlyProgress findUnique
   */
  export type UserMonthlyProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMonthlyProgress
     */
    select?: UserMonthlyProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMonthlyProgress
     */
    omit?: UserMonthlyProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMonthlyProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserMonthlyProgress to fetch.
     */
    where: UserMonthlyProgressWhereUniqueInput
  }

  /**
   * UserMonthlyProgress findUniqueOrThrow
   */
  export type UserMonthlyProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMonthlyProgress
     */
    select?: UserMonthlyProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMonthlyProgress
     */
    omit?: UserMonthlyProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMonthlyProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserMonthlyProgress to fetch.
     */
    where: UserMonthlyProgressWhereUniqueInput
  }

  /**
   * UserMonthlyProgress findFirst
   */
  export type UserMonthlyProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMonthlyProgress
     */
    select?: UserMonthlyProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMonthlyProgress
     */
    omit?: UserMonthlyProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMonthlyProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserMonthlyProgress to fetch.
     */
    where?: UserMonthlyProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserMonthlyProgresses to fetch.
     */
    orderBy?: UserMonthlyProgressOrderByWithRelationInput | UserMonthlyProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserMonthlyProgresses.
     */
    cursor?: UserMonthlyProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserMonthlyProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserMonthlyProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserMonthlyProgresses.
     */
    distinct?: UserMonthlyProgressScalarFieldEnum | UserMonthlyProgressScalarFieldEnum[]
  }

  /**
   * UserMonthlyProgress findFirstOrThrow
   */
  export type UserMonthlyProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMonthlyProgress
     */
    select?: UserMonthlyProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMonthlyProgress
     */
    omit?: UserMonthlyProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMonthlyProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserMonthlyProgress to fetch.
     */
    where?: UserMonthlyProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserMonthlyProgresses to fetch.
     */
    orderBy?: UserMonthlyProgressOrderByWithRelationInput | UserMonthlyProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserMonthlyProgresses.
     */
    cursor?: UserMonthlyProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserMonthlyProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserMonthlyProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserMonthlyProgresses.
     */
    distinct?: UserMonthlyProgressScalarFieldEnum | UserMonthlyProgressScalarFieldEnum[]
  }

  /**
   * UserMonthlyProgress findMany
   */
  export type UserMonthlyProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMonthlyProgress
     */
    select?: UserMonthlyProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMonthlyProgress
     */
    omit?: UserMonthlyProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMonthlyProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserMonthlyProgresses to fetch.
     */
    where?: UserMonthlyProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserMonthlyProgresses to fetch.
     */
    orderBy?: UserMonthlyProgressOrderByWithRelationInput | UserMonthlyProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserMonthlyProgresses.
     */
    cursor?: UserMonthlyProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserMonthlyProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserMonthlyProgresses.
     */
    skip?: number
    distinct?: UserMonthlyProgressScalarFieldEnum | UserMonthlyProgressScalarFieldEnum[]
  }

  /**
   * UserMonthlyProgress create
   */
  export type UserMonthlyProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMonthlyProgress
     */
    select?: UserMonthlyProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMonthlyProgress
     */
    omit?: UserMonthlyProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMonthlyProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a UserMonthlyProgress.
     */
    data: XOR<UserMonthlyProgressCreateInput, UserMonthlyProgressUncheckedCreateInput>
  }

  /**
   * UserMonthlyProgress createMany
   */
  export type UserMonthlyProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserMonthlyProgresses.
     */
    data: UserMonthlyProgressCreateManyInput | UserMonthlyProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserMonthlyProgress createManyAndReturn
   */
  export type UserMonthlyProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMonthlyProgress
     */
    select?: UserMonthlyProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserMonthlyProgress
     */
    omit?: UserMonthlyProgressOmit<ExtArgs> | null
    /**
     * The data used to create many UserMonthlyProgresses.
     */
    data: UserMonthlyProgressCreateManyInput | UserMonthlyProgressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMonthlyProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserMonthlyProgress update
   */
  export type UserMonthlyProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMonthlyProgress
     */
    select?: UserMonthlyProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMonthlyProgress
     */
    omit?: UserMonthlyProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMonthlyProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a UserMonthlyProgress.
     */
    data: XOR<UserMonthlyProgressUpdateInput, UserMonthlyProgressUncheckedUpdateInput>
    /**
     * Choose, which UserMonthlyProgress to update.
     */
    where: UserMonthlyProgressWhereUniqueInput
  }

  /**
   * UserMonthlyProgress updateMany
   */
  export type UserMonthlyProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserMonthlyProgresses.
     */
    data: XOR<UserMonthlyProgressUpdateManyMutationInput, UserMonthlyProgressUncheckedUpdateManyInput>
    /**
     * Filter which UserMonthlyProgresses to update
     */
    where?: UserMonthlyProgressWhereInput
    /**
     * Limit how many UserMonthlyProgresses to update.
     */
    limit?: number
  }

  /**
   * UserMonthlyProgress updateManyAndReturn
   */
  export type UserMonthlyProgressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMonthlyProgress
     */
    select?: UserMonthlyProgressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserMonthlyProgress
     */
    omit?: UserMonthlyProgressOmit<ExtArgs> | null
    /**
     * The data used to update UserMonthlyProgresses.
     */
    data: XOR<UserMonthlyProgressUpdateManyMutationInput, UserMonthlyProgressUncheckedUpdateManyInput>
    /**
     * Filter which UserMonthlyProgresses to update
     */
    where?: UserMonthlyProgressWhereInput
    /**
     * Limit how many UserMonthlyProgresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMonthlyProgressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserMonthlyProgress upsert
   */
  export type UserMonthlyProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMonthlyProgress
     */
    select?: UserMonthlyProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMonthlyProgress
     */
    omit?: UserMonthlyProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMonthlyProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the UserMonthlyProgress to update in case it exists.
     */
    where: UserMonthlyProgressWhereUniqueInput
    /**
     * In case the UserMonthlyProgress found by the `where` argument doesn't exist, create a new UserMonthlyProgress with this data.
     */
    create: XOR<UserMonthlyProgressCreateInput, UserMonthlyProgressUncheckedCreateInput>
    /**
     * In case the UserMonthlyProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserMonthlyProgressUpdateInput, UserMonthlyProgressUncheckedUpdateInput>
  }

  /**
   * UserMonthlyProgress delete
   */
  export type UserMonthlyProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMonthlyProgress
     */
    select?: UserMonthlyProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMonthlyProgress
     */
    omit?: UserMonthlyProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMonthlyProgressInclude<ExtArgs> | null
    /**
     * Filter which UserMonthlyProgress to delete.
     */
    where: UserMonthlyProgressWhereUniqueInput
  }

  /**
   * UserMonthlyProgress deleteMany
   */
  export type UserMonthlyProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserMonthlyProgresses to delete
     */
    where?: UserMonthlyProgressWhereInput
    /**
     * Limit how many UserMonthlyProgresses to delete.
     */
    limit?: number
  }

  /**
   * UserMonthlyProgress without action
   */
  export type UserMonthlyProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMonthlyProgress
     */
    select?: UserMonthlyProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMonthlyProgress
     */
    omit?: UserMonthlyProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMonthlyProgressInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    avatarUrl: 'avatarUrl',
    password: 'password',
    phone: 'phone',
    publicKey: 'publicKey',
    encryptedPrivateKey: 'encryptedPrivateKey',
    otpCode: 'otpCode',
    otpExpiry: 'otpExpiry',
    isVerified: 'isVerified',
    deviceId: 'deviceId',
    deviceInfo: 'deviceInfo',
    location: 'location',
    allowedCountry: 'allowedCountry',
    isBanned: 'isBanned',
    isFirstLogin: 'isFirstLogin',
    currentLocation: 'currentLocation',
    lastSeen: 'lastSeen',
    isOnline: 'isOnline',
    role: 'role',
    canPublishNotifications: 'canPublishNotifications',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserInvitationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    status: 'status',
    title: 'title',
    description: 'description',
    imageBase64: 'imageBase64',
    type: 'type',
    date: 'date',
    location: 'location',
    maxGuests: 'maxGuests',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserInvitationScalarFieldEnum = (typeof UserInvitationScalarFieldEnum)[keyof typeof UserInvitationScalarFieldEnum]


  export const InvitationGuestScalarFieldEnum: {
    id: 'id',
    invitationId: 'invitationId',
    name: 'name',
    phone: 'phone',
    confirmedAt: 'confirmedAt'
  };

  export type InvitationGuestScalarFieldEnum = (typeof InvitationGuestScalarFieldEnum)[keyof typeof InvitationGuestScalarFieldEnum]


  export const FollowScalarFieldEnum: {
    id: 'id',
    followerId: 'followerId',
    followingId: 'followingId',
    createdAt: 'createdAt'
  };

  export type FollowScalarFieldEnum = (typeof FollowScalarFieldEnum)[keyof typeof FollowScalarFieldEnum]


  export const OrganizationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    logo: 'logo',
    address: 'address',
    isSuspended: 'isSuspended',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    ownerId: 'ownerId'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export const OrganizationMemberScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    orgId: 'orgId',
    role: 'role',
    joinedAt: 'joinedAt'
  };

  export type OrganizationMemberScalarFieldEnum = (typeof OrganizationMemberScalarFieldEnum)[keyof typeof OrganizationMemberScalarFieldEnum]


  export const DepartmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    orgId: 'orgId',
    publicKey: 'publicKey',
    headId: 'headId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const DepartmentDocumentScalarFieldEnum: {
    id: 'id',
    deptId: 'deptId',
    filename: 'filename',
    type: 'type',
    data: 'data',
    uploadedBy: 'uploadedBy',
    createdAt: 'createdAt'
  };

  export type DepartmentDocumentScalarFieldEnum = (typeof DepartmentDocumentScalarFieldEnum)[keyof typeof DepartmentDocumentScalarFieldEnum]


  export const DepartmentGoalScalarFieldEnum: {
    id: 'id',
    deptId: 'deptId',
    title: 'title',
    description: 'description',
    targetValue: 'targetValue',
    currentValue: 'currentValue',
    period: 'period',
    periodKey: 'periodKey',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepartmentGoalScalarFieldEnum = (typeof DepartmentGoalScalarFieldEnum)[keyof typeof DepartmentGoalScalarFieldEnum]


  export const DepartmentMeetingScalarFieldEnum: {
    id: 'id',
    deptId: 'deptId',
    title: 'title',
    description: 'description',
    agenda: 'agenda',
    meetingDate: 'meetingDate',
    location: 'location',
    createdBy: 'createdBy',
    minutes: 'minutes',
    minutesAt: 'minutesAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepartmentMeetingScalarFieldEnum = (typeof DepartmentMeetingScalarFieldEnum)[keyof typeof DepartmentMeetingScalarFieldEnum]


  export const DepartmentPollScalarFieldEnum: {
    id: 'id',
    deptId: 'deptId',
    question: 'question',
    options: 'options',
    endDate: 'endDate',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepartmentPollScalarFieldEnum = (typeof DepartmentPollScalarFieldEnum)[keyof typeof DepartmentPollScalarFieldEnum]


  export const PollVoteScalarFieldEnum: {
    id: 'id',
    pollId: 'pollId',
    userId: 'userId',
    optionIndex: 'optionIndex',
    createdAt: 'createdAt'
  };

  export type PollVoteScalarFieldEnum = (typeof PollVoteScalarFieldEnum)[keyof typeof PollVoteScalarFieldEnum]


  export const TeamDecisionScalarFieldEnum: {
    id: 'id',
    deptId: 'deptId',
    title: 'title',
    description: 'description',
    voteDeadline: 'voteDeadline',
    status: 'status',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeamDecisionScalarFieldEnum = (typeof TeamDecisionScalarFieldEnum)[keyof typeof TeamDecisionScalarFieldEnum]


  export const DecisionVoteScalarFieldEnum: {
    id: 'id',
    decisionId: 'decisionId',
    userId: 'userId',
    vote: 'vote',
    createdAt: 'createdAt'
  };

  export type DecisionVoteScalarFieldEnum = (typeof DecisionVoteScalarFieldEnum)[keyof typeof DecisionVoteScalarFieldEnum]


  export const DepartmentMemberScalarFieldEnum: {
    id: 'id',
    deptId: 'deptId',
    userId: 'userId',
    encryptedDeptKey: 'encryptedDeptKey'
  };

  export type DepartmentMemberScalarFieldEnum = (typeof DepartmentMemberScalarFieldEnum)[keyof typeof DepartmentMemberScalarFieldEnum]


  export const GroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    isDirect: 'isDirect',
    deptId: 'deptId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GroupScalarFieldEnum = (typeof GroupScalarFieldEnum)[keyof typeof GroupScalarFieldEnum]


  export const GroupDocumentScalarFieldEnum: {
    id: 'id',
    groupId: 'groupId',
    title: 'title',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GroupDocumentScalarFieldEnum = (typeof GroupDocumentScalarFieldEnum)[keyof typeof GroupDocumentScalarFieldEnum]


  export const GroupNoteScalarFieldEnum: {
    id: 'id',
    documentId: 'documentId',
    title: 'title',
    content: 'content',
    textSize: 'textSize',
    order: 'order',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GroupNoteScalarFieldEnum = (typeof GroupNoteScalarFieldEnum)[keyof typeof GroupNoteScalarFieldEnum]


  export const GroupMemberScalarFieldEnum: {
    id: 'id',
    groupId: 'groupId',
    userId: 'userId',
    joinedAt: 'joinedAt',
    lastReadAt: 'lastReadAt'
  };

  export type GroupMemberScalarFieldEnum = (typeof GroupMemberScalarFieldEnum)[keyof typeof GroupMemberScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    content: 'content',
    senderId: 'senderId',
    groupId: 'groupId',
    isEdited: 'isEdited',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const AttachmentScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    type: 'type',
    filename: 'filename',
    data: 'data',
    createdAt: 'createdAt'
  };

  export type AttachmentScalarFieldEnum = (typeof AttachmentScalarFieldEnum)[keyof typeof AttachmentScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    content: 'content',
    userId: 'userId',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    isRead: 'isRead'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const AnnouncementScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    publisherId: 'publisherId',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    isActive: 'isActive'
  };

  export type AnnouncementScalarFieldEnum = (typeof AnnouncementScalarFieldEnum)[keyof typeof AnnouncementScalarFieldEnum]


  export const AnnouncementReadScalarFieldEnum: {
    id: 'id',
    announcementId: 'announcementId',
    userId: 'userId',
    readAt: 'readAt'
  };

  export type AnnouncementReadScalarFieldEnum = (typeof AnnouncementReadScalarFieldEnum)[keyof typeof AnnouncementReadScalarFieldEnum]


  export const OrganizationRequestScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    cardCode: 'cardCode',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    reviewedBy: 'reviewedBy',
    reviewedAt: 'reviewedAt',
    orgId: 'orgId'
  };

  export type OrganizationRequestScalarFieldEnum = (typeof OrganizationRequestScalarFieldEnum)[keyof typeof OrganizationRequestScalarFieldEnum]


  export const PendingSubscriptionPaymentScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    userId: 'userId',
    plan: 'plan',
    name: 'name',
    logo: 'logo',
    address: 'address',
    requestId: 'requestId',
    orgId: 'orgId',
    type: 'type',
    createdAt: 'createdAt'
  };

  export type PendingSubscriptionPaymentScalarFieldEnum = (typeof PendingSubscriptionPaymentScalarFieldEnum)[keyof typeof PendingSubscriptionPaymentScalarFieldEnum]


  export const PaymentOrderScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    plan: 'plan',
    name: 'name',
    logo: 'logo',
    address: 'address',
    requestId: 'requestId',
    orgId: 'orgId',
    type: 'type',
    amountFcfa: 'amountFcfa',
    status: 'status',
    approvedBy: 'approvedBy',
    approvedAt: 'approvedAt',
    rejectedAt: 'rejectedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentOrderScalarFieldEnum = (typeof PaymentOrderScalarFieldEnum)[keyof typeof PaymentOrderScalarFieldEnum]


  export const PaymentSettingScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value'
  };

  export type PaymentSettingScalarFieldEnum = (typeof PaymentSettingScalarFieldEnum)[keyof typeof PaymentSettingScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    plan: 'plan',
    startDate: 'startDate',
    endDate: 'endDate',
    maxDepartments: 'maxDepartments',
    maxMembersPerDept: 'maxMembersPerDept',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const EventInvitationScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    title: 'title',
    description: 'description',
    eventType: 'eventType',
    eventDate: 'eventDate',
    maxAttendees: 'maxAttendees',
    imageUrl: 'imageUrl',
    token: 'token',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EventInvitationScalarFieldEnum = (typeof EventInvitationScalarFieldEnum)[keyof typeof EventInvitationScalarFieldEnum]


  export const EventDepartmentBroadcastScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    deptId: 'deptId',
    createdAt: 'createdAt'
  };

  export type EventDepartmentBroadcastScalarFieldEnum = (typeof EventDepartmentBroadcastScalarFieldEnum)[keyof typeof EventDepartmentBroadcastScalarFieldEnum]


  export const InvitationRSVPScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    name: 'name',
    phone: 'phone',
    createdAt: 'createdAt'
  };

  export type InvitationRSVPScalarFieldEnum = (typeof InvitationRSVPScalarFieldEnum)[keyof typeof InvitationRSVPScalarFieldEnum]


  export const UserPageScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    handle: 'handle',
    bio: 'bio',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserPageScalarFieldEnum = (typeof UserPageScalarFieldEnum)[keyof typeof UserPageScalarFieldEnum]


  export const PostScalarFieldEnum: {
    id: 'id',
    pageId: 'pageId',
    type: 'type',
    content: 'content',
    imageUrl: 'imageUrl',
    caption: 'caption',
    reference: 'reference',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const LikeScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type LikeScalarFieldEnum = (typeof LikeScalarFieldEnum)[keyof typeof LikeScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    userId: 'userId',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    parentId: 'parentId'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const PostReadScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    postId: 'postId',
    readAt: 'readAt'
  };

  export type PostReadScalarFieldEnum = (typeof PostReadScalarFieldEnum)[keyof typeof PostReadScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    status: 'status',
    priority: 'priority',
    startDate: 'startDate',
    dueDate: 'dueDate',
    completedAt: 'completedAt',
    deptId: 'deptId',
    creatorId: 'creatorId',
    assigneeId: 'assigneeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const TaskMessageScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    senderId: 'senderId',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TaskMessageScalarFieldEnum = (typeof TaskMessageScalarFieldEnum)[keyof typeof TaskMessageScalarFieldEnum]


  export const TaskAttachmentScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    messageId: 'messageId',
    uploaderId: 'uploaderId',
    filename: 'filename',
    url: 'url',
    fileType: 'fileType',
    size: 'size',
    createdAt: 'createdAt'
  };

  export type TaskAttachmentScalarFieldEnum = (typeof TaskAttachmentScalarFieldEnum)[keyof typeof TaskAttachmentScalarFieldEnum]


  export const DepartmentMonthlyReportScalarFieldEnum: {
    id: 'id',
    deptId: 'deptId',
    userId: 'userId',
    month: 'month',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepartmentMonthlyReportScalarFieldEnum = (typeof DepartmentMonthlyReportScalarFieldEnum)[keyof typeof DepartmentMonthlyReportScalarFieldEnum]


  export const PushSubscriptionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    endpoint: 'endpoint',
    p256dh: 'p256dh',
    auth: 'auth',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PushSubscriptionScalarFieldEnum = (typeof PushSubscriptionScalarFieldEnum)[keyof typeof PushSubscriptionScalarFieldEnum]


  export const UserPersonalTaskScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    description: 'description',
    status: 'status',
    priority: 'priority',
    dueDate: 'dueDate',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserPersonalTaskScalarFieldEnum = (typeof UserPersonalTaskScalarFieldEnum)[keyof typeof UserPersonalTaskScalarFieldEnum]


  export const UserFinancialGoalScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    year: 'year',
    targetItem: 'targetItem',
    targetAmount: 'targetAmount',
    targetDate: 'targetDate',
    label: 'label',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserFinancialGoalScalarFieldEnum = (typeof UserFinancialGoalScalarFieldEnum)[keyof typeof UserFinancialGoalScalarFieldEnum]


  export const UserFinancialProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    monthlySalary: 'monthlySalary',
    supplementaryIncome: 'supplementaryIncome',
    currency: 'currency',
    preferredSavingsRate: 'preferredSavingsRate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserFinancialProfileScalarFieldEnum = (typeof UserFinancialProfileScalarFieldEnum)[keyof typeof UserFinancialProfileScalarFieldEnum]


  export const UserMonthlyStatementScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    year: 'year',
    month: 'month',
    salaryReceived: 'salaryReceived',
    supplementaryIncome: 'supplementaryIncome',
    totalExpenses: 'totalExpenses',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserMonthlyStatementScalarFieldEnum = (typeof UserMonthlyStatementScalarFieldEnum)[keyof typeof UserMonthlyStatementScalarFieldEnum]


  export const UserFinancialEntryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    year: 'year',
    month: 'month',
    type: 'type',
    amount: 'amount',
    note: 'note',
    isConfirmed: 'isConfirmed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserFinancialEntryScalarFieldEnum = (typeof UserFinancialEntryScalarFieldEnum)[keyof typeof UserFinancialEntryScalarFieldEnum]


  export const UserMonthlyProgressScalarFieldEnum: {
    id: 'id',
    goalId: 'goalId',
    year: 'year',
    month: 'month',
    amount: 'amount',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserMonthlyProgressScalarFieldEnum = (typeof UserMonthlyProgressScalarFieldEnum)[keyof typeof UserMonthlyProgressScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'InvitationStatus'
   */
  export type EnumInvitationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvitationStatus'>
    


  /**
   * Reference to a field of type 'InvitationStatus[]'
   */
  export type ListEnumInvitationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvitationStatus[]'>
    


  /**
   * Reference to a field of type 'InvitationType'
   */
  export type EnumInvitationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvitationType'>
    


  /**
   * Reference to a field of type 'InvitationType[]'
   */
  export type ListEnumInvitationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvitationType[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'OrgRole'
   */
  export type EnumOrgRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrgRole'>
    


  /**
   * Reference to a field of type 'OrgRole[]'
   */
  export type ListEnumOrgRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrgRole[]'>
    


  /**
   * Reference to a field of type 'FileType'
   */
  export type EnumFileTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FileType'>
    


  /**
   * Reference to a field of type 'FileType[]'
   */
  export type ListEnumFileTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FileType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'DecisionVoteType'
   */
  export type EnumDecisionVoteTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DecisionVoteType'>
    


  /**
   * Reference to a field of type 'DecisionVoteType[]'
   */
  export type ListEnumDecisionVoteTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DecisionVoteType[]'>
    


  /**
   * Reference to a field of type 'NoteTextSize'
   */
  export type EnumNoteTextSizeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NoteTextSize'>
    


  /**
   * Reference to a field of type 'NoteTextSize[]'
   */
  export type ListEnumNoteTextSizeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NoteTextSize[]'>
    


  /**
   * Reference to a field of type 'RequestStatus'
   */
  export type EnumRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequestStatus'>
    


  /**
   * Reference to a field of type 'RequestStatus[]'
   */
  export type ListEnumRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequestStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentOrderStatus'
   */
  export type EnumPaymentOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentOrderStatus'>
    


  /**
   * Reference to a field of type 'PaymentOrderStatus[]'
   */
  export type ListEnumPaymentOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentOrderStatus[]'>
    


  /**
   * Reference to a field of type 'SubscriptionPlan'
   */
  export type EnumSubscriptionPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionPlan'>
    


  /**
   * Reference to a field of type 'SubscriptionPlan[]'
   */
  export type ListEnumSubscriptionPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionPlan[]'>
    


  /**
   * Reference to a field of type 'EventType'
   */
  export type EnumEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventType'>
    


  /**
   * Reference to a field of type 'EventType[]'
   */
  export type ListEnumEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventType[]'>
    


  /**
   * Reference to a field of type 'PostType'
   */
  export type EnumPostTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostType'>
    


  /**
   * Reference to a field of type 'PostType[]'
   */
  export type ListEnumPostTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostType[]'>
    


  /**
   * Reference to a field of type 'TaskStatus'
   */
  export type EnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus'>
    


  /**
   * Reference to a field of type 'TaskStatus[]'
   */
  export type ListEnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus[]'>
    


  /**
   * Reference to a field of type 'TaskPriority'
   */
  export type EnumTaskPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskPriority'>
    


  /**
   * Reference to a field of type 'TaskPriority[]'
   */
  export type ListEnumTaskPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskPriority[]'>
    


  /**
   * Reference to a field of type 'PersonalTaskStatus'
   */
  export type EnumPersonalTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PersonalTaskStatus'>
    


  /**
   * Reference to a field of type 'PersonalTaskStatus[]'
   */
  export type ListEnumPersonalTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PersonalTaskStatus[]'>
    


  /**
   * Reference to a field of type 'PersonalTaskPriority'
   */
  export type EnumPersonalTaskPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PersonalTaskPriority'>
    


  /**
   * Reference to a field of type 'PersonalTaskPriority[]'
   */
  export type ListEnumPersonalTaskPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PersonalTaskPriority[]'>
    


  /**
   * Reference to a field of type 'FinancialGoalType'
   */
  export type EnumFinancialGoalTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FinancialGoalType'>
    


  /**
   * Reference to a field of type 'FinancialGoalType[]'
   */
  export type ListEnumFinancialGoalTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FinancialGoalType[]'>
    


  /**
   * Reference to a field of type 'FinancialEntryType'
   */
  export type EnumFinancialEntryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FinancialEntryType'>
    


  /**
   * Reference to a field of type 'FinancialEntryType[]'
   */
  export type ListEnumFinancialEntryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FinancialEntryType[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    publicKey?: StringFilter<"User"> | string
    encryptedPrivateKey?: StringFilter<"User"> | string
    otpCode?: StringNullableFilter<"User"> | string | null
    otpExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    isVerified?: BoolFilter<"User"> | boolean
    deviceId?: StringNullableFilter<"User"> | string | null
    deviceInfo?: JsonNullableFilter<"User">
    location?: JsonNullableFilter<"User">
    allowedCountry?: StringNullableFilter<"User"> | string | null
    isBanned?: BoolFilter<"User"> | boolean
    isFirstLogin?: BoolFilter<"User"> | boolean
    currentLocation?: JsonNullableFilter<"User">
    lastSeen?: DateTimeNullableFilter<"User"> | Date | string | null
    isOnline?: BoolFilter<"User"> | boolean
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    canPublishNotifications?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    publishedAnnouncements?: AnnouncementListRelationFilter
    deptMemberships?: DepartmentMemberListRelationFilter
    groupMemberships?: GroupMemberListRelationFilter
    sentMessages?: MessageListRelationFilter
    notifications?: NotificationListRelationFilter
    orgMemberships?: OrganizationMemberListRelationFilter
    userPage?: XOR<UserPageNullableScalarRelationFilter, UserPageWhereInput> | null
    likes?: LikeListRelationFilter
    comments?: CommentListRelationFilter
    postReads?: PostReadListRelationFilter
    assignedTasks?: TaskListRelationFilter
    createdTasks?: TaskListRelationFilter
    headedDepartments?: DepartmentListRelationFilter
    taskMessages?: TaskMessageListRelationFilter
    departmentMonthlyReports?: DepartmentMonthlyReportListRelationFilter
    createdMeetings?: DepartmentMeetingListRelationFilter
    createdPolls?: DepartmentPollListRelationFilter
    createdDecisions?: TeamDecisionListRelationFilter
    pollVotes?: PollVoteListRelationFilter
    decisionVotes?: DecisionVoteListRelationFilter
    pushSubscriptions?: PushSubscriptionListRelationFilter
    invitations?: UserInvitationListRelationFilter
    personalTasks?: UserPersonalTaskListRelationFilter
    financialGoals?: UserFinancialGoalListRelationFilter
    financialProfile?: XOR<UserFinancialProfileNullableScalarRelationFilter, UserFinancialProfileWhereInput> | null
    monthlyStatements?: UserMonthlyStatementListRelationFilter
    financialEntries?: UserFinancialEntryListRelationFilter
    followers?: FollowListRelationFilter
    following?: FollowListRelationFilter
    uploadedDepartmentDocuments?: DepartmentDocumentListRelationFilter
    groupNotes?: GroupNoteListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    password?: SortOrder
    phone?: SortOrderInput | SortOrder
    publicKey?: SortOrder
    encryptedPrivateKey?: SortOrder
    otpCode?: SortOrderInput | SortOrder
    otpExpiry?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    deviceId?: SortOrderInput | SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    allowedCountry?: SortOrderInput | SortOrder
    isBanned?: SortOrder
    isFirstLogin?: SortOrder
    currentLocation?: SortOrderInput | SortOrder
    lastSeen?: SortOrderInput | SortOrder
    isOnline?: SortOrder
    role?: SortOrder
    canPublishNotifications?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAnnouncements?: AnnouncementOrderByRelationAggregateInput
    deptMemberships?: DepartmentMemberOrderByRelationAggregateInput
    groupMemberships?: GroupMemberOrderByRelationAggregateInput
    sentMessages?: MessageOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    orgMemberships?: OrganizationMemberOrderByRelationAggregateInput
    userPage?: UserPageOrderByWithRelationInput
    likes?: LikeOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    postReads?: PostReadOrderByRelationAggregateInput
    assignedTasks?: TaskOrderByRelationAggregateInput
    createdTasks?: TaskOrderByRelationAggregateInput
    headedDepartments?: DepartmentOrderByRelationAggregateInput
    taskMessages?: TaskMessageOrderByRelationAggregateInput
    departmentMonthlyReports?: DepartmentMonthlyReportOrderByRelationAggregateInput
    createdMeetings?: DepartmentMeetingOrderByRelationAggregateInput
    createdPolls?: DepartmentPollOrderByRelationAggregateInput
    createdDecisions?: TeamDecisionOrderByRelationAggregateInput
    pollVotes?: PollVoteOrderByRelationAggregateInput
    decisionVotes?: DecisionVoteOrderByRelationAggregateInput
    pushSubscriptions?: PushSubscriptionOrderByRelationAggregateInput
    invitations?: UserInvitationOrderByRelationAggregateInput
    personalTasks?: UserPersonalTaskOrderByRelationAggregateInput
    financialGoals?: UserFinancialGoalOrderByRelationAggregateInput
    financialProfile?: UserFinancialProfileOrderByWithRelationInput
    monthlyStatements?: UserMonthlyStatementOrderByRelationAggregateInput
    financialEntries?: UserFinancialEntryOrderByRelationAggregateInput
    followers?: FollowOrderByRelationAggregateInput
    following?: FollowOrderByRelationAggregateInput
    uploadedDepartmentDocuments?: DepartmentDocumentOrderByRelationAggregateInput
    groupNotes?: GroupNoteOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    publicKey?: StringFilter<"User"> | string
    encryptedPrivateKey?: StringFilter<"User"> | string
    otpCode?: StringNullableFilter<"User"> | string | null
    otpExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    isVerified?: BoolFilter<"User"> | boolean
    deviceId?: StringNullableFilter<"User"> | string | null
    deviceInfo?: JsonNullableFilter<"User">
    location?: JsonNullableFilter<"User">
    allowedCountry?: StringNullableFilter<"User"> | string | null
    isBanned?: BoolFilter<"User"> | boolean
    isFirstLogin?: BoolFilter<"User"> | boolean
    currentLocation?: JsonNullableFilter<"User">
    lastSeen?: DateTimeNullableFilter<"User"> | Date | string | null
    isOnline?: BoolFilter<"User"> | boolean
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    canPublishNotifications?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    publishedAnnouncements?: AnnouncementListRelationFilter
    deptMemberships?: DepartmentMemberListRelationFilter
    groupMemberships?: GroupMemberListRelationFilter
    sentMessages?: MessageListRelationFilter
    notifications?: NotificationListRelationFilter
    orgMemberships?: OrganizationMemberListRelationFilter
    userPage?: XOR<UserPageNullableScalarRelationFilter, UserPageWhereInput> | null
    likes?: LikeListRelationFilter
    comments?: CommentListRelationFilter
    postReads?: PostReadListRelationFilter
    assignedTasks?: TaskListRelationFilter
    createdTasks?: TaskListRelationFilter
    headedDepartments?: DepartmentListRelationFilter
    taskMessages?: TaskMessageListRelationFilter
    departmentMonthlyReports?: DepartmentMonthlyReportListRelationFilter
    createdMeetings?: DepartmentMeetingListRelationFilter
    createdPolls?: DepartmentPollListRelationFilter
    createdDecisions?: TeamDecisionListRelationFilter
    pollVotes?: PollVoteListRelationFilter
    decisionVotes?: DecisionVoteListRelationFilter
    pushSubscriptions?: PushSubscriptionListRelationFilter
    invitations?: UserInvitationListRelationFilter
    personalTasks?: UserPersonalTaskListRelationFilter
    financialGoals?: UserFinancialGoalListRelationFilter
    financialProfile?: XOR<UserFinancialProfileNullableScalarRelationFilter, UserFinancialProfileWhereInput> | null
    monthlyStatements?: UserMonthlyStatementListRelationFilter
    financialEntries?: UserFinancialEntryListRelationFilter
    followers?: FollowListRelationFilter
    following?: FollowListRelationFilter
    uploadedDepartmentDocuments?: DepartmentDocumentListRelationFilter
    groupNotes?: GroupNoteListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    password?: SortOrder
    phone?: SortOrderInput | SortOrder
    publicKey?: SortOrder
    encryptedPrivateKey?: SortOrder
    otpCode?: SortOrderInput | SortOrder
    otpExpiry?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    deviceId?: SortOrderInput | SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    allowedCountry?: SortOrderInput | SortOrder
    isBanned?: SortOrder
    isFirstLogin?: SortOrder
    currentLocation?: SortOrderInput | SortOrder
    lastSeen?: SortOrderInput | SortOrder
    isOnline?: SortOrder
    role?: SortOrder
    canPublishNotifications?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    publicKey?: StringWithAggregatesFilter<"User"> | string
    encryptedPrivateKey?: StringWithAggregatesFilter<"User"> | string
    otpCode?: StringNullableWithAggregatesFilter<"User"> | string | null
    otpExpiry?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    isVerified?: BoolWithAggregatesFilter<"User"> | boolean
    deviceId?: StringNullableWithAggregatesFilter<"User"> | string | null
    deviceInfo?: JsonNullableWithAggregatesFilter<"User">
    location?: JsonNullableWithAggregatesFilter<"User">
    allowedCountry?: StringNullableWithAggregatesFilter<"User"> | string | null
    isBanned?: BoolWithAggregatesFilter<"User"> | boolean
    isFirstLogin?: BoolWithAggregatesFilter<"User"> | boolean
    currentLocation?: JsonNullableWithAggregatesFilter<"User">
    lastSeen?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    isOnline?: BoolWithAggregatesFilter<"User"> | boolean
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    canPublishNotifications?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type UserInvitationWhereInput = {
    AND?: UserInvitationWhereInput | UserInvitationWhereInput[]
    OR?: UserInvitationWhereInput[]
    NOT?: UserInvitationWhereInput | UserInvitationWhereInput[]
    id?: StringFilter<"UserInvitation"> | string
    userId?: StringFilter<"UserInvitation"> | string
    token?: StringFilter<"UserInvitation"> | string
    status?: EnumInvitationStatusFilter<"UserInvitation"> | $Enums.InvitationStatus
    title?: StringFilter<"UserInvitation"> | string
    description?: StringNullableFilter<"UserInvitation"> | string | null
    imageBase64?: StringNullableFilter<"UserInvitation"> | string | null
    type?: EnumInvitationTypeFilter<"UserInvitation"> | $Enums.InvitationType
    date?: DateTimeFilter<"UserInvitation"> | Date | string
    location?: StringFilter<"UserInvitation"> | string
    maxGuests?: IntNullableFilter<"UserInvitation"> | number | null
    createdAt?: DateTimeFilter<"UserInvitation"> | Date | string
    updatedAt?: DateTimeFilter<"UserInvitation"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    guests?: InvitationGuestListRelationFilter
  }

  export type UserInvitationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    status?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    imageBase64?: SortOrderInput | SortOrder
    type?: SortOrder
    date?: SortOrder
    location?: SortOrder
    maxGuests?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    guests?: InvitationGuestOrderByRelationAggregateInput
  }

  export type UserInvitationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: UserInvitationWhereInput | UserInvitationWhereInput[]
    OR?: UserInvitationWhereInput[]
    NOT?: UserInvitationWhereInput | UserInvitationWhereInput[]
    userId?: StringFilter<"UserInvitation"> | string
    status?: EnumInvitationStatusFilter<"UserInvitation"> | $Enums.InvitationStatus
    title?: StringFilter<"UserInvitation"> | string
    description?: StringNullableFilter<"UserInvitation"> | string | null
    imageBase64?: StringNullableFilter<"UserInvitation"> | string | null
    type?: EnumInvitationTypeFilter<"UserInvitation"> | $Enums.InvitationType
    date?: DateTimeFilter<"UserInvitation"> | Date | string
    location?: StringFilter<"UserInvitation"> | string
    maxGuests?: IntNullableFilter<"UserInvitation"> | number | null
    createdAt?: DateTimeFilter<"UserInvitation"> | Date | string
    updatedAt?: DateTimeFilter<"UserInvitation"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    guests?: InvitationGuestListRelationFilter
  }, "id" | "token">

  export type UserInvitationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    status?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    imageBase64?: SortOrderInput | SortOrder
    type?: SortOrder
    date?: SortOrder
    location?: SortOrder
    maxGuests?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserInvitationCountOrderByAggregateInput
    _avg?: UserInvitationAvgOrderByAggregateInput
    _max?: UserInvitationMaxOrderByAggregateInput
    _min?: UserInvitationMinOrderByAggregateInput
    _sum?: UserInvitationSumOrderByAggregateInput
  }

  export type UserInvitationScalarWhereWithAggregatesInput = {
    AND?: UserInvitationScalarWhereWithAggregatesInput | UserInvitationScalarWhereWithAggregatesInput[]
    OR?: UserInvitationScalarWhereWithAggregatesInput[]
    NOT?: UserInvitationScalarWhereWithAggregatesInput | UserInvitationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserInvitation"> | string
    userId?: StringWithAggregatesFilter<"UserInvitation"> | string
    token?: StringWithAggregatesFilter<"UserInvitation"> | string
    status?: EnumInvitationStatusWithAggregatesFilter<"UserInvitation"> | $Enums.InvitationStatus
    title?: StringWithAggregatesFilter<"UserInvitation"> | string
    description?: StringNullableWithAggregatesFilter<"UserInvitation"> | string | null
    imageBase64?: StringNullableWithAggregatesFilter<"UserInvitation"> | string | null
    type?: EnumInvitationTypeWithAggregatesFilter<"UserInvitation"> | $Enums.InvitationType
    date?: DateTimeWithAggregatesFilter<"UserInvitation"> | Date | string
    location?: StringWithAggregatesFilter<"UserInvitation"> | string
    maxGuests?: IntNullableWithAggregatesFilter<"UserInvitation"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"UserInvitation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserInvitation"> | Date | string
  }

  export type InvitationGuestWhereInput = {
    AND?: InvitationGuestWhereInput | InvitationGuestWhereInput[]
    OR?: InvitationGuestWhereInput[]
    NOT?: InvitationGuestWhereInput | InvitationGuestWhereInput[]
    id?: StringFilter<"InvitationGuest"> | string
    invitationId?: StringFilter<"InvitationGuest"> | string
    name?: StringFilter<"InvitationGuest"> | string
    phone?: StringFilter<"InvitationGuest"> | string
    confirmedAt?: DateTimeFilter<"InvitationGuest"> | Date | string
    invitation?: XOR<UserInvitationScalarRelationFilter, UserInvitationWhereInput>
  }

  export type InvitationGuestOrderByWithRelationInput = {
    id?: SortOrder
    invitationId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    confirmedAt?: SortOrder
    invitation?: UserInvitationOrderByWithRelationInput
  }

  export type InvitationGuestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvitationGuestWhereInput | InvitationGuestWhereInput[]
    OR?: InvitationGuestWhereInput[]
    NOT?: InvitationGuestWhereInput | InvitationGuestWhereInput[]
    invitationId?: StringFilter<"InvitationGuest"> | string
    name?: StringFilter<"InvitationGuest"> | string
    phone?: StringFilter<"InvitationGuest"> | string
    confirmedAt?: DateTimeFilter<"InvitationGuest"> | Date | string
    invitation?: XOR<UserInvitationScalarRelationFilter, UserInvitationWhereInput>
  }, "id">

  export type InvitationGuestOrderByWithAggregationInput = {
    id?: SortOrder
    invitationId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    confirmedAt?: SortOrder
    _count?: InvitationGuestCountOrderByAggregateInput
    _max?: InvitationGuestMaxOrderByAggregateInput
    _min?: InvitationGuestMinOrderByAggregateInput
  }

  export type InvitationGuestScalarWhereWithAggregatesInput = {
    AND?: InvitationGuestScalarWhereWithAggregatesInput | InvitationGuestScalarWhereWithAggregatesInput[]
    OR?: InvitationGuestScalarWhereWithAggregatesInput[]
    NOT?: InvitationGuestScalarWhereWithAggregatesInput | InvitationGuestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InvitationGuest"> | string
    invitationId?: StringWithAggregatesFilter<"InvitationGuest"> | string
    name?: StringWithAggregatesFilter<"InvitationGuest"> | string
    phone?: StringWithAggregatesFilter<"InvitationGuest"> | string
    confirmedAt?: DateTimeWithAggregatesFilter<"InvitationGuest"> | Date | string
  }

  export type FollowWhereInput = {
    AND?: FollowWhereInput | FollowWhereInput[]
    OR?: FollowWhereInput[]
    NOT?: FollowWhereInput | FollowWhereInput[]
    id?: StringFilter<"Follow"> | string
    followerId?: StringFilter<"Follow"> | string
    followingId?: StringFilter<"Follow"> | string
    createdAt?: DateTimeFilter<"Follow"> | Date | string
    follower?: XOR<UserScalarRelationFilter, UserWhereInput>
    following?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FollowOrderByWithRelationInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
    follower?: UserOrderByWithRelationInput
    following?: UserOrderByWithRelationInput
  }

  export type FollowWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    followerId_followingId?: FollowFollowerIdFollowingIdCompoundUniqueInput
    AND?: FollowWhereInput | FollowWhereInput[]
    OR?: FollowWhereInput[]
    NOT?: FollowWhereInput | FollowWhereInput[]
    followerId?: StringFilter<"Follow"> | string
    followingId?: StringFilter<"Follow"> | string
    createdAt?: DateTimeFilter<"Follow"> | Date | string
    follower?: XOR<UserScalarRelationFilter, UserWhereInput>
    following?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "followerId_followingId">

  export type FollowOrderByWithAggregationInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
    _count?: FollowCountOrderByAggregateInput
    _max?: FollowMaxOrderByAggregateInput
    _min?: FollowMinOrderByAggregateInput
  }

  export type FollowScalarWhereWithAggregatesInput = {
    AND?: FollowScalarWhereWithAggregatesInput | FollowScalarWhereWithAggregatesInput[]
    OR?: FollowScalarWhereWithAggregatesInput[]
    NOT?: FollowScalarWhereWithAggregatesInput | FollowScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Follow"> | string
    followerId?: StringWithAggregatesFilter<"Follow"> | string
    followingId?: StringWithAggregatesFilter<"Follow"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Follow"> | Date | string
  }

  export type OrganizationWhereInput = {
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    id?: StringFilter<"Organization"> | string
    name?: StringFilter<"Organization"> | string
    code?: StringFilter<"Organization"> | string
    logo?: StringNullableFilter<"Organization"> | string | null
    address?: StringNullableFilter<"Organization"> | string | null
    isSuspended?: BoolFilter<"Organization"> | boolean
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    ownerId?: StringFilter<"Organization"> | string
    departments?: DepartmentListRelationFilter
    members?: OrganizationMemberListRelationFilter
    subscription?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null
    events?: EventInvitationListRelationFilter
  }

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    logo?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    isSuspended?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
    departments?: DepartmentOrderByRelationAggregateInput
    members?: OrganizationMemberOrderByRelationAggregateInput
    subscription?: SubscriptionOrderByWithRelationInput
    events?: EventInvitationOrderByRelationAggregateInput
  }

  export type OrganizationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    name?: StringFilter<"Organization"> | string
    logo?: StringNullableFilter<"Organization"> | string | null
    address?: StringNullableFilter<"Organization"> | string | null
    isSuspended?: BoolFilter<"Organization"> | boolean
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    ownerId?: StringFilter<"Organization"> | string
    departments?: DepartmentListRelationFilter
    members?: OrganizationMemberListRelationFilter
    subscription?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null
    events?: EventInvitationListRelationFilter
  }, "id" | "code">

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    logo?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    isSuspended?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
    _count?: OrganizationCountOrderByAggregateInput
    _max?: OrganizationMaxOrderByAggregateInput
    _min?: OrganizationMinOrderByAggregateInput
  }

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    OR?: OrganizationScalarWhereWithAggregatesInput[]
    NOT?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Organization"> | string
    name?: StringWithAggregatesFilter<"Organization"> | string
    code?: StringWithAggregatesFilter<"Organization"> | string
    logo?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    address?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    isSuspended?: BoolWithAggregatesFilter<"Organization"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
    ownerId?: StringWithAggregatesFilter<"Organization"> | string
  }

  export type OrganizationMemberWhereInput = {
    AND?: OrganizationMemberWhereInput | OrganizationMemberWhereInput[]
    OR?: OrganizationMemberWhereInput[]
    NOT?: OrganizationMemberWhereInput | OrganizationMemberWhereInput[]
    id?: StringFilter<"OrganizationMember"> | string
    userId?: StringFilter<"OrganizationMember"> | string
    orgId?: StringFilter<"OrganizationMember"> | string
    role?: EnumOrgRoleFilter<"OrganizationMember"> | $Enums.OrgRole
    joinedAt?: DateTimeFilter<"OrganizationMember"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type OrganizationMemberOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    orgId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type OrganizationMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_orgId?: OrganizationMemberUserIdOrgIdCompoundUniqueInput
    AND?: OrganizationMemberWhereInput | OrganizationMemberWhereInput[]
    OR?: OrganizationMemberWhereInput[]
    NOT?: OrganizationMemberWhereInput | OrganizationMemberWhereInput[]
    userId?: StringFilter<"OrganizationMember"> | string
    orgId?: StringFilter<"OrganizationMember"> | string
    role?: EnumOrgRoleFilter<"OrganizationMember"> | $Enums.OrgRole
    joinedAt?: DateTimeFilter<"OrganizationMember"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_orgId">

  export type OrganizationMemberOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    orgId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    _count?: OrganizationMemberCountOrderByAggregateInput
    _max?: OrganizationMemberMaxOrderByAggregateInput
    _min?: OrganizationMemberMinOrderByAggregateInput
  }

  export type OrganizationMemberScalarWhereWithAggregatesInput = {
    AND?: OrganizationMemberScalarWhereWithAggregatesInput | OrganizationMemberScalarWhereWithAggregatesInput[]
    OR?: OrganizationMemberScalarWhereWithAggregatesInput[]
    NOT?: OrganizationMemberScalarWhereWithAggregatesInput | OrganizationMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrganizationMember"> | string
    userId?: StringWithAggregatesFilter<"OrganizationMember"> | string
    orgId?: StringWithAggregatesFilter<"OrganizationMember"> | string
    role?: EnumOrgRoleWithAggregatesFilter<"OrganizationMember"> | $Enums.OrgRole
    joinedAt?: DateTimeWithAggregatesFilter<"OrganizationMember"> | Date | string
  }

  export type DepartmentWhereInput = {
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    id?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    orgId?: StringFilter<"Department"> | string
    publicKey?: StringFilter<"Department"> | string
    headId?: StringNullableFilter<"Department"> | string | null
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    head?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    members?: DepartmentMemberListRelationFilter
    conversations?: GroupListRelationFilter
    tasks?: TaskListRelationFilter
    eventBroadcasts?: EventDepartmentBroadcastListRelationFilter
    monthlyReports?: DepartmentMonthlyReportListRelationFilter
    goals?: DepartmentGoalListRelationFilter
    meetings?: DepartmentMeetingListRelationFilter
    polls?: DepartmentPollListRelationFilter
    teamDecisions?: TeamDecisionListRelationFilter
    documents?: DepartmentDocumentListRelationFilter
  }

  export type DepartmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    orgId?: SortOrder
    publicKey?: SortOrder
    headId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    head?: UserOrderByWithRelationInput
    members?: DepartmentMemberOrderByRelationAggregateInput
    conversations?: GroupOrderByRelationAggregateInput
    tasks?: TaskOrderByRelationAggregateInput
    eventBroadcasts?: EventDepartmentBroadcastOrderByRelationAggregateInput
    monthlyReports?: DepartmentMonthlyReportOrderByRelationAggregateInput
    goals?: DepartmentGoalOrderByRelationAggregateInput
    meetings?: DepartmentMeetingOrderByRelationAggregateInput
    polls?: DepartmentPollOrderByRelationAggregateInput
    teamDecisions?: TeamDecisionOrderByRelationAggregateInput
    documents?: DepartmentDocumentOrderByRelationAggregateInput
  }

  export type DepartmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    name?: StringFilter<"Department"> | string
    orgId?: StringFilter<"Department"> | string
    publicKey?: StringFilter<"Department"> | string
    headId?: StringNullableFilter<"Department"> | string | null
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    head?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    members?: DepartmentMemberListRelationFilter
    conversations?: GroupListRelationFilter
    tasks?: TaskListRelationFilter
    eventBroadcasts?: EventDepartmentBroadcastListRelationFilter
    monthlyReports?: DepartmentMonthlyReportListRelationFilter
    goals?: DepartmentGoalListRelationFilter
    meetings?: DepartmentMeetingListRelationFilter
    polls?: DepartmentPollListRelationFilter
    teamDecisions?: TeamDecisionListRelationFilter
    documents?: DepartmentDocumentListRelationFilter
  }, "id">

  export type DepartmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    orgId?: SortOrder
    publicKey?: SortOrder
    headId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DepartmentCountOrderByAggregateInput
    _max?: DepartmentMaxOrderByAggregateInput
    _min?: DepartmentMinOrderByAggregateInput
  }

  export type DepartmentScalarWhereWithAggregatesInput = {
    AND?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    OR?: DepartmentScalarWhereWithAggregatesInput[]
    NOT?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Department"> | string
    name?: StringWithAggregatesFilter<"Department"> | string
    orgId?: StringWithAggregatesFilter<"Department"> | string
    publicKey?: StringWithAggregatesFilter<"Department"> | string
    headId?: StringNullableWithAggregatesFilter<"Department"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
  }

  export type DepartmentDocumentWhereInput = {
    AND?: DepartmentDocumentWhereInput | DepartmentDocumentWhereInput[]
    OR?: DepartmentDocumentWhereInput[]
    NOT?: DepartmentDocumentWhereInput | DepartmentDocumentWhereInput[]
    id?: StringFilter<"DepartmentDocument"> | string
    deptId?: StringFilter<"DepartmentDocument"> | string
    filename?: StringFilter<"DepartmentDocument"> | string
    type?: EnumFileTypeFilter<"DepartmentDocument"> | $Enums.FileType
    data?: StringFilter<"DepartmentDocument"> | string
    uploadedBy?: StringFilter<"DepartmentDocument"> | string
    createdAt?: DateTimeFilter<"DepartmentDocument"> | Date | string
    department?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
    uploader?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DepartmentDocumentOrderByWithRelationInput = {
    id?: SortOrder
    deptId?: SortOrder
    filename?: SortOrder
    type?: SortOrder
    data?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
    department?: DepartmentOrderByWithRelationInput
    uploader?: UserOrderByWithRelationInput
  }

  export type DepartmentDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DepartmentDocumentWhereInput | DepartmentDocumentWhereInput[]
    OR?: DepartmentDocumentWhereInput[]
    NOT?: DepartmentDocumentWhereInput | DepartmentDocumentWhereInput[]
    deptId?: StringFilter<"DepartmentDocument"> | string
    filename?: StringFilter<"DepartmentDocument"> | string
    type?: EnumFileTypeFilter<"DepartmentDocument"> | $Enums.FileType
    data?: StringFilter<"DepartmentDocument"> | string
    uploadedBy?: StringFilter<"DepartmentDocument"> | string
    createdAt?: DateTimeFilter<"DepartmentDocument"> | Date | string
    department?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
    uploader?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type DepartmentDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    deptId?: SortOrder
    filename?: SortOrder
    type?: SortOrder
    data?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
    _count?: DepartmentDocumentCountOrderByAggregateInput
    _max?: DepartmentDocumentMaxOrderByAggregateInput
    _min?: DepartmentDocumentMinOrderByAggregateInput
  }

  export type DepartmentDocumentScalarWhereWithAggregatesInput = {
    AND?: DepartmentDocumentScalarWhereWithAggregatesInput | DepartmentDocumentScalarWhereWithAggregatesInput[]
    OR?: DepartmentDocumentScalarWhereWithAggregatesInput[]
    NOT?: DepartmentDocumentScalarWhereWithAggregatesInput | DepartmentDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DepartmentDocument"> | string
    deptId?: StringWithAggregatesFilter<"DepartmentDocument"> | string
    filename?: StringWithAggregatesFilter<"DepartmentDocument"> | string
    type?: EnumFileTypeWithAggregatesFilter<"DepartmentDocument"> | $Enums.FileType
    data?: StringWithAggregatesFilter<"DepartmentDocument"> | string
    uploadedBy?: StringWithAggregatesFilter<"DepartmentDocument"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DepartmentDocument"> | Date | string
  }

  export type DepartmentGoalWhereInput = {
    AND?: DepartmentGoalWhereInput | DepartmentGoalWhereInput[]
    OR?: DepartmentGoalWhereInput[]
    NOT?: DepartmentGoalWhereInput | DepartmentGoalWhereInput[]
    id?: StringFilter<"DepartmentGoal"> | string
    deptId?: StringFilter<"DepartmentGoal"> | string
    title?: StringFilter<"DepartmentGoal"> | string
    description?: StringNullableFilter<"DepartmentGoal"> | string | null
    targetValue?: FloatNullableFilter<"DepartmentGoal"> | number | null
    currentValue?: FloatFilter<"DepartmentGoal"> | number
    period?: StringFilter<"DepartmentGoal"> | string
    periodKey?: StringFilter<"DepartmentGoal"> | string
    createdAt?: DateTimeFilter<"DepartmentGoal"> | Date | string
    updatedAt?: DateTimeFilter<"DepartmentGoal"> | Date | string
    department?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
  }

  export type DepartmentGoalOrderByWithRelationInput = {
    id?: SortOrder
    deptId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    targetValue?: SortOrderInput | SortOrder
    currentValue?: SortOrder
    period?: SortOrder
    periodKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    department?: DepartmentOrderByWithRelationInput
  }

  export type DepartmentGoalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DepartmentGoalWhereInput | DepartmentGoalWhereInput[]
    OR?: DepartmentGoalWhereInput[]
    NOT?: DepartmentGoalWhereInput | DepartmentGoalWhereInput[]
    deptId?: StringFilter<"DepartmentGoal"> | string
    title?: StringFilter<"DepartmentGoal"> | string
    description?: StringNullableFilter<"DepartmentGoal"> | string | null
    targetValue?: FloatNullableFilter<"DepartmentGoal"> | number | null
    currentValue?: FloatFilter<"DepartmentGoal"> | number
    period?: StringFilter<"DepartmentGoal"> | string
    periodKey?: StringFilter<"DepartmentGoal"> | string
    createdAt?: DateTimeFilter<"DepartmentGoal"> | Date | string
    updatedAt?: DateTimeFilter<"DepartmentGoal"> | Date | string
    department?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
  }, "id">

  export type DepartmentGoalOrderByWithAggregationInput = {
    id?: SortOrder
    deptId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    targetValue?: SortOrderInput | SortOrder
    currentValue?: SortOrder
    period?: SortOrder
    periodKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DepartmentGoalCountOrderByAggregateInput
    _avg?: DepartmentGoalAvgOrderByAggregateInput
    _max?: DepartmentGoalMaxOrderByAggregateInput
    _min?: DepartmentGoalMinOrderByAggregateInput
    _sum?: DepartmentGoalSumOrderByAggregateInput
  }

  export type DepartmentGoalScalarWhereWithAggregatesInput = {
    AND?: DepartmentGoalScalarWhereWithAggregatesInput | DepartmentGoalScalarWhereWithAggregatesInput[]
    OR?: DepartmentGoalScalarWhereWithAggregatesInput[]
    NOT?: DepartmentGoalScalarWhereWithAggregatesInput | DepartmentGoalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DepartmentGoal"> | string
    deptId?: StringWithAggregatesFilter<"DepartmentGoal"> | string
    title?: StringWithAggregatesFilter<"DepartmentGoal"> | string
    description?: StringNullableWithAggregatesFilter<"DepartmentGoal"> | string | null
    targetValue?: FloatNullableWithAggregatesFilter<"DepartmentGoal"> | number | null
    currentValue?: FloatWithAggregatesFilter<"DepartmentGoal"> | number
    period?: StringWithAggregatesFilter<"DepartmentGoal"> | string
    periodKey?: StringWithAggregatesFilter<"DepartmentGoal"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DepartmentGoal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DepartmentGoal"> | Date | string
  }

  export type DepartmentMeetingWhereInput = {
    AND?: DepartmentMeetingWhereInput | DepartmentMeetingWhereInput[]
    OR?: DepartmentMeetingWhereInput[]
    NOT?: DepartmentMeetingWhereInput | DepartmentMeetingWhereInput[]
    id?: StringFilter<"DepartmentMeeting"> | string
    deptId?: StringFilter<"DepartmentMeeting"> | string
    title?: StringFilter<"DepartmentMeeting"> | string
    description?: StringNullableFilter<"DepartmentMeeting"> | string | null
    agenda?: StringNullableFilter<"DepartmentMeeting"> | string | null
    meetingDate?: DateTimeFilter<"DepartmentMeeting"> | Date | string
    location?: StringNullableFilter<"DepartmentMeeting"> | string | null
    createdBy?: StringFilter<"DepartmentMeeting"> | string
    minutes?: StringNullableFilter<"DepartmentMeeting"> | string | null
    minutesAt?: DateTimeNullableFilter<"DepartmentMeeting"> | Date | string | null
    createdAt?: DateTimeFilter<"DepartmentMeeting"> | Date | string
    updatedAt?: DateTimeFilter<"DepartmentMeeting"> | Date | string
    department?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DepartmentMeetingOrderByWithRelationInput = {
    id?: SortOrder
    deptId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    agenda?: SortOrderInput | SortOrder
    meetingDate?: SortOrder
    location?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    minutes?: SortOrderInput | SortOrder
    minutesAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    department?: DepartmentOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
  }

  export type DepartmentMeetingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DepartmentMeetingWhereInput | DepartmentMeetingWhereInput[]
    OR?: DepartmentMeetingWhereInput[]
    NOT?: DepartmentMeetingWhereInput | DepartmentMeetingWhereInput[]
    deptId?: StringFilter<"DepartmentMeeting"> | string
    title?: StringFilter<"DepartmentMeeting"> | string
    description?: StringNullableFilter<"DepartmentMeeting"> | string | null
    agenda?: StringNullableFilter<"DepartmentMeeting"> | string | null
    meetingDate?: DateTimeFilter<"DepartmentMeeting"> | Date | string
    location?: StringNullableFilter<"DepartmentMeeting"> | string | null
    createdBy?: StringFilter<"DepartmentMeeting"> | string
    minutes?: StringNullableFilter<"DepartmentMeeting"> | string | null
    minutesAt?: DateTimeNullableFilter<"DepartmentMeeting"> | Date | string | null
    createdAt?: DateTimeFilter<"DepartmentMeeting"> | Date | string
    updatedAt?: DateTimeFilter<"DepartmentMeeting"> | Date | string
    department?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type DepartmentMeetingOrderByWithAggregationInput = {
    id?: SortOrder
    deptId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    agenda?: SortOrderInput | SortOrder
    meetingDate?: SortOrder
    location?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    minutes?: SortOrderInput | SortOrder
    minutesAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DepartmentMeetingCountOrderByAggregateInput
    _max?: DepartmentMeetingMaxOrderByAggregateInput
    _min?: DepartmentMeetingMinOrderByAggregateInput
  }

  export type DepartmentMeetingScalarWhereWithAggregatesInput = {
    AND?: DepartmentMeetingScalarWhereWithAggregatesInput | DepartmentMeetingScalarWhereWithAggregatesInput[]
    OR?: DepartmentMeetingScalarWhereWithAggregatesInput[]
    NOT?: DepartmentMeetingScalarWhereWithAggregatesInput | DepartmentMeetingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DepartmentMeeting"> | string
    deptId?: StringWithAggregatesFilter<"DepartmentMeeting"> | string
    title?: StringWithAggregatesFilter<"DepartmentMeeting"> | string
    description?: StringNullableWithAggregatesFilter<"DepartmentMeeting"> | string | null
    agenda?: StringNullableWithAggregatesFilter<"DepartmentMeeting"> | string | null
    meetingDate?: DateTimeWithAggregatesFilter<"DepartmentMeeting"> | Date | string
    location?: StringNullableWithAggregatesFilter<"DepartmentMeeting"> | string | null
    createdBy?: StringWithAggregatesFilter<"DepartmentMeeting"> | string
    minutes?: StringNullableWithAggregatesFilter<"DepartmentMeeting"> | string | null
    minutesAt?: DateTimeNullableWithAggregatesFilter<"DepartmentMeeting"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DepartmentMeeting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DepartmentMeeting"> | Date | string
  }

  export type DepartmentPollWhereInput = {
    AND?: DepartmentPollWhereInput | DepartmentPollWhereInput[]
    OR?: DepartmentPollWhereInput[]
    NOT?: DepartmentPollWhereInput | DepartmentPollWhereInput[]
    id?: StringFilter<"DepartmentPoll"> | string
    deptId?: StringFilter<"DepartmentPoll"> | string
    question?: StringFilter<"DepartmentPoll"> | string
    options?: JsonFilter<"DepartmentPoll">
    endDate?: DateTimeNullableFilter<"DepartmentPoll"> | Date | string | null
    createdBy?: StringFilter<"DepartmentPoll"> | string
    createdAt?: DateTimeFilter<"DepartmentPoll"> | Date | string
    updatedAt?: DateTimeFilter<"DepartmentPoll"> | Date | string
    department?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    votes?: PollVoteListRelationFilter
  }

  export type DepartmentPollOrderByWithRelationInput = {
    id?: SortOrder
    deptId?: SortOrder
    question?: SortOrder
    options?: SortOrder
    endDate?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    department?: DepartmentOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    votes?: PollVoteOrderByRelationAggregateInput
  }

  export type DepartmentPollWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DepartmentPollWhereInput | DepartmentPollWhereInput[]
    OR?: DepartmentPollWhereInput[]
    NOT?: DepartmentPollWhereInput | DepartmentPollWhereInput[]
    deptId?: StringFilter<"DepartmentPoll"> | string
    question?: StringFilter<"DepartmentPoll"> | string
    options?: JsonFilter<"DepartmentPoll">
    endDate?: DateTimeNullableFilter<"DepartmentPoll"> | Date | string | null
    createdBy?: StringFilter<"DepartmentPoll"> | string
    createdAt?: DateTimeFilter<"DepartmentPoll"> | Date | string
    updatedAt?: DateTimeFilter<"DepartmentPoll"> | Date | string
    department?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    votes?: PollVoteListRelationFilter
  }, "id">

  export type DepartmentPollOrderByWithAggregationInput = {
    id?: SortOrder
    deptId?: SortOrder
    question?: SortOrder
    options?: SortOrder
    endDate?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DepartmentPollCountOrderByAggregateInput
    _max?: DepartmentPollMaxOrderByAggregateInput
    _min?: DepartmentPollMinOrderByAggregateInput
  }

  export type DepartmentPollScalarWhereWithAggregatesInput = {
    AND?: DepartmentPollScalarWhereWithAggregatesInput | DepartmentPollScalarWhereWithAggregatesInput[]
    OR?: DepartmentPollScalarWhereWithAggregatesInput[]
    NOT?: DepartmentPollScalarWhereWithAggregatesInput | DepartmentPollScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DepartmentPoll"> | string
    deptId?: StringWithAggregatesFilter<"DepartmentPoll"> | string
    question?: StringWithAggregatesFilter<"DepartmentPoll"> | string
    options?: JsonWithAggregatesFilter<"DepartmentPoll">
    endDate?: DateTimeNullableWithAggregatesFilter<"DepartmentPoll"> | Date | string | null
    createdBy?: StringWithAggregatesFilter<"DepartmentPoll"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DepartmentPoll"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DepartmentPoll"> | Date | string
  }

  export type PollVoteWhereInput = {
    AND?: PollVoteWhereInput | PollVoteWhereInput[]
    OR?: PollVoteWhereInput[]
    NOT?: PollVoteWhereInput | PollVoteWhereInput[]
    id?: StringFilter<"PollVote"> | string
    pollId?: StringFilter<"PollVote"> | string
    userId?: StringFilter<"PollVote"> | string
    optionIndex?: IntFilter<"PollVote"> | number
    createdAt?: DateTimeFilter<"PollVote"> | Date | string
    poll?: XOR<DepartmentPollScalarRelationFilter, DepartmentPollWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PollVoteOrderByWithRelationInput = {
    id?: SortOrder
    pollId?: SortOrder
    userId?: SortOrder
    optionIndex?: SortOrder
    createdAt?: SortOrder
    poll?: DepartmentPollOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type PollVoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    pollId_userId?: PollVotePollIdUserIdCompoundUniqueInput
    AND?: PollVoteWhereInput | PollVoteWhereInput[]
    OR?: PollVoteWhereInput[]
    NOT?: PollVoteWhereInput | PollVoteWhereInput[]
    pollId?: StringFilter<"PollVote"> | string
    userId?: StringFilter<"PollVote"> | string
    optionIndex?: IntFilter<"PollVote"> | number
    createdAt?: DateTimeFilter<"PollVote"> | Date | string
    poll?: XOR<DepartmentPollScalarRelationFilter, DepartmentPollWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "pollId_userId">

  export type PollVoteOrderByWithAggregationInput = {
    id?: SortOrder
    pollId?: SortOrder
    userId?: SortOrder
    optionIndex?: SortOrder
    createdAt?: SortOrder
    _count?: PollVoteCountOrderByAggregateInput
    _avg?: PollVoteAvgOrderByAggregateInput
    _max?: PollVoteMaxOrderByAggregateInput
    _min?: PollVoteMinOrderByAggregateInput
    _sum?: PollVoteSumOrderByAggregateInput
  }

  export type PollVoteScalarWhereWithAggregatesInput = {
    AND?: PollVoteScalarWhereWithAggregatesInput | PollVoteScalarWhereWithAggregatesInput[]
    OR?: PollVoteScalarWhereWithAggregatesInput[]
    NOT?: PollVoteScalarWhereWithAggregatesInput | PollVoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PollVote"> | string
    pollId?: StringWithAggregatesFilter<"PollVote"> | string
    userId?: StringWithAggregatesFilter<"PollVote"> | string
    optionIndex?: IntWithAggregatesFilter<"PollVote"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PollVote"> | Date | string
  }

  export type TeamDecisionWhereInput = {
    AND?: TeamDecisionWhereInput | TeamDecisionWhereInput[]
    OR?: TeamDecisionWhereInput[]
    NOT?: TeamDecisionWhereInput | TeamDecisionWhereInput[]
    id?: StringFilter<"TeamDecision"> | string
    deptId?: StringFilter<"TeamDecision"> | string
    title?: StringFilter<"TeamDecision"> | string
    description?: StringNullableFilter<"TeamDecision"> | string | null
    voteDeadline?: DateTimeNullableFilter<"TeamDecision"> | Date | string | null
    status?: StringFilter<"TeamDecision"> | string
    createdBy?: StringFilter<"TeamDecision"> | string
    createdAt?: DateTimeFilter<"TeamDecision"> | Date | string
    updatedAt?: DateTimeFilter<"TeamDecision"> | Date | string
    department?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    votes?: DecisionVoteListRelationFilter
  }

  export type TeamDecisionOrderByWithRelationInput = {
    id?: SortOrder
    deptId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    voteDeadline?: SortOrderInput | SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    department?: DepartmentOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    votes?: DecisionVoteOrderByRelationAggregateInput
  }

  export type TeamDecisionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TeamDecisionWhereInput | TeamDecisionWhereInput[]
    OR?: TeamDecisionWhereInput[]
    NOT?: TeamDecisionWhereInput | TeamDecisionWhereInput[]
    deptId?: StringFilter<"TeamDecision"> | string
    title?: StringFilter<"TeamDecision"> | string
    description?: StringNullableFilter<"TeamDecision"> | string | null
    voteDeadline?: DateTimeNullableFilter<"TeamDecision"> | Date | string | null
    status?: StringFilter<"TeamDecision"> | string
    createdBy?: StringFilter<"TeamDecision"> | string
    createdAt?: DateTimeFilter<"TeamDecision"> | Date | string
    updatedAt?: DateTimeFilter<"TeamDecision"> | Date | string
    department?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    votes?: DecisionVoteListRelationFilter
  }, "id">

  export type TeamDecisionOrderByWithAggregationInput = {
    id?: SortOrder
    deptId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    voteDeadline?: SortOrderInput | SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeamDecisionCountOrderByAggregateInput
    _max?: TeamDecisionMaxOrderByAggregateInput
    _min?: TeamDecisionMinOrderByAggregateInput
  }

  export type TeamDecisionScalarWhereWithAggregatesInput = {
    AND?: TeamDecisionScalarWhereWithAggregatesInput | TeamDecisionScalarWhereWithAggregatesInput[]
    OR?: TeamDecisionScalarWhereWithAggregatesInput[]
    NOT?: TeamDecisionScalarWhereWithAggregatesInput | TeamDecisionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TeamDecision"> | string
    deptId?: StringWithAggregatesFilter<"TeamDecision"> | string
    title?: StringWithAggregatesFilter<"TeamDecision"> | string
    description?: StringNullableWithAggregatesFilter<"TeamDecision"> | string | null
    voteDeadline?: DateTimeNullableWithAggregatesFilter<"TeamDecision"> | Date | string | null
    status?: StringWithAggregatesFilter<"TeamDecision"> | string
    createdBy?: StringWithAggregatesFilter<"TeamDecision"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TeamDecision"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TeamDecision"> | Date | string
  }

  export type DecisionVoteWhereInput = {
    AND?: DecisionVoteWhereInput | DecisionVoteWhereInput[]
    OR?: DecisionVoteWhereInput[]
    NOT?: DecisionVoteWhereInput | DecisionVoteWhereInput[]
    id?: StringFilter<"DecisionVote"> | string
    decisionId?: StringFilter<"DecisionVote"> | string
    userId?: StringFilter<"DecisionVote"> | string
    vote?: EnumDecisionVoteTypeFilter<"DecisionVote"> | $Enums.DecisionVoteType
    createdAt?: DateTimeFilter<"DecisionVote"> | Date | string
    decision?: XOR<TeamDecisionScalarRelationFilter, TeamDecisionWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DecisionVoteOrderByWithRelationInput = {
    id?: SortOrder
    decisionId?: SortOrder
    userId?: SortOrder
    vote?: SortOrder
    createdAt?: SortOrder
    decision?: TeamDecisionOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type DecisionVoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    decisionId_userId?: DecisionVoteDecisionIdUserIdCompoundUniqueInput
    AND?: DecisionVoteWhereInput | DecisionVoteWhereInput[]
    OR?: DecisionVoteWhereInput[]
    NOT?: DecisionVoteWhereInput | DecisionVoteWhereInput[]
    decisionId?: StringFilter<"DecisionVote"> | string
    userId?: StringFilter<"DecisionVote"> | string
    vote?: EnumDecisionVoteTypeFilter<"DecisionVote"> | $Enums.DecisionVoteType
    createdAt?: DateTimeFilter<"DecisionVote"> | Date | string
    decision?: XOR<TeamDecisionScalarRelationFilter, TeamDecisionWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "decisionId_userId">

  export type DecisionVoteOrderByWithAggregationInput = {
    id?: SortOrder
    decisionId?: SortOrder
    userId?: SortOrder
    vote?: SortOrder
    createdAt?: SortOrder
    _count?: DecisionVoteCountOrderByAggregateInput
    _max?: DecisionVoteMaxOrderByAggregateInput
    _min?: DecisionVoteMinOrderByAggregateInput
  }

  export type DecisionVoteScalarWhereWithAggregatesInput = {
    AND?: DecisionVoteScalarWhereWithAggregatesInput | DecisionVoteScalarWhereWithAggregatesInput[]
    OR?: DecisionVoteScalarWhereWithAggregatesInput[]
    NOT?: DecisionVoteScalarWhereWithAggregatesInput | DecisionVoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DecisionVote"> | string
    decisionId?: StringWithAggregatesFilter<"DecisionVote"> | string
    userId?: StringWithAggregatesFilter<"DecisionVote"> | string
    vote?: EnumDecisionVoteTypeWithAggregatesFilter<"DecisionVote"> | $Enums.DecisionVoteType
    createdAt?: DateTimeWithAggregatesFilter<"DecisionVote"> | Date | string
  }

  export type DepartmentMemberWhereInput = {
    AND?: DepartmentMemberWhereInput | DepartmentMemberWhereInput[]
    OR?: DepartmentMemberWhereInput[]
    NOT?: DepartmentMemberWhereInput | DepartmentMemberWhereInput[]
    id?: StringFilter<"DepartmentMember"> | string
    deptId?: StringFilter<"DepartmentMember"> | string
    userId?: StringFilter<"DepartmentMember"> | string
    encryptedDeptKey?: StringFilter<"DepartmentMember"> | string
    department?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DepartmentMemberOrderByWithRelationInput = {
    id?: SortOrder
    deptId?: SortOrder
    userId?: SortOrder
    encryptedDeptKey?: SortOrder
    department?: DepartmentOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type DepartmentMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    deptId_userId?: DepartmentMemberDeptIdUserIdCompoundUniqueInput
    AND?: DepartmentMemberWhereInput | DepartmentMemberWhereInput[]
    OR?: DepartmentMemberWhereInput[]
    NOT?: DepartmentMemberWhereInput | DepartmentMemberWhereInput[]
    deptId?: StringFilter<"DepartmentMember"> | string
    userId?: StringFilter<"DepartmentMember"> | string
    encryptedDeptKey?: StringFilter<"DepartmentMember"> | string
    department?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "deptId_userId">

  export type DepartmentMemberOrderByWithAggregationInput = {
    id?: SortOrder
    deptId?: SortOrder
    userId?: SortOrder
    encryptedDeptKey?: SortOrder
    _count?: DepartmentMemberCountOrderByAggregateInput
    _max?: DepartmentMemberMaxOrderByAggregateInput
    _min?: DepartmentMemberMinOrderByAggregateInput
  }

  export type DepartmentMemberScalarWhereWithAggregatesInput = {
    AND?: DepartmentMemberScalarWhereWithAggregatesInput | DepartmentMemberScalarWhereWithAggregatesInput[]
    OR?: DepartmentMemberScalarWhereWithAggregatesInput[]
    NOT?: DepartmentMemberScalarWhereWithAggregatesInput | DepartmentMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DepartmentMember"> | string
    deptId?: StringWithAggregatesFilter<"DepartmentMember"> | string
    userId?: StringWithAggregatesFilter<"DepartmentMember"> | string
    encryptedDeptKey?: StringWithAggregatesFilter<"DepartmentMember"> | string
  }

  export type GroupWhereInput = {
    AND?: GroupWhereInput | GroupWhereInput[]
    OR?: GroupWhereInput[]
    NOT?: GroupWhereInput | GroupWhereInput[]
    id?: StringFilter<"Group"> | string
    name?: StringNullableFilter<"Group"> | string | null
    isDirect?: BoolFilter<"Group"> | boolean
    deptId?: StringNullableFilter<"Group"> | string | null
    createdAt?: DateTimeFilter<"Group"> | Date | string
    updatedAt?: DateTimeFilter<"Group"> | Date | string
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    members?: GroupMemberListRelationFilter
    messages?: MessageListRelationFilter
    documents?: GroupDocumentListRelationFilter
  }

  export type GroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    isDirect?: SortOrder
    deptId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    department?: DepartmentOrderByWithRelationInput
    members?: GroupMemberOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
    documents?: GroupDocumentOrderByRelationAggregateInput
  }

  export type GroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GroupWhereInput | GroupWhereInput[]
    OR?: GroupWhereInput[]
    NOT?: GroupWhereInput | GroupWhereInput[]
    name?: StringNullableFilter<"Group"> | string | null
    isDirect?: BoolFilter<"Group"> | boolean
    deptId?: StringNullableFilter<"Group"> | string | null
    createdAt?: DateTimeFilter<"Group"> | Date | string
    updatedAt?: DateTimeFilter<"Group"> | Date | string
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    members?: GroupMemberListRelationFilter
    messages?: MessageListRelationFilter
    documents?: GroupDocumentListRelationFilter
  }, "id">

  export type GroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    isDirect?: SortOrder
    deptId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GroupCountOrderByAggregateInput
    _max?: GroupMaxOrderByAggregateInput
    _min?: GroupMinOrderByAggregateInput
  }

  export type GroupScalarWhereWithAggregatesInput = {
    AND?: GroupScalarWhereWithAggregatesInput | GroupScalarWhereWithAggregatesInput[]
    OR?: GroupScalarWhereWithAggregatesInput[]
    NOT?: GroupScalarWhereWithAggregatesInput | GroupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Group"> | string
    name?: StringNullableWithAggregatesFilter<"Group"> | string | null
    isDirect?: BoolWithAggregatesFilter<"Group"> | boolean
    deptId?: StringNullableWithAggregatesFilter<"Group"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Group"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Group"> | Date | string
  }

  export type GroupDocumentWhereInput = {
    AND?: GroupDocumentWhereInput | GroupDocumentWhereInput[]
    OR?: GroupDocumentWhereInput[]
    NOT?: GroupDocumentWhereInput | GroupDocumentWhereInput[]
    id?: StringFilter<"GroupDocument"> | string
    groupId?: StringFilter<"GroupDocument"> | string
    title?: StringFilter<"GroupDocument"> | string
    createdAt?: DateTimeFilter<"GroupDocument"> | Date | string
    updatedAt?: DateTimeFilter<"GroupDocument"> | Date | string
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
    notes?: GroupNoteListRelationFilter
  }

  export type GroupDocumentOrderByWithRelationInput = {
    id?: SortOrder
    groupId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    group?: GroupOrderByWithRelationInput
    notes?: GroupNoteOrderByRelationAggregateInput
  }

  export type GroupDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GroupDocumentWhereInput | GroupDocumentWhereInput[]
    OR?: GroupDocumentWhereInput[]
    NOT?: GroupDocumentWhereInput | GroupDocumentWhereInput[]
    groupId?: StringFilter<"GroupDocument"> | string
    title?: StringFilter<"GroupDocument"> | string
    createdAt?: DateTimeFilter<"GroupDocument"> | Date | string
    updatedAt?: DateTimeFilter<"GroupDocument"> | Date | string
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
    notes?: GroupNoteListRelationFilter
  }, "id">

  export type GroupDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    groupId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GroupDocumentCountOrderByAggregateInput
    _max?: GroupDocumentMaxOrderByAggregateInput
    _min?: GroupDocumentMinOrderByAggregateInput
  }

  export type GroupDocumentScalarWhereWithAggregatesInput = {
    AND?: GroupDocumentScalarWhereWithAggregatesInput | GroupDocumentScalarWhereWithAggregatesInput[]
    OR?: GroupDocumentScalarWhereWithAggregatesInput[]
    NOT?: GroupDocumentScalarWhereWithAggregatesInput | GroupDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GroupDocument"> | string
    groupId?: StringWithAggregatesFilter<"GroupDocument"> | string
    title?: StringWithAggregatesFilter<"GroupDocument"> | string
    createdAt?: DateTimeWithAggregatesFilter<"GroupDocument"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GroupDocument"> | Date | string
  }

  export type GroupNoteWhereInput = {
    AND?: GroupNoteWhereInput | GroupNoteWhereInput[]
    OR?: GroupNoteWhereInput[]
    NOT?: GroupNoteWhereInput | GroupNoteWhereInput[]
    id?: StringFilter<"GroupNote"> | string
    documentId?: StringFilter<"GroupNote"> | string
    title?: StringFilter<"GroupNote"> | string
    content?: StringFilter<"GroupNote"> | string
    textSize?: EnumNoteTextSizeFilter<"GroupNote"> | $Enums.NoteTextSize
    order?: IntFilter<"GroupNote"> | number
    createdBy?: StringFilter<"GroupNote"> | string
    createdAt?: DateTimeFilter<"GroupNote"> | Date | string
    updatedAt?: DateTimeFilter<"GroupNote"> | Date | string
    document?: XOR<GroupDocumentScalarRelationFilter, GroupDocumentWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type GroupNoteOrderByWithRelationInput = {
    id?: SortOrder
    documentId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    textSize?: SortOrder
    order?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    document?: GroupDocumentOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
  }

  export type GroupNoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GroupNoteWhereInput | GroupNoteWhereInput[]
    OR?: GroupNoteWhereInput[]
    NOT?: GroupNoteWhereInput | GroupNoteWhereInput[]
    documentId?: StringFilter<"GroupNote"> | string
    title?: StringFilter<"GroupNote"> | string
    content?: StringFilter<"GroupNote"> | string
    textSize?: EnumNoteTextSizeFilter<"GroupNote"> | $Enums.NoteTextSize
    order?: IntFilter<"GroupNote"> | number
    createdBy?: StringFilter<"GroupNote"> | string
    createdAt?: DateTimeFilter<"GroupNote"> | Date | string
    updatedAt?: DateTimeFilter<"GroupNote"> | Date | string
    document?: XOR<GroupDocumentScalarRelationFilter, GroupDocumentWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type GroupNoteOrderByWithAggregationInput = {
    id?: SortOrder
    documentId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    textSize?: SortOrder
    order?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GroupNoteCountOrderByAggregateInput
    _avg?: GroupNoteAvgOrderByAggregateInput
    _max?: GroupNoteMaxOrderByAggregateInput
    _min?: GroupNoteMinOrderByAggregateInput
    _sum?: GroupNoteSumOrderByAggregateInput
  }

  export type GroupNoteScalarWhereWithAggregatesInput = {
    AND?: GroupNoteScalarWhereWithAggregatesInput | GroupNoteScalarWhereWithAggregatesInput[]
    OR?: GroupNoteScalarWhereWithAggregatesInput[]
    NOT?: GroupNoteScalarWhereWithAggregatesInput | GroupNoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GroupNote"> | string
    documentId?: StringWithAggregatesFilter<"GroupNote"> | string
    title?: StringWithAggregatesFilter<"GroupNote"> | string
    content?: StringWithAggregatesFilter<"GroupNote"> | string
    textSize?: EnumNoteTextSizeWithAggregatesFilter<"GroupNote"> | $Enums.NoteTextSize
    order?: IntWithAggregatesFilter<"GroupNote"> | number
    createdBy?: StringWithAggregatesFilter<"GroupNote"> | string
    createdAt?: DateTimeWithAggregatesFilter<"GroupNote"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GroupNote"> | Date | string
  }

  export type GroupMemberWhereInput = {
    AND?: GroupMemberWhereInput | GroupMemberWhereInput[]
    OR?: GroupMemberWhereInput[]
    NOT?: GroupMemberWhereInput | GroupMemberWhereInput[]
    id?: StringFilter<"GroupMember"> | string
    groupId?: StringFilter<"GroupMember"> | string
    userId?: StringFilter<"GroupMember"> | string
    joinedAt?: DateTimeFilter<"GroupMember"> | Date | string
    lastReadAt?: DateTimeFilter<"GroupMember"> | Date | string
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type GroupMemberOrderByWithRelationInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
    lastReadAt?: SortOrder
    group?: GroupOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type GroupMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    groupId_userId?: GroupMemberGroupIdUserIdCompoundUniqueInput
    AND?: GroupMemberWhereInput | GroupMemberWhereInput[]
    OR?: GroupMemberWhereInput[]
    NOT?: GroupMemberWhereInput | GroupMemberWhereInput[]
    groupId?: StringFilter<"GroupMember"> | string
    userId?: StringFilter<"GroupMember"> | string
    joinedAt?: DateTimeFilter<"GroupMember"> | Date | string
    lastReadAt?: DateTimeFilter<"GroupMember"> | Date | string
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "groupId_userId">

  export type GroupMemberOrderByWithAggregationInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
    lastReadAt?: SortOrder
    _count?: GroupMemberCountOrderByAggregateInput
    _max?: GroupMemberMaxOrderByAggregateInput
    _min?: GroupMemberMinOrderByAggregateInput
  }

  export type GroupMemberScalarWhereWithAggregatesInput = {
    AND?: GroupMemberScalarWhereWithAggregatesInput | GroupMemberScalarWhereWithAggregatesInput[]
    OR?: GroupMemberScalarWhereWithAggregatesInput[]
    NOT?: GroupMemberScalarWhereWithAggregatesInput | GroupMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GroupMember"> | string
    groupId?: StringWithAggregatesFilter<"GroupMember"> | string
    userId?: StringWithAggregatesFilter<"GroupMember"> | string
    joinedAt?: DateTimeWithAggregatesFilter<"GroupMember"> | Date | string
    lastReadAt?: DateTimeWithAggregatesFilter<"GroupMember"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    groupId?: StringFilter<"Message"> | string
    isEdited?: BoolFilter<"Message"> | boolean
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    attachments?: AttachmentListRelationFilter
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    senderId?: SortOrder
    groupId?: SortOrder
    isEdited?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    attachments?: AttachmentOrderByRelationAggregateInput
    group?: GroupOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    content?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    groupId?: StringFilter<"Message"> | string
    isEdited?: BoolFilter<"Message"> | boolean
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    attachments?: AttachmentListRelationFilter
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    senderId?: SortOrder
    groupId?: SortOrder
    isEdited?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    content?: StringWithAggregatesFilter<"Message"> | string
    senderId?: StringWithAggregatesFilter<"Message"> | string
    groupId?: StringWithAggregatesFilter<"Message"> | string
    isEdited?: BoolWithAggregatesFilter<"Message"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type AttachmentWhereInput = {
    AND?: AttachmentWhereInput | AttachmentWhereInput[]
    OR?: AttachmentWhereInput[]
    NOT?: AttachmentWhereInput | AttachmentWhereInput[]
    id?: StringFilter<"Attachment"> | string
    messageId?: StringFilter<"Attachment"> | string
    type?: EnumFileTypeFilter<"Attachment"> | $Enums.FileType
    filename?: StringFilter<"Attachment"> | string
    data?: StringFilter<"Attachment"> | string
    createdAt?: DateTimeFilter<"Attachment"> | Date | string
    message?: XOR<MessageScalarRelationFilter, MessageWhereInput>
  }

  export type AttachmentOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    type?: SortOrder
    filename?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    message?: MessageOrderByWithRelationInput
  }

  export type AttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AttachmentWhereInput | AttachmentWhereInput[]
    OR?: AttachmentWhereInput[]
    NOT?: AttachmentWhereInput | AttachmentWhereInput[]
    messageId?: StringFilter<"Attachment"> | string
    type?: EnumFileTypeFilter<"Attachment"> | $Enums.FileType
    filename?: StringFilter<"Attachment"> | string
    data?: StringFilter<"Attachment"> | string
    createdAt?: DateTimeFilter<"Attachment"> | Date | string
    message?: XOR<MessageScalarRelationFilter, MessageWhereInput>
  }, "id">

  export type AttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    type?: SortOrder
    filename?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    _count?: AttachmentCountOrderByAggregateInput
    _max?: AttachmentMaxOrderByAggregateInput
    _min?: AttachmentMinOrderByAggregateInput
  }

  export type AttachmentScalarWhereWithAggregatesInput = {
    AND?: AttachmentScalarWhereWithAggregatesInput | AttachmentScalarWhereWithAggregatesInput[]
    OR?: AttachmentScalarWhereWithAggregatesInput[]
    NOT?: AttachmentScalarWhereWithAggregatesInput | AttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Attachment"> | string
    messageId?: StringWithAggregatesFilter<"Attachment"> | string
    type?: EnumFileTypeWithAggregatesFilter<"Attachment"> | $Enums.FileType
    filename?: StringWithAggregatesFilter<"Attachment"> | string
    data?: StringWithAggregatesFilter<"Attachment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Attachment"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    content?: StringFilter<"Notification"> | string
    userId?: StringNullableFilter<"Notification"> | string | null
    expiresAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    isRead?: BoolFilter<"Notification"> | boolean
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    userId?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    isRead?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    content?: StringFilter<"Notification"> | string
    userId?: StringNullableFilter<"Notification"> | string | null
    expiresAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    isRead?: BoolFilter<"Notification"> | boolean
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    userId?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    isRead?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    content?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
  }

  export type AnnouncementWhereInput = {
    AND?: AnnouncementWhereInput | AnnouncementWhereInput[]
    OR?: AnnouncementWhereInput[]
    NOT?: AnnouncementWhereInput | AnnouncementWhereInput[]
    id?: StringFilter<"Announcement"> | string
    title?: StringFilter<"Announcement"> | string
    content?: StringFilter<"Announcement"> | string
    publisherId?: StringFilter<"Announcement"> | string
    expiresAt?: DateTimeFilter<"Announcement"> | Date | string
    createdAt?: DateTimeFilter<"Announcement"> | Date | string
    isActive?: BoolFilter<"Announcement"> | boolean
    publisher?: XOR<UserScalarRelationFilter, UserWhereInput>
    reads?: AnnouncementReadListRelationFilter
  }

  export type AnnouncementOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    publisherId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    isActive?: SortOrder
    publisher?: UserOrderByWithRelationInput
    reads?: AnnouncementReadOrderByRelationAggregateInput
  }

  export type AnnouncementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnnouncementWhereInput | AnnouncementWhereInput[]
    OR?: AnnouncementWhereInput[]
    NOT?: AnnouncementWhereInput | AnnouncementWhereInput[]
    title?: StringFilter<"Announcement"> | string
    content?: StringFilter<"Announcement"> | string
    publisherId?: StringFilter<"Announcement"> | string
    expiresAt?: DateTimeFilter<"Announcement"> | Date | string
    createdAt?: DateTimeFilter<"Announcement"> | Date | string
    isActive?: BoolFilter<"Announcement"> | boolean
    publisher?: XOR<UserScalarRelationFilter, UserWhereInput>
    reads?: AnnouncementReadListRelationFilter
  }, "id">

  export type AnnouncementOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    publisherId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    isActive?: SortOrder
    _count?: AnnouncementCountOrderByAggregateInput
    _max?: AnnouncementMaxOrderByAggregateInput
    _min?: AnnouncementMinOrderByAggregateInput
  }

  export type AnnouncementScalarWhereWithAggregatesInput = {
    AND?: AnnouncementScalarWhereWithAggregatesInput | AnnouncementScalarWhereWithAggregatesInput[]
    OR?: AnnouncementScalarWhereWithAggregatesInput[]
    NOT?: AnnouncementScalarWhereWithAggregatesInput | AnnouncementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Announcement"> | string
    title?: StringWithAggregatesFilter<"Announcement"> | string
    content?: StringWithAggregatesFilter<"Announcement"> | string
    publisherId?: StringWithAggregatesFilter<"Announcement"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Announcement"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Announcement"> | Date | string
    isActive?: BoolWithAggregatesFilter<"Announcement"> | boolean
  }

  export type AnnouncementReadWhereInput = {
    AND?: AnnouncementReadWhereInput | AnnouncementReadWhereInput[]
    OR?: AnnouncementReadWhereInput[]
    NOT?: AnnouncementReadWhereInput | AnnouncementReadWhereInput[]
    id?: StringFilter<"AnnouncementRead"> | string
    announcementId?: StringFilter<"AnnouncementRead"> | string
    userId?: StringFilter<"AnnouncementRead"> | string
    readAt?: DateTimeFilter<"AnnouncementRead"> | Date | string
    announcement?: XOR<AnnouncementScalarRelationFilter, AnnouncementWhereInput>
  }

  export type AnnouncementReadOrderByWithRelationInput = {
    id?: SortOrder
    announcementId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
    announcement?: AnnouncementOrderByWithRelationInput
  }

  export type AnnouncementReadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    announcementId_userId?: AnnouncementReadAnnouncementIdUserIdCompoundUniqueInput
    AND?: AnnouncementReadWhereInput | AnnouncementReadWhereInput[]
    OR?: AnnouncementReadWhereInput[]
    NOT?: AnnouncementReadWhereInput | AnnouncementReadWhereInput[]
    announcementId?: StringFilter<"AnnouncementRead"> | string
    userId?: StringFilter<"AnnouncementRead"> | string
    readAt?: DateTimeFilter<"AnnouncementRead"> | Date | string
    announcement?: XOR<AnnouncementScalarRelationFilter, AnnouncementWhereInput>
  }, "id" | "announcementId_userId">

  export type AnnouncementReadOrderByWithAggregationInput = {
    id?: SortOrder
    announcementId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
    _count?: AnnouncementReadCountOrderByAggregateInput
    _max?: AnnouncementReadMaxOrderByAggregateInput
    _min?: AnnouncementReadMinOrderByAggregateInput
  }

  export type AnnouncementReadScalarWhereWithAggregatesInput = {
    AND?: AnnouncementReadScalarWhereWithAggregatesInput | AnnouncementReadScalarWhereWithAggregatesInput[]
    OR?: AnnouncementReadScalarWhereWithAggregatesInput[]
    NOT?: AnnouncementReadScalarWhereWithAggregatesInput | AnnouncementReadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AnnouncementRead"> | string
    announcementId?: StringWithAggregatesFilter<"AnnouncementRead"> | string
    userId?: StringWithAggregatesFilter<"AnnouncementRead"> | string
    readAt?: DateTimeWithAggregatesFilter<"AnnouncementRead"> | Date | string
  }

  export type OrganizationRequestWhereInput = {
    AND?: OrganizationRequestWhereInput | OrganizationRequestWhereInput[]
    OR?: OrganizationRequestWhereInput[]
    NOT?: OrganizationRequestWhereInput | OrganizationRequestWhereInput[]
    id?: StringFilter<"OrganizationRequest"> | string
    userId?: StringFilter<"OrganizationRequest"> | string
    cardCode?: StringFilter<"OrganizationRequest"> | string
    status?: EnumRequestStatusFilter<"OrganizationRequest"> | $Enums.RequestStatus
    createdAt?: DateTimeFilter<"OrganizationRequest"> | Date | string
    updatedAt?: DateTimeFilter<"OrganizationRequest"> | Date | string
    reviewedBy?: StringNullableFilter<"OrganizationRequest"> | string | null
    reviewedAt?: DateTimeNullableFilter<"OrganizationRequest"> | Date | string | null
    orgId?: StringNullableFilter<"OrganizationRequest"> | string | null
  }

  export type OrganizationRequestOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    cardCode?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    orgId?: SortOrderInput | SortOrder
  }

  export type OrganizationRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orgId?: string
    AND?: OrganizationRequestWhereInput | OrganizationRequestWhereInput[]
    OR?: OrganizationRequestWhereInput[]
    NOT?: OrganizationRequestWhereInput | OrganizationRequestWhereInput[]
    userId?: StringFilter<"OrganizationRequest"> | string
    cardCode?: StringFilter<"OrganizationRequest"> | string
    status?: EnumRequestStatusFilter<"OrganizationRequest"> | $Enums.RequestStatus
    createdAt?: DateTimeFilter<"OrganizationRequest"> | Date | string
    updatedAt?: DateTimeFilter<"OrganizationRequest"> | Date | string
    reviewedBy?: StringNullableFilter<"OrganizationRequest"> | string | null
    reviewedAt?: DateTimeNullableFilter<"OrganizationRequest"> | Date | string | null
  }, "id" | "orgId">

  export type OrganizationRequestOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    cardCode?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    orgId?: SortOrderInput | SortOrder
    _count?: OrganizationRequestCountOrderByAggregateInput
    _max?: OrganizationRequestMaxOrderByAggregateInput
    _min?: OrganizationRequestMinOrderByAggregateInput
  }

  export type OrganizationRequestScalarWhereWithAggregatesInput = {
    AND?: OrganizationRequestScalarWhereWithAggregatesInput | OrganizationRequestScalarWhereWithAggregatesInput[]
    OR?: OrganizationRequestScalarWhereWithAggregatesInput[]
    NOT?: OrganizationRequestScalarWhereWithAggregatesInput | OrganizationRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrganizationRequest"> | string
    userId?: StringWithAggregatesFilter<"OrganizationRequest"> | string
    cardCode?: StringWithAggregatesFilter<"OrganizationRequest"> | string
    status?: EnumRequestStatusWithAggregatesFilter<"OrganizationRequest"> | $Enums.RequestStatus
    createdAt?: DateTimeWithAggregatesFilter<"OrganizationRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OrganizationRequest"> | Date | string
    reviewedBy?: StringNullableWithAggregatesFilter<"OrganizationRequest"> | string | null
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"OrganizationRequest"> | Date | string | null
    orgId?: StringNullableWithAggregatesFilter<"OrganizationRequest"> | string | null
  }

  export type PendingSubscriptionPaymentWhereInput = {
    AND?: PendingSubscriptionPaymentWhereInput | PendingSubscriptionPaymentWhereInput[]
    OR?: PendingSubscriptionPaymentWhereInput[]
    NOT?: PendingSubscriptionPaymentWhereInput | PendingSubscriptionPaymentWhereInput[]
    id?: StringFilter<"PendingSubscriptionPayment"> | string
    transactionId?: StringFilter<"PendingSubscriptionPayment"> | string
    userId?: StringFilter<"PendingSubscriptionPayment"> | string
    plan?: StringFilter<"PendingSubscriptionPayment"> | string
    name?: StringFilter<"PendingSubscriptionPayment"> | string
    logo?: StringNullableFilter<"PendingSubscriptionPayment"> | string | null
    address?: StringNullableFilter<"PendingSubscriptionPayment"> | string | null
    requestId?: StringNullableFilter<"PendingSubscriptionPayment"> | string | null
    orgId?: StringNullableFilter<"PendingSubscriptionPayment"> | string | null
    type?: StringFilter<"PendingSubscriptionPayment"> | string
    createdAt?: DateTimeFilter<"PendingSubscriptionPayment"> | Date | string
  }

  export type PendingSubscriptionPaymentOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    userId?: SortOrder
    plan?: SortOrder
    name?: SortOrder
    logo?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    requestId?: SortOrderInput | SortOrder
    orgId?: SortOrderInput | SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type PendingSubscriptionPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    transactionId?: string
    AND?: PendingSubscriptionPaymentWhereInput | PendingSubscriptionPaymentWhereInput[]
    OR?: PendingSubscriptionPaymentWhereInput[]
    NOT?: PendingSubscriptionPaymentWhereInput | PendingSubscriptionPaymentWhereInput[]
    userId?: StringFilter<"PendingSubscriptionPayment"> | string
    plan?: StringFilter<"PendingSubscriptionPayment"> | string
    name?: StringFilter<"PendingSubscriptionPayment"> | string
    logo?: StringNullableFilter<"PendingSubscriptionPayment"> | string | null
    address?: StringNullableFilter<"PendingSubscriptionPayment"> | string | null
    requestId?: StringNullableFilter<"PendingSubscriptionPayment"> | string | null
    orgId?: StringNullableFilter<"PendingSubscriptionPayment"> | string | null
    type?: StringFilter<"PendingSubscriptionPayment"> | string
    createdAt?: DateTimeFilter<"PendingSubscriptionPayment"> | Date | string
  }, "id" | "transactionId">

  export type PendingSubscriptionPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    userId?: SortOrder
    plan?: SortOrder
    name?: SortOrder
    logo?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    requestId?: SortOrderInput | SortOrder
    orgId?: SortOrderInput | SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    _count?: PendingSubscriptionPaymentCountOrderByAggregateInput
    _max?: PendingSubscriptionPaymentMaxOrderByAggregateInput
    _min?: PendingSubscriptionPaymentMinOrderByAggregateInput
  }

  export type PendingSubscriptionPaymentScalarWhereWithAggregatesInput = {
    AND?: PendingSubscriptionPaymentScalarWhereWithAggregatesInput | PendingSubscriptionPaymentScalarWhereWithAggregatesInput[]
    OR?: PendingSubscriptionPaymentScalarWhereWithAggregatesInput[]
    NOT?: PendingSubscriptionPaymentScalarWhereWithAggregatesInput | PendingSubscriptionPaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PendingSubscriptionPayment"> | string
    transactionId?: StringWithAggregatesFilter<"PendingSubscriptionPayment"> | string
    userId?: StringWithAggregatesFilter<"PendingSubscriptionPayment"> | string
    plan?: StringWithAggregatesFilter<"PendingSubscriptionPayment"> | string
    name?: StringWithAggregatesFilter<"PendingSubscriptionPayment"> | string
    logo?: StringNullableWithAggregatesFilter<"PendingSubscriptionPayment"> | string | null
    address?: StringNullableWithAggregatesFilter<"PendingSubscriptionPayment"> | string | null
    requestId?: StringNullableWithAggregatesFilter<"PendingSubscriptionPayment"> | string | null
    orgId?: StringNullableWithAggregatesFilter<"PendingSubscriptionPayment"> | string | null
    type?: StringWithAggregatesFilter<"PendingSubscriptionPayment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PendingSubscriptionPayment"> | Date | string
  }

  export type PaymentOrderWhereInput = {
    AND?: PaymentOrderWhereInput | PaymentOrderWhereInput[]
    OR?: PaymentOrderWhereInput[]
    NOT?: PaymentOrderWhereInput | PaymentOrderWhereInput[]
    id?: StringFilter<"PaymentOrder"> | string
    userId?: StringFilter<"PaymentOrder"> | string
    plan?: StringFilter<"PaymentOrder"> | string
    name?: StringFilter<"PaymentOrder"> | string
    logo?: StringNullableFilter<"PaymentOrder"> | string | null
    address?: StringNullableFilter<"PaymentOrder"> | string | null
    requestId?: StringNullableFilter<"PaymentOrder"> | string | null
    orgId?: StringNullableFilter<"PaymentOrder"> | string | null
    type?: StringFilter<"PaymentOrder"> | string
    amountFcfa?: IntFilter<"PaymentOrder"> | number
    status?: EnumPaymentOrderStatusFilter<"PaymentOrder"> | $Enums.PaymentOrderStatus
    approvedBy?: StringNullableFilter<"PaymentOrder"> | string | null
    approvedAt?: DateTimeNullableFilter<"PaymentOrder"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"PaymentOrder"> | Date | string | null
    createdAt?: DateTimeFilter<"PaymentOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentOrder"> | Date | string
  }

  export type PaymentOrderOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    plan?: SortOrder
    name?: SortOrder
    logo?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    requestId?: SortOrderInput | SortOrder
    orgId?: SortOrderInput | SortOrder
    type?: SortOrder
    amountFcfa?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    rejectedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentOrderWhereInput | PaymentOrderWhereInput[]
    OR?: PaymentOrderWhereInput[]
    NOT?: PaymentOrderWhereInput | PaymentOrderWhereInput[]
    userId?: StringFilter<"PaymentOrder"> | string
    plan?: StringFilter<"PaymentOrder"> | string
    name?: StringFilter<"PaymentOrder"> | string
    logo?: StringNullableFilter<"PaymentOrder"> | string | null
    address?: StringNullableFilter<"PaymentOrder"> | string | null
    requestId?: StringNullableFilter<"PaymentOrder"> | string | null
    orgId?: StringNullableFilter<"PaymentOrder"> | string | null
    type?: StringFilter<"PaymentOrder"> | string
    amountFcfa?: IntFilter<"PaymentOrder"> | number
    status?: EnumPaymentOrderStatusFilter<"PaymentOrder"> | $Enums.PaymentOrderStatus
    approvedBy?: StringNullableFilter<"PaymentOrder"> | string | null
    approvedAt?: DateTimeNullableFilter<"PaymentOrder"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"PaymentOrder"> | Date | string | null
    createdAt?: DateTimeFilter<"PaymentOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentOrder"> | Date | string
  }, "id">

  export type PaymentOrderOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    plan?: SortOrder
    name?: SortOrder
    logo?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    requestId?: SortOrderInput | SortOrder
    orgId?: SortOrderInput | SortOrder
    type?: SortOrder
    amountFcfa?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    rejectedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentOrderCountOrderByAggregateInput
    _avg?: PaymentOrderAvgOrderByAggregateInput
    _max?: PaymentOrderMaxOrderByAggregateInput
    _min?: PaymentOrderMinOrderByAggregateInput
    _sum?: PaymentOrderSumOrderByAggregateInput
  }

  export type PaymentOrderScalarWhereWithAggregatesInput = {
    AND?: PaymentOrderScalarWhereWithAggregatesInput | PaymentOrderScalarWhereWithAggregatesInput[]
    OR?: PaymentOrderScalarWhereWithAggregatesInput[]
    NOT?: PaymentOrderScalarWhereWithAggregatesInput | PaymentOrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentOrder"> | string
    userId?: StringWithAggregatesFilter<"PaymentOrder"> | string
    plan?: StringWithAggregatesFilter<"PaymentOrder"> | string
    name?: StringWithAggregatesFilter<"PaymentOrder"> | string
    logo?: StringNullableWithAggregatesFilter<"PaymentOrder"> | string | null
    address?: StringNullableWithAggregatesFilter<"PaymentOrder"> | string | null
    requestId?: StringNullableWithAggregatesFilter<"PaymentOrder"> | string | null
    orgId?: StringNullableWithAggregatesFilter<"PaymentOrder"> | string | null
    type?: StringWithAggregatesFilter<"PaymentOrder"> | string
    amountFcfa?: IntWithAggregatesFilter<"PaymentOrder"> | number
    status?: EnumPaymentOrderStatusWithAggregatesFilter<"PaymentOrder"> | $Enums.PaymentOrderStatus
    approvedBy?: StringNullableWithAggregatesFilter<"PaymentOrder"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"PaymentOrder"> | Date | string | null
    rejectedAt?: DateTimeNullableWithAggregatesFilter<"PaymentOrder"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PaymentOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentOrder"> | Date | string
  }

  export type PaymentSettingWhereInput = {
    AND?: PaymentSettingWhereInput | PaymentSettingWhereInput[]
    OR?: PaymentSettingWhereInput[]
    NOT?: PaymentSettingWhereInput | PaymentSettingWhereInput[]
    id?: StringFilter<"PaymentSetting"> | string
    key?: StringFilter<"PaymentSetting"> | string
    value?: StringFilter<"PaymentSetting"> | string
  }

  export type PaymentSettingOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type PaymentSettingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: PaymentSettingWhereInput | PaymentSettingWhereInput[]
    OR?: PaymentSettingWhereInput[]
    NOT?: PaymentSettingWhereInput | PaymentSettingWhereInput[]
    value?: StringFilter<"PaymentSetting"> | string
  }, "id" | "key">

  export type PaymentSettingOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    _count?: PaymentSettingCountOrderByAggregateInput
    _max?: PaymentSettingMaxOrderByAggregateInput
    _min?: PaymentSettingMinOrderByAggregateInput
  }

  export type PaymentSettingScalarWhereWithAggregatesInput = {
    AND?: PaymentSettingScalarWhereWithAggregatesInput | PaymentSettingScalarWhereWithAggregatesInput[]
    OR?: PaymentSettingScalarWhereWithAggregatesInput[]
    NOT?: PaymentSettingScalarWhereWithAggregatesInput | PaymentSettingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentSetting"> | string
    key?: StringWithAggregatesFilter<"PaymentSetting"> | string
    value?: StringWithAggregatesFilter<"PaymentSetting"> | string
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: StringFilter<"Subscription"> | string
    orgId?: StringFilter<"Subscription"> | string
    plan?: EnumSubscriptionPlanFilter<"Subscription"> | $Enums.SubscriptionPlan
    startDate?: DateTimeFilter<"Subscription"> | Date | string
    endDate?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    maxDepartments?: IntFilter<"Subscription"> | number
    maxMembersPerDept?: IntFilter<"Subscription"> | number
    isActive?: BoolFilter<"Subscription"> | boolean
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    plan?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    maxDepartments?: SortOrder
    maxMembersPerDept?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orgId?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    plan?: EnumSubscriptionPlanFilter<"Subscription"> | $Enums.SubscriptionPlan
    startDate?: DateTimeFilter<"Subscription"> | Date | string
    endDate?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    maxDepartments?: IntFilter<"Subscription"> | number
    maxMembersPerDept?: IntFilter<"Subscription"> | number
    isActive?: BoolFilter<"Subscription"> | boolean
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }, "id" | "orgId">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    plan?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    maxDepartments?: SortOrder
    maxMembersPerDept?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _avg?: SubscriptionAvgOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
    _sum?: SubscriptionSumOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscription"> | string
    orgId?: StringWithAggregatesFilter<"Subscription"> | string
    plan?: EnumSubscriptionPlanWithAggregatesFilter<"Subscription"> | $Enums.SubscriptionPlan
    startDate?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    maxDepartments?: IntWithAggregatesFilter<"Subscription"> | number
    maxMembersPerDept?: IntWithAggregatesFilter<"Subscription"> | number
    isActive?: BoolWithAggregatesFilter<"Subscription"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
  }

  export type EventInvitationWhereInput = {
    AND?: EventInvitationWhereInput | EventInvitationWhereInput[]
    OR?: EventInvitationWhereInput[]
    NOT?: EventInvitationWhereInput | EventInvitationWhereInput[]
    id?: StringFilter<"EventInvitation"> | string
    orgId?: StringFilter<"EventInvitation"> | string
    title?: StringFilter<"EventInvitation"> | string
    description?: StringNullableFilter<"EventInvitation"> | string | null
    eventType?: EnumEventTypeFilter<"EventInvitation"> | $Enums.EventType
    eventDate?: DateTimeFilter<"EventInvitation"> | Date | string
    maxAttendees?: IntFilter<"EventInvitation"> | number
    imageUrl?: StringNullableFilter<"EventInvitation"> | string | null
    token?: StringFilter<"EventInvitation"> | string
    createdBy?: StringFilter<"EventInvitation"> | string
    createdAt?: DateTimeFilter<"EventInvitation"> | Date | string
    updatedAt?: DateTimeFilter<"EventInvitation"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    rsvps?: InvitationRSVPListRelationFilter
    departmentBroadcasts?: EventDepartmentBroadcastListRelationFilter
  }

  export type EventInvitationOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    eventType?: SortOrder
    eventDate?: SortOrder
    maxAttendees?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    token?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    rsvps?: InvitationRSVPOrderByRelationAggregateInput
    departmentBroadcasts?: EventDepartmentBroadcastOrderByRelationAggregateInput
  }

  export type EventInvitationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: EventInvitationWhereInput | EventInvitationWhereInput[]
    OR?: EventInvitationWhereInput[]
    NOT?: EventInvitationWhereInput | EventInvitationWhereInput[]
    orgId?: StringFilter<"EventInvitation"> | string
    title?: StringFilter<"EventInvitation"> | string
    description?: StringNullableFilter<"EventInvitation"> | string | null
    eventType?: EnumEventTypeFilter<"EventInvitation"> | $Enums.EventType
    eventDate?: DateTimeFilter<"EventInvitation"> | Date | string
    maxAttendees?: IntFilter<"EventInvitation"> | number
    imageUrl?: StringNullableFilter<"EventInvitation"> | string | null
    createdBy?: StringFilter<"EventInvitation"> | string
    createdAt?: DateTimeFilter<"EventInvitation"> | Date | string
    updatedAt?: DateTimeFilter<"EventInvitation"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    rsvps?: InvitationRSVPListRelationFilter
    departmentBroadcasts?: EventDepartmentBroadcastListRelationFilter
  }, "id" | "token">

  export type EventInvitationOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    eventType?: SortOrder
    eventDate?: SortOrder
    maxAttendees?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    token?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EventInvitationCountOrderByAggregateInput
    _avg?: EventInvitationAvgOrderByAggregateInput
    _max?: EventInvitationMaxOrderByAggregateInput
    _min?: EventInvitationMinOrderByAggregateInput
    _sum?: EventInvitationSumOrderByAggregateInput
  }

  export type EventInvitationScalarWhereWithAggregatesInput = {
    AND?: EventInvitationScalarWhereWithAggregatesInput | EventInvitationScalarWhereWithAggregatesInput[]
    OR?: EventInvitationScalarWhereWithAggregatesInput[]
    NOT?: EventInvitationScalarWhereWithAggregatesInput | EventInvitationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EventInvitation"> | string
    orgId?: StringWithAggregatesFilter<"EventInvitation"> | string
    title?: StringWithAggregatesFilter<"EventInvitation"> | string
    description?: StringNullableWithAggregatesFilter<"EventInvitation"> | string | null
    eventType?: EnumEventTypeWithAggregatesFilter<"EventInvitation"> | $Enums.EventType
    eventDate?: DateTimeWithAggregatesFilter<"EventInvitation"> | Date | string
    maxAttendees?: IntWithAggregatesFilter<"EventInvitation"> | number
    imageUrl?: StringNullableWithAggregatesFilter<"EventInvitation"> | string | null
    token?: StringWithAggregatesFilter<"EventInvitation"> | string
    createdBy?: StringWithAggregatesFilter<"EventInvitation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EventInvitation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EventInvitation"> | Date | string
  }

  export type EventDepartmentBroadcastWhereInput = {
    AND?: EventDepartmentBroadcastWhereInput | EventDepartmentBroadcastWhereInput[]
    OR?: EventDepartmentBroadcastWhereInput[]
    NOT?: EventDepartmentBroadcastWhereInput | EventDepartmentBroadcastWhereInput[]
    id?: StringFilter<"EventDepartmentBroadcast"> | string
    eventId?: StringFilter<"EventDepartmentBroadcast"> | string
    deptId?: StringFilter<"EventDepartmentBroadcast"> | string
    createdAt?: DateTimeFilter<"EventDepartmentBroadcast"> | Date | string
    event?: XOR<EventInvitationScalarRelationFilter, EventInvitationWhereInput>
    department?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
  }

  export type EventDepartmentBroadcastOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    deptId?: SortOrder
    createdAt?: SortOrder
    event?: EventInvitationOrderByWithRelationInput
    department?: DepartmentOrderByWithRelationInput
  }

  export type EventDepartmentBroadcastWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    eventId_deptId?: EventDepartmentBroadcastEventIdDeptIdCompoundUniqueInput
    AND?: EventDepartmentBroadcastWhereInput | EventDepartmentBroadcastWhereInput[]
    OR?: EventDepartmentBroadcastWhereInput[]
    NOT?: EventDepartmentBroadcastWhereInput | EventDepartmentBroadcastWhereInput[]
    eventId?: StringFilter<"EventDepartmentBroadcast"> | string
    deptId?: StringFilter<"EventDepartmentBroadcast"> | string
    createdAt?: DateTimeFilter<"EventDepartmentBroadcast"> | Date | string
    event?: XOR<EventInvitationScalarRelationFilter, EventInvitationWhereInput>
    department?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
  }, "id" | "eventId_deptId">

  export type EventDepartmentBroadcastOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    deptId?: SortOrder
    createdAt?: SortOrder
    _count?: EventDepartmentBroadcastCountOrderByAggregateInput
    _max?: EventDepartmentBroadcastMaxOrderByAggregateInput
    _min?: EventDepartmentBroadcastMinOrderByAggregateInput
  }

  export type EventDepartmentBroadcastScalarWhereWithAggregatesInput = {
    AND?: EventDepartmentBroadcastScalarWhereWithAggregatesInput | EventDepartmentBroadcastScalarWhereWithAggregatesInput[]
    OR?: EventDepartmentBroadcastScalarWhereWithAggregatesInput[]
    NOT?: EventDepartmentBroadcastScalarWhereWithAggregatesInput | EventDepartmentBroadcastScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EventDepartmentBroadcast"> | string
    eventId?: StringWithAggregatesFilter<"EventDepartmentBroadcast"> | string
    deptId?: StringWithAggregatesFilter<"EventDepartmentBroadcast"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EventDepartmentBroadcast"> | Date | string
  }

  export type InvitationRSVPWhereInput = {
    AND?: InvitationRSVPWhereInput | InvitationRSVPWhereInput[]
    OR?: InvitationRSVPWhereInput[]
    NOT?: InvitationRSVPWhereInput | InvitationRSVPWhereInput[]
    id?: StringFilter<"InvitationRSVP"> | string
    eventId?: StringFilter<"InvitationRSVP"> | string
    name?: StringFilter<"InvitationRSVP"> | string
    phone?: StringFilter<"InvitationRSVP"> | string
    createdAt?: DateTimeFilter<"InvitationRSVP"> | Date | string
    event?: XOR<EventInvitationScalarRelationFilter, EventInvitationWhereInput>
  }

  export type InvitationRSVPOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    event?: EventInvitationOrderByWithRelationInput
  }

  export type InvitationRSVPWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvitationRSVPWhereInput | InvitationRSVPWhereInput[]
    OR?: InvitationRSVPWhereInput[]
    NOT?: InvitationRSVPWhereInput | InvitationRSVPWhereInput[]
    eventId?: StringFilter<"InvitationRSVP"> | string
    name?: StringFilter<"InvitationRSVP"> | string
    phone?: StringFilter<"InvitationRSVP"> | string
    createdAt?: DateTimeFilter<"InvitationRSVP"> | Date | string
    event?: XOR<EventInvitationScalarRelationFilter, EventInvitationWhereInput>
  }, "id">

  export type InvitationRSVPOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    _count?: InvitationRSVPCountOrderByAggregateInput
    _max?: InvitationRSVPMaxOrderByAggregateInput
    _min?: InvitationRSVPMinOrderByAggregateInput
  }

  export type InvitationRSVPScalarWhereWithAggregatesInput = {
    AND?: InvitationRSVPScalarWhereWithAggregatesInput | InvitationRSVPScalarWhereWithAggregatesInput[]
    OR?: InvitationRSVPScalarWhereWithAggregatesInput[]
    NOT?: InvitationRSVPScalarWhereWithAggregatesInput | InvitationRSVPScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InvitationRSVP"> | string
    eventId?: StringWithAggregatesFilter<"InvitationRSVP"> | string
    name?: StringWithAggregatesFilter<"InvitationRSVP"> | string
    phone?: StringWithAggregatesFilter<"InvitationRSVP"> | string
    createdAt?: DateTimeWithAggregatesFilter<"InvitationRSVP"> | Date | string
  }

  export type UserPageWhereInput = {
    AND?: UserPageWhereInput | UserPageWhereInput[]
    OR?: UserPageWhereInput[]
    NOT?: UserPageWhereInput | UserPageWhereInput[]
    id?: StringFilter<"UserPage"> | string
    userId?: StringFilter<"UserPage"> | string
    handle?: StringFilter<"UserPage"> | string
    bio?: StringNullableFilter<"UserPage"> | string | null
    createdAt?: DateTimeFilter<"UserPage"> | Date | string
    updatedAt?: DateTimeFilter<"UserPage"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    posts?: PostListRelationFilter
  }

  export type UserPageOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    handle?: SortOrder
    bio?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    posts?: PostOrderByRelationAggregateInput
  }

  export type UserPageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    handle?: string
    AND?: UserPageWhereInput | UserPageWhereInput[]
    OR?: UserPageWhereInput[]
    NOT?: UserPageWhereInput | UserPageWhereInput[]
    bio?: StringNullableFilter<"UserPage"> | string | null
    createdAt?: DateTimeFilter<"UserPage"> | Date | string
    updatedAt?: DateTimeFilter<"UserPage"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    posts?: PostListRelationFilter
  }, "id" | "userId" | "handle">

  export type UserPageOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    handle?: SortOrder
    bio?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserPageCountOrderByAggregateInput
    _max?: UserPageMaxOrderByAggregateInput
    _min?: UserPageMinOrderByAggregateInput
  }

  export type UserPageScalarWhereWithAggregatesInput = {
    AND?: UserPageScalarWhereWithAggregatesInput | UserPageScalarWhereWithAggregatesInput[]
    OR?: UserPageScalarWhereWithAggregatesInput[]
    NOT?: UserPageScalarWhereWithAggregatesInput | UserPageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserPage"> | string
    userId?: StringWithAggregatesFilter<"UserPage"> | string
    handle?: StringWithAggregatesFilter<"UserPage"> | string
    bio?: StringNullableWithAggregatesFilter<"UserPage"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserPage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserPage"> | Date | string
  }

  export type PostWhereInput = {
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    id?: StringFilter<"Post"> | string
    pageId?: StringFilter<"Post"> | string
    type?: EnumPostTypeFilter<"Post"> | $Enums.PostType
    content?: StringFilter<"Post"> | string
    imageUrl?: StringNullableFilter<"Post"> | string | null
    caption?: StringNullableFilter<"Post"> | string | null
    reference?: StringNullableFilter<"Post"> | string | null
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    page?: XOR<UserPageScalarRelationFilter, UserPageWhereInput>
    likes?: LikeListRelationFilter
    comments?: CommentListRelationFilter
    postReads?: PostReadListRelationFilter
  }

  export type PostOrderByWithRelationInput = {
    id?: SortOrder
    pageId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    page?: UserPageOrderByWithRelationInput
    likes?: LikeOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    postReads?: PostReadOrderByRelationAggregateInput
  }

  export type PostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    pageId?: StringFilter<"Post"> | string
    type?: EnumPostTypeFilter<"Post"> | $Enums.PostType
    content?: StringFilter<"Post"> | string
    imageUrl?: StringNullableFilter<"Post"> | string | null
    caption?: StringNullableFilter<"Post"> | string | null
    reference?: StringNullableFilter<"Post"> | string | null
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    page?: XOR<UserPageScalarRelationFilter, UserPageWhereInput>
    likes?: LikeListRelationFilter
    comments?: CommentListRelationFilter
    postReads?: PostReadListRelationFilter
  }, "id">

  export type PostOrderByWithAggregationInput = {
    id?: SortOrder
    pageId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PostCountOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    OR?: PostScalarWhereWithAggregatesInput[]
    NOT?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Post"> | string
    pageId?: StringWithAggregatesFilter<"Post"> | string
    type?: EnumPostTypeWithAggregatesFilter<"Post"> | $Enums.PostType
    content?: StringWithAggregatesFilter<"Post"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"Post"> | string | null
    caption?: StringNullableWithAggregatesFilter<"Post"> | string | null
    reference?: StringNullableWithAggregatesFilter<"Post"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
  }

  export type LikeWhereInput = {
    AND?: LikeWhereInput | LikeWhereInput[]
    OR?: LikeWhereInput[]
    NOT?: LikeWhereInput | LikeWhereInput[]
    id?: StringFilter<"Like"> | string
    postId?: StringFilter<"Like"> | string
    userId?: StringFilter<"Like"> | string
    createdAt?: DateTimeFilter<"Like"> | Date | string
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type LikeOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    post?: PostOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type LikeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    postId_userId?: LikePostIdUserIdCompoundUniqueInput
    AND?: LikeWhereInput | LikeWhereInput[]
    OR?: LikeWhereInput[]
    NOT?: LikeWhereInput | LikeWhereInput[]
    postId?: StringFilter<"Like"> | string
    userId?: StringFilter<"Like"> | string
    createdAt?: DateTimeFilter<"Like"> | Date | string
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "postId_userId">

  export type LikeOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: LikeCountOrderByAggregateInput
    _max?: LikeMaxOrderByAggregateInput
    _min?: LikeMinOrderByAggregateInput
  }

  export type LikeScalarWhereWithAggregatesInput = {
    AND?: LikeScalarWhereWithAggregatesInput | LikeScalarWhereWithAggregatesInput[]
    OR?: LikeScalarWhereWithAggregatesInput[]
    NOT?: LikeScalarWhereWithAggregatesInput | LikeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Like"> | string
    postId?: StringWithAggregatesFilter<"Like"> | string
    userId?: StringWithAggregatesFilter<"Like"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Like"> | Date | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    postId?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    parentId?: StringNullableFilter<"Comment"> | string | null
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    parent?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
    replies?: CommentListRelationFilter
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrderInput | SortOrder
    post?: PostOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    parent?: CommentOrderByWithRelationInput
    replies?: CommentOrderByRelationAggregateInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    postId?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    parentId?: StringNullableFilter<"Comment"> | string | null
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    parent?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
    replies?: CommentListRelationFilter
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrderInput | SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    postId?: StringWithAggregatesFilter<"Comment"> | string
    userId?: StringWithAggregatesFilter<"Comment"> | string
    content?: StringWithAggregatesFilter<"Comment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    parentId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
  }

  export type PostReadWhereInput = {
    AND?: PostReadWhereInput | PostReadWhereInput[]
    OR?: PostReadWhereInput[]
    NOT?: PostReadWhereInput | PostReadWhereInput[]
    id?: StringFilter<"PostRead"> | string
    userId?: StringFilter<"PostRead"> | string
    postId?: StringFilter<"PostRead"> | string
    readAt?: DateTimeFilter<"PostRead"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
  }

  export type PostReadOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    readAt?: SortOrder
    user?: UserOrderByWithRelationInput
    post?: PostOrderByWithRelationInput
  }

  export type PostReadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_postId?: PostReadUserIdPostIdCompoundUniqueInput
    AND?: PostReadWhereInput | PostReadWhereInput[]
    OR?: PostReadWhereInput[]
    NOT?: PostReadWhereInput | PostReadWhereInput[]
    userId?: StringFilter<"PostRead"> | string
    postId?: StringFilter<"PostRead"> | string
    readAt?: DateTimeFilter<"PostRead"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
  }, "id" | "userId_postId">

  export type PostReadOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    readAt?: SortOrder
    _count?: PostReadCountOrderByAggregateInput
    _max?: PostReadMaxOrderByAggregateInput
    _min?: PostReadMinOrderByAggregateInput
  }

  export type PostReadScalarWhereWithAggregatesInput = {
    AND?: PostReadScalarWhereWithAggregatesInput | PostReadScalarWhereWithAggregatesInput[]
    OR?: PostReadScalarWhereWithAggregatesInput[]
    NOT?: PostReadScalarWhereWithAggregatesInput | PostReadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PostRead"> | string
    userId?: StringWithAggregatesFilter<"PostRead"> | string
    postId?: StringWithAggregatesFilter<"PostRead"> | string
    readAt?: DateTimeWithAggregatesFilter<"PostRead"> | Date | string
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    status?: EnumTaskStatusFilter<"Task"> | $Enums.TaskStatus
    priority?: EnumTaskPriorityFilter<"Task"> | $Enums.TaskPriority
    startDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    deptId?: StringFilter<"Task"> | string
    creatorId?: StringFilter<"Task"> | string
    assigneeId?: StringFilter<"Task"> | string
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    department?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    assignee?: XOR<UserScalarRelationFilter, UserWhereInput>
    messages?: TaskMessageListRelationFilter
    attachments?: TaskAttachmentListRelationFilter
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    startDate?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    deptId?: SortOrder
    creatorId?: SortOrder
    assigneeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    department?: DepartmentOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    assignee?: UserOrderByWithRelationInput
    messages?: TaskMessageOrderByRelationAggregateInput
    attachments?: TaskAttachmentOrderByRelationAggregateInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    status?: EnumTaskStatusFilter<"Task"> | $Enums.TaskStatus
    priority?: EnumTaskPriorityFilter<"Task"> | $Enums.TaskPriority
    startDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    deptId?: StringFilter<"Task"> | string
    creatorId?: StringFilter<"Task"> | string
    assigneeId?: StringFilter<"Task"> | string
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    department?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    assignee?: XOR<UserScalarRelationFilter, UserWhereInput>
    messages?: TaskMessageListRelationFilter
    attachments?: TaskAttachmentListRelationFilter
  }, "id">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    startDate?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    deptId?: SortOrder
    creatorId?: SortOrder
    assigneeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TaskCountOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Task"> | string
    title?: StringWithAggregatesFilter<"Task"> | string
    description?: StringNullableWithAggregatesFilter<"Task"> | string | null
    status?: EnumTaskStatusWithAggregatesFilter<"Task"> | $Enums.TaskStatus
    priority?: EnumTaskPriorityWithAggregatesFilter<"Task"> | $Enums.TaskPriority
    startDate?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    dueDate?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    deptId?: StringWithAggregatesFilter<"Task"> | string
    creatorId?: StringWithAggregatesFilter<"Task"> | string
    assigneeId?: StringWithAggregatesFilter<"Task"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
  }

  export type TaskMessageWhereInput = {
    AND?: TaskMessageWhereInput | TaskMessageWhereInput[]
    OR?: TaskMessageWhereInput[]
    NOT?: TaskMessageWhereInput | TaskMessageWhereInput[]
    id?: StringFilter<"TaskMessage"> | string
    taskId?: StringFilter<"TaskMessage"> | string
    senderId?: StringFilter<"TaskMessage"> | string
    content?: StringFilter<"TaskMessage"> | string
    createdAt?: DateTimeFilter<"TaskMessage"> | Date | string
    updatedAt?: DateTimeFilter<"TaskMessage"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    attachments?: TaskAttachmentListRelationFilter
  }

  export type TaskMessageOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    task?: TaskOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
    attachments?: TaskAttachmentOrderByRelationAggregateInput
  }

  export type TaskMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskMessageWhereInput | TaskMessageWhereInput[]
    OR?: TaskMessageWhereInput[]
    NOT?: TaskMessageWhereInput | TaskMessageWhereInput[]
    taskId?: StringFilter<"TaskMessage"> | string
    senderId?: StringFilter<"TaskMessage"> | string
    content?: StringFilter<"TaskMessage"> | string
    createdAt?: DateTimeFilter<"TaskMessage"> | Date | string
    updatedAt?: DateTimeFilter<"TaskMessage"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    attachments?: TaskAttachmentListRelationFilter
  }, "id">

  export type TaskMessageOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TaskMessageCountOrderByAggregateInput
    _max?: TaskMessageMaxOrderByAggregateInput
    _min?: TaskMessageMinOrderByAggregateInput
  }

  export type TaskMessageScalarWhereWithAggregatesInput = {
    AND?: TaskMessageScalarWhereWithAggregatesInput | TaskMessageScalarWhereWithAggregatesInput[]
    OR?: TaskMessageScalarWhereWithAggregatesInput[]
    NOT?: TaskMessageScalarWhereWithAggregatesInput | TaskMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaskMessage"> | string
    taskId?: StringWithAggregatesFilter<"TaskMessage"> | string
    senderId?: StringWithAggregatesFilter<"TaskMessage"> | string
    content?: StringWithAggregatesFilter<"TaskMessage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TaskMessage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TaskMessage"> | Date | string
  }

  export type TaskAttachmentWhereInput = {
    AND?: TaskAttachmentWhereInput | TaskAttachmentWhereInput[]
    OR?: TaskAttachmentWhereInput[]
    NOT?: TaskAttachmentWhereInput | TaskAttachmentWhereInput[]
    id?: StringFilter<"TaskAttachment"> | string
    taskId?: StringFilter<"TaskAttachment"> | string
    messageId?: StringNullableFilter<"TaskAttachment"> | string | null
    uploaderId?: StringFilter<"TaskAttachment"> | string
    filename?: StringFilter<"TaskAttachment"> | string
    url?: StringFilter<"TaskAttachment"> | string
    fileType?: StringNullableFilter<"TaskAttachment"> | string | null
    size?: IntNullableFilter<"TaskAttachment"> | number | null
    createdAt?: DateTimeFilter<"TaskAttachment"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    message?: XOR<TaskMessageNullableScalarRelationFilter, TaskMessageWhereInput> | null
  }

  export type TaskAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    messageId?: SortOrderInput | SortOrder
    uploaderId?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    fileType?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    task?: TaskOrderByWithRelationInput
    message?: TaskMessageOrderByWithRelationInput
  }

  export type TaskAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskAttachmentWhereInput | TaskAttachmentWhereInput[]
    OR?: TaskAttachmentWhereInput[]
    NOT?: TaskAttachmentWhereInput | TaskAttachmentWhereInput[]
    taskId?: StringFilter<"TaskAttachment"> | string
    messageId?: StringNullableFilter<"TaskAttachment"> | string | null
    uploaderId?: StringFilter<"TaskAttachment"> | string
    filename?: StringFilter<"TaskAttachment"> | string
    url?: StringFilter<"TaskAttachment"> | string
    fileType?: StringNullableFilter<"TaskAttachment"> | string | null
    size?: IntNullableFilter<"TaskAttachment"> | number | null
    createdAt?: DateTimeFilter<"TaskAttachment"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    message?: XOR<TaskMessageNullableScalarRelationFilter, TaskMessageWhereInput> | null
  }, "id">

  export type TaskAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    messageId?: SortOrderInput | SortOrder
    uploaderId?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    fileType?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TaskAttachmentCountOrderByAggregateInput
    _avg?: TaskAttachmentAvgOrderByAggregateInput
    _max?: TaskAttachmentMaxOrderByAggregateInput
    _min?: TaskAttachmentMinOrderByAggregateInput
    _sum?: TaskAttachmentSumOrderByAggregateInput
  }

  export type TaskAttachmentScalarWhereWithAggregatesInput = {
    AND?: TaskAttachmentScalarWhereWithAggregatesInput | TaskAttachmentScalarWhereWithAggregatesInput[]
    OR?: TaskAttachmentScalarWhereWithAggregatesInput[]
    NOT?: TaskAttachmentScalarWhereWithAggregatesInput | TaskAttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaskAttachment"> | string
    taskId?: StringWithAggregatesFilter<"TaskAttachment"> | string
    messageId?: StringNullableWithAggregatesFilter<"TaskAttachment"> | string | null
    uploaderId?: StringWithAggregatesFilter<"TaskAttachment"> | string
    filename?: StringWithAggregatesFilter<"TaskAttachment"> | string
    url?: StringWithAggregatesFilter<"TaskAttachment"> | string
    fileType?: StringNullableWithAggregatesFilter<"TaskAttachment"> | string | null
    size?: IntNullableWithAggregatesFilter<"TaskAttachment"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"TaskAttachment"> | Date | string
  }

  export type DepartmentMonthlyReportWhereInput = {
    AND?: DepartmentMonthlyReportWhereInput | DepartmentMonthlyReportWhereInput[]
    OR?: DepartmentMonthlyReportWhereInput[]
    NOT?: DepartmentMonthlyReportWhereInput | DepartmentMonthlyReportWhereInput[]
    id?: StringFilter<"DepartmentMonthlyReport"> | string
    deptId?: StringFilter<"DepartmentMonthlyReport"> | string
    userId?: StringFilter<"DepartmentMonthlyReport"> | string
    month?: StringFilter<"DepartmentMonthlyReport"> | string
    content?: StringFilter<"DepartmentMonthlyReport"> | string
    createdAt?: DateTimeFilter<"DepartmentMonthlyReport"> | Date | string
    updatedAt?: DateTimeFilter<"DepartmentMonthlyReport"> | Date | string
    department?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DepartmentMonthlyReportOrderByWithRelationInput = {
    id?: SortOrder
    deptId?: SortOrder
    userId?: SortOrder
    month?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    department?: DepartmentOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type DepartmentMonthlyReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    deptId_userId_month?: DepartmentMonthlyReportDeptIdUserIdMonthCompoundUniqueInput
    AND?: DepartmentMonthlyReportWhereInput | DepartmentMonthlyReportWhereInput[]
    OR?: DepartmentMonthlyReportWhereInput[]
    NOT?: DepartmentMonthlyReportWhereInput | DepartmentMonthlyReportWhereInput[]
    deptId?: StringFilter<"DepartmentMonthlyReport"> | string
    userId?: StringFilter<"DepartmentMonthlyReport"> | string
    month?: StringFilter<"DepartmentMonthlyReport"> | string
    content?: StringFilter<"DepartmentMonthlyReport"> | string
    createdAt?: DateTimeFilter<"DepartmentMonthlyReport"> | Date | string
    updatedAt?: DateTimeFilter<"DepartmentMonthlyReport"> | Date | string
    department?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "deptId_userId_month">

  export type DepartmentMonthlyReportOrderByWithAggregationInput = {
    id?: SortOrder
    deptId?: SortOrder
    userId?: SortOrder
    month?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DepartmentMonthlyReportCountOrderByAggregateInput
    _max?: DepartmentMonthlyReportMaxOrderByAggregateInput
    _min?: DepartmentMonthlyReportMinOrderByAggregateInput
  }

  export type DepartmentMonthlyReportScalarWhereWithAggregatesInput = {
    AND?: DepartmentMonthlyReportScalarWhereWithAggregatesInput | DepartmentMonthlyReportScalarWhereWithAggregatesInput[]
    OR?: DepartmentMonthlyReportScalarWhereWithAggregatesInput[]
    NOT?: DepartmentMonthlyReportScalarWhereWithAggregatesInput | DepartmentMonthlyReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DepartmentMonthlyReport"> | string
    deptId?: StringWithAggregatesFilter<"DepartmentMonthlyReport"> | string
    userId?: StringWithAggregatesFilter<"DepartmentMonthlyReport"> | string
    month?: StringWithAggregatesFilter<"DepartmentMonthlyReport"> | string
    content?: StringWithAggregatesFilter<"DepartmentMonthlyReport"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DepartmentMonthlyReport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DepartmentMonthlyReport"> | Date | string
  }

  export type PushSubscriptionWhereInput = {
    AND?: PushSubscriptionWhereInput | PushSubscriptionWhereInput[]
    OR?: PushSubscriptionWhereInput[]
    NOT?: PushSubscriptionWhereInput | PushSubscriptionWhereInput[]
    id?: StringFilter<"PushSubscription"> | string
    userId?: StringFilter<"PushSubscription"> | string
    endpoint?: StringFilter<"PushSubscription"> | string
    p256dh?: StringFilter<"PushSubscription"> | string
    auth?: StringFilter<"PushSubscription"> | string
    createdAt?: DateTimeFilter<"PushSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"PushSubscription"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PushSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    endpoint?: SortOrder
    p256dh?: SortOrder
    auth?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PushSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    endpoint?: string
    AND?: PushSubscriptionWhereInput | PushSubscriptionWhereInput[]
    OR?: PushSubscriptionWhereInput[]
    NOT?: PushSubscriptionWhereInput | PushSubscriptionWhereInput[]
    userId?: StringFilter<"PushSubscription"> | string
    p256dh?: StringFilter<"PushSubscription"> | string
    auth?: StringFilter<"PushSubscription"> | string
    createdAt?: DateTimeFilter<"PushSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"PushSubscription"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "endpoint">

  export type PushSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    endpoint?: SortOrder
    p256dh?: SortOrder
    auth?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PushSubscriptionCountOrderByAggregateInput
    _max?: PushSubscriptionMaxOrderByAggregateInput
    _min?: PushSubscriptionMinOrderByAggregateInput
  }

  export type PushSubscriptionScalarWhereWithAggregatesInput = {
    AND?: PushSubscriptionScalarWhereWithAggregatesInput | PushSubscriptionScalarWhereWithAggregatesInput[]
    OR?: PushSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: PushSubscriptionScalarWhereWithAggregatesInput | PushSubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PushSubscription"> | string
    userId?: StringWithAggregatesFilter<"PushSubscription"> | string
    endpoint?: StringWithAggregatesFilter<"PushSubscription"> | string
    p256dh?: StringWithAggregatesFilter<"PushSubscription"> | string
    auth?: StringWithAggregatesFilter<"PushSubscription"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PushSubscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PushSubscription"> | Date | string
  }

  export type UserPersonalTaskWhereInput = {
    AND?: UserPersonalTaskWhereInput | UserPersonalTaskWhereInput[]
    OR?: UserPersonalTaskWhereInput[]
    NOT?: UserPersonalTaskWhereInput | UserPersonalTaskWhereInput[]
    id?: StringFilter<"UserPersonalTask"> | string
    userId?: StringFilter<"UserPersonalTask"> | string
    title?: StringFilter<"UserPersonalTask"> | string
    description?: StringNullableFilter<"UserPersonalTask"> | string | null
    status?: EnumPersonalTaskStatusFilter<"UserPersonalTask"> | $Enums.PersonalTaskStatus
    priority?: EnumPersonalTaskPriorityFilter<"UserPersonalTask"> | $Enums.PersonalTaskPriority
    dueDate?: DateTimeNullableFilter<"UserPersonalTask"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"UserPersonalTask"> | Date | string | null
    createdAt?: DateTimeFilter<"UserPersonalTask"> | Date | string
    updatedAt?: DateTimeFilter<"UserPersonalTask"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserPersonalTaskOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserPersonalTaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserPersonalTaskWhereInput | UserPersonalTaskWhereInput[]
    OR?: UserPersonalTaskWhereInput[]
    NOT?: UserPersonalTaskWhereInput | UserPersonalTaskWhereInput[]
    userId?: StringFilter<"UserPersonalTask"> | string
    title?: StringFilter<"UserPersonalTask"> | string
    description?: StringNullableFilter<"UserPersonalTask"> | string | null
    status?: EnumPersonalTaskStatusFilter<"UserPersonalTask"> | $Enums.PersonalTaskStatus
    priority?: EnumPersonalTaskPriorityFilter<"UserPersonalTask"> | $Enums.PersonalTaskPriority
    dueDate?: DateTimeNullableFilter<"UserPersonalTask"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"UserPersonalTask"> | Date | string | null
    createdAt?: DateTimeFilter<"UserPersonalTask"> | Date | string
    updatedAt?: DateTimeFilter<"UserPersonalTask"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserPersonalTaskOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserPersonalTaskCountOrderByAggregateInput
    _max?: UserPersonalTaskMaxOrderByAggregateInput
    _min?: UserPersonalTaskMinOrderByAggregateInput
  }

  export type UserPersonalTaskScalarWhereWithAggregatesInput = {
    AND?: UserPersonalTaskScalarWhereWithAggregatesInput | UserPersonalTaskScalarWhereWithAggregatesInput[]
    OR?: UserPersonalTaskScalarWhereWithAggregatesInput[]
    NOT?: UserPersonalTaskScalarWhereWithAggregatesInput | UserPersonalTaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserPersonalTask"> | string
    userId?: StringWithAggregatesFilter<"UserPersonalTask"> | string
    title?: StringWithAggregatesFilter<"UserPersonalTask"> | string
    description?: StringNullableWithAggregatesFilter<"UserPersonalTask"> | string | null
    status?: EnumPersonalTaskStatusWithAggregatesFilter<"UserPersonalTask"> | $Enums.PersonalTaskStatus
    priority?: EnumPersonalTaskPriorityWithAggregatesFilter<"UserPersonalTask"> | $Enums.PersonalTaskPriority
    dueDate?: DateTimeNullableWithAggregatesFilter<"UserPersonalTask"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"UserPersonalTask"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserPersonalTask"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserPersonalTask"> | Date | string
  }

  export type UserFinancialGoalWhereInput = {
    AND?: UserFinancialGoalWhereInput | UserFinancialGoalWhereInput[]
    OR?: UserFinancialGoalWhereInput[]
    NOT?: UserFinancialGoalWhereInput | UserFinancialGoalWhereInput[]
    id?: StringFilter<"UserFinancialGoal"> | string
    userId?: StringFilter<"UserFinancialGoal"> | string
    type?: EnumFinancialGoalTypeFilter<"UserFinancialGoal"> | $Enums.FinancialGoalType
    year?: IntNullableFilter<"UserFinancialGoal"> | number | null
    targetItem?: StringNullableFilter<"UserFinancialGoal"> | string | null
    targetAmount?: FloatFilter<"UserFinancialGoal"> | number
    targetDate?: DateTimeNullableFilter<"UserFinancialGoal"> | Date | string | null
    label?: StringNullableFilter<"UserFinancialGoal"> | string | null
    createdAt?: DateTimeFilter<"UserFinancialGoal"> | Date | string
    updatedAt?: DateTimeFilter<"UserFinancialGoal"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    progress?: UserMonthlyProgressListRelationFilter
  }

  export type UserFinancialGoalOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    year?: SortOrderInput | SortOrder
    targetItem?: SortOrderInput | SortOrder
    targetAmount?: SortOrder
    targetDate?: SortOrderInput | SortOrder
    label?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    progress?: UserMonthlyProgressOrderByRelationAggregateInput
  }

  export type UserFinancialGoalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserFinancialGoalWhereInput | UserFinancialGoalWhereInput[]
    OR?: UserFinancialGoalWhereInput[]
    NOT?: UserFinancialGoalWhereInput | UserFinancialGoalWhereInput[]
    userId?: StringFilter<"UserFinancialGoal"> | string
    type?: EnumFinancialGoalTypeFilter<"UserFinancialGoal"> | $Enums.FinancialGoalType
    year?: IntNullableFilter<"UserFinancialGoal"> | number | null
    targetItem?: StringNullableFilter<"UserFinancialGoal"> | string | null
    targetAmount?: FloatFilter<"UserFinancialGoal"> | number
    targetDate?: DateTimeNullableFilter<"UserFinancialGoal"> | Date | string | null
    label?: StringNullableFilter<"UserFinancialGoal"> | string | null
    createdAt?: DateTimeFilter<"UserFinancialGoal"> | Date | string
    updatedAt?: DateTimeFilter<"UserFinancialGoal"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    progress?: UserMonthlyProgressListRelationFilter
  }, "id">

  export type UserFinancialGoalOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    year?: SortOrderInput | SortOrder
    targetItem?: SortOrderInput | SortOrder
    targetAmount?: SortOrder
    targetDate?: SortOrderInput | SortOrder
    label?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserFinancialGoalCountOrderByAggregateInput
    _avg?: UserFinancialGoalAvgOrderByAggregateInput
    _max?: UserFinancialGoalMaxOrderByAggregateInput
    _min?: UserFinancialGoalMinOrderByAggregateInput
    _sum?: UserFinancialGoalSumOrderByAggregateInput
  }

  export type UserFinancialGoalScalarWhereWithAggregatesInput = {
    AND?: UserFinancialGoalScalarWhereWithAggregatesInput | UserFinancialGoalScalarWhereWithAggregatesInput[]
    OR?: UserFinancialGoalScalarWhereWithAggregatesInput[]
    NOT?: UserFinancialGoalScalarWhereWithAggregatesInput | UserFinancialGoalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserFinancialGoal"> | string
    userId?: StringWithAggregatesFilter<"UserFinancialGoal"> | string
    type?: EnumFinancialGoalTypeWithAggregatesFilter<"UserFinancialGoal"> | $Enums.FinancialGoalType
    year?: IntNullableWithAggregatesFilter<"UserFinancialGoal"> | number | null
    targetItem?: StringNullableWithAggregatesFilter<"UserFinancialGoal"> | string | null
    targetAmount?: FloatWithAggregatesFilter<"UserFinancialGoal"> | number
    targetDate?: DateTimeNullableWithAggregatesFilter<"UserFinancialGoal"> | Date | string | null
    label?: StringNullableWithAggregatesFilter<"UserFinancialGoal"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserFinancialGoal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserFinancialGoal"> | Date | string
  }

  export type UserFinancialProfileWhereInput = {
    AND?: UserFinancialProfileWhereInput | UserFinancialProfileWhereInput[]
    OR?: UserFinancialProfileWhereInput[]
    NOT?: UserFinancialProfileWhereInput | UserFinancialProfileWhereInput[]
    id?: StringFilter<"UserFinancialProfile"> | string
    userId?: StringFilter<"UserFinancialProfile"> | string
    monthlySalary?: FloatFilter<"UserFinancialProfile"> | number
    supplementaryIncome?: FloatFilter<"UserFinancialProfile"> | number
    currency?: StringFilter<"UserFinancialProfile"> | string
    preferredSavingsRate?: FloatNullableFilter<"UserFinancialProfile"> | number | null
    createdAt?: DateTimeFilter<"UserFinancialProfile"> | Date | string
    updatedAt?: DateTimeFilter<"UserFinancialProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserFinancialProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    monthlySalary?: SortOrder
    supplementaryIncome?: SortOrder
    currency?: SortOrder
    preferredSavingsRate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserFinancialProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserFinancialProfileWhereInput | UserFinancialProfileWhereInput[]
    OR?: UserFinancialProfileWhereInput[]
    NOT?: UserFinancialProfileWhereInput | UserFinancialProfileWhereInput[]
    monthlySalary?: FloatFilter<"UserFinancialProfile"> | number
    supplementaryIncome?: FloatFilter<"UserFinancialProfile"> | number
    currency?: StringFilter<"UserFinancialProfile"> | string
    preferredSavingsRate?: FloatNullableFilter<"UserFinancialProfile"> | number | null
    createdAt?: DateTimeFilter<"UserFinancialProfile"> | Date | string
    updatedAt?: DateTimeFilter<"UserFinancialProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserFinancialProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    monthlySalary?: SortOrder
    supplementaryIncome?: SortOrder
    currency?: SortOrder
    preferredSavingsRate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserFinancialProfileCountOrderByAggregateInput
    _avg?: UserFinancialProfileAvgOrderByAggregateInput
    _max?: UserFinancialProfileMaxOrderByAggregateInput
    _min?: UserFinancialProfileMinOrderByAggregateInput
    _sum?: UserFinancialProfileSumOrderByAggregateInput
  }

  export type UserFinancialProfileScalarWhereWithAggregatesInput = {
    AND?: UserFinancialProfileScalarWhereWithAggregatesInput | UserFinancialProfileScalarWhereWithAggregatesInput[]
    OR?: UserFinancialProfileScalarWhereWithAggregatesInput[]
    NOT?: UserFinancialProfileScalarWhereWithAggregatesInput | UserFinancialProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserFinancialProfile"> | string
    userId?: StringWithAggregatesFilter<"UserFinancialProfile"> | string
    monthlySalary?: FloatWithAggregatesFilter<"UserFinancialProfile"> | number
    supplementaryIncome?: FloatWithAggregatesFilter<"UserFinancialProfile"> | number
    currency?: StringWithAggregatesFilter<"UserFinancialProfile"> | string
    preferredSavingsRate?: FloatNullableWithAggregatesFilter<"UserFinancialProfile"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"UserFinancialProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserFinancialProfile"> | Date | string
  }

  export type UserMonthlyStatementWhereInput = {
    AND?: UserMonthlyStatementWhereInput | UserMonthlyStatementWhereInput[]
    OR?: UserMonthlyStatementWhereInput[]
    NOT?: UserMonthlyStatementWhereInput | UserMonthlyStatementWhereInput[]
    id?: StringFilter<"UserMonthlyStatement"> | string
    userId?: StringFilter<"UserMonthlyStatement"> | string
    year?: IntFilter<"UserMonthlyStatement"> | number
    month?: IntFilter<"UserMonthlyStatement"> | number
    salaryReceived?: FloatFilter<"UserMonthlyStatement"> | number
    supplementaryIncome?: FloatFilter<"UserMonthlyStatement"> | number
    totalExpenses?: FloatFilter<"UserMonthlyStatement"> | number
    notes?: StringNullableFilter<"UserMonthlyStatement"> | string | null
    createdAt?: DateTimeFilter<"UserMonthlyStatement"> | Date | string
    updatedAt?: DateTimeFilter<"UserMonthlyStatement"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserMonthlyStatementOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    year?: SortOrder
    month?: SortOrder
    salaryReceived?: SortOrder
    supplementaryIncome?: SortOrder
    totalExpenses?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserMonthlyStatementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_year_month?: UserMonthlyStatementUserIdYearMonthCompoundUniqueInput
    AND?: UserMonthlyStatementWhereInput | UserMonthlyStatementWhereInput[]
    OR?: UserMonthlyStatementWhereInput[]
    NOT?: UserMonthlyStatementWhereInput | UserMonthlyStatementWhereInput[]
    userId?: StringFilter<"UserMonthlyStatement"> | string
    year?: IntFilter<"UserMonthlyStatement"> | number
    month?: IntFilter<"UserMonthlyStatement"> | number
    salaryReceived?: FloatFilter<"UserMonthlyStatement"> | number
    supplementaryIncome?: FloatFilter<"UserMonthlyStatement"> | number
    totalExpenses?: FloatFilter<"UserMonthlyStatement"> | number
    notes?: StringNullableFilter<"UserMonthlyStatement"> | string | null
    createdAt?: DateTimeFilter<"UserMonthlyStatement"> | Date | string
    updatedAt?: DateTimeFilter<"UserMonthlyStatement"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_year_month">

  export type UserMonthlyStatementOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    year?: SortOrder
    month?: SortOrder
    salaryReceived?: SortOrder
    supplementaryIncome?: SortOrder
    totalExpenses?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserMonthlyStatementCountOrderByAggregateInput
    _avg?: UserMonthlyStatementAvgOrderByAggregateInput
    _max?: UserMonthlyStatementMaxOrderByAggregateInput
    _min?: UserMonthlyStatementMinOrderByAggregateInput
    _sum?: UserMonthlyStatementSumOrderByAggregateInput
  }

  export type UserMonthlyStatementScalarWhereWithAggregatesInput = {
    AND?: UserMonthlyStatementScalarWhereWithAggregatesInput | UserMonthlyStatementScalarWhereWithAggregatesInput[]
    OR?: UserMonthlyStatementScalarWhereWithAggregatesInput[]
    NOT?: UserMonthlyStatementScalarWhereWithAggregatesInput | UserMonthlyStatementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserMonthlyStatement"> | string
    userId?: StringWithAggregatesFilter<"UserMonthlyStatement"> | string
    year?: IntWithAggregatesFilter<"UserMonthlyStatement"> | number
    month?: IntWithAggregatesFilter<"UserMonthlyStatement"> | number
    salaryReceived?: FloatWithAggregatesFilter<"UserMonthlyStatement"> | number
    supplementaryIncome?: FloatWithAggregatesFilter<"UserMonthlyStatement"> | number
    totalExpenses?: FloatWithAggregatesFilter<"UserMonthlyStatement"> | number
    notes?: StringNullableWithAggregatesFilter<"UserMonthlyStatement"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserMonthlyStatement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserMonthlyStatement"> | Date | string
  }

  export type UserFinancialEntryWhereInput = {
    AND?: UserFinancialEntryWhereInput | UserFinancialEntryWhereInput[]
    OR?: UserFinancialEntryWhereInput[]
    NOT?: UserFinancialEntryWhereInput | UserFinancialEntryWhereInput[]
    id?: StringFilter<"UserFinancialEntry"> | string
    userId?: StringFilter<"UserFinancialEntry"> | string
    year?: IntFilter<"UserFinancialEntry"> | number
    month?: IntFilter<"UserFinancialEntry"> | number
    type?: EnumFinancialEntryTypeFilter<"UserFinancialEntry"> | $Enums.FinancialEntryType
    amount?: FloatFilter<"UserFinancialEntry"> | number
    note?: StringNullableFilter<"UserFinancialEntry"> | string | null
    isConfirmed?: BoolFilter<"UserFinancialEntry"> | boolean
    createdAt?: DateTimeFilter<"UserFinancialEntry"> | Date | string
    updatedAt?: DateTimeFilter<"UserFinancialEntry"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserFinancialEntryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    year?: SortOrder
    month?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    note?: SortOrderInput | SortOrder
    isConfirmed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserFinancialEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserFinancialEntryWhereInput | UserFinancialEntryWhereInput[]
    OR?: UserFinancialEntryWhereInput[]
    NOT?: UserFinancialEntryWhereInput | UserFinancialEntryWhereInput[]
    userId?: StringFilter<"UserFinancialEntry"> | string
    year?: IntFilter<"UserFinancialEntry"> | number
    month?: IntFilter<"UserFinancialEntry"> | number
    type?: EnumFinancialEntryTypeFilter<"UserFinancialEntry"> | $Enums.FinancialEntryType
    amount?: FloatFilter<"UserFinancialEntry"> | number
    note?: StringNullableFilter<"UserFinancialEntry"> | string | null
    isConfirmed?: BoolFilter<"UserFinancialEntry"> | boolean
    createdAt?: DateTimeFilter<"UserFinancialEntry"> | Date | string
    updatedAt?: DateTimeFilter<"UserFinancialEntry"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserFinancialEntryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    year?: SortOrder
    month?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    note?: SortOrderInput | SortOrder
    isConfirmed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserFinancialEntryCountOrderByAggregateInput
    _avg?: UserFinancialEntryAvgOrderByAggregateInput
    _max?: UserFinancialEntryMaxOrderByAggregateInput
    _min?: UserFinancialEntryMinOrderByAggregateInput
    _sum?: UserFinancialEntrySumOrderByAggregateInput
  }

  export type UserFinancialEntryScalarWhereWithAggregatesInput = {
    AND?: UserFinancialEntryScalarWhereWithAggregatesInput | UserFinancialEntryScalarWhereWithAggregatesInput[]
    OR?: UserFinancialEntryScalarWhereWithAggregatesInput[]
    NOT?: UserFinancialEntryScalarWhereWithAggregatesInput | UserFinancialEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserFinancialEntry"> | string
    userId?: StringWithAggregatesFilter<"UserFinancialEntry"> | string
    year?: IntWithAggregatesFilter<"UserFinancialEntry"> | number
    month?: IntWithAggregatesFilter<"UserFinancialEntry"> | number
    type?: EnumFinancialEntryTypeWithAggregatesFilter<"UserFinancialEntry"> | $Enums.FinancialEntryType
    amount?: FloatWithAggregatesFilter<"UserFinancialEntry"> | number
    note?: StringNullableWithAggregatesFilter<"UserFinancialEntry"> | string | null
    isConfirmed?: BoolWithAggregatesFilter<"UserFinancialEntry"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserFinancialEntry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserFinancialEntry"> | Date | string
  }

  export type UserMonthlyProgressWhereInput = {
    AND?: UserMonthlyProgressWhereInput | UserMonthlyProgressWhereInput[]
    OR?: UserMonthlyProgressWhereInput[]
    NOT?: UserMonthlyProgressWhereInput | UserMonthlyProgressWhereInput[]
    id?: StringFilter<"UserMonthlyProgress"> | string
    goalId?: StringFilter<"UserMonthlyProgress"> | string
    year?: IntFilter<"UserMonthlyProgress"> | number
    month?: IntFilter<"UserMonthlyProgress"> | number
    amount?: FloatFilter<"UserMonthlyProgress"> | number
    notes?: StringNullableFilter<"UserMonthlyProgress"> | string | null
    createdAt?: DateTimeFilter<"UserMonthlyProgress"> | Date | string
    updatedAt?: DateTimeFilter<"UserMonthlyProgress"> | Date | string
    goal?: XOR<UserFinancialGoalScalarRelationFilter, UserFinancialGoalWhereInput>
  }

  export type UserMonthlyProgressOrderByWithRelationInput = {
    id?: SortOrder
    goalId?: SortOrder
    year?: SortOrder
    month?: SortOrder
    amount?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    goal?: UserFinancialGoalOrderByWithRelationInput
  }

  export type UserMonthlyProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserMonthlyProgressWhereInput | UserMonthlyProgressWhereInput[]
    OR?: UserMonthlyProgressWhereInput[]
    NOT?: UserMonthlyProgressWhereInput | UserMonthlyProgressWhereInput[]
    goalId?: StringFilter<"UserMonthlyProgress"> | string
    year?: IntFilter<"UserMonthlyProgress"> | number
    month?: IntFilter<"UserMonthlyProgress"> | number
    amount?: FloatFilter<"UserMonthlyProgress"> | number
    notes?: StringNullableFilter<"UserMonthlyProgress"> | string | null
    createdAt?: DateTimeFilter<"UserMonthlyProgress"> | Date | string
    updatedAt?: DateTimeFilter<"UserMonthlyProgress"> | Date | string
    goal?: XOR<UserFinancialGoalScalarRelationFilter, UserFinancialGoalWhereInput>
  }, "id">

  export type UserMonthlyProgressOrderByWithAggregationInput = {
    id?: SortOrder
    goalId?: SortOrder
    year?: SortOrder
    month?: SortOrder
    amount?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserMonthlyProgressCountOrderByAggregateInput
    _avg?: UserMonthlyProgressAvgOrderByAggregateInput
    _max?: UserMonthlyProgressMaxOrderByAggregateInput
    _min?: UserMonthlyProgressMinOrderByAggregateInput
    _sum?: UserMonthlyProgressSumOrderByAggregateInput
  }

  export type UserMonthlyProgressScalarWhereWithAggregatesInput = {
    AND?: UserMonthlyProgressScalarWhereWithAggregatesInput | UserMonthlyProgressScalarWhereWithAggregatesInput[]
    OR?: UserMonthlyProgressScalarWhereWithAggregatesInput[]
    NOT?: UserMonthlyProgressScalarWhereWithAggregatesInput | UserMonthlyProgressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserMonthlyProgress"> | string
    goalId?: StringWithAggregatesFilter<"UserMonthlyProgress"> | string
    year?: IntWithAggregatesFilter<"UserMonthlyProgress"> | number
    month?: IntWithAggregatesFilter<"UserMonthlyProgress"> | number
    amount?: FloatWithAggregatesFilter<"UserMonthlyProgress"> | number
    notes?: StringNullableWithAggregatesFilter<"UserMonthlyProgress"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserMonthlyProgress"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserMonthlyProgress"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberCreateNestedManyWithoutUserInput
    userPage?: UserPageCreateNestedOneWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    postReads?: PostReadCreateNestedManyWithoutUserInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    invitations?: UserInvitationCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementUncheckedCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberUncheckedCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    userPage?: UserPageUncheckedCreateNestedOneWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    postReads?: PostReadUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageUncheckedCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingUncheckedCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollUncheckedCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionUncheckedCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitations?: UserInvitationUncheckedCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskUncheckedCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalUncheckedCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileUncheckedCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementUncheckedCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUpdateManyWithoutUserNestedInput
    userPage?: UserPageUpdateOneWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    postReads?: PostReadUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUncheckedUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    userPage?: UserPageUncheckedUpdateOneWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    postReads?: PostReadUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUncheckedUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUncheckedUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUncheckedUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUncheckedUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUncheckedUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUncheckedUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUncheckedUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUncheckedUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUncheckedUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInvitationCreateInput = {
    id?: string
    token: string
    status?: $Enums.InvitationStatus
    title: string
    description?: string | null
    imageBase64?: string | null
    type?: $Enums.InvitationType
    date: Date | string
    location: string
    maxGuests?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInvitationsInput
    guests?: InvitationGuestCreateNestedManyWithoutInvitationInput
  }

  export type UserInvitationUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    status?: $Enums.InvitationStatus
    title: string
    description?: string | null
    imageBase64?: string | null
    type?: $Enums.InvitationType
    date: Date | string
    location: string
    maxGuests?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    guests?: InvitationGuestUncheckedCreateNestedManyWithoutInvitationInput
  }

  export type UserInvitationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageBase64?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInvitationTypeFieldUpdateOperationsInput | $Enums.InvitationType
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInvitationsNestedInput
    guests?: InvitationGuestUpdateManyWithoutInvitationNestedInput
  }

  export type UserInvitationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageBase64?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInvitationTypeFieldUpdateOperationsInput | $Enums.InvitationType
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guests?: InvitationGuestUncheckedUpdateManyWithoutInvitationNestedInput
  }

  export type UserInvitationCreateManyInput = {
    id?: string
    userId: string
    token: string
    status?: $Enums.InvitationStatus
    title: string
    description?: string | null
    imageBase64?: string | null
    type?: $Enums.InvitationType
    date: Date | string
    location: string
    maxGuests?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserInvitationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageBase64?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInvitationTypeFieldUpdateOperationsInput | $Enums.InvitationType
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInvitationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageBase64?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInvitationTypeFieldUpdateOperationsInput | $Enums.InvitationType
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationGuestCreateInput = {
    id?: string
    name: string
    phone: string
    confirmedAt?: Date | string
    invitation: UserInvitationCreateNestedOneWithoutGuestsInput
  }

  export type InvitationGuestUncheckedCreateInput = {
    id?: string
    invitationId: string
    name: string
    phone: string
    confirmedAt?: Date | string
  }

  export type InvitationGuestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    confirmedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitation?: UserInvitationUpdateOneRequiredWithoutGuestsNestedInput
  }

  export type InvitationGuestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invitationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    confirmedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationGuestCreateManyInput = {
    id?: string
    invitationId: string
    name: string
    phone: string
    confirmedAt?: Date | string
  }

  export type InvitationGuestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    confirmedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationGuestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invitationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    confirmedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowCreateInput = {
    id?: string
    createdAt?: Date | string
    follower: UserCreateNestedOneWithoutFollowingInput
    following: UserCreateNestedOneWithoutFollowersInput
  }

  export type FollowUncheckedCreateInput = {
    id?: string
    followerId: string
    followingId: string
    createdAt?: Date | string
  }

  export type FollowUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    follower?: UserUpdateOneRequiredWithoutFollowingNestedInput
    following?: UserUpdateOneRequiredWithoutFollowersNestedInput
  }

  export type FollowUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    followingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowCreateManyInput = {
    id?: string
    followerId: string
    followingId: string
    createdAt?: Date | string
  }

  export type FollowUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    followingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationCreateInput = {
    id?: string
    name: string
    code: string
    logo?: string | null
    address?: string | null
    isSuspended?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    departments?: DepartmentCreateNestedManyWithoutOrganizationInput
    members?: OrganizationMemberCreateNestedManyWithoutOrganizationInput
    subscription?: SubscriptionCreateNestedOneWithoutOrganizationInput
    events?: EventInvitationCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    logo?: string | null
    address?: string | null
    isSuspended?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    departments?: DepartmentUncheckedCreateNestedManyWithoutOrganizationInput
    members?: OrganizationMemberUncheckedCreateNestedManyWithoutOrganizationInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutOrganizationInput
    events?: EventInvitationUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    departments?: DepartmentUpdateManyWithoutOrganizationNestedInput
    members?: OrganizationMemberUpdateManyWithoutOrganizationNestedInput
    subscription?: SubscriptionUpdateOneWithoutOrganizationNestedInput
    events?: EventInvitationUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    departments?: DepartmentUncheckedUpdateManyWithoutOrganizationNestedInput
    members?: OrganizationMemberUncheckedUpdateManyWithoutOrganizationNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutOrganizationNestedInput
    events?: EventInvitationUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateManyInput = {
    id?: string
    name: string
    code: string
    logo?: string | null
    address?: string | null
    isSuspended?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
  }

  export type OrganizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
  }

  export type OrganizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
  }

  export type OrganizationMemberCreateInput = {
    id?: string
    role?: $Enums.OrgRole
    joinedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutOrgMembershipsInput
  }

  export type OrganizationMemberUncheckedCreateInput = {
    id?: string
    userId: string
    orgId: string
    role?: $Enums.OrgRole
    joinedAt?: Date | string
  }

  export type OrganizationMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumOrgRoleFieldUpdateOperationsInput | $Enums.OrgRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutOrgMembershipsNestedInput
  }

  export type OrganizationMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    role?: EnumOrgRoleFieldUpdateOperationsInput | $Enums.OrgRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationMemberCreateManyInput = {
    id?: string
    userId: string
    orgId: string
    role?: $Enums.OrgRole
    joinedAt?: Date | string
  }

  export type OrganizationMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumOrgRoleFieldUpdateOperationsInput | $Enums.OrgRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    role?: EnumOrgRoleFieldUpdateOperationsInput | $Enums.OrgRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentCreateInput = {
    id?: string
    name: string
    publicKey: string
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutDepartmentsInput
    head?: UserCreateNestedOneWithoutHeadedDepartmentsInput
    members?: DepartmentMemberCreateNestedManyWithoutDepartmentInput
    conversations?: GroupCreateNestedManyWithoutDepartmentInput
    tasks?: TaskCreateNestedManyWithoutDepartmentInput
    eventBroadcasts?: EventDepartmentBroadcastCreateNestedManyWithoutDepartmentInput
    monthlyReports?: DepartmentMonthlyReportCreateNestedManyWithoutDepartmentInput
    goals?: DepartmentGoalCreateNestedManyWithoutDepartmentInput
    meetings?: DepartmentMeetingCreateNestedManyWithoutDepartmentInput
    polls?: DepartmentPollCreateNestedManyWithoutDepartmentInput
    teamDecisions?: TeamDecisionCreateNestedManyWithoutDepartmentInput
    documents?: DepartmentDocumentCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateInput = {
    id?: string
    name: string
    orgId: string
    publicKey: string
    headId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: DepartmentMemberUncheckedCreateNestedManyWithoutDepartmentInput
    conversations?: GroupUncheckedCreateNestedManyWithoutDepartmentInput
    tasks?: TaskUncheckedCreateNestedManyWithoutDepartmentInput
    eventBroadcasts?: EventDepartmentBroadcastUncheckedCreateNestedManyWithoutDepartmentInput
    monthlyReports?: DepartmentMonthlyReportUncheckedCreateNestedManyWithoutDepartmentInput
    goals?: DepartmentGoalUncheckedCreateNestedManyWithoutDepartmentInput
    meetings?: DepartmentMeetingUncheckedCreateNestedManyWithoutDepartmentInput
    polls?: DepartmentPollUncheckedCreateNestedManyWithoutDepartmentInput
    teamDecisions?: TeamDecisionUncheckedCreateNestedManyWithoutDepartmentInput
    documents?: DepartmentDocumentUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutDepartmentsNestedInput
    head?: UserUpdateOneWithoutHeadedDepartmentsNestedInput
    members?: DepartmentMemberUpdateManyWithoutDepartmentNestedInput
    conversations?: GroupUpdateManyWithoutDepartmentNestedInput
    tasks?: TaskUpdateManyWithoutDepartmentNestedInput
    eventBroadcasts?: EventDepartmentBroadcastUpdateManyWithoutDepartmentNestedInput
    monthlyReports?: DepartmentMonthlyReportUpdateManyWithoutDepartmentNestedInput
    goals?: DepartmentGoalUpdateManyWithoutDepartmentNestedInput
    meetings?: DepartmentMeetingUpdateManyWithoutDepartmentNestedInput
    polls?: DepartmentPollUpdateManyWithoutDepartmentNestedInput
    teamDecisions?: TeamDecisionUpdateManyWithoutDepartmentNestedInput
    documents?: DepartmentDocumentUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    headId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: DepartmentMemberUncheckedUpdateManyWithoutDepartmentNestedInput
    conversations?: GroupUncheckedUpdateManyWithoutDepartmentNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutDepartmentNestedInput
    eventBroadcasts?: EventDepartmentBroadcastUncheckedUpdateManyWithoutDepartmentNestedInput
    monthlyReports?: DepartmentMonthlyReportUncheckedUpdateManyWithoutDepartmentNestedInput
    goals?: DepartmentGoalUncheckedUpdateManyWithoutDepartmentNestedInput
    meetings?: DepartmentMeetingUncheckedUpdateManyWithoutDepartmentNestedInput
    polls?: DepartmentPollUncheckedUpdateManyWithoutDepartmentNestedInput
    teamDecisions?: TeamDecisionUncheckedUpdateManyWithoutDepartmentNestedInput
    documents?: DepartmentDocumentUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentCreateManyInput = {
    id?: string
    name: string
    orgId: string
    publicKey: string
    headId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    headId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentDocumentCreateInput = {
    id?: string
    filename: string
    type: $Enums.FileType
    data: string
    createdAt?: Date | string
    department: DepartmentCreateNestedOneWithoutDocumentsInput
    uploader: UserCreateNestedOneWithoutUploadedDepartmentDocumentsInput
  }

  export type DepartmentDocumentUncheckedCreateInput = {
    id?: string
    deptId: string
    filename: string
    type: $Enums.FileType
    data: string
    uploadedBy: string
    createdAt?: Date | string
  }

  export type DepartmentDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    data?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneRequiredWithoutDocumentsNestedInput
    uploader?: UserUpdateOneRequiredWithoutUploadedDepartmentDocumentsNestedInput
  }

  export type DepartmentDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deptId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    data?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentDocumentCreateManyInput = {
    id?: string
    deptId: string
    filename: string
    type: $Enums.FileType
    data: string
    uploadedBy: string
    createdAt?: Date | string
  }

  export type DepartmentDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    data?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    deptId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    data?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentGoalCreateInput = {
    id?: string
    title: string
    description?: string | null
    targetValue?: number | null
    currentValue?: number
    period: string
    periodKey: string
    createdAt?: Date | string
    updatedAt?: Date | string
    department: DepartmentCreateNestedOneWithoutGoalsInput
  }

  export type DepartmentGoalUncheckedCreateInput = {
    id?: string
    deptId: string
    title: string
    description?: string | null
    targetValue?: number | null
    currentValue?: number
    period: string
    periodKey: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentGoalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    period?: StringFieldUpdateOperationsInput | string
    periodKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneRequiredWithoutGoalsNestedInput
  }

  export type DepartmentGoalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deptId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    period?: StringFieldUpdateOperationsInput | string
    periodKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentGoalCreateManyInput = {
    id?: string
    deptId: string
    title: string
    description?: string | null
    targetValue?: number | null
    currentValue?: number
    period: string
    periodKey: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentGoalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    period?: StringFieldUpdateOperationsInput | string
    periodKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentGoalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    deptId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    period?: StringFieldUpdateOperationsInput | string
    periodKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentMeetingCreateInput = {
    id?: string
    title: string
    description?: string | null
    agenda?: string | null
    meetingDate: Date | string
    location?: string | null
    minutes?: string | null
    minutesAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department: DepartmentCreateNestedOneWithoutMeetingsInput
    creator: UserCreateNestedOneWithoutCreatedMeetingsInput
  }

  export type DepartmentMeetingUncheckedCreateInput = {
    id?: string
    deptId: string
    title: string
    description?: string | null
    agenda?: string | null
    meetingDate: Date | string
    location?: string | null
    createdBy: string
    minutes?: string | null
    minutesAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentMeetingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    meetingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    minutes?: NullableStringFieldUpdateOperationsInput | string | null
    minutesAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneRequiredWithoutMeetingsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedMeetingsNestedInput
  }

  export type DepartmentMeetingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deptId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    meetingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    minutes?: NullableStringFieldUpdateOperationsInput | string | null
    minutesAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentMeetingCreateManyInput = {
    id?: string
    deptId: string
    title: string
    description?: string | null
    agenda?: string | null
    meetingDate: Date | string
    location?: string | null
    createdBy: string
    minutes?: string | null
    minutesAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentMeetingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    meetingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    minutes?: NullableStringFieldUpdateOperationsInput | string | null
    minutesAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentMeetingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    deptId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    meetingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    minutes?: NullableStringFieldUpdateOperationsInput | string | null
    minutesAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentPollCreateInput = {
    id?: string
    question: string
    options: JsonNullValueInput | InputJsonValue
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department: DepartmentCreateNestedOneWithoutPollsInput
    creator: UserCreateNestedOneWithoutCreatedPollsInput
    votes?: PollVoteCreateNestedManyWithoutPollInput
  }

  export type DepartmentPollUncheckedCreateInput = {
    id?: string
    deptId: string
    question: string
    options: JsonNullValueInput | InputJsonValue
    endDate?: Date | string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: PollVoteUncheckedCreateNestedManyWithoutPollInput
  }

  export type DepartmentPollUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneRequiredWithoutPollsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedPollsNestedInput
    votes?: PollVoteUpdateManyWithoutPollNestedInput
  }

  export type DepartmentPollUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deptId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: PollVoteUncheckedUpdateManyWithoutPollNestedInput
  }

  export type DepartmentPollCreateManyInput = {
    id?: string
    deptId: string
    question: string
    options: JsonNullValueInput | InputJsonValue
    endDate?: Date | string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentPollUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentPollUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    deptId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PollVoteCreateInput = {
    id?: string
    optionIndex: number
    createdAt?: Date | string
    poll: DepartmentPollCreateNestedOneWithoutVotesInput
    user: UserCreateNestedOneWithoutPollVotesInput
  }

  export type PollVoteUncheckedCreateInput = {
    id?: string
    pollId: string
    userId: string
    optionIndex: number
    createdAt?: Date | string
  }

  export type PollVoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    optionIndex?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    poll?: DepartmentPollUpdateOneRequiredWithoutVotesNestedInput
    user?: UserUpdateOneRequiredWithoutPollVotesNestedInput
  }

  export type PollVoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pollId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    optionIndex?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PollVoteCreateManyInput = {
    id?: string
    pollId: string
    userId: string
    optionIndex: number
    createdAt?: Date | string
  }

  export type PollVoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    optionIndex?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PollVoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    pollId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    optionIndex?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamDecisionCreateInput = {
    id?: string
    title: string
    description?: string | null
    voteDeadline?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    department: DepartmentCreateNestedOneWithoutTeamDecisionsInput
    creator: UserCreateNestedOneWithoutCreatedDecisionsInput
    votes?: DecisionVoteCreateNestedManyWithoutDecisionInput
  }

  export type TeamDecisionUncheckedCreateInput = {
    id?: string
    deptId: string
    title: string
    description?: string | null
    voteDeadline?: Date | string | null
    status?: string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: DecisionVoteUncheckedCreateNestedManyWithoutDecisionInput
  }

  export type TeamDecisionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    voteDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneRequiredWithoutTeamDecisionsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedDecisionsNestedInput
    votes?: DecisionVoteUpdateManyWithoutDecisionNestedInput
  }

  export type TeamDecisionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deptId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    voteDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: DecisionVoteUncheckedUpdateManyWithoutDecisionNestedInput
  }

  export type TeamDecisionCreateManyInput = {
    id?: string
    deptId: string
    title: string
    description?: string | null
    voteDeadline?: Date | string | null
    status?: string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamDecisionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    voteDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamDecisionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    deptId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    voteDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DecisionVoteCreateInput = {
    id?: string
    vote: $Enums.DecisionVoteType
    createdAt?: Date | string
    decision: TeamDecisionCreateNestedOneWithoutVotesInput
    user: UserCreateNestedOneWithoutDecisionVotesInput
  }

  export type DecisionVoteUncheckedCreateInput = {
    id?: string
    decisionId: string
    userId: string
    vote: $Enums.DecisionVoteType
    createdAt?: Date | string
  }

  export type DecisionVoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vote?: EnumDecisionVoteTypeFieldUpdateOperationsInput | $Enums.DecisionVoteType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    decision?: TeamDecisionUpdateOneRequiredWithoutVotesNestedInput
    user?: UserUpdateOneRequiredWithoutDecisionVotesNestedInput
  }

  export type DecisionVoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    decisionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vote?: EnumDecisionVoteTypeFieldUpdateOperationsInput | $Enums.DecisionVoteType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DecisionVoteCreateManyInput = {
    id?: string
    decisionId: string
    userId: string
    vote: $Enums.DecisionVoteType
    createdAt?: Date | string
  }

  export type DecisionVoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    vote?: EnumDecisionVoteTypeFieldUpdateOperationsInput | $Enums.DecisionVoteType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DecisionVoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    decisionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vote?: EnumDecisionVoteTypeFieldUpdateOperationsInput | $Enums.DecisionVoteType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentMemberCreateInput = {
    id?: string
    encryptedDeptKey: string
    department: DepartmentCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutDeptMembershipsInput
  }

  export type DepartmentMemberUncheckedCreateInput = {
    id?: string
    deptId: string
    userId: string
    encryptedDeptKey: string
  }

  export type DepartmentMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    encryptedDeptKey?: StringFieldUpdateOperationsInput | string
    department?: DepartmentUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutDeptMembershipsNestedInput
  }

  export type DepartmentMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deptId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    encryptedDeptKey?: StringFieldUpdateOperationsInput | string
  }

  export type DepartmentMemberCreateManyInput = {
    id?: string
    deptId: string
    userId: string
    encryptedDeptKey: string
  }

  export type DepartmentMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    encryptedDeptKey?: StringFieldUpdateOperationsInput | string
  }

  export type DepartmentMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    deptId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    encryptedDeptKey?: StringFieldUpdateOperationsInput | string
  }

  export type GroupCreateInput = {
    id?: string
    name?: string | null
    isDirect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutConversationsInput
    members?: GroupMemberCreateNestedManyWithoutGroupInput
    messages?: MessageCreateNestedManyWithoutGroupInput
    documents?: GroupDocumentCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateInput = {
    id?: string
    name?: string | null
    isDirect?: boolean
    deptId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: GroupMemberUncheckedCreateNestedManyWithoutGroupInput
    messages?: MessageUncheckedCreateNestedManyWithoutGroupInput
    documents?: GroupDocumentUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isDirect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutConversationsNestedInput
    members?: GroupMemberUpdateManyWithoutGroupNestedInput
    messages?: MessageUpdateManyWithoutGroupNestedInput
    documents?: GroupDocumentUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isDirect?: BoolFieldUpdateOperationsInput | boolean
    deptId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: GroupMemberUncheckedUpdateManyWithoutGroupNestedInput
    messages?: MessageUncheckedUpdateManyWithoutGroupNestedInput
    documents?: GroupDocumentUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type GroupCreateManyInput = {
    id?: string
    name?: string | null
    isDirect?: boolean
    deptId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isDirect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isDirect?: BoolFieldUpdateOperationsInput | boolean
    deptId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupDocumentCreateInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    group: GroupCreateNestedOneWithoutDocumentsInput
    notes?: GroupNoteCreateNestedManyWithoutDocumentInput
  }

  export type GroupDocumentUncheckedCreateInput = {
    id?: string
    groupId: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: GroupNoteUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type GroupDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: GroupUpdateOneRequiredWithoutDocumentsNestedInput
    notes?: GroupNoteUpdateManyWithoutDocumentNestedInput
  }

  export type GroupDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: GroupNoteUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type GroupDocumentCreateManyInput = {
    id?: string
    groupId: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupNoteCreateInput = {
    id?: string
    title: string
    content: string
    textSize?: $Enums.NoteTextSize
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    document: GroupDocumentCreateNestedOneWithoutNotesInput
    creator: UserCreateNestedOneWithoutGroupNotesInput
  }

  export type GroupNoteUncheckedCreateInput = {
    id?: string
    documentId: string
    title: string
    content: string
    textSize?: $Enums.NoteTextSize
    order?: number
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupNoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    textSize?: EnumNoteTextSizeFieldUpdateOperationsInput | $Enums.NoteTextSize
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: GroupDocumentUpdateOneRequiredWithoutNotesNestedInput
    creator?: UserUpdateOneRequiredWithoutGroupNotesNestedInput
  }

  export type GroupNoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    textSize?: EnumNoteTextSizeFieldUpdateOperationsInput | $Enums.NoteTextSize
    order?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupNoteCreateManyInput = {
    id?: string
    documentId: string
    title: string
    content: string
    textSize?: $Enums.NoteTextSize
    order?: number
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupNoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    textSize?: EnumNoteTextSizeFieldUpdateOperationsInput | $Enums.NoteTextSize
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupNoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    textSize?: EnumNoteTextSizeFieldUpdateOperationsInput | $Enums.NoteTextSize
    order?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberCreateInput = {
    id?: string
    joinedAt?: Date | string
    lastReadAt?: Date | string
    group: GroupCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutGroupMembershipsInput
  }

  export type GroupMemberUncheckedCreateInput = {
    id?: string
    groupId: string
    userId: string
    joinedAt?: Date | string
    lastReadAt?: Date | string
  }

  export type GroupMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReadAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: GroupUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutGroupMembershipsNestedInput
  }

  export type GroupMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReadAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberCreateManyInput = {
    id?: string
    groupId: string
    userId: string
    joinedAt?: Date | string
    lastReadAt?: Date | string
  }

  export type GroupMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReadAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReadAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    content: string
    isEdited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: AttachmentCreateNestedManyWithoutMessageInput
    group: GroupCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutSentMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    content: string
    senderId: string
    groupId: string
    isEdited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: AttachmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: AttachmentUpdateManyWithoutMessageNestedInput
    group?: GroupUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: AttachmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageCreateManyInput = {
    id?: string
    content: string
    senderId: string
    groupId: string
    isEdited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentCreateInput = {
    id?: string
    type: $Enums.FileType
    filename: string
    data: string
    createdAt?: Date | string
    message: MessageCreateNestedOneWithoutAttachmentsInput
  }

  export type AttachmentUncheckedCreateInput = {
    id?: string
    messageId: string
    type: $Enums.FileType
    filename: string
    data: string
    createdAt?: Date | string
  }

  export type AttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    filename?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type AttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    filename?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentCreateManyInput = {
    id?: string
    messageId: string
    type: $Enums.FileType
    filename: string
    data: string
    createdAt?: Date | string
  }

  export type AttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    filename?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    filename?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    content: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    isRead?: boolean
    user?: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    content: string
    userId?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    isRead?: boolean
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationCreateManyInput = {
    id?: string
    content: string
    userId?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    isRead?: boolean
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AnnouncementCreateInput = {
    id?: string
    title: string
    content: string
    expiresAt: Date | string
    createdAt?: Date | string
    isActive?: boolean
    publisher: UserCreateNestedOneWithoutPublishedAnnouncementsInput
    reads?: AnnouncementReadCreateNestedManyWithoutAnnouncementInput
  }

  export type AnnouncementUncheckedCreateInput = {
    id?: string
    title: string
    content: string
    publisherId: string
    expiresAt: Date | string
    createdAt?: Date | string
    isActive?: boolean
    reads?: AnnouncementReadUncheckedCreateNestedManyWithoutAnnouncementInput
  }

  export type AnnouncementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    publisher?: UserUpdateOneRequiredWithoutPublishedAnnouncementsNestedInput
    reads?: AnnouncementReadUpdateManyWithoutAnnouncementNestedInput
  }

  export type AnnouncementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publisherId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    reads?: AnnouncementReadUncheckedUpdateManyWithoutAnnouncementNestedInput
  }

  export type AnnouncementCreateManyInput = {
    id?: string
    title: string
    content: string
    publisherId: string
    expiresAt: Date | string
    createdAt?: Date | string
    isActive?: boolean
  }

  export type AnnouncementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AnnouncementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publisherId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AnnouncementReadCreateInput = {
    id?: string
    userId: string
    readAt?: Date | string
    announcement: AnnouncementCreateNestedOneWithoutReadsInput
  }

  export type AnnouncementReadUncheckedCreateInput = {
    id?: string
    announcementId: string
    userId: string
    readAt?: Date | string
  }

  export type AnnouncementReadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
    announcement?: AnnouncementUpdateOneRequiredWithoutReadsNestedInput
  }

  export type AnnouncementReadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    announcementId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementReadCreateManyInput = {
    id?: string
    announcementId: string
    userId: string
    readAt?: Date | string
  }

  export type AnnouncementReadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementReadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    announcementId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationRequestCreateInput = {
    id?: string
    userId: string
    cardCode: string
    status?: $Enums.RequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    orgId?: string | null
  }

  export type OrganizationRequestUncheckedCreateInput = {
    id?: string
    userId: string
    cardCode: string
    status?: $Enums.RequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    orgId?: string | null
  }

  export type OrganizationRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cardCode?: StringFieldUpdateOperationsInput | string
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrganizationRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cardCode?: StringFieldUpdateOperationsInput | string
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrganizationRequestCreateManyInput = {
    id?: string
    userId: string
    cardCode: string
    status?: $Enums.RequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    orgId?: string | null
  }

  export type OrganizationRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cardCode?: StringFieldUpdateOperationsInput | string
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrganizationRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cardCode?: StringFieldUpdateOperationsInput | string
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PendingSubscriptionPaymentCreateInput = {
    id?: string
    transactionId: string
    userId: string
    plan: string
    name: string
    logo?: string | null
    address?: string | null
    requestId?: string | null
    orgId?: string | null
    type?: string
    createdAt?: Date | string
  }

  export type PendingSubscriptionPaymentUncheckedCreateInput = {
    id?: string
    transactionId: string
    userId: string
    plan: string
    name: string
    logo?: string | null
    address?: string | null
    requestId?: string | null
    orgId?: string | null
    type?: string
    createdAt?: Date | string
  }

  export type PendingSubscriptionPaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingSubscriptionPaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingSubscriptionPaymentCreateManyInput = {
    id?: string
    transactionId: string
    userId: string
    plan: string
    name: string
    logo?: string | null
    address?: string | null
    requestId?: string | null
    orgId?: string | null
    type?: string
    createdAt?: Date | string
  }

  export type PendingSubscriptionPaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingSubscriptionPaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentOrderCreateInput = {
    id?: string
    userId: string
    plan: string
    name: string
    logo?: string | null
    address?: string | null
    requestId?: string | null
    orgId?: string | null
    type?: string
    amountFcfa: number
    status?: $Enums.PaymentOrderStatus
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentOrderUncheckedCreateInput = {
    id?: string
    userId: string
    plan: string
    name: string
    logo?: string | null
    address?: string | null
    requestId?: string | null
    orgId?: string | null
    type?: string
    amountFcfa: number
    status?: $Enums.PaymentOrderStatus
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    amountFcfa?: IntFieldUpdateOperationsInput | number
    status?: EnumPaymentOrderStatusFieldUpdateOperationsInput | $Enums.PaymentOrderStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    amountFcfa?: IntFieldUpdateOperationsInput | number
    status?: EnumPaymentOrderStatusFieldUpdateOperationsInput | $Enums.PaymentOrderStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentOrderCreateManyInput = {
    id?: string
    userId: string
    plan: string
    name: string
    logo?: string | null
    address?: string | null
    requestId?: string | null
    orgId?: string | null
    type?: string
    amountFcfa: number
    status?: $Enums.PaymentOrderStatus
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    amountFcfa?: IntFieldUpdateOperationsInput | number
    status?: EnumPaymentOrderStatusFieldUpdateOperationsInput | $Enums.PaymentOrderStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    orgId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    amountFcfa?: IntFieldUpdateOperationsInput | number
    status?: EnumPaymentOrderStatusFieldUpdateOperationsInput | $Enums.PaymentOrderStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentSettingCreateInput = {
    id?: string
    key: string
    value: string
  }

  export type PaymentSettingUncheckedCreateInput = {
    id?: string
    key: string
    value: string
  }

  export type PaymentSettingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentSettingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentSettingCreateManyInput = {
    id?: string
    key: string
    value: string
  }

  export type PaymentSettingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentSettingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type SubscriptionCreateInput = {
    id?: string
    plan?: $Enums.SubscriptionPlan
    startDate?: Date | string
    endDate?: Date | string | null
    maxDepartments?: number
    maxMembersPerDept?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    orgId: string
    plan?: $Enums.SubscriptionPlan
    startDate?: Date | string
    endDate?: Date | string | null
    maxDepartments?: number
    maxMembersPerDept?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxDepartments?: IntFieldUpdateOperationsInput | number
    maxMembersPerDept?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxDepartments?: IntFieldUpdateOperationsInput | number
    maxMembersPerDept?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    orgId: string
    plan?: $Enums.SubscriptionPlan
    startDate?: Date | string
    endDate?: Date | string | null
    maxDepartments?: number
    maxMembersPerDept?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxDepartments?: IntFieldUpdateOperationsInput | number
    maxMembersPerDept?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxDepartments?: IntFieldUpdateOperationsInput | number
    maxMembersPerDept?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventInvitationCreateInput = {
    id?: string
    title: string
    description?: string | null
    eventType?: $Enums.EventType
    eventDate: Date | string
    maxAttendees: number
    imageUrl?: string | null
    token: string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutEventsInput
    rsvps?: InvitationRSVPCreateNestedManyWithoutEventInput
    departmentBroadcasts?: EventDepartmentBroadcastCreateNestedManyWithoutEventInput
  }

  export type EventInvitationUncheckedCreateInput = {
    id?: string
    orgId: string
    title: string
    description?: string | null
    eventType?: $Enums.EventType
    eventDate: Date | string
    maxAttendees: number
    imageUrl?: string | null
    token: string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rsvps?: InvitationRSVPUncheckedCreateNestedManyWithoutEventInput
    departmentBroadcasts?: EventDepartmentBroadcastUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventInvitationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAttendees?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutEventsNestedInput
    rsvps?: InvitationRSVPUpdateManyWithoutEventNestedInput
    departmentBroadcasts?: EventDepartmentBroadcastUpdateManyWithoutEventNestedInput
  }

  export type EventInvitationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAttendees?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rsvps?: InvitationRSVPUncheckedUpdateManyWithoutEventNestedInput
    departmentBroadcasts?: EventDepartmentBroadcastUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventInvitationCreateManyInput = {
    id?: string
    orgId: string
    title: string
    description?: string | null
    eventType?: $Enums.EventType
    eventDate: Date | string
    maxAttendees: number
    imageUrl?: string | null
    token: string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventInvitationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAttendees?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventInvitationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAttendees?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventDepartmentBroadcastCreateInput = {
    id?: string
    createdAt?: Date | string
    event: EventInvitationCreateNestedOneWithoutDepartmentBroadcastsInput
    department: DepartmentCreateNestedOneWithoutEventBroadcastsInput
  }

  export type EventDepartmentBroadcastUncheckedCreateInput = {
    id?: string
    eventId: string
    deptId: string
    createdAt?: Date | string
  }

  export type EventDepartmentBroadcastUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventInvitationUpdateOneRequiredWithoutDepartmentBroadcastsNestedInput
    department?: DepartmentUpdateOneRequiredWithoutEventBroadcastsNestedInput
  }

  export type EventDepartmentBroadcastUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    deptId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventDepartmentBroadcastCreateManyInput = {
    id?: string
    eventId: string
    deptId: string
    createdAt?: Date | string
  }

  export type EventDepartmentBroadcastUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventDepartmentBroadcastUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    deptId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationRSVPCreateInput = {
    id?: string
    name: string
    phone: string
    createdAt?: Date | string
    event: EventInvitationCreateNestedOneWithoutRsvpsInput
  }

  export type InvitationRSVPUncheckedCreateInput = {
    id?: string
    eventId: string
    name: string
    phone: string
    createdAt?: Date | string
  }

  export type InvitationRSVPUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventInvitationUpdateOneRequiredWithoutRsvpsNestedInput
  }

  export type InvitationRSVPUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationRSVPCreateManyInput = {
    id?: string
    eventId: string
    name: string
    phone: string
    createdAt?: Date | string
  }

  export type InvitationRSVPUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationRSVPUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPageCreateInput = {
    id?: string
    handle: string
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserPageInput
    posts?: PostCreateNestedManyWithoutPageInput
  }

  export type UserPageUncheckedCreateInput = {
    id?: string
    userId: string
    handle: string
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostUncheckedCreateNestedManyWithoutPageInput
  }

  export type UserPageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    handle?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserPageNestedInput
    posts?: PostUpdateManyWithoutPageNestedInput
  }

  export type UserPageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    handle?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostUncheckedUpdateManyWithoutPageNestedInput
  }

  export type UserPageCreateManyInput = {
    id?: string
    userId: string
    handle: string
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    handle?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    handle?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCreateInput = {
    id?: string
    type: $Enums.PostType
    content: string
    imageUrl?: string | null
    caption?: string | null
    reference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    page: UserPageCreateNestedOneWithoutPostsInput
    likes?: LikeCreateNestedManyWithoutPostInput
    comments?: CommentCreateNestedManyWithoutPostInput
    postReads?: PostReadCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateInput = {
    id?: string
    pageId: string
    type: $Enums.PostType
    content: string
    imageUrl?: string | null
    caption?: string | null
    reference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: LikeUncheckedCreateNestedManyWithoutPostInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    postReads?: PostReadUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    page?: UserPageUpdateOneRequiredWithoutPostsNestedInput
    likes?: LikeUpdateManyWithoutPostNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    postReads?: PostReadUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageId?: StringFieldUpdateOperationsInput | string
    type?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: LikeUncheckedUpdateManyWithoutPostNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    postReads?: PostReadUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostCreateManyInput = {
    id?: string
    pageId: string
    type: $Enums.PostType
    content: string
    imageUrl?: string | null
    caption?: string | null
    reference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageId?: StringFieldUpdateOperationsInput | string
    type?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeCreateInput = {
    id?: string
    createdAt?: Date | string
    post: PostCreateNestedOneWithoutLikesInput
    user: UserCreateNestedOneWithoutLikesInput
  }

  export type LikeUncheckedCreateInput = {
    id?: string
    postId: string
    userId: string
    createdAt?: Date | string
  }

  export type LikeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutLikesNestedInput
    user?: UserUpdateOneRequiredWithoutLikesNestedInput
  }

  export type LikeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeCreateManyInput = {
    id?: string
    postId: string
    userId: string
    createdAt?: Date | string
  }

  export type LikeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    post: PostCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    postId: string
    userId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentCreateManyInput = {
    id?: string
    postId: string
    userId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostReadCreateInput = {
    id?: string
    readAt?: Date | string
    user: UserCreateNestedOneWithoutPostReadsInput
    post: PostCreateNestedOneWithoutPostReadsInput
  }

  export type PostReadUncheckedCreateInput = {
    id?: string
    userId: string
    postId: string
    readAt?: Date | string
  }

  export type PostReadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPostReadsNestedInput
    post?: PostUpdateOneRequiredWithoutPostReadsNestedInput
  }

  export type PostReadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostReadCreateManyInput = {
    id?: string
    userId: string
    postId: string
    readAt?: Date | string
  }

  export type PostReadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostReadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.TaskPriority
    startDate?: Date | string | null
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department: DepartmentCreateNestedOneWithoutTasksInput
    creator: UserCreateNestedOneWithoutCreatedTasksInput
    assignee: UserCreateNestedOneWithoutAssignedTasksInput
    messages?: TaskMessageCreateNestedManyWithoutTaskInput
    attachments?: TaskAttachmentCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.TaskPriority
    startDate?: Date | string | null
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deptId: string
    creatorId: string
    assigneeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: TaskMessageUncheckedCreateNestedManyWithoutTaskInput
    attachments?: TaskAttachmentUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneRequiredWithoutTasksNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedTasksNestedInput
    assignee?: UserUpdateOneRequiredWithoutAssignedTasksNestedInput
    messages?: TaskMessageUpdateManyWithoutTaskNestedInput
    attachments?: TaskAttachmentUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deptId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    assigneeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: TaskMessageUncheckedUpdateManyWithoutTaskNestedInput
    attachments?: TaskAttachmentUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.TaskPriority
    startDate?: Date | string | null
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deptId: string
    creatorId: string
    assigneeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deptId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    assigneeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskMessageCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    task: TaskCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutTaskMessagesInput
    attachments?: TaskAttachmentCreateNestedManyWithoutMessageInput
  }

  export type TaskMessageUncheckedCreateInput = {
    id?: string
    taskId: string
    senderId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: TaskAttachmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type TaskMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutTaskMessagesNestedInput
    attachments?: TaskAttachmentUpdateManyWithoutMessageNestedInput
  }

  export type TaskMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: TaskAttachmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type TaskMessageCreateManyInput = {
    id?: string
    taskId: string
    senderId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAttachmentCreateInput = {
    id?: string
    uploaderId: string
    filename: string
    url: string
    fileType?: string | null
    size?: number | null
    createdAt?: Date | string
    task: TaskCreateNestedOneWithoutAttachmentsInput
    message?: TaskMessageCreateNestedOneWithoutAttachmentsInput
  }

  export type TaskAttachmentUncheckedCreateInput = {
    id?: string
    taskId: string
    messageId?: string | null
    uploaderId: string
    filename: string
    url: string
    fileType?: string | null
    size?: number | null
    createdAt?: Date | string
  }

  export type TaskAttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploaderId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutAttachmentsNestedInput
    message?: TaskMessageUpdateOneWithoutAttachmentsNestedInput
  }

  export type TaskAttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    uploaderId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAttachmentCreateManyInput = {
    id?: string
    taskId: string
    messageId?: string | null
    uploaderId: string
    filename: string
    url: string
    fileType?: string | null
    size?: number | null
    createdAt?: Date | string
  }

  export type TaskAttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploaderId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    uploaderId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentMonthlyReportCreateInput = {
    id?: string
    month: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    department: DepartmentCreateNestedOneWithoutMonthlyReportsInput
    user: UserCreateNestedOneWithoutDepartmentMonthlyReportsInput
  }

  export type DepartmentMonthlyReportUncheckedCreateInput = {
    id?: string
    deptId: string
    userId: string
    month: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentMonthlyReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneRequiredWithoutMonthlyReportsNestedInput
    user?: UserUpdateOneRequiredWithoutDepartmentMonthlyReportsNestedInput
  }

  export type DepartmentMonthlyReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deptId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentMonthlyReportCreateManyInput = {
    id?: string
    deptId: string
    userId: string
    month: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentMonthlyReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentMonthlyReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    deptId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionCreateInput = {
    id?: string
    endpoint: string
    p256dh: string
    auth: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPushSubscriptionsInput
  }

  export type PushSubscriptionUncheckedCreateInput = {
    id?: string
    userId: string
    endpoint: string
    p256dh: string
    auth: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PushSubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dh?: StringFieldUpdateOperationsInput | string
    auth?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPushSubscriptionsNestedInput
  }

  export type PushSubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dh?: StringFieldUpdateOperationsInput | string
    auth?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionCreateManyInput = {
    id?: string
    userId: string
    endpoint: string
    p256dh: string
    auth: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PushSubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dh?: StringFieldUpdateOperationsInput | string
    auth?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dh?: StringFieldUpdateOperationsInput | string
    auth?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPersonalTaskCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.PersonalTaskStatus
    priority?: $Enums.PersonalTaskPriority
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPersonalTasksInput
  }

  export type UserPersonalTaskUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    status?: $Enums.PersonalTaskStatus
    priority?: $Enums.PersonalTaskPriority
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPersonalTaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPersonalTaskStatusFieldUpdateOperationsInput | $Enums.PersonalTaskStatus
    priority?: EnumPersonalTaskPriorityFieldUpdateOperationsInput | $Enums.PersonalTaskPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPersonalTasksNestedInput
  }

  export type UserPersonalTaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPersonalTaskStatusFieldUpdateOperationsInput | $Enums.PersonalTaskStatus
    priority?: EnumPersonalTaskPriorityFieldUpdateOperationsInput | $Enums.PersonalTaskPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPersonalTaskCreateManyInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    status?: $Enums.PersonalTaskStatus
    priority?: $Enums.PersonalTaskPriority
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPersonalTaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPersonalTaskStatusFieldUpdateOperationsInput | $Enums.PersonalTaskStatus
    priority?: EnumPersonalTaskPriorityFieldUpdateOperationsInput | $Enums.PersonalTaskPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPersonalTaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPersonalTaskStatusFieldUpdateOperationsInput | $Enums.PersonalTaskStatus
    priority?: EnumPersonalTaskPriorityFieldUpdateOperationsInput | $Enums.PersonalTaskPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFinancialGoalCreateInput = {
    id?: string
    type?: $Enums.FinancialGoalType
    year?: number | null
    targetItem?: string | null
    targetAmount: number
    targetDate?: Date | string | null
    label?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutFinancialGoalsInput
    progress?: UserMonthlyProgressCreateNestedManyWithoutGoalInput
  }

  export type UserFinancialGoalUncheckedCreateInput = {
    id?: string
    userId: string
    type?: $Enums.FinancialGoalType
    year?: number | null
    targetItem?: string | null
    targetAmount: number
    targetDate?: Date | string | null
    label?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: UserMonthlyProgressUncheckedCreateNestedManyWithoutGoalInput
  }

  export type UserFinancialGoalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFinancialGoalTypeFieldUpdateOperationsInput | $Enums.FinancialGoalType
    year?: NullableIntFieldUpdateOperationsInput | number | null
    targetItem?: NullableStringFieldUpdateOperationsInput | string | null
    targetAmount?: FloatFieldUpdateOperationsInput | number
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFinancialGoalsNestedInput
    progress?: UserMonthlyProgressUpdateManyWithoutGoalNestedInput
  }

  export type UserFinancialGoalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumFinancialGoalTypeFieldUpdateOperationsInput | $Enums.FinancialGoalType
    year?: NullableIntFieldUpdateOperationsInput | number | null
    targetItem?: NullableStringFieldUpdateOperationsInput | string | null
    targetAmount?: FloatFieldUpdateOperationsInput | number
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: UserMonthlyProgressUncheckedUpdateManyWithoutGoalNestedInput
  }

  export type UserFinancialGoalCreateManyInput = {
    id?: string
    userId: string
    type?: $Enums.FinancialGoalType
    year?: number | null
    targetItem?: string | null
    targetAmount: number
    targetDate?: Date | string | null
    label?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserFinancialGoalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFinancialGoalTypeFieldUpdateOperationsInput | $Enums.FinancialGoalType
    year?: NullableIntFieldUpdateOperationsInput | number | null
    targetItem?: NullableStringFieldUpdateOperationsInput | string | null
    targetAmount?: FloatFieldUpdateOperationsInput | number
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFinancialGoalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumFinancialGoalTypeFieldUpdateOperationsInput | $Enums.FinancialGoalType
    year?: NullableIntFieldUpdateOperationsInput | number | null
    targetItem?: NullableStringFieldUpdateOperationsInput | string | null
    targetAmount?: FloatFieldUpdateOperationsInput | number
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFinancialProfileCreateInput = {
    id?: string
    monthlySalary?: number
    supplementaryIncome?: number
    currency?: string
    preferredSavingsRate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutFinancialProfileInput
  }

  export type UserFinancialProfileUncheckedCreateInput = {
    id?: string
    userId: string
    monthlySalary?: number
    supplementaryIncome?: number
    currency?: string
    preferredSavingsRate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserFinancialProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    monthlySalary?: FloatFieldUpdateOperationsInput | number
    supplementaryIncome?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    preferredSavingsRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFinancialProfileNestedInput
  }

  export type UserFinancialProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    monthlySalary?: FloatFieldUpdateOperationsInput | number
    supplementaryIncome?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    preferredSavingsRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFinancialProfileCreateManyInput = {
    id?: string
    userId: string
    monthlySalary?: number
    supplementaryIncome?: number
    currency?: string
    preferredSavingsRate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserFinancialProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    monthlySalary?: FloatFieldUpdateOperationsInput | number
    supplementaryIncome?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    preferredSavingsRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFinancialProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    monthlySalary?: FloatFieldUpdateOperationsInput | number
    supplementaryIncome?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    preferredSavingsRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserMonthlyStatementCreateInput = {
    id?: string
    year: number
    month: number
    salaryReceived?: number
    supplementaryIncome?: number
    totalExpenses?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMonthlyStatementsInput
  }

  export type UserMonthlyStatementUncheckedCreateInput = {
    id?: string
    userId: string
    year: number
    month: number
    salaryReceived?: number
    supplementaryIncome?: number
    totalExpenses?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserMonthlyStatementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    salaryReceived?: FloatFieldUpdateOperationsInput | number
    supplementaryIncome?: FloatFieldUpdateOperationsInput | number
    totalExpenses?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMonthlyStatementsNestedInput
  }

  export type UserMonthlyStatementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    salaryReceived?: FloatFieldUpdateOperationsInput | number
    supplementaryIncome?: FloatFieldUpdateOperationsInput | number
    totalExpenses?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserMonthlyStatementCreateManyInput = {
    id?: string
    userId: string
    year: number
    month: number
    salaryReceived?: number
    supplementaryIncome?: number
    totalExpenses?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserMonthlyStatementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    salaryReceived?: FloatFieldUpdateOperationsInput | number
    supplementaryIncome?: FloatFieldUpdateOperationsInput | number
    totalExpenses?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserMonthlyStatementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    salaryReceived?: FloatFieldUpdateOperationsInput | number
    supplementaryIncome?: FloatFieldUpdateOperationsInput | number
    totalExpenses?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFinancialEntryCreateInput = {
    id?: string
    year: number
    month: number
    type: $Enums.FinancialEntryType
    amount: number
    note?: string | null
    isConfirmed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutFinancialEntriesInput
  }

  export type UserFinancialEntryUncheckedCreateInput = {
    id?: string
    userId: string
    year: number
    month: number
    type: $Enums.FinancialEntryType
    amount: number
    note?: string | null
    isConfirmed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserFinancialEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    type?: EnumFinancialEntryTypeFieldUpdateOperationsInput | $Enums.FinancialEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFinancialEntriesNestedInput
  }

  export type UserFinancialEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    type?: EnumFinancialEntryTypeFieldUpdateOperationsInput | $Enums.FinancialEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFinancialEntryCreateManyInput = {
    id?: string
    userId: string
    year: number
    month: number
    type: $Enums.FinancialEntryType
    amount: number
    note?: string | null
    isConfirmed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserFinancialEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    type?: EnumFinancialEntryTypeFieldUpdateOperationsInput | $Enums.FinancialEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFinancialEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    type?: EnumFinancialEntryTypeFieldUpdateOperationsInput | $Enums.FinancialEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserMonthlyProgressCreateInput = {
    id?: string
    year: number
    month: number
    amount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    goal: UserFinancialGoalCreateNestedOneWithoutProgressInput
  }

  export type UserMonthlyProgressUncheckedCreateInput = {
    id?: string
    goalId: string
    year: number
    month: number
    amount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserMonthlyProgressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goal?: UserFinancialGoalUpdateOneRequiredWithoutProgressNestedInput
  }

  export type UserMonthlyProgressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserMonthlyProgressCreateManyInput = {
    id?: string
    goalId: string
    year: number
    month: number
    amount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserMonthlyProgressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserMonthlyProgressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AnnouncementListRelationFilter = {
    every?: AnnouncementWhereInput
    some?: AnnouncementWhereInput
    none?: AnnouncementWhereInput
  }

  export type DepartmentMemberListRelationFilter = {
    every?: DepartmentMemberWhereInput
    some?: DepartmentMemberWhereInput
    none?: DepartmentMemberWhereInput
  }

  export type GroupMemberListRelationFilter = {
    every?: GroupMemberWhereInput
    some?: GroupMemberWhereInput
    none?: GroupMemberWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type OrganizationMemberListRelationFilter = {
    every?: OrganizationMemberWhereInput
    some?: OrganizationMemberWhereInput
    none?: OrganizationMemberWhereInput
  }

  export type UserPageNullableScalarRelationFilter = {
    is?: UserPageWhereInput | null
    isNot?: UserPageWhereInput | null
  }

  export type LikeListRelationFilter = {
    every?: LikeWhereInput
    some?: LikeWhereInput
    none?: LikeWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type PostReadListRelationFilter = {
    every?: PostReadWhereInput
    some?: PostReadWhereInput
    none?: PostReadWhereInput
  }

  export type TaskListRelationFilter = {
    every?: TaskWhereInput
    some?: TaskWhereInput
    none?: TaskWhereInput
  }

  export type DepartmentListRelationFilter = {
    every?: DepartmentWhereInput
    some?: DepartmentWhereInput
    none?: DepartmentWhereInput
  }

  export type TaskMessageListRelationFilter = {
    every?: TaskMessageWhereInput
    some?: TaskMessageWhereInput
    none?: TaskMessageWhereInput
  }

  export type DepartmentMonthlyReportListRelationFilter = {
    every?: DepartmentMonthlyReportWhereInput
    some?: DepartmentMonthlyReportWhereInput
    none?: DepartmentMonthlyReportWhereInput
  }

  export type DepartmentMeetingListRelationFilter = {
    every?: DepartmentMeetingWhereInput
    some?: DepartmentMeetingWhereInput
    none?: DepartmentMeetingWhereInput
  }

  export type DepartmentPollListRelationFilter = {
    every?: DepartmentPollWhereInput
    some?: DepartmentPollWhereInput
    none?: DepartmentPollWhereInput
  }

  export type TeamDecisionListRelationFilter = {
    every?: TeamDecisionWhereInput
    some?: TeamDecisionWhereInput
    none?: TeamDecisionWhereInput
  }

  export type PollVoteListRelationFilter = {
    every?: PollVoteWhereInput
    some?: PollVoteWhereInput
    none?: PollVoteWhereInput
  }

  export type DecisionVoteListRelationFilter = {
    every?: DecisionVoteWhereInput
    some?: DecisionVoteWhereInput
    none?: DecisionVoteWhereInput
  }

  export type PushSubscriptionListRelationFilter = {
    every?: PushSubscriptionWhereInput
    some?: PushSubscriptionWhereInput
    none?: PushSubscriptionWhereInput
  }

  export type UserInvitationListRelationFilter = {
    every?: UserInvitationWhereInput
    some?: UserInvitationWhereInput
    none?: UserInvitationWhereInput
  }

  export type UserPersonalTaskListRelationFilter = {
    every?: UserPersonalTaskWhereInput
    some?: UserPersonalTaskWhereInput
    none?: UserPersonalTaskWhereInput
  }

  export type UserFinancialGoalListRelationFilter = {
    every?: UserFinancialGoalWhereInput
    some?: UserFinancialGoalWhereInput
    none?: UserFinancialGoalWhereInput
  }

  export type UserFinancialProfileNullableScalarRelationFilter = {
    is?: UserFinancialProfileWhereInput | null
    isNot?: UserFinancialProfileWhereInput | null
  }

  export type UserMonthlyStatementListRelationFilter = {
    every?: UserMonthlyStatementWhereInput
    some?: UserMonthlyStatementWhereInput
    none?: UserMonthlyStatementWhereInput
  }

  export type UserFinancialEntryListRelationFilter = {
    every?: UserFinancialEntryWhereInput
    some?: UserFinancialEntryWhereInput
    none?: UserFinancialEntryWhereInput
  }

  export type FollowListRelationFilter = {
    every?: FollowWhereInput
    some?: FollowWhereInput
    none?: FollowWhereInput
  }

  export type DepartmentDocumentListRelationFilter = {
    every?: DepartmentDocumentWhereInput
    some?: DepartmentDocumentWhereInput
    none?: DepartmentDocumentWhereInput
  }

  export type GroupNoteListRelationFilter = {
    every?: GroupNoteWhereInput
    some?: GroupNoteWhereInput
    none?: GroupNoteWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AnnouncementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostReadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentMonthlyReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentMeetingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentPollOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamDecisionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PollVoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DecisionVoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PushSubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserInvitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserPersonalTaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserFinancialGoalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserMonthlyStatementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserFinancialEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FollowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupNoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    publicKey?: SortOrder
    encryptedPrivateKey?: SortOrder
    otpCode?: SortOrder
    otpExpiry?: SortOrder
    isVerified?: SortOrder
    deviceId?: SortOrder
    deviceInfo?: SortOrder
    location?: SortOrder
    allowedCountry?: SortOrder
    isBanned?: SortOrder
    isFirstLogin?: SortOrder
    currentLocation?: SortOrder
    lastSeen?: SortOrder
    isOnline?: SortOrder
    role?: SortOrder
    canPublishNotifications?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    publicKey?: SortOrder
    encryptedPrivateKey?: SortOrder
    otpCode?: SortOrder
    otpExpiry?: SortOrder
    isVerified?: SortOrder
    deviceId?: SortOrder
    allowedCountry?: SortOrder
    isBanned?: SortOrder
    isFirstLogin?: SortOrder
    lastSeen?: SortOrder
    isOnline?: SortOrder
    role?: SortOrder
    canPublishNotifications?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    publicKey?: SortOrder
    encryptedPrivateKey?: SortOrder
    otpCode?: SortOrder
    otpExpiry?: SortOrder
    isVerified?: SortOrder
    deviceId?: SortOrder
    allowedCountry?: SortOrder
    isBanned?: SortOrder
    isFirstLogin?: SortOrder
    lastSeen?: SortOrder
    isOnline?: SortOrder
    role?: SortOrder
    canPublishNotifications?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumInvitationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusFilter<$PrismaModel> | $Enums.InvitationStatus
  }

  export type EnumInvitationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationType | EnumInvitationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationType[] | ListEnumInvitationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationType[] | ListEnumInvitationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationTypeFilter<$PrismaModel> | $Enums.InvitationType
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type InvitationGuestListRelationFilter = {
    every?: InvitationGuestWhereInput
    some?: InvitationGuestWhereInput
    none?: InvitationGuestWhereInput
  }

  export type InvitationGuestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserInvitationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    status?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageBase64?: SortOrder
    type?: SortOrder
    date?: SortOrder
    location?: SortOrder
    maxGuests?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserInvitationAvgOrderByAggregateInput = {
    maxGuests?: SortOrder
  }

  export type UserInvitationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    status?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageBase64?: SortOrder
    type?: SortOrder
    date?: SortOrder
    location?: SortOrder
    maxGuests?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserInvitationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    status?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageBase64?: SortOrder
    type?: SortOrder
    date?: SortOrder
    location?: SortOrder
    maxGuests?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserInvitationSumOrderByAggregateInput = {
    maxGuests?: SortOrder
  }

  export type EnumInvitationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvitationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvitationStatusFilter<$PrismaModel>
    _max?: NestedEnumInvitationStatusFilter<$PrismaModel>
  }

  export type EnumInvitationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationType | EnumInvitationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationType[] | ListEnumInvitationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationType[] | ListEnumInvitationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationTypeWithAggregatesFilter<$PrismaModel> | $Enums.InvitationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvitationTypeFilter<$PrismaModel>
    _max?: NestedEnumInvitationTypeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type UserInvitationScalarRelationFilter = {
    is?: UserInvitationWhereInput
    isNot?: UserInvitationWhereInput
  }

  export type InvitationGuestCountOrderByAggregateInput = {
    id?: SortOrder
    invitationId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    confirmedAt?: SortOrder
  }

  export type InvitationGuestMaxOrderByAggregateInput = {
    id?: SortOrder
    invitationId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    confirmedAt?: SortOrder
  }

  export type InvitationGuestMinOrderByAggregateInput = {
    id?: SortOrder
    invitationId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    confirmedAt?: SortOrder
  }

  export type FollowFollowerIdFollowingIdCompoundUniqueInput = {
    followerId: string
    followingId: string
  }

  export type FollowCountOrderByAggregateInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
  }

  export type FollowMaxOrderByAggregateInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
  }

  export type FollowMinOrderByAggregateInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
  }

  export type SubscriptionNullableScalarRelationFilter = {
    is?: SubscriptionWhereInput | null
    isNot?: SubscriptionWhereInput | null
  }

  export type EventInvitationListRelationFilter = {
    every?: EventInvitationWhereInput
    some?: EventInvitationWhereInput
    none?: EventInvitationWhereInput
  }

  export type EventInvitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    logo?: SortOrder
    address?: SortOrder
    isSuspended?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
  }

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    logo?: SortOrder
    address?: SortOrder
    isSuspended?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
  }

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    logo?: SortOrder
    address?: SortOrder
    isSuspended?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
  }

  export type EnumOrgRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.OrgRole | EnumOrgRoleFieldRefInput<$PrismaModel>
    in?: $Enums.OrgRole[] | ListEnumOrgRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrgRole[] | ListEnumOrgRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumOrgRoleFilter<$PrismaModel> | $Enums.OrgRole
  }

  export type OrganizationScalarRelationFilter = {
    is?: OrganizationWhereInput
    isNot?: OrganizationWhereInput
  }

  export type OrganizationMemberUserIdOrgIdCompoundUniqueInput = {
    userId: string
    orgId: string
  }

  export type OrganizationMemberCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    orgId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type OrganizationMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    orgId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type OrganizationMemberMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    orgId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type EnumOrgRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrgRole | EnumOrgRoleFieldRefInput<$PrismaModel>
    in?: $Enums.OrgRole[] | ListEnumOrgRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrgRole[] | ListEnumOrgRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumOrgRoleWithAggregatesFilter<$PrismaModel> | $Enums.OrgRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrgRoleFilter<$PrismaModel>
    _max?: NestedEnumOrgRoleFilter<$PrismaModel>
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type GroupListRelationFilter = {
    every?: GroupWhereInput
    some?: GroupWhereInput
    none?: GroupWhereInput
  }

  export type EventDepartmentBroadcastListRelationFilter = {
    every?: EventDepartmentBroadcastWhereInput
    some?: EventDepartmentBroadcastWhereInput
    none?: EventDepartmentBroadcastWhereInput
  }

  export type DepartmentGoalListRelationFilter = {
    every?: DepartmentGoalWhereInput
    some?: DepartmentGoalWhereInput
    none?: DepartmentGoalWhereInput
  }

  export type GroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventDepartmentBroadcastOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentGoalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    orgId?: SortOrder
    publicKey?: SortOrder
    headId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    orgId?: SortOrder
    publicKey?: SortOrder
    headId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    orgId?: SortOrder
    publicKey?: SortOrder
    headId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumFileTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeFilter<$PrismaModel> | $Enums.FileType
  }

  export type DepartmentScalarRelationFilter = {
    is?: DepartmentWhereInput
    isNot?: DepartmentWhereInput
  }

  export type DepartmentDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    deptId?: SortOrder
    filename?: SortOrder
    type?: SortOrder
    data?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type DepartmentDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    deptId?: SortOrder
    filename?: SortOrder
    type?: SortOrder
    data?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type DepartmentDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    deptId?: SortOrder
    filename?: SortOrder
    type?: SortOrder
    data?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumFileTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeWithAggregatesFilter<$PrismaModel> | $Enums.FileType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFileTypeFilter<$PrismaModel>
    _max?: NestedEnumFileTypeFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DepartmentGoalCountOrderByAggregateInput = {
    id?: SortOrder
    deptId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    targetValue?: SortOrder
    currentValue?: SortOrder
    period?: SortOrder
    periodKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentGoalAvgOrderByAggregateInput = {
    targetValue?: SortOrder
    currentValue?: SortOrder
  }

  export type DepartmentGoalMaxOrderByAggregateInput = {
    id?: SortOrder
    deptId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    targetValue?: SortOrder
    currentValue?: SortOrder
    period?: SortOrder
    periodKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentGoalMinOrderByAggregateInput = {
    id?: SortOrder
    deptId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    targetValue?: SortOrder
    currentValue?: SortOrder
    period?: SortOrder
    periodKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentGoalSumOrderByAggregateInput = {
    targetValue?: SortOrder
    currentValue?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DepartmentMeetingCountOrderByAggregateInput = {
    id?: SortOrder
    deptId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    agenda?: SortOrder
    meetingDate?: SortOrder
    location?: SortOrder
    createdBy?: SortOrder
    minutes?: SortOrder
    minutesAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentMeetingMaxOrderByAggregateInput = {
    id?: SortOrder
    deptId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    agenda?: SortOrder
    meetingDate?: SortOrder
    location?: SortOrder
    createdBy?: SortOrder
    minutes?: SortOrder
    minutesAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentMeetingMinOrderByAggregateInput = {
    id?: SortOrder
    deptId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    agenda?: SortOrder
    meetingDate?: SortOrder
    location?: SortOrder
    createdBy?: SortOrder
    minutes?: SortOrder
    minutesAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DepartmentPollCountOrderByAggregateInput = {
    id?: SortOrder
    deptId?: SortOrder
    question?: SortOrder
    options?: SortOrder
    endDate?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentPollMaxOrderByAggregateInput = {
    id?: SortOrder
    deptId?: SortOrder
    question?: SortOrder
    endDate?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentPollMinOrderByAggregateInput = {
    id?: SortOrder
    deptId?: SortOrder
    question?: SortOrder
    endDate?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DepartmentPollScalarRelationFilter = {
    is?: DepartmentPollWhereInput
    isNot?: DepartmentPollWhereInput
  }

  export type PollVotePollIdUserIdCompoundUniqueInput = {
    pollId: string
    userId: string
  }

  export type PollVoteCountOrderByAggregateInput = {
    id?: SortOrder
    pollId?: SortOrder
    userId?: SortOrder
    optionIndex?: SortOrder
    createdAt?: SortOrder
  }

  export type PollVoteAvgOrderByAggregateInput = {
    optionIndex?: SortOrder
  }

  export type PollVoteMaxOrderByAggregateInput = {
    id?: SortOrder
    pollId?: SortOrder
    userId?: SortOrder
    optionIndex?: SortOrder
    createdAt?: SortOrder
  }

  export type PollVoteMinOrderByAggregateInput = {
    id?: SortOrder
    pollId?: SortOrder
    userId?: SortOrder
    optionIndex?: SortOrder
    createdAt?: SortOrder
  }

  export type PollVoteSumOrderByAggregateInput = {
    optionIndex?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type TeamDecisionCountOrderByAggregateInput = {
    id?: SortOrder
    deptId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    voteDeadline?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamDecisionMaxOrderByAggregateInput = {
    id?: SortOrder
    deptId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    voteDeadline?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamDecisionMinOrderByAggregateInput = {
    id?: SortOrder
    deptId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    voteDeadline?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDecisionVoteTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DecisionVoteType | EnumDecisionVoteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DecisionVoteType[] | ListEnumDecisionVoteTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DecisionVoteType[] | ListEnumDecisionVoteTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDecisionVoteTypeFilter<$PrismaModel> | $Enums.DecisionVoteType
  }

  export type TeamDecisionScalarRelationFilter = {
    is?: TeamDecisionWhereInput
    isNot?: TeamDecisionWhereInput
  }

  export type DecisionVoteDecisionIdUserIdCompoundUniqueInput = {
    decisionId: string
    userId: string
  }

  export type DecisionVoteCountOrderByAggregateInput = {
    id?: SortOrder
    decisionId?: SortOrder
    userId?: SortOrder
    vote?: SortOrder
    createdAt?: SortOrder
  }

  export type DecisionVoteMaxOrderByAggregateInput = {
    id?: SortOrder
    decisionId?: SortOrder
    userId?: SortOrder
    vote?: SortOrder
    createdAt?: SortOrder
  }

  export type DecisionVoteMinOrderByAggregateInput = {
    id?: SortOrder
    decisionId?: SortOrder
    userId?: SortOrder
    vote?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumDecisionVoteTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DecisionVoteType | EnumDecisionVoteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DecisionVoteType[] | ListEnumDecisionVoteTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DecisionVoteType[] | ListEnumDecisionVoteTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDecisionVoteTypeWithAggregatesFilter<$PrismaModel> | $Enums.DecisionVoteType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDecisionVoteTypeFilter<$PrismaModel>
    _max?: NestedEnumDecisionVoteTypeFilter<$PrismaModel>
  }

  export type DepartmentMemberDeptIdUserIdCompoundUniqueInput = {
    deptId: string
    userId: string
  }

  export type DepartmentMemberCountOrderByAggregateInput = {
    id?: SortOrder
    deptId?: SortOrder
    userId?: SortOrder
    encryptedDeptKey?: SortOrder
  }

  export type DepartmentMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    deptId?: SortOrder
    userId?: SortOrder
    encryptedDeptKey?: SortOrder
  }

  export type DepartmentMemberMinOrderByAggregateInput = {
    id?: SortOrder
    deptId?: SortOrder
    userId?: SortOrder
    encryptedDeptKey?: SortOrder
  }

  export type DepartmentNullableScalarRelationFilter = {
    is?: DepartmentWhereInput | null
    isNot?: DepartmentWhereInput | null
  }

  export type GroupDocumentListRelationFilter = {
    every?: GroupDocumentWhereInput
    some?: GroupDocumentWhereInput
    none?: GroupDocumentWhereInput
  }

  export type GroupDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isDirect?: SortOrder
    deptId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isDirect?: SortOrder
    deptId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isDirect?: SortOrder
    deptId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupScalarRelationFilter = {
    is?: GroupWhereInput
    isNot?: GroupWhereInput
  }

  export type GroupDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNoteTextSizeFilter<$PrismaModel = never> = {
    equals?: $Enums.NoteTextSize | EnumNoteTextSizeFieldRefInput<$PrismaModel>
    in?: $Enums.NoteTextSize[] | ListEnumNoteTextSizeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NoteTextSize[] | ListEnumNoteTextSizeFieldRefInput<$PrismaModel>
    not?: NestedEnumNoteTextSizeFilter<$PrismaModel> | $Enums.NoteTextSize
  }

  export type GroupDocumentScalarRelationFilter = {
    is?: GroupDocumentWhereInput
    isNot?: GroupDocumentWhereInput
  }

  export type GroupNoteCountOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    textSize?: SortOrder
    order?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupNoteAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type GroupNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    textSize?: SortOrder
    order?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupNoteMinOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    textSize?: SortOrder
    order?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupNoteSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumNoteTextSizeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NoteTextSize | EnumNoteTextSizeFieldRefInput<$PrismaModel>
    in?: $Enums.NoteTextSize[] | ListEnumNoteTextSizeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NoteTextSize[] | ListEnumNoteTextSizeFieldRefInput<$PrismaModel>
    not?: NestedEnumNoteTextSizeWithAggregatesFilter<$PrismaModel> | $Enums.NoteTextSize
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNoteTextSizeFilter<$PrismaModel>
    _max?: NestedEnumNoteTextSizeFilter<$PrismaModel>
  }

  export type GroupMemberGroupIdUserIdCompoundUniqueInput = {
    groupId: string
    userId: string
  }

  export type GroupMemberCountOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
    lastReadAt?: SortOrder
  }

  export type GroupMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
    lastReadAt?: SortOrder
  }

  export type GroupMemberMinOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
    lastReadAt?: SortOrder
  }

  export type AttachmentListRelationFilter = {
    every?: AttachmentWhereInput
    some?: AttachmentWhereInput
    none?: AttachmentWhereInput
  }

  export type AttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    senderId?: SortOrder
    groupId?: SortOrder
    isEdited?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    senderId?: SortOrder
    groupId?: SortOrder
    isEdited?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    senderId?: SortOrder
    groupId?: SortOrder
    isEdited?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageScalarRelationFilter = {
    is?: MessageWhereInput
    isNot?: MessageWhereInput
  }

  export type AttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    type?: SortOrder
    filename?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
  }

  export type AttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    type?: SortOrder
    filename?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
  }

  export type AttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    type?: SortOrder
    filename?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    isRead?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    isRead?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    isRead?: SortOrder
  }

  export type AnnouncementReadListRelationFilter = {
    every?: AnnouncementReadWhereInput
    some?: AnnouncementReadWhereInput
    none?: AnnouncementReadWhereInput
  }

  export type AnnouncementReadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnnouncementCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    publisherId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    isActive?: SortOrder
  }

  export type AnnouncementMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    publisherId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    isActive?: SortOrder
  }

  export type AnnouncementMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    publisherId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    isActive?: SortOrder
  }

  export type AnnouncementScalarRelationFilter = {
    is?: AnnouncementWhereInput
    isNot?: AnnouncementWhereInput
  }

  export type AnnouncementReadAnnouncementIdUserIdCompoundUniqueInput = {
    announcementId: string
    userId: string
  }

  export type AnnouncementReadCountOrderByAggregateInput = {
    id?: SortOrder
    announcementId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
  }

  export type AnnouncementReadMaxOrderByAggregateInput = {
    id?: SortOrder
    announcementId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
  }

  export type AnnouncementReadMinOrderByAggregateInput = {
    id?: SortOrder
    announcementId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
  }

  export type EnumRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestStatus | EnumRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestStatusFilter<$PrismaModel> | $Enums.RequestStatus
  }

  export type OrganizationRequestCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    cardCode?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    orgId?: SortOrder
  }

  export type OrganizationRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    cardCode?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    orgId?: SortOrder
  }

  export type OrganizationRequestMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    cardCode?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    orgId?: SortOrder
  }

  export type EnumRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestStatus | EnumRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.RequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumRequestStatusFilter<$PrismaModel>
  }

  export type PendingSubscriptionPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    userId?: SortOrder
    plan?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    address?: SortOrder
    requestId?: SortOrder
    orgId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type PendingSubscriptionPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    userId?: SortOrder
    plan?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    address?: SortOrder
    requestId?: SortOrder
    orgId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type PendingSubscriptionPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    userId?: SortOrder
    plan?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    address?: SortOrder
    requestId?: SortOrder
    orgId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumPaymentOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentOrderStatus | EnumPaymentOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentOrderStatus[] | ListEnumPaymentOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentOrderStatus[] | ListEnumPaymentOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentOrderStatusFilter<$PrismaModel> | $Enums.PaymentOrderStatus
  }

  export type PaymentOrderCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    plan?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    address?: SortOrder
    requestId?: SortOrder
    orgId?: SortOrder
    type?: SortOrder
    amountFcfa?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    rejectedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentOrderAvgOrderByAggregateInput = {
    amountFcfa?: SortOrder
  }

  export type PaymentOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    plan?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    address?: SortOrder
    requestId?: SortOrder
    orgId?: SortOrder
    type?: SortOrder
    amountFcfa?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    rejectedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentOrderMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    plan?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    address?: SortOrder
    requestId?: SortOrder
    orgId?: SortOrder
    type?: SortOrder
    amountFcfa?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    rejectedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentOrderSumOrderByAggregateInput = {
    amountFcfa?: SortOrder
  }

  export type EnumPaymentOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentOrderStatus | EnumPaymentOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentOrderStatus[] | ListEnumPaymentOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentOrderStatus[] | ListEnumPaymentOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentOrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentOrderStatusFilter<$PrismaModel>
  }

  export type PaymentSettingCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type PaymentSettingMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type PaymentSettingMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type EnumSubscriptionPlanFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionPlanFilter<$PrismaModel> | $Enums.SubscriptionPlan
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    plan?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    maxDepartments?: SortOrder
    maxMembersPerDept?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionAvgOrderByAggregateInput = {
    maxDepartments?: SortOrder
    maxMembersPerDept?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    plan?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    maxDepartments?: SortOrder
    maxMembersPerDept?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    plan?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    maxDepartments?: SortOrder
    maxMembersPerDept?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionSumOrderByAggregateInput = {
    maxDepartments?: SortOrder
    maxMembersPerDept?: SortOrder
  }

  export type EnumSubscriptionPlanWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionPlanWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionPlan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
  }

  export type EnumEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeFilter<$PrismaModel> | $Enums.EventType
  }

  export type InvitationRSVPListRelationFilter = {
    every?: InvitationRSVPWhereInput
    some?: InvitationRSVPWhereInput
    none?: InvitationRSVPWhereInput
  }

  export type InvitationRSVPOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventInvitationCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    eventType?: SortOrder
    eventDate?: SortOrder
    maxAttendees?: SortOrder
    imageUrl?: SortOrder
    token?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventInvitationAvgOrderByAggregateInput = {
    maxAttendees?: SortOrder
  }

  export type EventInvitationMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    eventType?: SortOrder
    eventDate?: SortOrder
    maxAttendees?: SortOrder
    imageUrl?: SortOrder
    token?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventInvitationMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    eventType?: SortOrder
    eventDate?: SortOrder
    maxAttendees?: SortOrder
    imageUrl?: SortOrder
    token?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventInvitationSumOrderByAggregateInput = {
    maxAttendees?: SortOrder
  }

  export type EnumEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.EventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventTypeFilter<$PrismaModel>
    _max?: NestedEnumEventTypeFilter<$PrismaModel>
  }

  export type EventInvitationScalarRelationFilter = {
    is?: EventInvitationWhereInput
    isNot?: EventInvitationWhereInput
  }

  export type EventDepartmentBroadcastEventIdDeptIdCompoundUniqueInput = {
    eventId: string
    deptId: string
  }

  export type EventDepartmentBroadcastCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    deptId?: SortOrder
    createdAt?: SortOrder
  }

  export type EventDepartmentBroadcastMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    deptId?: SortOrder
    createdAt?: SortOrder
  }

  export type EventDepartmentBroadcastMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    deptId?: SortOrder
    createdAt?: SortOrder
  }

  export type InvitationRSVPCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
  }

  export type InvitationRSVPMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
  }

  export type InvitationRSVPMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
  }

  export type PostListRelationFilter = {
    every?: PostWhereInput
    some?: PostWhereInput
    none?: PostWhereInput
  }

  export type PostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserPageCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    handle?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPageMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    handle?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPageMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    handle?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPostTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PostType | EnumPostTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPostTypeFilter<$PrismaModel> | $Enums.PostType
  }

  export type UserPageScalarRelationFilter = {
    is?: UserPageWhereInput
    isNot?: UserPageWhereInput
  }

  export type PostCountOrderByAggregateInput = {
    id?: SortOrder
    pageId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    caption?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    id?: SortOrder
    pageId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    caption?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    id?: SortOrder
    pageId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    caption?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPostTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostType | EnumPostTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPostTypeWithAggregatesFilter<$PrismaModel> | $Enums.PostType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostTypeFilter<$PrismaModel>
    _max?: NestedEnumPostTypeFilter<$PrismaModel>
  }

  export type PostScalarRelationFilter = {
    is?: PostWhereInput
    isNot?: PostWhereInput
  }

  export type LikePostIdUserIdCompoundUniqueInput = {
    postId: string
    userId: string
  }

  export type LikeCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type LikeMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type LikeMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type CommentNullableScalarRelationFilter = {
    is?: CommentWhereInput | null
    isNot?: CommentWhereInput | null
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrder
  }

  export type PostReadUserIdPostIdCompoundUniqueInput = {
    userId: string
    postId: string
  }

  export type PostReadCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    readAt?: SortOrder
  }

  export type PostReadMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    readAt?: SortOrder
  }

  export type PostReadMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    readAt?: SortOrder
  }

  export type EnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type EnumTaskPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskPriority | EnumTaskPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TaskPriority[] | ListEnumTaskPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskPriority[] | ListEnumTaskPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskPriorityFilter<$PrismaModel> | $Enums.TaskPriority
  }

  export type TaskAttachmentListRelationFilter = {
    every?: TaskAttachmentWhereInput
    some?: TaskAttachmentWhereInput
    none?: TaskAttachmentWhereInput
  }

  export type TaskAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    startDate?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    deptId?: SortOrder
    creatorId?: SortOrder
    assigneeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    startDate?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    deptId?: SortOrder
    creatorId?: SortOrder
    assigneeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    startDate?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    deptId?: SortOrder
    creatorId?: SortOrder
    assigneeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type EnumTaskPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskPriority | EnumTaskPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TaskPriority[] | ListEnumTaskPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskPriority[] | ListEnumTaskPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskPriorityWithAggregatesFilter<$PrismaModel> | $Enums.TaskPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskPriorityFilter<$PrismaModel>
    _max?: NestedEnumTaskPriorityFilter<$PrismaModel>
  }

  export type TaskScalarRelationFilter = {
    is?: TaskWhereInput
    isNot?: TaskWhereInput
  }

  export type TaskMessageCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskMessageMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskMessageNullableScalarRelationFilter = {
    is?: TaskMessageWhereInput | null
    isNot?: TaskMessageWhereInput | null
  }

  export type TaskAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    messageId?: SortOrder
    uploaderId?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    fileType?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskAttachmentAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type TaskAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    messageId?: SortOrder
    uploaderId?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    fileType?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    messageId?: SortOrder
    uploaderId?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    fileType?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskAttachmentSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type DepartmentMonthlyReportDeptIdUserIdMonthCompoundUniqueInput = {
    deptId: string
    userId: string
    month: string
  }

  export type DepartmentMonthlyReportCountOrderByAggregateInput = {
    id?: SortOrder
    deptId?: SortOrder
    userId?: SortOrder
    month?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentMonthlyReportMaxOrderByAggregateInput = {
    id?: SortOrder
    deptId?: SortOrder
    userId?: SortOrder
    month?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentMonthlyReportMinOrderByAggregateInput = {
    id?: SortOrder
    deptId?: SortOrder
    userId?: SortOrder
    month?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PushSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    endpoint?: SortOrder
    p256dh?: SortOrder
    auth?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PushSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    endpoint?: SortOrder
    p256dh?: SortOrder
    auth?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PushSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    endpoint?: SortOrder
    p256dh?: SortOrder
    auth?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPersonalTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PersonalTaskStatus | EnumPersonalTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PersonalTaskStatus[] | ListEnumPersonalTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PersonalTaskStatus[] | ListEnumPersonalTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPersonalTaskStatusFilter<$PrismaModel> | $Enums.PersonalTaskStatus
  }

  export type EnumPersonalTaskPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.PersonalTaskPriority | EnumPersonalTaskPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.PersonalTaskPriority[] | ListEnumPersonalTaskPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.PersonalTaskPriority[] | ListEnumPersonalTaskPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPersonalTaskPriorityFilter<$PrismaModel> | $Enums.PersonalTaskPriority
  }

  export type UserPersonalTaskCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPersonalTaskMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPersonalTaskMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPersonalTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PersonalTaskStatus | EnumPersonalTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PersonalTaskStatus[] | ListEnumPersonalTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PersonalTaskStatus[] | ListEnumPersonalTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPersonalTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.PersonalTaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPersonalTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumPersonalTaskStatusFilter<$PrismaModel>
  }

  export type EnumPersonalTaskPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PersonalTaskPriority | EnumPersonalTaskPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.PersonalTaskPriority[] | ListEnumPersonalTaskPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.PersonalTaskPriority[] | ListEnumPersonalTaskPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPersonalTaskPriorityWithAggregatesFilter<$PrismaModel> | $Enums.PersonalTaskPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPersonalTaskPriorityFilter<$PrismaModel>
    _max?: NestedEnumPersonalTaskPriorityFilter<$PrismaModel>
  }

  export type EnumFinancialGoalTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FinancialGoalType | EnumFinancialGoalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FinancialGoalType[] | ListEnumFinancialGoalTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FinancialGoalType[] | ListEnumFinancialGoalTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFinancialGoalTypeFilter<$PrismaModel> | $Enums.FinancialGoalType
  }

  export type UserMonthlyProgressListRelationFilter = {
    every?: UserMonthlyProgressWhereInput
    some?: UserMonthlyProgressWhereInput
    none?: UserMonthlyProgressWhereInput
  }

  export type UserMonthlyProgressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserFinancialGoalCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    year?: SortOrder
    targetItem?: SortOrder
    targetAmount?: SortOrder
    targetDate?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserFinancialGoalAvgOrderByAggregateInput = {
    year?: SortOrder
    targetAmount?: SortOrder
  }

  export type UserFinancialGoalMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    year?: SortOrder
    targetItem?: SortOrder
    targetAmount?: SortOrder
    targetDate?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserFinancialGoalMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    year?: SortOrder
    targetItem?: SortOrder
    targetAmount?: SortOrder
    targetDate?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserFinancialGoalSumOrderByAggregateInput = {
    year?: SortOrder
    targetAmount?: SortOrder
  }

  export type EnumFinancialGoalTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FinancialGoalType | EnumFinancialGoalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FinancialGoalType[] | ListEnumFinancialGoalTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FinancialGoalType[] | ListEnumFinancialGoalTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFinancialGoalTypeWithAggregatesFilter<$PrismaModel> | $Enums.FinancialGoalType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFinancialGoalTypeFilter<$PrismaModel>
    _max?: NestedEnumFinancialGoalTypeFilter<$PrismaModel>
  }

  export type UserFinancialProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    monthlySalary?: SortOrder
    supplementaryIncome?: SortOrder
    currency?: SortOrder
    preferredSavingsRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserFinancialProfileAvgOrderByAggregateInput = {
    monthlySalary?: SortOrder
    supplementaryIncome?: SortOrder
    preferredSavingsRate?: SortOrder
  }

  export type UserFinancialProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    monthlySalary?: SortOrder
    supplementaryIncome?: SortOrder
    currency?: SortOrder
    preferredSavingsRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserFinancialProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    monthlySalary?: SortOrder
    supplementaryIncome?: SortOrder
    currency?: SortOrder
    preferredSavingsRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserFinancialProfileSumOrderByAggregateInput = {
    monthlySalary?: SortOrder
    supplementaryIncome?: SortOrder
    preferredSavingsRate?: SortOrder
  }

  export type UserMonthlyStatementUserIdYearMonthCompoundUniqueInput = {
    userId: string
    year: number
    month: number
  }

  export type UserMonthlyStatementCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    year?: SortOrder
    month?: SortOrder
    salaryReceived?: SortOrder
    supplementaryIncome?: SortOrder
    totalExpenses?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMonthlyStatementAvgOrderByAggregateInput = {
    year?: SortOrder
    month?: SortOrder
    salaryReceived?: SortOrder
    supplementaryIncome?: SortOrder
    totalExpenses?: SortOrder
  }

  export type UserMonthlyStatementMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    year?: SortOrder
    month?: SortOrder
    salaryReceived?: SortOrder
    supplementaryIncome?: SortOrder
    totalExpenses?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMonthlyStatementMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    year?: SortOrder
    month?: SortOrder
    salaryReceived?: SortOrder
    supplementaryIncome?: SortOrder
    totalExpenses?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMonthlyStatementSumOrderByAggregateInput = {
    year?: SortOrder
    month?: SortOrder
    salaryReceived?: SortOrder
    supplementaryIncome?: SortOrder
    totalExpenses?: SortOrder
  }

  export type EnumFinancialEntryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FinancialEntryType | EnumFinancialEntryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FinancialEntryType[] | ListEnumFinancialEntryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FinancialEntryType[] | ListEnumFinancialEntryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFinancialEntryTypeFilter<$PrismaModel> | $Enums.FinancialEntryType
  }

  export type UserFinancialEntryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    year?: SortOrder
    month?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    note?: SortOrder
    isConfirmed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserFinancialEntryAvgOrderByAggregateInput = {
    year?: SortOrder
    month?: SortOrder
    amount?: SortOrder
  }

  export type UserFinancialEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    year?: SortOrder
    month?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    note?: SortOrder
    isConfirmed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserFinancialEntryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    year?: SortOrder
    month?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    note?: SortOrder
    isConfirmed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserFinancialEntrySumOrderByAggregateInput = {
    year?: SortOrder
    month?: SortOrder
    amount?: SortOrder
  }

  export type EnumFinancialEntryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FinancialEntryType | EnumFinancialEntryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FinancialEntryType[] | ListEnumFinancialEntryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FinancialEntryType[] | ListEnumFinancialEntryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFinancialEntryTypeWithAggregatesFilter<$PrismaModel> | $Enums.FinancialEntryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFinancialEntryTypeFilter<$PrismaModel>
    _max?: NestedEnumFinancialEntryTypeFilter<$PrismaModel>
  }

  export type UserFinancialGoalScalarRelationFilter = {
    is?: UserFinancialGoalWhereInput
    isNot?: UserFinancialGoalWhereInput
  }

  export type UserMonthlyProgressCountOrderByAggregateInput = {
    id?: SortOrder
    goalId?: SortOrder
    year?: SortOrder
    month?: SortOrder
    amount?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMonthlyProgressAvgOrderByAggregateInput = {
    year?: SortOrder
    month?: SortOrder
    amount?: SortOrder
  }

  export type UserMonthlyProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    goalId?: SortOrder
    year?: SortOrder
    month?: SortOrder
    amount?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMonthlyProgressMinOrderByAggregateInput = {
    id?: SortOrder
    goalId?: SortOrder
    year?: SortOrder
    month?: SortOrder
    amount?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMonthlyProgressSumOrderByAggregateInput = {
    year?: SortOrder
    month?: SortOrder
    amount?: SortOrder
  }

  export type AnnouncementCreateNestedManyWithoutPublisherInput = {
    create?: XOR<AnnouncementCreateWithoutPublisherInput, AnnouncementUncheckedCreateWithoutPublisherInput> | AnnouncementCreateWithoutPublisherInput[] | AnnouncementUncheckedCreateWithoutPublisherInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutPublisherInput | AnnouncementCreateOrConnectWithoutPublisherInput[]
    createMany?: AnnouncementCreateManyPublisherInputEnvelope
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
  }

  export type DepartmentMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<DepartmentMemberCreateWithoutUserInput, DepartmentMemberUncheckedCreateWithoutUserInput> | DepartmentMemberCreateWithoutUserInput[] | DepartmentMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DepartmentMemberCreateOrConnectWithoutUserInput | DepartmentMemberCreateOrConnectWithoutUserInput[]
    createMany?: DepartmentMemberCreateManyUserInputEnvelope
    connect?: DepartmentMemberWhereUniqueInput | DepartmentMemberWhereUniqueInput[]
  }

  export type GroupMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput> | GroupMemberCreateWithoutUserInput[] | GroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutUserInput | GroupMemberCreateOrConnectWithoutUserInput[]
    createMany?: GroupMemberCreateManyUserInputEnvelope
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type OrganizationMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<OrganizationMemberCreateWithoutUserInput, OrganizationMemberUncheckedCreateWithoutUserInput> | OrganizationMemberCreateWithoutUserInput[] | OrganizationMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrganizationMemberCreateOrConnectWithoutUserInput | OrganizationMemberCreateOrConnectWithoutUserInput[]
    createMany?: OrganizationMemberCreateManyUserInputEnvelope
    connect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
  }

  export type UserPageCreateNestedOneWithoutUserInput = {
    create?: XOR<UserPageCreateWithoutUserInput, UserPageUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPageCreateOrConnectWithoutUserInput
    connect?: UserPageWhereUniqueInput
  }

  export type LikeCreateNestedManyWithoutUserInput = {
    create?: XOR<LikeCreateWithoutUserInput, LikeUncheckedCreateWithoutUserInput> | LikeCreateWithoutUserInput[] | LikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutUserInput | LikeCreateOrConnectWithoutUserInput[]
    createMany?: LikeCreateManyUserInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type PostReadCreateNestedManyWithoutUserInput = {
    create?: XOR<PostReadCreateWithoutUserInput, PostReadUncheckedCreateWithoutUserInput> | PostReadCreateWithoutUserInput[] | PostReadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostReadCreateOrConnectWithoutUserInput | PostReadCreateOrConnectWithoutUserInput[]
    createMany?: PostReadCreateManyUserInputEnvelope
    connect?: PostReadWhereUniqueInput | PostReadWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutAssigneeInput = {
    create?: XOR<TaskCreateWithoutAssigneeInput, TaskUncheckedCreateWithoutAssigneeInput> | TaskCreateWithoutAssigneeInput[] | TaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssigneeInput | TaskCreateOrConnectWithoutAssigneeInput[]
    createMany?: TaskCreateManyAssigneeInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TaskCreateWithoutCreatorInput, TaskUncheckedCreateWithoutCreatorInput> | TaskCreateWithoutCreatorInput[] | TaskUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCreatorInput | TaskCreateOrConnectWithoutCreatorInput[]
    createMany?: TaskCreateManyCreatorInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type DepartmentCreateNestedManyWithoutHeadInput = {
    create?: XOR<DepartmentCreateWithoutHeadInput, DepartmentUncheckedCreateWithoutHeadInput> | DepartmentCreateWithoutHeadInput[] | DepartmentUncheckedCreateWithoutHeadInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutHeadInput | DepartmentCreateOrConnectWithoutHeadInput[]
    createMany?: DepartmentCreateManyHeadInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type TaskMessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<TaskMessageCreateWithoutSenderInput, TaskMessageUncheckedCreateWithoutSenderInput> | TaskMessageCreateWithoutSenderInput[] | TaskMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: TaskMessageCreateOrConnectWithoutSenderInput | TaskMessageCreateOrConnectWithoutSenderInput[]
    createMany?: TaskMessageCreateManySenderInputEnvelope
    connect?: TaskMessageWhereUniqueInput | TaskMessageWhereUniqueInput[]
  }

  export type DepartmentMonthlyReportCreateNestedManyWithoutUserInput = {
    create?: XOR<DepartmentMonthlyReportCreateWithoutUserInput, DepartmentMonthlyReportUncheckedCreateWithoutUserInput> | DepartmentMonthlyReportCreateWithoutUserInput[] | DepartmentMonthlyReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DepartmentMonthlyReportCreateOrConnectWithoutUserInput | DepartmentMonthlyReportCreateOrConnectWithoutUserInput[]
    createMany?: DepartmentMonthlyReportCreateManyUserInputEnvelope
    connect?: DepartmentMonthlyReportWhereUniqueInput | DepartmentMonthlyReportWhereUniqueInput[]
  }

  export type DepartmentMeetingCreateNestedManyWithoutCreatorInput = {
    create?: XOR<DepartmentMeetingCreateWithoutCreatorInput, DepartmentMeetingUncheckedCreateWithoutCreatorInput> | DepartmentMeetingCreateWithoutCreatorInput[] | DepartmentMeetingUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: DepartmentMeetingCreateOrConnectWithoutCreatorInput | DepartmentMeetingCreateOrConnectWithoutCreatorInput[]
    createMany?: DepartmentMeetingCreateManyCreatorInputEnvelope
    connect?: DepartmentMeetingWhereUniqueInput | DepartmentMeetingWhereUniqueInput[]
  }

  export type DepartmentPollCreateNestedManyWithoutCreatorInput = {
    create?: XOR<DepartmentPollCreateWithoutCreatorInput, DepartmentPollUncheckedCreateWithoutCreatorInput> | DepartmentPollCreateWithoutCreatorInput[] | DepartmentPollUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: DepartmentPollCreateOrConnectWithoutCreatorInput | DepartmentPollCreateOrConnectWithoutCreatorInput[]
    createMany?: DepartmentPollCreateManyCreatorInputEnvelope
    connect?: DepartmentPollWhereUniqueInput | DepartmentPollWhereUniqueInput[]
  }

  export type TeamDecisionCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TeamDecisionCreateWithoutCreatorInput, TeamDecisionUncheckedCreateWithoutCreatorInput> | TeamDecisionCreateWithoutCreatorInput[] | TeamDecisionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TeamDecisionCreateOrConnectWithoutCreatorInput | TeamDecisionCreateOrConnectWithoutCreatorInput[]
    createMany?: TeamDecisionCreateManyCreatorInputEnvelope
    connect?: TeamDecisionWhereUniqueInput | TeamDecisionWhereUniqueInput[]
  }

  export type PollVoteCreateNestedManyWithoutUserInput = {
    create?: XOR<PollVoteCreateWithoutUserInput, PollVoteUncheckedCreateWithoutUserInput> | PollVoteCreateWithoutUserInput[] | PollVoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PollVoteCreateOrConnectWithoutUserInput | PollVoteCreateOrConnectWithoutUserInput[]
    createMany?: PollVoteCreateManyUserInputEnvelope
    connect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
  }

  export type DecisionVoteCreateNestedManyWithoutUserInput = {
    create?: XOR<DecisionVoteCreateWithoutUserInput, DecisionVoteUncheckedCreateWithoutUserInput> | DecisionVoteCreateWithoutUserInput[] | DecisionVoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DecisionVoteCreateOrConnectWithoutUserInput | DecisionVoteCreateOrConnectWithoutUserInput[]
    createMany?: DecisionVoteCreateManyUserInputEnvelope
    connect?: DecisionVoteWhereUniqueInput | DecisionVoteWhereUniqueInput[]
  }

  export type PushSubscriptionCreateNestedManyWithoutUserInput = {
    create?: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput> | PushSubscriptionCreateWithoutUserInput[] | PushSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PushSubscriptionCreateOrConnectWithoutUserInput | PushSubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: PushSubscriptionCreateManyUserInputEnvelope
    connect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
  }

  export type UserInvitationCreateNestedManyWithoutUserInput = {
    create?: XOR<UserInvitationCreateWithoutUserInput, UserInvitationUncheckedCreateWithoutUserInput> | UserInvitationCreateWithoutUserInput[] | UserInvitationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserInvitationCreateOrConnectWithoutUserInput | UserInvitationCreateOrConnectWithoutUserInput[]
    createMany?: UserInvitationCreateManyUserInputEnvelope
    connect?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
  }

  export type UserPersonalTaskCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPersonalTaskCreateWithoutUserInput, UserPersonalTaskUncheckedCreateWithoutUserInput> | UserPersonalTaskCreateWithoutUserInput[] | UserPersonalTaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPersonalTaskCreateOrConnectWithoutUserInput | UserPersonalTaskCreateOrConnectWithoutUserInput[]
    createMany?: UserPersonalTaskCreateManyUserInputEnvelope
    connect?: UserPersonalTaskWhereUniqueInput | UserPersonalTaskWhereUniqueInput[]
  }

  export type UserFinancialGoalCreateNestedManyWithoutUserInput = {
    create?: XOR<UserFinancialGoalCreateWithoutUserInput, UserFinancialGoalUncheckedCreateWithoutUserInput> | UserFinancialGoalCreateWithoutUserInput[] | UserFinancialGoalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFinancialGoalCreateOrConnectWithoutUserInput | UserFinancialGoalCreateOrConnectWithoutUserInput[]
    createMany?: UserFinancialGoalCreateManyUserInputEnvelope
    connect?: UserFinancialGoalWhereUniqueInput | UserFinancialGoalWhereUniqueInput[]
  }

  export type UserFinancialProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<UserFinancialProfileCreateWithoutUserInput, UserFinancialProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserFinancialProfileCreateOrConnectWithoutUserInput
    connect?: UserFinancialProfileWhereUniqueInput
  }

  export type UserMonthlyStatementCreateNestedManyWithoutUserInput = {
    create?: XOR<UserMonthlyStatementCreateWithoutUserInput, UserMonthlyStatementUncheckedCreateWithoutUserInput> | UserMonthlyStatementCreateWithoutUserInput[] | UserMonthlyStatementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserMonthlyStatementCreateOrConnectWithoutUserInput | UserMonthlyStatementCreateOrConnectWithoutUserInput[]
    createMany?: UserMonthlyStatementCreateManyUserInputEnvelope
    connect?: UserMonthlyStatementWhereUniqueInput | UserMonthlyStatementWhereUniqueInput[]
  }

  export type UserFinancialEntryCreateNestedManyWithoutUserInput = {
    create?: XOR<UserFinancialEntryCreateWithoutUserInput, UserFinancialEntryUncheckedCreateWithoutUserInput> | UserFinancialEntryCreateWithoutUserInput[] | UserFinancialEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFinancialEntryCreateOrConnectWithoutUserInput | UserFinancialEntryCreateOrConnectWithoutUserInput[]
    createMany?: UserFinancialEntryCreateManyUserInputEnvelope
    connect?: UserFinancialEntryWhereUniqueInput | UserFinancialEntryWhereUniqueInput[]
  }

  export type FollowCreateNestedManyWithoutFollowingInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type FollowCreateNestedManyWithoutFollowerInput = {
    create?: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput> | FollowCreateWithoutFollowerInput[] | FollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowerInput | FollowCreateOrConnectWithoutFollowerInput[]
    createMany?: FollowCreateManyFollowerInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type DepartmentDocumentCreateNestedManyWithoutUploaderInput = {
    create?: XOR<DepartmentDocumentCreateWithoutUploaderInput, DepartmentDocumentUncheckedCreateWithoutUploaderInput> | DepartmentDocumentCreateWithoutUploaderInput[] | DepartmentDocumentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: DepartmentDocumentCreateOrConnectWithoutUploaderInput | DepartmentDocumentCreateOrConnectWithoutUploaderInput[]
    createMany?: DepartmentDocumentCreateManyUploaderInputEnvelope
    connect?: DepartmentDocumentWhereUniqueInput | DepartmentDocumentWhereUniqueInput[]
  }

  export type GroupNoteCreateNestedManyWithoutCreatorInput = {
    create?: XOR<GroupNoteCreateWithoutCreatorInput, GroupNoteUncheckedCreateWithoutCreatorInput> | GroupNoteCreateWithoutCreatorInput[] | GroupNoteUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: GroupNoteCreateOrConnectWithoutCreatorInput | GroupNoteCreateOrConnectWithoutCreatorInput[]
    createMany?: GroupNoteCreateManyCreatorInputEnvelope
    connect?: GroupNoteWhereUniqueInput | GroupNoteWhereUniqueInput[]
  }

  export type AnnouncementUncheckedCreateNestedManyWithoutPublisherInput = {
    create?: XOR<AnnouncementCreateWithoutPublisherInput, AnnouncementUncheckedCreateWithoutPublisherInput> | AnnouncementCreateWithoutPublisherInput[] | AnnouncementUncheckedCreateWithoutPublisherInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutPublisherInput | AnnouncementCreateOrConnectWithoutPublisherInput[]
    createMany?: AnnouncementCreateManyPublisherInputEnvelope
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
  }

  export type DepartmentMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DepartmentMemberCreateWithoutUserInput, DepartmentMemberUncheckedCreateWithoutUserInput> | DepartmentMemberCreateWithoutUserInput[] | DepartmentMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DepartmentMemberCreateOrConnectWithoutUserInput | DepartmentMemberCreateOrConnectWithoutUserInput[]
    createMany?: DepartmentMemberCreateManyUserInputEnvelope
    connect?: DepartmentMemberWhereUniqueInput | DepartmentMemberWhereUniqueInput[]
  }

  export type GroupMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput> | GroupMemberCreateWithoutUserInput[] | GroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutUserInput | GroupMemberCreateOrConnectWithoutUserInput[]
    createMany?: GroupMemberCreateManyUserInputEnvelope
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type OrganizationMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OrganizationMemberCreateWithoutUserInput, OrganizationMemberUncheckedCreateWithoutUserInput> | OrganizationMemberCreateWithoutUserInput[] | OrganizationMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrganizationMemberCreateOrConnectWithoutUserInput | OrganizationMemberCreateOrConnectWithoutUserInput[]
    createMany?: OrganizationMemberCreateManyUserInputEnvelope
    connect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
  }

  export type UserPageUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserPageCreateWithoutUserInput, UserPageUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPageCreateOrConnectWithoutUserInput
    connect?: UserPageWhereUniqueInput
  }

  export type LikeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LikeCreateWithoutUserInput, LikeUncheckedCreateWithoutUserInput> | LikeCreateWithoutUserInput[] | LikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutUserInput | LikeCreateOrConnectWithoutUserInput[]
    createMany?: LikeCreateManyUserInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type PostReadUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PostReadCreateWithoutUserInput, PostReadUncheckedCreateWithoutUserInput> | PostReadCreateWithoutUserInput[] | PostReadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostReadCreateOrConnectWithoutUserInput | PostReadCreateOrConnectWithoutUserInput[]
    createMany?: PostReadCreateManyUserInputEnvelope
    connect?: PostReadWhereUniqueInput | PostReadWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutAssigneeInput = {
    create?: XOR<TaskCreateWithoutAssigneeInput, TaskUncheckedCreateWithoutAssigneeInput> | TaskCreateWithoutAssigneeInput[] | TaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssigneeInput | TaskCreateOrConnectWithoutAssigneeInput[]
    createMany?: TaskCreateManyAssigneeInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TaskCreateWithoutCreatorInput, TaskUncheckedCreateWithoutCreatorInput> | TaskCreateWithoutCreatorInput[] | TaskUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCreatorInput | TaskCreateOrConnectWithoutCreatorInput[]
    createMany?: TaskCreateManyCreatorInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type DepartmentUncheckedCreateNestedManyWithoutHeadInput = {
    create?: XOR<DepartmentCreateWithoutHeadInput, DepartmentUncheckedCreateWithoutHeadInput> | DepartmentCreateWithoutHeadInput[] | DepartmentUncheckedCreateWithoutHeadInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutHeadInput | DepartmentCreateOrConnectWithoutHeadInput[]
    createMany?: DepartmentCreateManyHeadInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type TaskMessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<TaskMessageCreateWithoutSenderInput, TaskMessageUncheckedCreateWithoutSenderInput> | TaskMessageCreateWithoutSenderInput[] | TaskMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: TaskMessageCreateOrConnectWithoutSenderInput | TaskMessageCreateOrConnectWithoutSenderInput[]
    createMany?: TaskMessageCreateManySenderInputEnvelope
    connect?: TaskMessageWhereUniqueInput | TaskMessageWhereUniqueInput[]
  }

  export type DepartmentMonthlyReportUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DepartmentMonthlyReportCreateWithoutUserInput, DepartmentMonthlyReportUncheckedCreateWithoutUserInput> | DepartmentMonthlyReportCreateWithoutUserInput[] | DepartmentMonthlyReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DepartmentMonthlyReportCreateOrConnectWithoutUserInput | DepartmentMonthlyReportCreateOrConnectWithoutUserInput[]
    createMany?: DepartmentMonthlyReportCreateManyUserInputEnvelope
    connect?: DepartmentMonthlyReportWhereUniqueInput | DepartmentMonthlyReportWhereUniqueInput[]
  }

  export type DepartmentMeetingUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<DepartmentMeetingCreateWithoutCreatorInput, DepartmentMeetingUncheckedCreateWithoutCreatorInput> | DepartmentMeetingCreateWithoutCreatorInput[] | DepartmentMeetingUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: DepartmentMeetingCreateOrConnectWithoutCreatorInput | DepartmentMeetingCreateOrConnectWithoutCreatorInput[]
    createMany?: DepartmentMeetingCreateManyCreatorInputEnvelope
    connect?: DepartmentMeetingWhereUniqueInput | DepartmentMeetingWhereUniqueInput[]
  }

  export type DepartmentPollUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<DepartmentPollCreateWithoutCreatorInput, DepartmentPollUncheckedCreateWithoutCreatorInput> | DepartmentPollCreateWithoutCreatorInput[] | DepartmentPollUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: DepartmentPollCreateOrConnectWithoutCreatorInput | DepartmentPollCreateOrConnectWithoutCreatorInput[]
    createMany?: DepartmentPollCreateManyCreatorInputEnvelope
    connect?: DepartmentPollWhereUniqueInput | DepartmentPollWhereUniqueInput[]
  }

  export type TeamDecisionUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TeamDecisionCreateWithoutCreatorInput, TeamDecisionUncheckedCreateWithoutCreatorInput> | TeamDecisionCreateWithoutCreatorInput[] | TeamDecisionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TeamDecisionCreateOrConnectWithoutCreatorInput | TeamDecisionCreateOrConnectWithoutCreatorInput[]
    createMany?: TeamDecisionCreateManyCreatorInputEnvelope
    connect?: TeamDecisionWhereUniqueInput | TeamDecisionWhereUniqueInput[]
  }

  export type PollVoteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PollVoteCreateWithoutUserInput, PollVoteUncheckedCreateWithoutUserInput> | PollVoteCreateWithoutUserInput[] | PollVoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PollVoteCreateOrConnectWithoutUserInput | PollVoteCreateOrConnectWithoutUserInput[]
    createMany?: PollVoteCreateManyUserInputEnvelope
    connect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
  }

  export type DecisionVoteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DecisionVoteCreateWithoutUserInput, DecisionVoteUncheckedCreateWithoutUserInput> | DecisionVoteCreateWithoutUserInput[] | DecisionVoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DecisionVoteCreateOrConnectWithoutUserInput | DecisionVoteCreateOrConnectWithoutUserInput[]
    createMany?: DecisionVoteCreateManyUserInputEnvelope
    connect?: DecisionVoteWhereUniqueInput | DecisionVoteWhereUniqueInput[]
  }

  export type PushSubscriptionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput> | PushSubscriptionCreateWithoutUserInput[] | PushSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PushSubscriptionCreateOrConnectWithoutUserInput | PushSubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: PushSubscriptionCreateManyUserInputEnvelope
    connect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
  }

  export type UserInvitationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserInvitationCreateWithoutUserInput, UserInvitationUncheckedCreateWithoutUserInput> | UserInvitationCreateWithoutUserInput[] | UserInvitationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserInvitationCreateOrConnectWithoutUserInput | UserInvitationCreateOrConnectWithoutUserInput[]
    createMany?: UserInvitationCreateManyUserInputEnvelope
    connect?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
  }

  export type UserPersonalTaskUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPersonalTaskCreateWithoutUserInput, UserPersonalTaskUncheckedCreateWithoutUserInput> | UserPersonalTaskCreateWithoutUserInput[] | UserPersonalTaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPersonalTaskCreateOrConnectWithoutUserInput | UserPersonalTaskCreateOrConnectWithoutUserInput[]
    createMany?: UserPersonalTaskCreateManyUserInputEnvelope
    connect?: UserPersonalTaskWhereUniqueInput | UserPersonalTaskWhereUniqueInput[]
  }

  export type UserFinancialGoalUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserFinancialGoalCreateWithoutUserInput, UserFinancialGoalUncheckedCreateWithoutUserInput> | UserFinancialGoalCreateWithoutUserInput[] | UserFinancialGoalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFinancialGoalCreateOrConnectWithoutUserInput | UserFinancialGoalCreateOrConnectWithoutUserInput[]
    createMany?: UserFinancialGoalCreateManyUserInputEnvelope
    connect?: UserFinancialGoalWhereUniqueInput | UserFinancialGoalWhereUniqueInput[]
  }

  export type UserFinancialProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserFinancialProfileCreateWithoutUserInput, UserFinancialProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserFinancialProfileCreateOrConnectWithoutUserInput
    connect?: UserFinancialProfileWhereUniqueInput
  }

  export type UserMonthlyStatementUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserMonthlyStatementCreateWithoutUserInput, UserMonthlyStatementUncheckedCreateWithoutUserInput> | UserMonthlyStatementCreateWithoutUserInput[] | UserMonthlyStatementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserMonthlyStatementCreateOrConnectWithoutUserInput | UserMonthlyStatementCreateOrConnectWithoutUserInput[]
    createMany?: UserMonthlyStatementCreateManyUserInputEnvelope
    connect?: UserMonthlyStatementWhereUniqueInput | UserMonthlyStatementWhereUniqueInput[]
  }

  export type UserFinancialEntryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserFinancialEntryCreateWithoutUserInput, UserFinancialEntryUncheckedCreateWithoutUserInput> | UserFinancialEntryCreateWithoutUserInput[] | UserFinancialEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFinancialEntryCreateOrConnectWithoutUserInput | UserFinancialEntryCreateOrConnectWithoutUserInput[]
    createMany?: UserFinancialEntryCreateManyUserInputEnvelope
    connect?: UserFinancialEntryWhereUniqueInput | UserFinancialEntryWhereUniqueInput[]
  }

  export type FollowUncheckedCreateNestedManyWithoutFollowingInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type FollowUncheckedCreateNestedManyWithoutFollowerInput = {
    create?: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput> | FollowCreateWithoutFollowerInput[] | FollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowerInput | FollowCreateOrConnectWithoutFollowerInput[]
    createMany?: FollowCreateManyFollowerInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type DepartmentDocumentUncheckedCreateNestedManyWithoutUploaderInput = {
    create?: XOR<DepartmentDocumentCreateWithoutUploaderInput, DepartmentDocumentUncheckedCreateWithoutUploaderInput> | DepartmentDocumentCreateWithoutUploaderInput[] | DepartmentDocumentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: DepartmentDocumentCreateOrConnectWithoutUploaderInput | DepartmentDocumentCreateOrConnectWithoutUploaderInput[]
    createMany?: DepartmentDocumentCreateManyUploaderInputEnvelope
    connect?: DepartmentDocumentWhereUniqueInput | DepartmentDocumentWhereUniqueInput[]
  }

  export type GroupNoteUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<GroupNoteCreateWithoutCreatorInput, GroupNoteUncheckedCreateWithoutCreatorInput> | GroupNoteCreateWithoutCreatorInput[] | GroupNoteUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: GroupNoteCreateOrConnectWithoutCreatorInput | GroupNoteCreateOrConnectWithoutCreatorInput[]
    createMany?: GroupNoteCreateManyCreatorInputEnvelope
    connect?: GroupNoteWhereUniqueInput | GroupNoteWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AnnouncementUpdateManyWithoutPublisherNestedInput = {
    create?: XOR<AnnouncementCreateWithoutPublisherInput, AnnouncementUncheckedCreateWithoutPublisherInput> | AnnouncementCreateWithoutPublisherInput[] | AnnouncementUncheckedCreateWithoutPublisherInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutPublisherInput | AnnouncementCreateOrConnectWithoutPublisherInput[]
    upsert?: AnnouncementUpsertWithWhereUniqueWithoutPublisherInput | AnnouncementUpsertWithWhereUniqueWithoutPublisherInput[]
    createMany?: AnnouncementCreateManyPublisherInputEnvelope
    set?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    disconnect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    delete?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    update?: AnnouncementUpdateWithWhereUniqueWithoutPublisherInput | AnnouncementUpdateWithWhereUniqueWithoutPublisherInput[]
    updateMany?: AnnouncementUpdateManyWithWhereWithoutPublisherInput | AnnouncementUpdateManyWithWhereWithoutPublisherInput[]
    deleteMany?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
  }

  export type DepartmentMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<DepartmentMemberCreateWithoutUserInput, DepartmentMemberUncheckedCreateWithoutUserInput> | DepartmentMemberCreateWithoutUserInput[] | DepartmentMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DepartmentMemberCreateOrConnectWithoutUserInput | DepartmentMemberCreateOrConnectWithoutUserInput[]
    upsert?: DepartmentMemberUpsertWithWhereUniqueWithoutUserInput | DepartmentMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DepartmentMemberCreateManyUserInputEnvelope
    set?: DepartmentMemberWhereUniqueInput | DepartmentMemberWhereUniqueInput[]
    disconnect?: DepartmentMemberWhereUniqueInput | DepartmentMemberWhereUniqueInput[]
    delete?: DepartmentMemberWhereUniqueInput | DepartmentMemberWhereUniqueInput[]
    connect?: DepartmentMemberWhereUniqueInput | DepartmentMemberWhereUniqueInput[]
    update?: DepartmentMemberUpdateWithWhereUniqueWithoutUserInput | DepartmentMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DepartmentMemberUpdateManyWithWhereWithoutUserInput | DepartmentMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DepartmentMemberScalarWhereInput | DepartmentMemberScalarWhereInput[]
  }

  export type GroupMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput> | GroupMemberCreateWithoutUserInput[] | GroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutUserInput | GroupMemberCreateOrConnectWithoutUserInput[]
    upsert?: GroupMemberUpsertWithWhereUniqueWithoutUserInput | GroupMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GroupMemberCreateManyUserInputEnvelope
    set?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    disconnect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    delete?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    update?: GroupMemberUpdateWithWhereUniqueWithoutUserInput | GroupMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GroupMemberUpdateManyWithWhereWithoutUserInput | GroupMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type OrganizationMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrganizationMemberCreateWithoutUserInput, OrganizationMemberUncheckedCreateWithoutUserInput> | OrganizationMemberCreateWithoutUserInput[] | OrganizationMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrganizationMemberCreateOrConnectWithoutUserInput | OrganizationMemberCreateOrConnectWithoutUserInput[]
    upsert?: OrganizationMemberUpsertWithWhereUniqueWithoutUserInput | OrganizationMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrganizationMemberCreateManyUserInputEnvelope
    set?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    disconnect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    delete?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    connect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    update?: OrganizationMemberUpdateWithWhereUniqueWithoutUserInput | OrganizationMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrganizationMemberUpdateManyWithWhereWithoutUserInput | OrganizationMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrganizationMemberScalarWhereInput | OrganizationMemberScalarWhereInput[]
  }

  export type UserPageUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserPageCreateWithoutUserInput, UserPageUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPageCreateOrConnectWithoutUserInput
    upsert?: UserPageUpsertWithoutUserInput
    disconnect?: UserPageWhereInput | boolean
    delete?: UserPageWhereInput | boolean
    connect?: UserPageWhereUniqueInput
    update?: XOR<XOR<UserPageUpdateToOneWithWhereWithoutUserInput, UserPageUpdateWithoutUserInput>, UserPageUncheckedUpdateWithoutUserInput>
  }

  export type LikeUpdateManyWithoutUserNestedInput = {
    create?: XOR<LikeCreateWithoutUserInput, LikeUncheckedCreateWithoutUserInput> | LikeCreateWithoutUserInput[] | LikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutUserInput | LikeCreateOrConnectWithoutUserInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutUserInput | LikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LikeCreateManyUserInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutUserInput | LikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutUserInput | LikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type PostReadUpdateManyWithoutUserNestedInput = {
    create?: XOR<PostReadCreateWithoutUserInput, PostReadUncheckedCreateWithoutUserInput> | PostReadCreateWithoutUserInput[] | PostReadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostReadCreateOrConnectWithoutUserInput | PostReadCreateOrConnectWithoutUserInput[]
    upsert?: PostReadUpsertWithWhereUniqueWithoutUserInput | PostReadUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PostReadCreateManyUserInputEnvelope
    set?: PostReadWhereUniqueInput | PostReadWhereUniqueInput[]
    disconnect?: PostReadWhereUniqueInput | PostReadWhereUniqueInput[]
    delete?: PostReadWhereUniqueInput | PostReadWhereUniqueInput[]
    connect?: PostReadWhereUniqueInput | PostReadWhereUniqueInput[]
    update?: PostReadUpdateWithWhereUniqueWithoutUserInput | PostReadUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PostReadUpdateManyWithWhereWithoutUserInput | PostReadUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PostReadScalarWhereInput | PostReadScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutAssigneeNestedInput = {
    create?: XOR<TaskCreateWithoutAssigneeInput, TaskUncheckedCreateWithoutAssigneeInput> | TaskCreateWithoutAssigneeInput[] | TaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssigneeInput | TaskCreateOrConnectWithoutAssigneeInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutAssigneeInput | TaskUpsertWithWhereUniqueWithoutAssigneeInput[]
    createMany?: TaskCreateManyAssigneeInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutAssigneeInput | TaskUpdateWithWhereUniqueWithoutAssigneeInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutAssigneeInput | TaskUpdateManyWithWhereWithoutAssigneeInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TaskCreateWithoutCreatorInput, TaskUncheckedCreateWithoutCreatorInput> | TaskCreateWithoutCreatorInput[] | TaskUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCreatorInput | TaskCreateOrConnectWithoutCreatorInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutCreatorInput | TaskUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TaskCreateManyCreatorInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutCreatorInput | TaskUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutCreatorInput | TaskUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type DepartmentUpdateManyWithoutHeadNestedInput = {
    create?: XOR<DepartmentCreateWithoutHeadInput, DepartmentUncheckedCreateWithoutHeadInput> | DepartmentCreateWithoutHeadInput[] | DepartmentUncheckedCreateWithoutHeadInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutHeadInput | DepartmentCreateOrConnectWithoutHeadInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutHeadInput | DepartmentUpsertWithWhereUniqueWithoutHeadInput[]
    createMany?: DepartmentCreateManyHeadInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutHeadInput | DepartmentUpdateWithWhereUniqueWithoutHeadInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutHeadInput | DepartmentUpdateManyWithWhereWithoutHeadInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type TaskMessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<TaskMessageCreateWithoutSenderInput, TaskMessageUncheckedCreateWithoutSenderInput> | TaskMessageCreateWithoutSenderInput[] | TaskMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: TaskMessageCreateOrConnectWithoutSenderInput | TaskMessageCreateOrConnectWithoutSenderInput[]
    upsert?: TaskMessageUpsertWithWhereUniqueWithoutSenderInput | TaskMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: TaskMessageCreateManySenderInputEnvelope
    set?: TaskMessageWhereUniqueInput | TaskMessageWhereUniqueInput[]
    disconnect?: TaskMessageWhereUniqueInput | TaskMessageWhereUniqueInput[]
    delete?: TaskMessageWhereUniqueInput | TaskMessageWhereUniqueInput[]
    connect?: TaskMessageWhereUniqueInput | TaskMessageWhereUniqueInput[]
    update?: TaskMessageUpdateWithWhereUniqueWithoutSenderInput | TaskMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: TaskMessageUpdateManyWithWhereWithoutSenderInput | TaskMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: TaskMessageScalarWhereInput | TaskMessageScalarWhereInput[]
  }

  export type DepartmentMonthlyReportUpdateManyWithoutUserNestedInput = {
    create?: XOR<DepartmentMonthlyReportCreateWithoutUserInput, DepartmentMonthlyReportUncheckedCreateWithoutUserInput> | DepartmentMonthlyReportCreateWithoutUserInput[] | DepartmentMonthlyReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DepartmentMonthlyReportCreateOrConnectWithoutUserInput | DepartmentMonthlyReportCreateOrConnectWithoutUserInput[]
    upsert?: DepartmentMonthlyReportUpsertWithWhereUniqueWithoutUserInput | DepartmentMonthlyReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DepartmentMonthlyReportCreateManyUserInputEnvelope
    set?: DepartmentMonthlyReportWhereUniqueInput | DepartmentMonthlyReportWhereUniqueInput[]
    disconnect?: DepartmentMonthlyReportWhereUniqueInput | DepartmentMonthlyReportWhereUniqueInput[]
    delete?: DepartmentMonthlyReportWhereUniqueInput | DepartmentMonthlyReportWhereUniqueInput[]
    connect?: DepartmentMonthlyReportWhereUniqueInput | DepartmentMonthlyReportWhereUniqueInput[]
    update?: DepartmentMonthlyReportUpdateWithWhereUniqueWithoutUserInput | DepartmentMonthlyReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DepartmentMonthlyReportUpdateManyWithWhereWithoutUserInput | DepartmentMonthlyReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DepartmentMonthlyReportScalarWhereInput | DepartmentMonthlyReportScalarWhereInput[]
  }

  export type DepartmentMeetingUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<DepartmentMeetingCreateWithoutCreatorInput, DepartmentMeetingUncheckedCreateWithoutCreatorInput> | DepartmentMeetingCreateWithoutCreatorInput[] | DepartmentMeetingUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: DepartmentMeetingCreateOrConnectWithoutCreatorInput | DepartmentMeetingCreateOrConnectWithoutCreatorInput[]
    upsert?: DepartmentMeetingUpsertWithWhereUniqueWithoutCreatorInput | DepartmentMeetingUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: DepartmentMeetingCreateManyCreatorInputEnvelope
    set?: DepartmentMeetingWhereUniqueInput | DepartmentMeetingWhereUniqueInput[]
    disconnect?: DepartmentMeetingWhereUniqueInput | DepartmentMeetingWhereUniqueInput[]
    delete?: DepartmentMeetingWhereUniqueInput | DepartmentMeetingWhereUniqueInput[]
    connect?: DepartmentMeetingWhereUniqueInput | DepartmentMeetingWhereUniqueInput[]
    update?: DepartmentMeetingUpdateWithWhereUniqueWithoutCreatorInput | DepartmentMeetingUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: DepartmentMeetingUpdateManyWithWhereWithoutCreatorInput | DepartmentMeetingUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: DepartmentMeetingScalarWhereInput | DepartmentMeetingScalarWhereInput[]
  }

  export type DepartmentPollUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<DepartmentPollCreateWithoutCreatorInput, DepartmentPollUncheckedCreateWithoutCreatorInput> | DepartmentPollCreateWithoutCreatorInput[] | DepartmentPollUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: DepartmentPollCreateOrConnectWithoutCreatorInput | DepartmentPollCreateOrConnectWithoutCreatorInput[]
    upsert?: DepartmentPollUpsertWithWhereUniqueWithoutCreatorInput | DepartmentPollUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: DepartmentPollCreateManyCreatorInputEnvelope
    set?: DepartmentPollWhereUniqueInput | DepartmentPollWhereUniqueInput[]
    disconnect?: DepartmentPollWhereUniqueInput | DepartmentPollWhereUniqueInput[]
    delete?: DepartmentPollWhereUniqueInput | DepartmentPollWhereUniqueInput[]
    connect?: DepartmentPollWhereUniqueInput | DepartmentPollWhereUniqueInput[]
    update?: DepartmentPollUpdateWithWhereUniqueWithoutCreatorInput | DepartmentPollUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: DepartmentPollUpdateManyWithWhereWithoutCreatorInput | DepartmentPollUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: DepartmentPollScalarWhereInput | DepartmentPollScalarWhereInput[]
  }

  export type TeamDecisionUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TeamDecisionCreateWithoutCreatorInput, TeamDecisionUncheckedCreateWithoutCreatorInput> | TeamDecisionCreateWithoutCreatorInput[] | TeamDecisionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TeamDecisionCreateOrConnectWithoutCreatorInput | TeamDecisionCreateOrConnectWithoutCreatorInput[]
    upsert?: TeamDecisionUpsertWithWhereUniqueWithoutCreatorInput | TeamDecisionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TeamDecisionCreateManyCreatorInputEnvelope
    set?: TeamDecisionWhereUniqueInput | TeamDecisionWhereUniqueInput[]
    disconnect?: TeamDecisionWhereUniqueInput | TeamDecisionWhereUniqueInput[]
    delete?: TeamDecisionWhereUniqueInput | TeamDecisionWhereUniqueInput[]
    connect?: TeamDecisionWhereUniqueInput | TeamDecisionWhereUniqueInput[]
    update?: TeamDecisionUpdateWithWhereUniqueWithoutCreatorInput | TeamDecisionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TeamDecisionUpdateManyWithWhereWithoutCreatorInput | TeamDecisionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TeamDecisionScalarWhereInput | TeamDecisionScalarWhereInput[]
  }

  export type PollVoteUpdateManyWithoutUserNestedInput = {
    create?: XOR<PollVoteCreateWithoutUserInput, PollVoteUncheckedCreateWithoutUserInput> | PollVoteCreateWithoutUserInput[] | PollVoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PollVoteCreateOrConnectWithoutUserInput | PollVoteCreateOrConnectWithoutUserInput[]
    upsert?: PollVoteUpsertWithWhereUniqueWithoutUserInput | PollVoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PollVoteCreateManyUserInputEnvelope
    set?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    disconnect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    delete?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    connect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    update?: PollVoteUpdateWithWhereUniqueWithoutUserInput | PollVoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PollVoteUpdateManyWithWhereWithoutUserInput | PollVoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PollVoteScalarWhereInput | PollVoteScalarWhereInput[]
  }

  export type DecisionVoteUpdateManyWithoutUserNestedInput = {
    create?: XOR<DecisionVoteCreateWithoutUserInput, DecisionVoteUncheckedCreateWithoutUserInput> | DecisionVoteCreateWithoutUserInput[] | DecisionVoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DecisionVoteCreateOrConnectWithoutUserInput | DecisionVoteCreateOrConnectWithoutUserInput[]
    upsert?: DecisionVoteUpsertWithWhereUniqueWithoutUserInput | DecisionVoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DecisionVoteCreateManyUserInputEnvelope
    set?: DecisionVoteWhereUniqueInput | DecisionVoteWhereUniqueInput[]
    disconnect?: DecisionVoteWhereUniqueInput | DecisionVoteWhereUniqueInput[]
    delete?: DecisionVoteWhereUniqueInput | DecisionVoteWhereUniqueInput[]
    connect?: DecisionVoteWhereUniqueInput | DecisionVoteWhereUniqueInput[]
    update?: DecisionVoteUpdateWithWhereUniqueWithoutUserInput | DecisionVoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DecisionVoteUpdateManyWithWhereWithoutUserInput | DecisionVoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DecisionVoteScalarWhereInput | DecisionVoteScalarWhereInput[]
  }

  export type PushSubscriptionUpdateManyWithoutUserNestedInput = {
    create?: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput> | PushSubscriptionCreateWithoutUserInput[] | PushSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PushSubscriptionCreateOrConnectWithoutUserInput | PushSubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: PushSubscriptionUpsertWithWhereUniqueWithoutUserInput | PushSubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PushSubscriptionCreateManyUserInputEnvelope
    set?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    disconnect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    delete?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    connect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    update?: PushSubscriptionUpdateWithWhereUniqueWithoutUserInput | PushSubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PushSubscriptionUpdateManyWithWhereWithoutUserInput | PushSubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PushSubscriptionScalarWhereInput | PushSubscriptionScalarWhereInput[]
  }

  export type UserInvitationUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserInvitationCreateWithoutUserInput, UserInvitationUncheckedCreateWithoutUserInput> | UserInvitationCreateWithoutUserInput[] | UserInvitationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserInvitationCreateOrConnectWithoutUserInput | UserInvitationCreateOrConnectWithoutUserInput[]
    upsert?: UserInvitationUpsertWithWhereUniqueWithoutUserInput | UserInvitationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserInvitationCreateManyUserInputEnvelope
    set?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    disconnect?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    delete?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    connect?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    update?: UserInvitationUpdateWithWhereUniqueWithoutUserInput | UserInvitationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserInvitationUpdateManyWithWhereWithoutUserInput | UserInvitationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserInvitationScalarWhereInput | UserInvitationScalarWhereInput[]
  }

  export type UserPersonalTaskUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPersonalTaskCreateWithoutUserInput, UserPersonalTaskUncheckedCreateWithoutUserInput> | UserPersonalTaskCreateWithoutUserInput[] | UserPersonalTaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPersonalTaskCreateOrConnectWithoutUserInput | UserPersonalTaskCreateOrConnectWithoutUserInput[]
    upsert?: UserPersonalTaskUpsertWithWhereUniqueWithoutUserInput | UserPersonalTaskUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPersonalTaskCreateManyUserInputEnvelope
    set?: UserPersonalTaskWhereUniqueInput | UserPersonalTaskWhereUniqueInput[]
    disconnect?: UserPersonalTaskWhereUniqueInput | UserPersonalTaskWhereUniqueInput[]
    delete?: UserPersonalTaskWhereUniqueInput | UserPersonalTaskWhereUniqueInput[]
    connect?: UserPersonalTaskWhereUniqueInput | UserPersonalTaskWhereUniqueInput[]
    update?: UserPersonalTaskUpdateWithWhereUniqueWithoutUserInput | UserPersonalTaskUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPersonalTaskUpdateManyWithWhereWithoutUserInput | UserPersonalTaskUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPersonalTaskScalarWhereInput | UserPersonalTaskScalarWhereInput[]
  }

  export type UserFinancialGoalUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserFinancialGoalCreateWithoutUserInput, UserFinancialGoalUncheckedCreateWithoutUserInput> | UserFinancialGoalCreateWithoutUserInput[] | UserFinancialGoalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFinancialGoalCreateOrConnectWithoutUserInput | UserFinancialGoalCreateOrConnectWithoutUserInput[]
    upsert?: UserFinancialGoalUpsertWithWhereUniqueWithoutUserInput | UserFinancialGoalUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserFinancialGoalCreateManyUserInputEnvelope
    set?: UserFinancialGoalWhereUniqueInput | UserFinancialGoalWhereUniqueInput[]
    disconnect?: UserFinancialGoalWhereUniqueInput | UserFinancialGoalWhereUniqueInput[]
    delete?: UserFinancialGoalWhereUniqueInput | UserFinancialGoalWhereUniqueInput[]
    connect?: UserFinancialGoalWhereUniqueInput | UserFinancialGoalWhereUniqueInput[]
    update?: UserFinancialGoalUpdateWithWhereUniqueWithoutUserInput | UserFinancialGoalUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserFinancialGoalUpdateManyWithWhereWithoutUserInput | UserFinancialGoalUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserFinancialGoalScalarWhereInput | UserFinancialGoalScalarWhereInput[]
  }

  export type UserFinancialProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserFinancialProfileCreateWithoutUserInput, UserFinancialProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserFinancialProfileCreateOrConnectWithoutUserInput
    upsert?: UserFinancialProfileUpsertWithoutUserInput
    disconnect?: UserFinancialProfileWhereInput | boolean
    delete?: UserFinancialProfileWhereInput | boolean
    connect?: UserFinancialProfileWhereUniqueInput
    update?: XOR<XOR<UserFinancialProfileUpdateToOneWithWhereWithoutUserInput, UserFinancialProfileUpdateWithoutUserInput>, UserFinancialProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserMonthlyStatementUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserMonthlyStatementCreateWithoutUserInput, UserMonthlyStatementUncheckedCreateWithoutUserInput> | UserMonthlyStatementCreateWithoutUserInput[] | UserMonthlyStatementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserMonthlyStatementCreateOrConnectWithoutUserInput | UserMonthlyStatementCreateOrConnectWithoutUserInput[]
    upsert?: UserMonthlyStatementUpsertWithWhereUniqueWithoutUserInput | UserMonthlyStatementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserMonthlyStatementCreateManyUserInputEnvelope
    set?: UserMonthlyStatementWhereUniqueInput | UserMonthlyStatementWhereUniqueInput[]
    disconnect?: UserMonthlyStatementWhereUniqueInput | UserMonthlyStatementWhereUniqueInput[]
    delete?: UserMonthlyStatementWhereUniqueInput | UserMonthlyStatementWhereUniqueInput[]
    connect?: UserMonthlyStatementWhereUniqueInput | UserMonthlyStatementWhereUniqueInput[]
    update?: UserMonthlyStatementUpdateWithWhereUniqueWithoutUserInput | UserMonthlyStatementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserMonthlyStatementUpdateManyWithWhereWithoutUserInput | UserMonthlyStatementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserMonthlyStatementScalarWhereInput | UserMonthlyStatementScalarWhereInput[]
  }

  export type UserFinancialEntryUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserFinancialEntryCreateWithoutUserInput, UserFinancialEntryUncheckedCreateWithoutUserInput> | UserFinancialEntryCreateWithoutUserInput[] | UserFinancialEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFinancialEntryCreateOrConnectWithoutUserInput | UserFinancialEntryCreateOrConnectWithoutUserInput[]
    upsert?: UserFinancialEntryUpsertWithWhereUniqueWithoutUserInput | UserFinancialEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserFinancialEntryCreateManyUserInputEnvelope
    set?: UserFinancialEntryWhereUniqueInput | UserFinancialEntryWhereUniqueInput[]
    disconnect?: UserFinancialEntryWhereUniqueInput | UserFinancialEntryWhereUniqueInput[]
    delete?: UserFinancialEntryWhereUniqueInput | UserFinancialEntryWhereUniqueInput[]
    connect?: UserFinancialEntryWhereUniqueInput | UserFinancialEntryWhereUniqueInput[]
    update?: UserFinancialEntryUpdateWithWhereUniqueWithoutUserInput | UserFinancialEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserFinancialEntryUpdateManyWithWhereWithoutUserInput | UserFinancialEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserFinancialEntryScalarWhereInput | UserFinancialEntryScalarWhereInput[]
  }

  export type FollowUpdateManyWithoutFollowingNestedInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowingInput | FollowUpsertWithWhereUniqueWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowingInput | FollowUpdateWithWhereUniqueWithoutFollowingInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowingInput | FollowUpdateManyWithWhereWithoutFollowingInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type FollowUpdateManyWithoutFollowerNestedInput = {
    create?: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput> | FollowCreateWithoutFollowerInput[] | FollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowerInput | FollowCreateOrConnectWithoutFollowerInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowerInput | FollowUpsertWithWhereUniqueWithoutFollowerInput[]
    createMany?: FollowCreateManyFollowerInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowerInput | FollowUpdateWithWhereUniqueWithoutFollowerInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowerInput | FollowUpdateManyWithWhereWithoutFollowerInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type DepartmentDocumentUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<DepartmentDocumentCreateWithoutUploaderInput, DepartmentDocumentUncheckedCreateWithoutUploaderInput> | DepartmentDocumentCreateWithoutUploaderInput[] | DepartmentDocumentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: DepartmentDocumentCreateOrConnectWithoutUploaderInput | DepartmentDocumentCreateOrConnectWithoutUploaderInput[]
    upsert?: DepartmentDocumentUpsertWithWhereUniqueWithoutUploaderInput | DepartmentDocumentUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: DepartmentDocumentCreateManyUploaderInputEnvelope
    set?: DepartmentDocumentWhereUniqueInput | DepartmentDocumentWhereUniqueInput[]
    disconnect?: DepartmentDocumentWhereUniqueInput | DepartmentDocumentWhereUniqueInput[]
    delete?: DepartmentDocumentWhereUniqueInput | DepartmentDocumentWhereUniqueInput[]
    connect?: DepartmentDocumentWhereUniqueInput | DepartmentDocumentWhereUniqueInput[]
    update?: DepartmentDocumentUpdateWithWhereUniqueWithoutUploaderInput | DepartmentDocumentUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: DepartmentDocumentUpdateManyWithWhereWithoutUploaderInput | DepartmentDocumentUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: DepartmentDocumentScalarWhereInput | DepartmentDocumentScalarWhereInput[]
  }

  export type GroupNoteUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<GroupNoteCreateWithoutCreatorInput, GroupNoteUncheckedCreateWithoutCreatorInput> | GroupNoteCreateWithoutCreatorInput[] | GroupNoteUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: GroupNoteCreateOrConnectWithoutCreatorInput | GroupNoteCreateOrConnectWithoutCreatorInput[]
    upsert?: GroupNoteUpsertWithWhereUniqueWithoutCreatorInput | GroupNoteUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: GroupNoteCreateManyCreatorInputEnvelope
    set?: GroupNoteWhereUniqueInput | GroupNoteWhereUniqueInput[]
    disconnect?: GroupNoteWhereUniqueInput | GroupNoteWhereUniqueInput[]
    delete?: GroupNoteWhereUniqueInput | GroupNoteWhereUniqueInput[]
    connect?: GroupNoteWhereUniqueInput | GroupNoteWhereUniqueInput[]
    update?: GroupNoteUpdateWithWhereUniqueWithoutCreatorInput | GroupNoteUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: GroupNoteUpdateManyWithWhereWithoutCreatorInput | GroupNoteUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: GroupNoteScalarWhereInput | GroupNoteScalarWhereInput[]
  }

  export type AnnouncementUncheckedUpdateManyWithoutPublisherNestedInput = {
    create?: XOR<AnnouncementCreateWithoutPublisherInput, AnnouncementUncheckedCreateWithoutPublisherInput> | AnnouncementCreateWithoutPublisherInput[] | AnnouncementUncheckedCreateWithoutPublisherInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutPublisherInput | AnnouncementCreateOrConnectWithoutPublisherInput[]
    upsert?: AnnouncementUpsertWithWhereUniqueWithoutPublisherInput | AnnouncementUpsertWithWhereUniqueWithoutPublisherInput[]
    createMany?: AnnouncementCreateManyPublisherInputEnvelope
    set?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    disconnect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    delete?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    update?: AnnouncementUpdateWithWhereUniqueWithoutPublisherInput | AnnouncementUpdateWithWhereUniqueWithoutPublisherInput[]
    updateMany?: AnnouncementUpdateManyWithWhereWithoutPublisherInput | AnnouncementUpdateManyWithWhereWithoutPublisherInput[]
    deleteMany?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
  }

  export type DepartmentMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DepartmentMemberCreateWithoutUserInput, DepartmentMemberUncheckedCreateWithoutUserInput> | DepartmentMemberCreateWithoutUserInput[] | DepartmentMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DepartmentMemberCreateOrConnectWithoutUserInput | DepartmentMemberCreateOrConnectWithoutUserInput[]
    upsert?: DepartmentMemberUpsertWithWhereUniqueWithoutUserInput | DepartmentMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DepartmentMemberCreateManyUserInputEnvelope
    set?: DepartmentMemberWhereUniqueInput | DepartmentMemberWhereUniqueInput[]
    disconnect?: DepartmentMemberWhereUniqueInput | DepartmentMemberWhereUniqueInput[]
    delete?: DepartmentMemberWhereUniqueInput | DepartmentMemberWhereUniqueInput[]
    connect?: DepartmentMemberWhereUniqueInput | DepartmentMemberWhereUniqueInput[]
    update?: DepartmentMemberUpdateWithWhereUniqueWithoutUserInput | DepartmentMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DepartmentMemberUpdateManyWithWhereWithoutUserInput | DepartmentMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DepartmentMemberScalarWhereInput | DepartmentMemberScalarWhereInput[]
  }

  export type GroupMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput> | GroupMemberCreateWithoutUserInput[] | GroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutUserInput | GroupMemberCreateOrConnectWithoutUserInput[]
    upsert?: GroupMemberUpsertWithWhereUniqueWithoutUserInput | GroupMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GroupMemberCreateManyUserInputEnvelope
    set?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    disconnect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    delete?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    update?: GroupMemberUpdateWithWhereUniqueWithoutUserInput | GroupMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GroupMemberUpdateManyWithWhereWithoutUserInput | GroupMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrganizationMemberCreateWithoutUserInput, OrganizationMemberUncheckedCreateWithoutUserInput> | OrganizationMemberCreateWithoutUserInput[] | OrganizationMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrganizationMemberCreateOrConnectWithoutUserInput | OrganizationMemberCreateOrConnectWithoutUserInput[]
    upsert?: OrganizationMemberUpsertWithWhereUniqueWithoutUserInput | OrganizationMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrganizationMemberCreateManyUserInputEnvelope
    set?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    disconnect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    delete?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    connect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    update?: OrganizationMemberUpdateWithWhereUniqueWithoutUserInput | OrganizationMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrganizationMemberUpdateManyWithWhereWithoutUserInput | OrganizationMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrganizationMemberScalarWhereInput | OrganizationMemberScalarWhereInput[]
  }

  export type UserPageUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserPageCreateWithoutUserInput, UserPageUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPageCreateOrConnectWithoutUserInput
    upsert?: UserPageUpsertWithoutUserInput
    disconnect?: UserPageWhereInput | boolean
    delete?: UserPageWhereInput | boolean
    connect?: UserPageWhereUniqueInput
    update?: XOR<XOR<UserPageUpdateToOneWithWhereWithoutUserInput, UserPageUpdateWithoutUserInput>, UserPageUncheckedUpdateWithoutUserInput>
  }

  export type LikeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LikeCreateWithoutUserInput, LikeUncheckedCreateWithoutUserInput> | LikeCreateWithoutUserInput[] | LikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutUserInput | LikeCreateOrConnectWithoutUserInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutUserInput | LikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LikeCreateManyUserInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutUserInput | LikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutUserInput | LikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type PostReadUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PostReadCreateWithoutUserInput, PostReadUncheckedCreateWithoutUserInput> | PostReadCreateWithoutUserInput[] | PostReadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostReadCreateOrConnectWithoutUserInput | PostReadCreateOrConnectWithoutUserInput[]
    upsert?: PostReadUpsertWithWhereUniqueWithoutUserInput | PostReadUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PostReadCreateManyUserInputEnvelope
    set?: PostReadWhereUniqueInput | PostReadWhereUniqueInput[]
    disconnect?: PostReadWhereUniqueInput | PostReadWhereUniqueInput[]
    delete?: PostReadWhereUniqueInput | PostReadWhereUniqueInput[]
    connect?: PostReadWhereUniqueInput | PostReadWhereUniqueInput[]
    update?: PostReadUpdateWithWhereUniqueWithoutUserInput | PostReadUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PostReadUpdateManyWithWhereWithoutUserInput | PostReadUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PostReadScalarWhereInput | PostReadScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutAssigneeNestedInput = {
    create?: XOR<TaskCreateWithoutAssigneeInput, TaskUncheckedCreateWithoutAssigneeInput> | TaskCreateWithoutAssigneeInput[] | TaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssigneeInput | TaskCreateOrConnectWithoutAssigneeInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutAssigneeInput | TaskUpsertWithWhereUniqueWithoutAssigneeInput[]
    createMany?: TaskCreateManyAssigneeInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutAssigneeInput | TaskUpdateWithWhereUniqueWithoutAssigneeInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutAssigneeInput | TaskUpdateManyWithWhereWithoutAssigneeInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TaskCreateWithoutCreatorInput, TaskUncheckedCreateWithoutCreatorInput> | TaskCreateWithoutCreatorInput[] | TaskUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCreatorInput | TaskCreateOrConnectWithoutCreatorInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutCreatorInput | TaskUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TaskCreateManyCreatorInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutCreatorInput | TaskUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutCreatorInput | TaskUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type DepartmentUncheckedUpdateManyWithoutHeadNestedInput = {
    create?: XOR<DepartmentCreateWithoutHeadInput, DepartmentUncheckedCreateWithoutHeadInput> | DepartmentCreateWithoutHeadInput[] | DepartmentUncheckedCreateWithoutHeadInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutHeadInput | DepartmentCreateOrConnectWithoutHeadInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutHeadInput | DepartmentUpsertWithWhereUniqueWithoutHeadInput[]
    createMany?: DepartmentCreateManyHeadInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutHeadInput | DepartmentUpdateWithWhereUniqueWithoutHeadInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutHeadInput | DepartmentUpdateManyWithWhereWithoutHeadInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type TaskMessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<TaskMessageCreateWithoutSenderInput, TaskMessageUncheckedCreateWithoutSenderInput> | TaskMessageCreateWithoutSenderInput[] | TaskMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: TaskMessageCreateOrConnectWithoutSenderInput | TaskMessageCreateOrConnectWithoutSenderInput[]
    upsert?: TaskMessageUpsertWithWhereUniqueWithoutSenderInput | TaskMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: TaskMessageCreateManySenderInputEnvelope
    set?: TaskMessageWhereUniqueInput | TaskMessageWhereUniqueInput[]
    disconnect?: TaskMessageWhereUniqueInput | TaskMessageWhereUniqueInput[]
    delete?: TaskMessageWhereUniqueInput | TaskMessageWhereUniqueInput[]
    connect?: TaskMessageWhereUniqueInput | TaskMessageWhereUniqueInput[]
    update?: TaskMessageUpdateWithWhereUniqueWithoutSenderInput | TaskMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: TaskMessageUpdateManyWithWhereWithoutSenderInput | TaskMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: TaskMessageScalarWhereInput | TaskMessageScalarWhereInput[]
  }

  export type DepartmentMonthlyReportUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DepartmentMonthlyReportCreateWithoutUserInput, DepartmentMonthlyReportUncheckedCreateWithoutUserInput> | DepartmentMonthlyReportCreateWithoutUserInput[] | DepartmentMonthlyReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DepartmentMonthlyReportCreateOrConnectWithoutUserInput | DepartmentMonthlyReportCreateOrConnectWithoutUserInput[]
    upsert?: DepartmentMonthlyReportUpsertWithWhereUniqueWithoutUserInput | DepartmentMonthlyReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DepartmentMonthlyReportCreateManyUserInputEnvelope
    set?: DepartmentMonthlyReportWhereUniqueInput | DepartmentMonthlyReportWhereUniqueInput[]
    disconnect?: DepartmentMonthlyReportWhereUniqueInput | DepartmentMonthlyReportWhereUniqueInput[]
    delete?: DepartmentMonthlyReportWhereUniqueInput | DepartmentMonthlyReportWhereUniqueInput[]
    connect?: DepartmentMonthlyReportWhereUniqueInput | DepartmentMonthlyReportWhereUniqueInput[]
    update?: DepartmentMonthlyReportUpdateWithWhereUniqueWithoutUserInput | DepartmentMonthlyReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DepartmentMonthlyReportUpdateManyWithWhereWithoutUserInput | DepartmentMonthlyReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DepartmentMonthlyReportScalarWhereInput | DepartmentMonthlyReportScalarWhereInput[]
  }

  export type DepartmentMeetingUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<DepartmentMeetingCreateWithoutCreatorInput, DepartmentMeetingUncheckedCreateWithoutCreatorInput> | DepartmentMeetingCreateWithoutCreatorInput[] | DepartmentMeetingUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: DepartmentMeetingCreateOrConnectWithoutCreatorInput | DepartmentMeetingCreateOrConnectWithoutCreatorInput[]
    upsert?: DepartmentMeetingUpsertWithWhereUniqueWithoutCreatorInput | DepartmentMeetingUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: DepartmentMeetingCreateManyCreatorInputEnvelope
    set?: DepartmentMeetingWhereUniqueInput | DepartmentMeetingWhereUniqueInput[]
    disconnect?: DepartmentMeetingWhereUniqueInput | DepartmentMeetingWhereUniqueInput[]
    delete?: DepartmentMeetingWhereUniqueInput | DepartmentMeetingWhereUniqueInput[]
    connect?: DepartmentMeetingWhereUniqueInput | DepartmentMeetingWhereUniqueInput[]
    update?: DepartmentMeetingUpdateWithWhereUniqueWithoutCreatorInput | DepartmentMeetingUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: DepartmentMeetingUpdateManyWithWhereWithoutCreatorInput | DepartmentMeetingUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: DepartmentMeetingScalarWhereInput | DepartmentMeetingScalarWhereInput[]
  }

  export type DepartmentPollUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<DepartmentPollCreateWithoutCreatorInput, DepartmentPollUncheckedCreateWithoutCreatorInput> | DepartmentPollCreateWithoutCreatorInput[] | DepartmentPollUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: DepartmentPollCreateOrConnectWithoutCreatorInput | DepartmentPollCreateOrConnectWithoutCreatorInput[]
    upsert?: DepartmentPollUpsertWithWhereUniqueWithoutCreatorInput | DepartmentPollUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: DepartmentPollCreateManyCreatorInputEnvelope
    set?: DepartmentPollWhereUniqueInput | DepartmentPollWhereUniqueInput[]
    disconnect?: DepartmentPollWhereUniqueInput | DepartmentPollWhereUniqueInput[]
    delete?: DepartmentPollWhereUniqueInput | DepartmentPollWhereUniqueInput[]
    connect?: DepartmentPollWhereUniqueInput | DepartmentPollWhereUniqueInput[]
    update?: DepartmentPollUpdateWithWhereUniqueWithoutCreatorInput | DepartmentPollUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: DepartmentPollUpdateManyWithWhereWithoutCreatorInput | DepartmentPollUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: DepartmentPollScalarWhereInput | DepartmentPollScalarWhereInput[]
  }

  export type TeamDecisionUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TeamDecisionCreateWithoutCreatorInput, TeamDecisionUncheckedCreateWithoutCreatorInput> | TeamDecisionCreateWithoutCreatorInput[] | TeamDecisionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TeamDecisionCreateOrConnectWithoutCreatorInput | TeamDecisionCreateOrConnectWithoutCreatorInput[]
    upsert?: TeamDecisionUpsertWithWhereUniqueWithoutCreatorInput | TeamDecisionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TeamDecisionCreateManyCreatorInputEnvelope
    set?: TeamDecisionWhereUniqueInput | TeamDecisionWhereUniqueInput[]
    disconnect?: TeamDecisionWhereUniqueInput | TeamDecisionWhereUniqueInput[]
    delete?: TeamDecisionWhereUniqueInput | TeamDecisionWhereUniqueInput[]
    connect?: TeamDecisionWhereUniqueInput | TeamDecisionWhereUniqueInput[]
    update?: TeamDecisionUpdateWithWhereUniqueWithoutCreatorInput | TeamDecisionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TeamDecisionUpdateManyWithWhereWithoutCreatorInput | TeamDecisionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TeamDecisionScalarWhereInput | TeamDecisionScalarWhereInput[]
  }

  export type PollVoteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PollVoteCreateWithoutUserInput, PollVoteUncheckedCreateWithoutUserInput> | PollVoteCreateWithoutUserInput[] | PollVoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PollVoteCreateOrConnectWithoutUserInput | PollVoteCreateOrConnectWithoutUserInput[]
    upsert?: PollVoteUpsertWithWhereUniqueWithoutUserInput | PollVoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PollVoteCreateManyUserInputEnvelope
    set?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    disconnect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    delete?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    connect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    update?: PollVoteUpdateWithWhereUniqueWithoutUserInput | PollVoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PollVoteUpdateManyWithWhereWithoutUserInput | PollVoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PollVoteScalarWhereInput | PollVoteScalarWhereInput[]
  }

  export type DecisionVoteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DecisionVoteCreateWithoutUserInput, DecisionVoteUncheckedCreateWithoutUserInput> | DecisionVoteCreateWithoutUserInput[] | DecisionVoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DecisionVoteCreateOrConnectWithoutUserInput | DecisionVoteCreateOrConnectWithoutUserInput[]
    upsert?: DecisionVoteUpsertWithWhereUniqueWithoutUserInput | DecisionVoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DecisionVoteCreateManyUserInputEnvelope
    set?: DecisionVoteWhereUniqueInput | DecisionVoteWhereUniqueInput[]
    disconnect?: DecisionVoteWhereUniqueInput | DecisionVoteWhereUniqueInput[]
    delete?: DecisionVoteWhereUniqueInput | DecisionVoteWhereUniqueInput[]
    connect?: DecisionVoteWhereUniqueInput | DecisionVoteWhereUniqueInput[]
    update?: DecisionVoteUpdateWithWhereUniqueWithoutUserInput | DecisionVoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DecisionVoteUpdateManyWithWhereWithoutUserInput | DecisionVoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DecisionVoteScalarWhereInput | DecisionVoteScalarWhereInput[]
  }

  export type PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput> | PushSubscriptionCreateWithoutUserInput[] | PushSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PushSubscriptionCreateOrConnectWithoutUserInput | PushSubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: PushSubscriptionUpsertWithWhereUniqueWithoutUserInput | PushSubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PushSubscriptionCreateManyUserInputEnvelope
    set?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    disconnect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    delete?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    connect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    update?: PushSubscriptionUpdateWithWhereUniqueWithoutUserInput | PushSubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PushSubscriptionUpdateManyWithWhereWithoutUserInput | PushSubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PushSubscriptionScalarWhereInput | PushSubscriptionScalarWhereInput[]
  }

  export type UserInvitationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserInvitationCreateWithoutUserInput, UserInvitationUncheckedCreateWithoutUserInput> | UserInvitationCreateWithoutUserInput[] | UserInvitationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserInvitationCreateOrConnectWithoutUserInput | UserInvitationCreateOrConnectWithoutUserInput[]
    upsert?: UserInvitationUpsertWithWhereUniqueWithoutUserInput | UserInvitationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserInvitationCreateManyUserInputEnvelope
    set?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    disconnect?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    delete?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    connect?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    update?: UserInvitationUpdateWithWhereUniqueWithoutUserInput | UserInvitationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserInvitationUpdateManyWithWhereWithoutUserInput | UserInvitationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserInvitationScalarWhereInput | UserInvitationScalarWhereInput[]
  }

  export type UserPersonalTaskUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPersonalTaskCreateWithoutUserInput, UserPersonalTaskUncheckedCreateWithoutUserInput> | UserPersonalTaskCreateWithoutUserInput[] | UserPersonalTaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPersonalTaskCreateOrConnectWithoutUserInput | UserPersonalTaskCreateOrConnectWithoutUserInput[]
    upsert?: UserPersonalTaskUpsertWithWhereUniqueWithoutUserInput | UserPersonalTaskUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPersonalTaskCreateManyUserInputEnvelope
    set?: UserPersonalTaskWhereUniqueInput | UserPersonalTaskWhereUniqueInput[]
    disconnect?: UserPersonalTaskWhereUniqueInput | UserPersonalTaskWhereUniqueInput[]
    delete?: UserPersonalTaskWhereUniqueInput | UserPersonalTaskWhereUniqueInput[]
    connect?: UserPersonalTaskWhereUniqueInput | UserPersonalTaskWhereUniqueInput[]
    update?: UserPersonalTaskUpdateWithWhereUniqueWithoutUserInput | UserPersonalTaskUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPersonalTaskUpdateManyWithWhereWithoutUserInput | UserPersonalTaskUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPersonalTaskScalarWhereInput | UserPersonalTaskScalarWhereInput[]
  }

  export type UserFinancialGoalUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserFinancialGoalCreateWithoutUserInput, UserFinancialGoalUncheckedCreateWithoutUserInput> | UserFinancialGoalCreateWithoutUserInput[] | UserFinancialGoalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFinancialGoalCreateOrConnectWithoutUserInput | UserFinancialGoalCreateOrConnectWithoutUserInput[]
    upsert?: UserFinancialGoalUpsertWithWhereUniqueWithoutUserInput | UserFinancialGoalUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserFinancialGoalCreateManyUserInputEnvelope
    set?: UserFinancialGoalWhereUniqueInput | UserFinancialGoalWhereUniqueInput[]
    disconnect?: UserFinancialGoalWhereUniqueInput | UserFinancialGoalWhereUniqueInput[]
    delete?: UserFinancialGoalWhereUniqueInput | UserFinancialGoalWhereUniqueInput[]
    connect?: UserFinancialGoalWhereUniqueInput | UserFinancialGoalWhereUniqueInput[]
    update?: UserFinancialGoalUpdateWithWhereUniqueWithoutUserInput | UserFinancialGoalUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserFinancialGoalUpdateManyWithWhereWithoutUserInput | UserFinancialGoalUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserFinancialGoalScalarWhereInput | UserFinancialGoalScalarWhereInput[]
  }

  export type UserFinancialProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserFinancialProfileCreateWithoutUserInput, UserFinancialProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserFinancialProfileCreateOrConnectWithoutUserInput
    upsert?: UserFinancialProfileUpsertWithoutUserInput
    disconnect?: UserFinancialProfileWhereInput | boolean
    delete?: UserFinancialProfileWhereInput | boolean
    connect?: UserFinancialProfileWhereUniqueInput
    update?: XOR<XOR<UserFinancialProfileUpdateToOneWithWhereWithoutUserInput, UserFinancialProfileUpdateWithoutUserInput>, UserFinancialProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserMonthlyStatementUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserMonthlyStatementCreateWithoutUserInput, UserMonthlyStatementUncheckedCreateWithoutUserInput> | UserMonthlyStatementCreateWithoutUserInput[] | UserMonthlyStatementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserMonthlyStatementCreateOrConnectWithoutUserInput | UserMonthlyStatementCreateOrConnectWithoutUserInput[]
    upsert?: UserMonthlyStatementUpsertWithWhereUniqueWithoutUserInput | UserMonthlyStatementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserMonthlyStatementCreateManyUserInputEnvelope
    set?: UserMonthlyStatementWhereUniqueInput | UserMonthlyStatementWhereUniqueInput[]
    disconnect?: UserMonthlyStatementWhereUniqueInput | UserMonthlyStatementWhereUniqueInput[]
    delete?: UserMonthlyStatementWhereUniqueInput | UserMonthlyStatementWhereUniqueInput[]
    connect?: UserMonthlyStatementWhereUniqueInput | UserMonthlyStatementWhereUniqueInput[]
    update?: UserMonthlyStatementUpdateWithWhereUniqueWithoutUserInput | UserMonthlyStatementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserMonthlyStatementUpdateManyWithWhereWithoutUserInput | UserMonthlyStatementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserMonthlyStatementScalarWhereInput | UserMonthlyStatementScalarWhereInput[]
  }

  export type UserFinancialEntryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserFinancialEntryCreateWithoutUserInput, UserFinancialEntryUncheckedCreateWithoutUserInput> | UserFinancialEntryCreateWithoutUserInput[] | UserFinancialEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFinancialEntryCreateOrConnectWithoutUserInput | UserFinancialEntryCreateOrConnectWithoutUserInput[]
    upsert?: UserFinancialEntryUpsertWithWhereUniqueWithoutUserInput | UserFinancialEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserFinancialEntryCreateManyUserInputEnvelope
    set?: UserFinancialEntryWhereUniqueInput | UserFinancialEntryWhereUniqueInput[]
    disconnect?: UserFinancialEntryWhereUniqueInput | UserFinancialEntryWhereUniqueInput[]
    delete?: UserFinancialEntryWhereUniqueInput | UserFinancialEntryWhereUniqueInput[]
    connect?: UserFinancialEntryWhereUniqueInput | UserFinancialEntryWhereUniqueInput[]
    update?: UserFinancialEntryUpdateWithWhereUniqueWithoutUserInput | UserFinancialEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserFinancialEntryUpdateManyWithWhereWithoutUserInput | UserFinancialEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserFinancialEntryScalarWhereInput | UserFinancialEntryScalarWhereInput[]
  }

  export type FollowUncheckedUpdateManyWithoutFollowingNestedInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowingInput | FollowUpsertWithWhereUniqueWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowingInput | FollowUpdateWithWhereUniqueWithoutFollowingInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowingInput | FollowUpdateManyWithWhereWithoutFollowingInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type FollowUncheckedUpdateManyWithoutFollowerNestedInput = {
    create?: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput> | FollowCreateWithoutFollowerInput[] | FollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowerInput | FollowCreateOrConnectWithoutFollowerInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowerInput | FollowUpsertWithWhereUniqueWithoutFollowerInput[]
    createMany?: FollowCreateManyFollowerInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowerInput | FollowUpdateWithWhereUniqueWithoutFollowerInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowerInput | FollowUpdateManyWithWhereWithoutFollowerInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type DepartmentDocumentUncheckedUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<DepartmentDocumentCreateWithoutUploaderInput, DepartmentDocumentUncheckedCreateWithoutUploaderInput> | DepartmentDocumentCreateWithoutUploaderInput[] | DepartmentDocumentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: DepartmentDocumentCreateOrConnectWithoutUploaderInput | DepartmentDocumentCreateOrConnectWithoutUploaderInput[]
    upsert?: DepartmentDocumentUpsertWithWhereUniqueWithoutUploaderInput | DepartmentDocumentUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: DepartmentDocumentCreateManyUploaderInputEnvelope
    set?: DepartmentDocumentWhereUniqueInput | DepartmentDocumentWhereUniqueInput[]
    disconnect?: DepartmentDocumentWhereUniqueInput | DepartmentDocumentWhereUniqueInput[]
    delete?: DepartmentDocumentWhereUniqueInput | DepartmentDocumentWhereUniqueInput[]
    connect?: DepartmentDocumentWhereUniqueInput | DepartmentDocumentWhereUniqueInput[]
    update?: DepartmentDocumentUpdateWithWhereUniqueWithoutUploaderInput | DepartmentDocumentUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: DepartmentDocumentUpdateManyWithWhereWithoutUploaderInput | DepartmentDocumentUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: DepartmentDocumentScalarWhereInput | DepartmentDocumentScalarWhereInput[]
  }

  export type GroupNoteUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<GroupNoteCreateWithoutCreatorInput, GroupNoteUncheckedCreateWithoutCreatorInput> | GroupNoteCreateWithoutCreatorInput[] | GroupNoteUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: GroupNoteCreateOrConnectWithoutCreatorInput | GroupNoteCreateOrConnectWithoutCreatorInput[]
    upsert?: GroupNoteUpsertWithWhereUniqueWithoutCreatorInput | GroupNoteUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: GroupNoteCreateManyCreatorInputEnvelope
    set?: GroupNoteWhereUniqueInput | GroupNoteWhereUniqueInput[]
    disconnect?: GroupNoteWhereUniqueInput | GroupNoteWhereUniqueInput[]
    delete?: GroupNoteWhereUniqueInput | GroupNoteWhereUniqueInput[]
    connect?: GroupNoteWhereUniqueInput | GroupNoteWhereUniqueInput[]
    update?: GroupNoteUpdateWithWhereUniqueWithoutCreatorInput | GroupNoteUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: GroupNoteUpdateManyWithWhereWithoutCreatorInput | GroupNoteUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: GroupNoteScalarWhereInput | GroupNoteScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutInvitationsInput = {
    create?: XOR<UserCreateWithoutInvitationsInput, UserUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitationsInput
    connect?: UserWhereUniqueInput
  }

  export type InvitationGuestCreateNestedManyWithoutInvitationInput = {
    create?: XOR<InvitationGuestCreateWithoutInvitationInput, InvitationGuestUncheckedCreateWithoutInvitationInput> | InvitationGuestCreateWithoutInvitationInput[] | InvitationGuestUncheckedCreateWithoutInvitationInput[]
    connectOrCreate?: InvitationGuestCreateOrConnectWithoutInvitationInput | InvitationGuestCreateOrConnectWithoutInvitationInput[]
    createMany?: InvitationGuestCreateManyInvitationInputEnvelope
    connect?: InvitationGuestWhereUniqueInput | InvitationGuestWhereUniqueInput[]
  }

  export type InvitationGuestUncheckedCreateNestedManyWithoutInvitationInput = {
    create?: XOR<InvitationGuestCreateWithoutInvitationInput, InvitationGuestUncheckedCreateWithoutInvitationInput> | InvitationGuestCreateWithoutInvitationInput[] | InvitationGuestUncheckedCreateWithoutInvitationInput[]
    connectOrCreate?: InvitationGuestCreateOrConnectWithoutInvitationInput | InvitationGuestCreateOrConnectWithoutInvitationInput[]
    createMany?: InvitationGuestCreateManyInvitationInputEnvelope
    connect?: InvitationGuestWhereUniqueInput | InvitationGuestWhereUniqueInput[]
  }

  export type EnumInvitationStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvitationStatus
  }

  export type EnumInvitationTypeFieldUpdateOperationsInput = {
    set?: $Enums.InvitationType
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutInvitationsNestedInput = {
    create?: XOR<UserCreateWithoutInvitationsInput, UserUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitationsInput
    upsert?: UserUpsertWithoutInvitationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvitationsInput, UserUpdateWithoutInvitationsInput>, UserUncheckedUpdateWithoutInvitationsInput>
  }

  export type InvitationGuestUpdateManyWithoutInvitationNestedInput = {
    create?: XOR<InvitationGuestCreateWithoutInvitationInput, InvitationGuestUncheckedCreateWithoutInvitationInput> | InvitationGuestCreateWithoutInvitationInput[] | InvitationGuestUncheckedCreateWithoutInvitationInput[]
    connectOrCreate?: InvitationGuestCreateOrConnectWithoutInvitationInput | InvitationGuestCreateOrConnectWithoutInvitationInput[]
    upsert?: InvitationGuestUpsertWithWhereUniqueWithoutInvitationInput | InvitationGuestUpsertWithWhereUniqueWithoutInvitationInput[]
    createMany?: InvitationGuestCreateManyInvitationInputEnvelope
    set?: InvitationGuestWhereUniqueInput | InvitationGuestWhereUniqueInput[]
    disconnect?: InvitationGuestWhereUniqueInput | InvitationGuestWhereUniqueInput[]
    delete?: InvitationGuestWhereUniqueInput | InvitationGuestWhereUniqueInput[]
    connect?: InvitationGuestWhereUniqueInput | InvitationGuestWhereUniqueInput[]
    update?: InvitationGuestUpdateWithWhereUniqueWithoutInvitationInput | InvitationGuestUpdateWithWhereUniqueWithoutInvitationInput[]
    updateMany?: InvitationGuestUpdateManyWithWhereWithoutInvitationInput | InvitationGuestUpdateManyWithWhereWithoutInvitationInput[]
    deleteMany?: InvitationGuestScalarWhereInput | InvitationGuestScalarWhereInput[]
  }

  export type InvitationGuestUncheckedUpdateManyWithoutInvitationNestedInput = {
    create?: XOR<InvitationGuestCreateWithoutInvitationInput, InvitationGuestUncheckedCreateWithoutInvitationInput> | InvitationGuestCreateWithoutInvitationInput[] | InvitationGuestUncheckedCreateWithoutInvitationInput[]
    connectOrCreate?: InvitationGuestCreateOrConnectWithoutInvitationInput | InvitationGuestCreateOrConnectWithoutInvitationInput[]
    upsert?: InvitationGuestUpsertWithWhereUniqueWithoutInvitationInput | InvitationGuestUpsertWithWhereUniqueWithoutInvitationInput[]
    createMany?: InvitationGuestCreateManyInvitationInputEnvelope
    set?: InvitationGuestWhereUniqueInput | InvitationGuestWhereUniqueInput[]
    disconnect?: InvitationGuestWhereUniqueInput | InvitationGuestWhereUniqueInput[]
    delete?: InvitationGuestWhereUniqueInput | InvitationGuestWhereUniqueInput[]
    connect?: InvitationGuestWhereUniqueInput | InvitationGuestWhereUniqueInput[]
    update?: InvitationGuestUpdateWithWhereUniqueWithoutInvitationInput | InvitationGuestUpdateWithWhereUniqueWithoutInvitationInput[]
    updateMany?: InvitationGuestUpdateManyWithWhereWithoutInvitationInput | InvitationGuestUpdateManyWithWhereWithoutInvitationInput[]
    deleteMany?: InvitationGuestScalarWhereInput | InvitationGuestScalarWhereInput[]
  }

  export type UserInvitationCreateNestedOneWithoutGuestsInput = {
    create?: XOR<UserInvitationCreateWithoutGuestsInput, UserInvitationUncheckedCreateWithoutGuestsInput>
    connectOrCreate?: UserInvitationCreateOrConnectWithoutGuestsInput
    connect?: UserInvitationWhereUniqueInput
  }

  export type UserInvitationUpdateOneRequiredWithoutGuestsNestedInput = {
    create?: XOR<UserInvitationCreateWithoutGuestsInput, UserInvitationUncheckedCreateWithoutGuestsInput>
    connectOrCreate?: UserInvitationCreateOrConnectWithoutGuestsInput
    upsert?: UserInvitationUpsertWithoutGuestsInput
    connect?: UserInvitationWhereUniqueInput
    update?: XOR<XOR<UserInvitationUpdateToOneWithWhereWithoutGuestsInput, UserInvitationUpdateWithoutGuestsInput>, UserInvitationUncheckedUpdateWithoutGuestsInput>
  }

  export type UserCreateNestedOneWithoutFollowingInput = {
    create?: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowingInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFollowersInput = {
    create?: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowersInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFollowingNestedInput = {
    create?: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowingInput
    upsert?: UserUpsertWithoutFollowingInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFollowingInput, UserUpdateWithoutFollowingInput>, UserUncheckedUpdateWithoutFollowingInput>
  }

  export type UserUpdateOneRequiredWithoutFollowersNestedInput = {
    create?: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowersInput
    upsert?: UserUpsertWithoutFollowersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFollowersInput, UserUpdateWithoutFollowersInput>, UserUncheckedUpdateWithoutFollowersInput>
  }

  export type DepartmentCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<DepartmentCreateWithoutOrganizationInput, DepartmentUncheckedCreateWithoutOrganizationInput> | DepartmentCreateWithoutOrganizationInput[] | DepartmentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutOrganizationInput | DepartmentCreateOrConnectWithoutOrganizationInput[]
    createMany?: DepartmentCreateManyOrganizationInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type OrganizationMemberCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<OrganizationMemberCreateWithoutOrganizationInput, OrganizationMemberUncheckedCreateWithoutOrganizationInput> | OrganizationMemberCreateWithoutOrganizationInput[] | OrganizationMemberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationMemberCreateOrConnectWithoutOrganizationInput | OrganizationMemberCreateOrConnectWithoutOrganizationInput[]
    createMany?: OrganizationMemberCreateManyOrganizationInputEnvelope
    connect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedOneWithoutOrganizationInput = {
    create?: XOR<SubscriptionCreateWithoutOrganizationInput, SubscriptionUncheckedCreateWithoutOrganizationInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutOrganizationInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type EventInvitationCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<EventInvitationCreateWithoutOrganizationInput, EventInvitationUncheckedCreateWithoutOrganizationInput> | EventInvitationCreateWithoutOrganizationInput[] | EventInvitationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: EventInvitationCreateOrConnectWithoutOrganizationInput | EventInvitationCreateOrConnectWithoutOrganizationInput[]
    createMany?: EventInvitationCreateManyOrganizationInputEnvelope
    connect?: EventInvitationWhereUniqueInput | EventInvitationWhereUniqueInput[]
  }

  export type DepartmentUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<DepartmentCreateWithoutOrganizationInput, DepartmentUncheckedCreateWithoutOrganizationInput> | DepartmentCreateWithoutOrganizationInput[] | DepartmentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutOrganizationInput | DepartmentCreateOrConnectWithoutOrganizationInput[]
    createMany?: DepartmentCreateManyOrganizationInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type OrganizationMemberUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<OrganizationMemberCreateWithoutOrganizationInput, OrganizationMemberUncheckedCreateWithoutOrganizationInput> | OrganizationMemberCreateWithoutOrganizationInput[] | OrganizationMemberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationMemberCreateOrConnectWithoutOrganizationInput | OrganizationMemberCreateOrConnectWithoutOrganizationInput[]
    createMany?: OrganizationMemberCreateManyOrganizationInputEnvelope
    connect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedOneWithoutOrganizationInput = {
    create?: XOR<SubscriptionCreateWithoutOrganizationInput, SubscriptionUncheckedCreateWithoutOrganizationInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutOrganizationInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type EventInvitationUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<EventInvitationCreateWithoutOrganizationInput, EventInvitationUncheckedCreateWithoutOrganizationInput> | EventInvitationCreateWithoutOrganizationInput[] | EventInvitationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: EventInvitationCreateOrConnectWithoutOrganizationInput | EventInvitationCreateOrConnectWithoutOrganizationInput[]
    createMany?: EventInvitationCreateManyOrganizationInputEnvelope
    connect?: EventInvitationWhereUniqueInput | EventInvitationWhereUniqueInput[]
  }

  export type DepartmentUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<DepartmentCreateWithoutOrganizationInput, DepartmentUncheckedCreateWithoutOrganizationInput> | DepartmentCreateWithoutOrganizationInput[] | DepartmentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutOrganizationInput | DepartmentCreateOrConnectWithoutOrganizationInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutOrganizationInput | DepartmentUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: DepartmentCreateManyOrganizationInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutOrganizationInput | DepartmentUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutOrganizationInput | DepartmentUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type OrganizationMemberUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<OrganizationMemberCreateWithoutOrganizationInput, OrganizationMemberUncheckedCreateWithoutOrganizationInput> | OrganizationMemberCreateWithoutOrganizationInput[] | OrganizationMemberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationMemberCreateOrConnectWithoutOrganizationInput | OrganizationMemberCreateOrConnectWithoutOrganizationInput[]
    upsert?: OrganizationMemberUpsertWithWhereUniqueWithoutOrganizationInput | OrganizationMemberUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: OrganizationMemberCreateManyOrganizationInputEnvelope
    set?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    disconnect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    delete?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    connect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    update?: OrganizationMemberUpdateWithWhereUniqueWithoutOrganizationInput | OrganizationMemberUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: OrganizationMemberUpdateManyWithWhereWithoutOrganizationInput | OrganizationMemberUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: OrganizationMemberScalarWhereInput | OrganizationMemberScalarWhereInput[]
  }

  export type SubscriptionUpdateOneWithoutOrganizationNestedInput = {
    create?: XOR<SubscriptionCreateWithoutOrganizationInput, SubscriptionUncheckedCreateWithoutOrganizationInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutOrganizationInput
    upsert?: SubscriptionUpsertWithoutOrganizationInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutOrganizationInput, SubscriptionUpdateWithoutOrganizationInput>, SubscriptionUncheckedUpdateWithoutOrganizationInput>
  }

  export type EventInvitationUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<EventInvitationCreateWithoutOrganizationInput, EventInvitationUncheckedCreateWithoutOrganizationInput> | EventInvitationCreateWithoutOrganizationInput[] | EventInvitationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: EventInvitationCreateOrConnectWithoutOrganizationInput | EventInvitationCreateOrConnectWithoutOrganizationInput[]
    upsert?: EventInvitationUpsertWithWhereUniqueWithoutOrganizationInput | EventInvitationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: EventInvitationCreateManyOrganizationInputEnvelope
    set?: EventInvitationWhereUniqueInput | EventInvitationWhereUniqueInput[]
    disconnect?: EventInvitationWhereUniqueInput | EventInvitationWhereUniqueInput[]
    delete?: EventInvitationWhereUniqueInput | EventInvitationWhereUniqueInput[]
    connect?: EventInvitationWhereUniqueInput | EventInvitationWhereUniqueInput[]
    update?: EventInvitationUpdateWithWhereUniqueWithoutOrganizationInput | EventInvitationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: EventInvitationUpdateManyWithWhereWithoutOrganizationInput | EventInvitationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: EventInvitationScalarWhereInput | EventInvitationScalarWhereInput[]
  }

  export type DepartmentUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<DepartmentCreateWithoutOrganizationInput, DepartmentUncheckedCreateWithoutOrganizationInput> | DepartmentCreateWithoutOrganizationInput[] | DepartmentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutOrganizationInput | DepartmentCreateOrConnectWithoutOrganizationInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutOrganizationInput | DepartmentUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: DepartmentCreateManyOrganizationInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutOrganizationInput | DepartmentUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutOrganizationInput | DepartmentUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type OrganizationMemberUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<OrganizationMemberCreateWithoutOrganizationInput, OrganizationMemberUncheckedCreateWithoutOrganizationInput> | OrganizationMemberCreateWithoutOrganizationInput[] | OrganizationMemberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationMemberCreateOrConnectWithoutOrganizationInput | OrganizationMemberCreateOrConnectWithoutOrganizationInput[]
    upsert?: OrganizationMemberUpsertWithWhereUniqueWithoutOrganizationInput | OrganizationMemberUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: OrganizationMemberCreateManyOrganizationInputEnvelope
    set?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    disconnect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    delete?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    connect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    update?: OrganizationMemberUpdateWithWhereUniqueWithoutOrganizationInput | OrganizationMemberUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: OrganizationMemberUpdateManyWithWhereWithoutOrganizationInput | OrganizationMemberUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: OrganizationMemberScalarWhereInput | OrganizationMemberScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateOneWithoutOrganizationNestedInput = {
    create?: XOR<SubscriptionCreateWithoutOrganizationInput, SubscriptionUncheckedCreateWithoutOrganizationInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutOrganizationInput
    upsert?: SubscriptionUpsertWithoutOrganizationInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutOrganizationInput, SubscriptionUpdateWithoutOrganizationInput>, SubscriptionUncheckedUpdateWithoutOrganizationInput>
  }

  export type EventInvitationUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<EventInvitationCreateWithoutOrganizationInput, EventInvitationUncheckedCreateWithoutOrganizationInput> | EventInvitationCreateWithoutOrganizationInput[] | EventInvitationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: EventInvitationCreateOrConnectWithoutOrganizationInput | EventInvitationCreateOrConnectWithoutOrganizationInput[]
    upsert?: EventInvitationUpsertWithWhereUniqueWithoutOrganizationInput | EventInvitationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: EventInvitationCreateManyOrganizationInputEnvelope
    set?: EventInvitationWhereUniqueInput | EventInvitationWhereUniqueInput[]
    disconnect?: EventInvitationWhereUniqueInput | EventInvitationWhereUniqueInput[]
    delete?: EventInvitationWhereUniqueInput | EventInvitationWhereUniqueInput[]
    connect?: EventInvitationWhereUniqueInput | EventInvitationWhereUniqueInput[]
    update?: EventInvitationUpdateWithWhereUniqueWithoutOrganizationInput | EventInvitationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: EventInvitationUpdateManyWithWhereWithoutOrganizationInput | EventInvitationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: EventInvitationScalarWhereInput | EventInvitationScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutMembersInput = {
    create?: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutMembersInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOrgMembershipsInput = {
    create?: XOR<UserCreateWithoutOrgMembershipsInput, UserUncheckedCreateWithoutOrgMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrgMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumOrgRoleFieldUpdateOperationsInput = {
    set?: $Enums.OrgRole
  }

  export type OrganizationUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutMembersInput
    upsert?: OrganizationUpsertWithoutMembersInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutMembersInput, OrganizationUpdateWithoutMembersInput>, OrganizationUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutOrgMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutOrgMembershipsInput, UserUncheckedCreateWithoutOrgMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrgMembershipsInput
    upsert?: UserUpsertWithoutOrgMembershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrgMembershipsInput, UserUpdateWithoutOrgMembershipsInput>, UserUncheckedUpdateWithoutOrgMembershipsInput>
  }

  export type OrganizationCreateNestedOneWithoutDepartmentsInput = {
    create?: XOR<OrganizationCreateWithoutDepartmentsInput, OrganizationUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutDepartmentsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutHeadedDepartmentsInput = {
    create?: XOR<UserCreateWithoutHeadedDepartmentsInput, UserUncheckedCreateWithoutHeadedDepartmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutHeadedDepartmentsInput
    connect?: UserWhereUniqueInput
  }

  export type DepartmentMemberCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<DepartmentMemberCreateWithoutDepartmentInput, DepartmentMemberUncheckedCreateWithoutDepartmentInput> | DepartmentMemberCreateWithoutDepartmentInput[] | DepartmentMemberUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DepartmentMemberCreateOrConnectWithoutDepartmentInput | DepartmentMemberCreateOrConnectWithoutDepartmentInput[]
    createMany?: DepartmentMemberCreateManyDepartmentInputEnvelope
    connect?: DepartmentMemberWhereUniqueInput | DepartmentMemberWhereUniqueInput[]
  }

  export type GroupCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<GroupCreateWithoutDepartmentInput, GroupUncheckedCreateWithoutDepartmentInput> | GroupCreateWithoutDepartmentInput[] | GroupUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutDepartmentInput | GroupCreateOrConnectWithoutDepartmentInput[]
    createMany?: GroupCreateManyDepartmentInputEnvelope
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<TaskCreateWithoutDepartmentInput, TaskUncheckedCreateWithoutDepartmentInput> | TaskCreateWithoutDepartmentInput[] | TaskUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutDepartmentInput | TaskCreateOrConnectWithoutDepartmentInput[]
    createMany?: TaskCreateManyDepartmentInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type EventDepartmentBroadcastCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<EventDepartmentBroadcastCreateWithoutDepartmentInput, EventDepartmentBroadcastUncheckedCreateWithoutDepartmentInput> | EventDepartmentBroadcastCreateWithoutDepartmentInput[] | EventDepartmentBroadcastUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: EventDepartmentBroadcastCreateOrConnectWithoutDepartmentInput | EventDepartmentBroadcastCreateOrConnectWithoutDepartmentInput[]
    createMany?: EventDepartmentBroadcastCreateManyDepartmentInputEnvelope
    connect?: EventDepartmentBroadcastWhereUniqueInput | EventDepartmentBroadcastWhereUniqueInput[]
  }

  export type DepartmentMonthlyReportCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<DepartmentMonthlyReportCreateWithoutDepartmentInput, DepartmentMonthlyReportUncheckedCreateWithoutDepartmentInput> | DepartmentMonthlyReportCreateWithoutDepartmentInput[] | DepartmentMonthlyReportUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DepartmentMonthlyReportCreateOrConnectWithoutDepartmentInput | DepartmentMonthlyReportCreateOrConnectWithoutDepartmentInput[]
    createMany?: DepartmentMonthlyReportCreateManyDepartmentInputEnvelope
    connect?: DepartmentMonthlyReportWhereUniqueInput | DepartmentMonthlyReportWhereUniqueInput[]
  }

  export type DepartmentGoalCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<DepartmentGoalCreateWithoutDepartmentInput, DepartmentGoalUncheckedCreateWithoutDepartmentInput> | DepartmentGoalCreateWithoutDepartmentInput[] | DepartmentGoalUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DepartmentGoalCreateOrConnectWithoutDepartmentInput | DepartmentGoalCreateOrConnectWithoutDepartmentInput[]
    createMany?: DepartmentGoalCreateManyDepartmentInputEnvelope
    connect?: DepartmentGoalWhereUniqueInput | DepartmentGoalWhereUniqueInput[]
  }

  export type DepartmentMeetingCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<DepartmentMeetingCreateWithoutDepartmentInput, DepartmentMeetingUncheckedCreateWithoutDepartmentInput> | DepartmentMeetingCreateWithoutDepartmentInput[] | DepartmentMeetingUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DepartmentMeetingCreateOrConnectWithoutDepartmentInput | DepartmentMeetingCreateOrConnectWithoutDepartmentInput[]
    createMany?: DepartmentMeetingCreateManyDepartmentInputEnvelope
    connect?: DepartmentMeetingWhereUniqueInput | DepartmentMeetingWhereUniqueInput[]
  }

  export type DepartmentPollCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<DepartmentPollCreateWithoutDepartmentInput, DepartmentPollUncheckedCreateWithoutDepartmentInput> | DepartmentPollCreateWithoutDepartmentInput[] | DepartmentPollUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DepartmentPollCreateOrConnectWithoutDepartmentInput | DepartmentPollCreateOrConnectWithoutDepartmentInput[]
    createMany?: DepartmentPollCreateManyDepartmentInputEnvelope
    connect?: DepartmentPollWhereUniqueInput | DepartmentPollWhereUniqueInput[]
  }

  export type TeamDecisionCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<TeamDecisionCreateWithoutDepartmentInput, TeamDecisionUncheckedCreateWithoutDepartmentInput> | TeamDecisionCreateWithoutDepartmentInput[] | TeamDecisionUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: TeamDecisionCreateOrConnectWithoutDepartmentInput | TeamDecisionCreateOrConnectWithoutDepartmentInput[]
    createMany?: TeamDecisionCreateManyDepartmentInputEnvelope
    connect?: TeamDecisionWhereUniqueInput | TeamDecisionWhereUniqueInput[]
  }

  export type DepartmentDocumentCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<DepartmentDocumentCreateWithoutDepartmentInput, DepartmentDocumentUncheckedCreateWithoutDepartmentInput> | DepartmentDocumentCreateWithoutDepartmentInput[] | DepartmentDocumentUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DepartmentDocumentCreateOrConnectWithoutDepartmentInput | DepartmentDocumentCreateOrConnectWithoutDepartmentInput[]
    createMany?: DepartmentDocumentCreateManyDepartmentInputEnvelope
    connect?: DepartmentDocumentWhereUniqueInput | DepartmentDocumentWhereUniqueInput[]
  }

  export type DepartmentMemberUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<DepartmentMemberCreateWithoutDepartmentInput, DepartmentMemberUncheckedCreateWithoutDepartmentInput> | DepartmentMemberCreateWithoutDepartmentInput[] | DepartmentMemberUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DepartmentMemberCreateOrConnectWithoutDepartmentInput | DepartmentMemberCreateOrConnectWithoutDepartmentInput[]
    createMany?: DepartmentMemberCreateManyDepartmentInputEnvelope
    connect?: DepartmentMemberWhereUniqueInput | DepartmentMemberWhereUniqueInput[]
  }

  export type GroupUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<GroupCreateWithoutDepartmentInput, GroupUncheckedCreateWithoutDepartmentInput> | GroupCreateWithoutDepartmentInput[] | GroupUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutDepartmentInput | GroupCreateOrConnectWithoutDepartmentInput[]
    createMany?: GroupCreateManyDepartmentInputEnvelope
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<TaskCreateWithoutDepartmentInput, TaskUncheckedCreateWithoutDepartmentInput> | TaskCreateWithoutDepartmentInput[] | TaskUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutDepartmentInput | TaskCreateOrConnectWithoutDepartmentInput[]
    createMany?: TaskCreateManyDepartmentInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type EventDepartmentBroadcastUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<EventDepartmentBroadcastCreateWithoutDepartmentInput, EventDepartmentBroadcastUncheckedCreateWithoutDepartmentInput> | EventDepartmentBroadcastCreateWithoutDepartmentInput[] | EventDepartmentBroadcastUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: EventDepartmentBroadcastCreateOrConnectWithoutDepartmentInput | EventDepartmentBroadcastCreateOrConnectWithoutDepartmentInput[]
    createMany?: EventDepartmentBroadcastCreateManyDepartmentInputEnvelope
    connect?: EventDepartmentBroadcastWhereUniqueInput | EventDepartmentBroadcastWhereUniqueInput[]
  }

  export type DepartmentMonthlyReportUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<DepartmentMonthlyReportCreateWithoutDepartmentInput, DepartmentMonthlyReportUncheckedCreateWithoutDepartmentInput> | DepartmentMonthlyReportCreateWithoutDepartmentInput[] | DepartmentMonthlyReportUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DepartmentMonthlyReportCreateOrConnectWithoutDepartmentInput | DepartmentMonthlyReportCreateOrConnectWithoutDepartmentInput[]
    createMany?: DepartmentMonthlyReportCreateManyDepartmentInputEnvelope
    connect?: DepartmentMonthlyReportWhereUniqueInput | DepartmentMonthlyReportWhereUniqueInput[]
  }

  export type DepartmentGoalUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<DepartmentGoalCreateWithoutDepartmentInput, DepartmentGoalUncheckedCreateWithoutDepartmentInput> | DepartmentGoalCreateWithoutDepartmentInput[] | DepartmentGoalUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DepartmentGoalCreateOrConnectWithoutDepartmentInput | DepartmentGoalCreateOrConnectWithoutDepartmentInput[]
    createMany?: DepartmentGoalCreateManyDepartmentInputEnvelope
    connect?: DepartmentGoalWhereUniqueInput | DepartmentGoalWhereUniqueInput[]
  }

  export type DepartmentMeetingUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<DepartmentMeetingCreateWithoutDepartmentInput, DepartmentMeetingUncheckedCreateWithoutDepartmentInput> | DepartmentMeetingCreateWithoutDepartmentInput[] | DepartmentMeetingUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DepartmentMeetingCreateOrConnectWithoutDepartmentInput | DepartmentMeetingCreateOrConnectWithoutDepartmentInput[]
    createMany?: DepartmentMeetingCreateManyDepartmentInputEnvelope
    connect?: DepartmentMeetingWhereUniqueInput | DepartmentMeetingWhereUniqueInput[]
  }

  export type DepartmentPollUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<DepartmentPollCreateWithoutDepartmentInput, DepartmentPollUncheckedCreateWithoutDepartmentInput> | DepartmentPollCreateWithoutDepartmentInput[] | DepartmentPollUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DepartmentPollCreateOrConnectWithoutDepartmentInput | DepartmentPollCreateOrConnectWithoutDepartmentInput[]
    createMany?: DepartmentPollCreateManyDepartmentInputEnvelope
    connect?: DepartmentPollWhereUniqueInput | DepartmentPollWhereUniqueInput[]
  }

  export type TeamDecisionUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<TeamDecisionCreateWithoutDepartmentInput, TeamDecisionUncheckedCreateWithoutDepartmentInput> | TeamDecisionCreateWithoutDepartmentInput[] | TeamDecisionUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: TeamDecisionCreateOrConnectWithoutDepartmentInput | TeamDecisionCreateOrConnectWithoutDepartmentInput[]
    createMany?: TeamDecisionCreateManyDepartmentInputEnvelope
    connect?: TeamDecisionWhereUniqueInput | TeamDecisionWhereUniqueInput[]
  }

  export type DepartmentDocumentUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<DepartmentDocumentCreateWithoutDepartmentInput, DepartmentDocumentUncheckedCreateWithoutDepartmentInput> | DepartmentDocumentCreateWithoutDepartmentInput[] | DepartmentDocumentUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DepartmentDocumentCreateOrConnectWithoutDepartmentInput | DepartmentDocumentCreateOrConnectWithoutDepartmentInput[]
    createMany?: DepartmentDocumentCreateManyDepartmentInputEnvelope
    connect?: DepartmentDocumentWhereUniqueInput | DepartmentDocumentWhereUniqueInput[]
  }

  export type OrganizationUpdateOneRequiredWithoutDepartmentsNestedInput = {
    create?: XOR<OrganizationCreateWithoutDepartmentsInput, OrganizationUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutDepartmentsInput
    upsert?: OrganizationUpsertWithoutDepartmentsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutDepartmentsInput, OrganizationUpdateWithoutDepartmentsInput>, OrganizationUncheckedUpdateWithoutDepartmentsInput>
  }

  export type UserUpdateOneWithoutHeadedDepartmentsNestedInput = {
    create?: XOR<UserCreateWithoutHeadedDepartmentsInput, UserUncheckedCreateWithoutHeadedDepartmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutHeadedDepartmentsInput
    upsert?: UserUpsertWithoutHeadedDepartmentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutHeadedDepartmentsInput, UserUpdateWithoutHeadedDepartmentsInput>, UserUncheckedUpdateWithoutHeadedDepartmentsInput>
  }

  export type DepartmentMemberUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<DepartmentMemberCreateWithoutDepartmentInput, DepartmentMemberUncheckedCreateWithoutDepartmentInput> | DepartmentMemberCreateWithoutDepartmentInput[] | DepartmentMemberUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DepartmentMemberCreateOrConnectWithoutDepartmentInput | DepartmentMemberCreateOrConnectWithoutDepartmentInput[]
    upsert?: DepartmentMemberUpsertWithWhereUniqueWithoutDepartmentInput | DepartmentMemberUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: DepartmentMemberCreateManyDepartmentInputEnvelope
    set?: DepartmentMemberWhereUniqueInput | DepartmentMemberWhereUniqueInput[]
    disconnect?: DepartmentMemberWhereUniqueInput | DepartmentMemberWhereUniqueInput[]
    delete?: DepartmentMemberWhereUniqueInput | DepartmentMemberWhereUniqueInput[]
    connect?: DepartmentMemberWhereUniqueInput | DepartmentMemberWhereUniqueInput[]
    update?: DepartmentMemberUpdateWithWhereUniqueWithoutDepartmentInput | DepartmentMemberUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: DepartmentMemberUpdateManyWithWhereWithoutDepartmentInput | DepartmentMemberUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: DepartmentMemberScalarWhereInput | DepartmentMemberScalarWhereInput[]
  }

  export type GroupUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<GroupCreateWithoutDepartmentInput, GroupUncheckedCreateWithoutDepartmentInput> | GroupCreateWithoutDepartmentInput[] | GroupUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutDepartmentInput | GroupCreateOrConnectWithoutDepartmentInput[]
    upsert?: GroupUpsertWithWhereUniqueWithoutDepartmentInput | GroupUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: GroupCreateManyDepartmentInputEnvelope
    set?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    disconnect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    delete?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    update?: GroupUpdateWithWhereUniqueWithoutDepartmentInput | GroupUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: GroupUpdateManyWithWhereWithoutDepartmentInput | GroupUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: GroupScalarWhereInput | GroupScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<TaskCreateWithoutDepartmentInput, TaskUncheckedCreateWithoutDepartmentInput> | TaskCreateWithoutDepartmentInput[] | TaskUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutDepartmentInput | TaskCreateOrConnectWithoutDepartmentInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutDepartmentInput | TaskUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: TaskCreateManyDepartmentInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutDepartmentInput | TaskUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutDepartmentInput | TaskUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type EventDepartmentBroadcastUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<EventDepartmentBroadcastCreateWithoutDepartmentInput, EventDepartmentBroadcastUncheckedCreateWithoutDepartmentInput> | EventDepartmentBroadcastCreateWithoutDepartmentInput[] | EventDepartmentBroadcastUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: EventDepartmentBroadcastCreateOrConnectWithoutDepartmentInput | EventDepartmentBroadcastCreateOrConnectWithoutDepartmentInput[]
    upsert?: EventDepartmentBroadcastUpsertWithWhereUniqueWithoutDepartmentInput | EventDepartmentBroadcastUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: EventDepartmentBroadcastCreateManyDepartmentInputEnvelope
    set?: EventDepartmentBroadcastWhereUniqueInput | EventDepartmentBroadcastWhereUniqueInput[]
    disconnect?: EventDepartmentBroadcastWhereUniqueInput | EventDepartmentBroadcastWhereUniqueInput[]
    delete?: EventDepartmentBroadcastWhereUniqueInput | EventDepartmentBroadcastWhereUniqueInput[]
    connect?: EventDepartmentBroadcastWhereUniqueInput | EventDepartmentBroadcastWhereUniqueInput[]
    update?: EventDepartmentBroadcastUpdateWithWhereUniqueWithoutDepartmentInput | EventDepartmentBroadcastUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: EventDepartmentBroadcastUpdateManyWithWhereWithoutDepartmentInput | EventDepartmentBroadcastUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: EventDepartmentBroadcastScalarWhereInput | EventDepartmentBroadcastScalarWhereInput[]
  }

  export type DepartmentMonthlyReportUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<DepartmentMonthlyReportCreateWithoutDepartmentInput, DepartmentMonthlyReportUncheckedCreateWithoutDepartmentInput> | DepartmentMonthlyReportCreateWithoutDepartmentInput[] | DepartmentMonthlyReportUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DepartmentMonthlyReportCreateOrConnectWithoutDepartmentInput | DepartmentMonthlyReportCreateOrConnectWithoutDepartmentInput[]
    upsert?: DepartmentMonthlyReportUpsertWithWhereUniqueWithoutDepartmentInput | DepartmentMonthlyReportUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: DepartmentMonthlyReportCreateManyDepartmentInputEnvelope
    set?: DepartmentMonthlyReportWhereUniqueInput | DepartmentMonthlyReportWhereUniqueInput[]
    disconnect?: DepartmentMonthlyReportWhereUniqueInput | DepartmentMonthlyReportWhereUniqueInput[]
    delete?: DepartmentMonthlyReportWhereUniqueInput | DepartmentMonthlyReportWhereUniqueInput[]
    connect?: DepartmentMonthlyReportWhereUniqueInput | DepartmentMonthlyReportWhereUniqueInput[]
    update?: DepartmentMonthlyReportUpdateWithWhereUniqueWithoutDepartmentInput | DepartmentMonthlyReportUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: DepartmentMonthlyReportUpdateManyWithWhereWithoutDepartmentInput | DepartmentMonthlyReportUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: DepartmentMonthlyReportScalarWhereInput | DepartmentMonthlyReportScalarWhereInput[]
  }

  export type DepartmentGoalUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<DepartmentGoalCreateWithoutDepartmentInput, DepartmentGoalUncheckedCreateWithoutDepartmentInput> | DepartmentGoalCreateWithoutDepartmentInput[] | DepartmentGoalUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DepartmentGoalCreateOrConnectWithoutDepartmentInput | DepartmentGoalCreateOrConnectWithoutDepartmentInput[]
    upsert?: DepartmentGoalUpsertWithWhereUniqueWithoutDepartmentInput | DepartmentGoalUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: DepartmentGoalCreateManyDepartmentInputEnvelope
    set?: DepartmentGoalWhereUniqueInput | DepartmentGoalWhereUniqueInput[]
    disconnect?: DepartmentGoalWhereUniqueInput | DepartmentGoalWhereUniqueInput[]
    delete?: DepartmentGoalWhereUniqueInput | DepartmentGoalWhereUniqueInput[]
    connect?: DepartmentGoalWhereUniqueInput | DepartmentGoalWhereUniqueInput[]
    update?: DepartmentGoalUpdateWithWhereUniqueWithoutDepartmentInput | DepartmentGoalUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: DepartmentGoalUpdateManyWithWhereWithoutDepartmentInput | DepartmentGoalUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: DepartmentGoalScalarWhereInput | DepartmentGoalScalarWhereInput[]
  }

  export type DepartmentMeetingUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<DepartmentMeetingCreateWithoutDepartmentInput, DepartmentMeetingUncheckedCreateWithoutDepartmentInput> | DepartmentMeetingCreateWithoutDepartmentInput[] | DepartmentMeetingUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DepartmentMeetingCreateOrConnectWithoutDepartmentInput | DepartmentMeetingCreateOrConnectWithoutDepartmentInput[]
    upsert?: DepartmentMeetingUpsertWithWhereUniqueWithoutDepartmentInput | DepartmentMeetingUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: DepartmentMeetingCreateManyDepartmentInputEnvelope
    set?: DepartmentMeetingWhereUniqueInput | DepartmentMeetingWhereUniqueInput[]
    disconnect?: DepartmentMeetingWhereUniqueInput | DepartmentMeetingWhereUniqueInput[]
    delete?: DepartmentMeetingWhereUniqueInput | DepartmentMeetingWhereUniqueInput[]
    connect?: DepartmentMeetingWhereUniqueInput | DepartmentMeetingWhereUniqueInput[]
    update?: DepartmentMeetingUpdateWithWhereUniqueWithoutDepartmentInput | DepartmentMeetingUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: DepartmentMeetingUpdateManyWithWhereWithoutDepartmentInput | DepartmentMeetingUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: DepartmentMeetingScalarWhereInput | DepartmentMeetingScalarWhereInput[]
  }

  export type DepartmentPollUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<DepartmentPollCreateWithoutDepartmentInput, DepartmentPollUncheckedCreateWithoutDepartmentInput> | DepartmentPollCreateWithoutDepartmentInput[] | DepartmentPollUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DepartmentPollCreateOrConnectWithoutDepartmentInput | DepartmentPollCreateOrConnectWithoutDepartmentInput[]
    upsert?: DepartmentPollUpsertWithWhereUniqueWithoutDepartmentInput | DepartmentPollUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: DepartmentPollCreateManyDepartmentInputEnvelope
    set?: DepartmentPollWhereUniqueInput | DepartmentPollWhereUniqueInput[]
    disconnect?: DepartmentPollWhereUniqueInput | DepartmentPollWhereUniqueInput[]
    delete?: DepartmentPollWhereUniqueInput | DepartmentPollWhereUniqueInput[]
    connect?: DepartmentPollWhereUniqueInput | DepartmentPollWhereUniqueInput[]
    update?: DepartmentPollUpdateWithWhereUniqueWithoutDepartmentInput | DepartmentPollUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: DepartmentPollUpdateManyWithWhereWithoutDepartmentInput | DepartmentPollUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: DepartmentPollScalarWhereInput | DepartmentPollScalarWhereInput[]
  }

  export type TeamDecisionUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<TeamDecisionCreateWithoutDepartmentInput, TeamDecisionUncheckedCreateWithoutDepartmentInput> | TeamDecisionCreateWithoutDepartmentInput[] | TeamDecisionUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: TeamDecisionCreateOrConnectWithoutDepartmentInput | TeamDecisionCreateOrConnectWithoutDepartmentInput[]
    upsert?: TeamDecisionUpsertWithWhereUniqueWithoutDepartmentInput | TeamDecisionUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: TeamDecisionCreateManyDepartmentInputEnvelope
    set?: TeamDecisionWhereUniqueInput | TeamDecisionWhereUniqueInput[]
    disconnect?: TeamDecisionWhereUniqueInput | TeamDecisionWhereUniqueInput[]
    delete?: TeamDecisionWhereUniqueInput | TeamDecisionWhereUniqueInput[]
    connect?: TeamDecisionWhereUniqueInput | TeamDecisionWhereUniqueInput[]
    update?: TeamDecisionUpdateWithWhereUniqueWithoutDepartmentInput | TeamDecisionUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: TeamDecisionUpdateManyWithWhereWithoutDepartmentInput | TeamDecisionUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: TeamDecisionScalarWhereInput | TeamDecisionScalarWhereInput[]
  }

  export type DepartmentDocumentUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<DepartmentDocumentCreateWithoutDepartmentInput, DepartmentDocumentUncheckedCreateWithoutDepartmentInput> | DepartmentDocumentCreateWithoutDepartmentInput[] | DepartmentDocumentUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DepartmentDocumentCreateOrConnectWithoutDepartmentInput | DepartmentDocumentCreateOrConnectWithoutDepartmentInput[]
    upsert?: DepartmentDocumentUpsertWithWhereUniqueWithoutDepartmentInput | DepartmentDocumentUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: DepartmentDocumentCreateManyDepartmentInputEnvelope
    set?: DepartmentDocumentWhereUniqueInput | DepartmentDocumentWhereUniqueInput[]
    disconnect?: DepartmentDocumentWhereUniqueInput | DepartmentDocumentWhereUniqueInput[]
    delete?: DepartmentDocumentWhereUniqueInput | DepartmentDocumentWhereUniqueInput[]
    connect?: DepartmentDocumentWhereUniqueInput | DepartmentDocumentWhereUniqueInput[]
    update?: DepartmentDocumentUpdateWithWhereUniqueWithoutDepartmentInput | DepartmentDocumentUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: DepartmentDocumentUpdateManyWithWhereWithoutDepartmentInput | DepartmentDocumentUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: DepartmentDocumentScalarWhereInput | DepartmentDocumentScalarWhereInput[]
  }

  export type DepartmentMemberUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<DepartmentMemberCreateWithoutDepartmentInput, DepartmentMemberUncheckedCreateWithoutDepartmentInput> | DepartmentMemberCreateWithoutDepartmentInput[] | DepartmentMemberUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DepartmentMemberCreateOrConnectWithoutDepartmentInput | DepartmentMemberCreateOrConnectWithoutDepartmentInput[]
    upsert?: DepartmentMemberUpsertWithWhereUniqueWithoutDepartmentInput | DepartmentMemberUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: DepartmentMemberCreateManyDepartmentInputEnvelope
    set?: DepartmentMemberWhereUniqueInput | DepartmentMemberWhereUniqueInput[]
    disconnect?: DepartmentMemberWhereUniqueInput | DepartmentMemberWhereUniqueInput[]
    delete?: DepartmentMemberWhereUniqueInput | DepartmentMemberWhereUniqueInput[]
    connect?: DepartmentMemberWhereUniqueInput | DepartmentMemberWhereUniqueInput[]
    update?: DepartmentMemberUpdateWithWhereUniqueWithoutDepartmentInput | DepartmentMemberUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: DepartmentMemberUpdateManyWithWhereWithoutDepartmentInput | DepartmentMemberUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: DepartmentMemberScalarWhereInput | DepartmentMemberScalarWhereInput[]
  }

  export type GroupUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<GroupCreateWithoutDepartmentInput, GroupUncheckedCreateWithoutDepartmentInput> | GroupCreateWithoutDepartmentInput[] | GroupUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutDepartmentInput | GroupCreateOrConnectWithoutDepartmentInput[]
    upsert?: GroupUpsertWithWhereUniqueWithoutDepartmentInput | GroupUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: GroupCreateManyDepartmentInputEnvelope
    set?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    disconnect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    delete?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    update?: GroupUpdateWithWhereUniqueWithoutDepartmentInput | GroupUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: GroupUpdateManyWithWhereWithoutDepartmentInput | GroupUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: GroupScalarWhereInput | GroupScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<TaskCreateWithoutDepartmentInput, TaskUncheckedCreateWithoutDepartmentInput> | TaskCreateWithoutDepartmentInput[] | TaskUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutDepartmentInput | TaskCreateOrConnectWithoutDepartmentInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutDepartmentInput | TaskUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: TaskCreateManyDepartmentInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutDepartmentInput | TaskUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutDepartmentInput | TaskUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type EventDepartmentBroadcastUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<EventDepartmentBroadcastCreateWithoutDepartmentInput, EventDepartmentBroadcastUncheckedCreateWithoutDepartmentInput> | EventDepartmentBroadcastCreateWithoutDepartmentInput[] | EventDepartmentBroadcastUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: EventDepartmentBroadcastCreateOrConnectWithoutDepartmentInput | EventDepartmentBroadcastCreateOrConnectWithoutDepartmentInput[]
    upsert?: EventDepartmentBroadcastUpsertWithWhereUniqueWithoutDepartmentInput | EventDepartmentBroadcastUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: EventDepartmentBroadcastCreateManyDepartmentInputEnvelope
    set?: EventDepartmentBroadcastWhereUniqueInput | EventDepartmentBroadcastWhereUniqueInput[]
    disconnect?: EventDepartmentBroadcastWhereUniqueInput | EventDepartmentBroadcastWhereUniqueInput[]
    delete?: EventDepartmentBroadcastWhereUniqueInput | EventDepartmentBroadcastWhereUniqueInput[]
    connect?: EventDepartmentBroadcastWhereUniqueInput | EventDepartmentBroadcastWhereUniqueInput[]
    update?: EventDepartmentBroadcastUpdateWithWhereUniqueWithoutDepartmentInput | EventDepartmentBroadcastUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: EventDepartmentBroadcastUpdateManyWithWhereWithoutDepartmentInput | EventDepartmentBroadcastUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: EventDepartmentBroadcastScalarWhereInput | EventDepartmentBroadcastScalarWhereInput[]
  }

  export type DepartmentMonthlyReportUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<DepartmentMonthlyReportCreateWithoutDepartmentInput, DepartmentMonthlyReportUncheckedCreateWithoutDepartmentInput> | DepartmentMonthlyReportCreateWithoutDepartmentInput[] | DepartmentMonthlyReportUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DepartmentMonthlyReportCreateOrConnectWithoutDepartmentInput | DepartmentMonthlyReportCreateOrConnectWithoutDepartmentInput[]
    upsert?: DepartmentMonthlyReportUpsertWithWhereUniqueWithoutDepartmentInput | DepartmentMonthlyReportUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: DepartmentMonthlyReportCreateManyDepartmentInputEnvelope
    set?: DepartmentMonthlyReportWhereUniqueInput | DepartmentMonthlyReportWhereUniqueInput[]
    disconnect?: DepartmentMonthlyReportWhereUniqueInput | DepartmentMonthlyReportWhereUniqueInput[]
    delete?: DepartmentMonthlyReportWhereUniqueInput | DepartmentMonthlyReportWhereUniqueInput[]
    connect?: DepartmentMonthlyReportWhereUniqueInput | DepartmentMonthlyReportWhereUniqueInput[]
    update?: DepartmentMonthlyReportUpdateWithWhereUniqueWithoutDepartmentInput | DepartmentMonthlyReportUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: DepartmentMonthlyReportUpdateManyWithWhereWithoutDepartmentInput | DepartmentMonthlyReportUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: DepartmentMonthlyReportScalarWhereInput | DepartmentMonthlyReportScalarWhereInput[]
  }

  export type DepartmentGoalUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<DepartmentGoalCreateWithoutDepartmentInput, DepartmentGoalUncheckedCreateWithoutDepartmentInput> | DepartmentGoalCreateWithoutDepartmentInput[] | DepartmentGoalUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DepartmentGoalCreateOrConnectWithoutDepartmentInput | DepartmentGoalCreateOrConnectWithoutDepartmentInput[]
    upsert?: DepartmentGoalUpsertWithWhereUniqueWithoutDepartmentInput | DepartmentGoalUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: DepartmentGoalCreateManyDepartmentInputEnvelope
    set?: DepartmentGoalWhereUniqueInput | DepartmentGoalWhereUniqueInput[]
    disconnect?: DepartmentGoalWhereUniqueInput | DepartmentGoalWhereUniqueInput[]
    delete?: DepartmentGoalWhereUniqueInput | DepartmentGoalWhereUniqueInput[]
    connect?: DepartmentGoalWhereUniqueInput | DepartmentGoalWhereUniqueInput[]
    update?: DepartmentGoalUpdateWithWhereUniqueWithoutDepartmentInput | DepartmentGoalUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: DepartmentGoalUpdateManyWithWhereWithoutDepartmentInput | DepartmentGoalUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: DepartmentGoalScalarWhereInput | DepartmentGoalScalarWhereInput[]
  }

  export type DepartmentMeetingUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<DepartmentMeetingCreateWithoutDepartmentInput, DepartmentMeetingUncheckedCreateWithoutDepartmentInput> | DepartmentMeetingCreateWithoutDepartmentInput[] | DepartmentMeetingUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DepartmentMeetingCreateOrConnectWithoutDepartmentInput | DepartmentMeetingCreateOrConnectWithoutDepartmentInput[]
    upsert?: DepartmentMeetingUpsertWithWhereUniqueWithoutDepartmentInput | DepartmentMeetingUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: DepartmentMeetingCreateManyDepartmentInputEnvelope
    set?: DepartmentMeetingWhereUniqueInput | DepartmentMeetingWhereUniqueInput[]
    disconnect?: DepartmentMeetingWhereUniqueInput | DepartmentMeetingWhereUniqueInput[]
    delete?: DepartmentMeetingWhereUniqueInput | DepartmentMeetingWhereUniqueInput[]
    connect?: DepartmentMeetingWhereUniqueInput | DepartmentMeetingWhereUniqueInput[]
    update?: DepartmentMeetingUpdateWithWhereUniqueWithoutDepartmentInput | DepartmentMeetingUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: DepartmentMeetingUpdateManyWithWhereWithoutDepartmentInput | DepartmentMeetingUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: DepartmentMeetingScalarWhereInput | DepartmentMeetingScalarWhereInput[]
  }

  export type DepartmentPollUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<DepartmentPollCreateWithoutDepartmentInput, DepartmentPollUncheckedCreateWithoutDepartmentInput> | DepartmentPollCreateWithoutDepartmentInput[] | DepartmentPollUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DepartmentPollCreateOrConnectWithoutDepartmentInput | DepartmentPollCreateOrConnectWithoutDepartmentInput[]
    upsert?: DepartmentPollUpsertWithWhereUniqueWithoutDepartmentInput | DepartmentPollUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: DepartmentPollCreateManyDepartmentInputEnvelope
    set?: DepartmentPollWhereUniqueInput | DepartmentPollWhereUniqueInput[]
    disconnect?: DepartmentPollWhereUniqueInput | DepartmentPollWhereUniqueInput[]
    delete?: DepartmentPollWhereUniqueInput | DepartmentPollWhereUniqueInput[]
    connect?: DepartmentPollWhereUniqueInput | DepartmentPollWhereUniqueInput[]
    update?: DepartmentPollUpdateWithWhereUniqueWithoutDepartmentInput | DepartmentPollUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: DepartmentPollUpdateManyWithWhereWithoutDepartmentInput | DepartmentPollUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: DepartmentPollScalarWhereInput | DepartmentPollScalarWhereInput[]
  }

  export type TeamDecisionUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<TeamDecisionCreateWithoutDepartmentInput, TeamDecisionUncheckedCreateWithoutDepartmentInput> | TeamDecisionCreateWithoutDepartmentInput[] | TeamDecisionUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: TeamDecisionCreateOrConnectWithoutDepartmentInput | TeamDecisionCreateOrConnectWithoutDepartmentInput[]
    upsert?: TeamDecisionUpsertWithWhereUniqueWithoutDepartmentInput | TeamDecisionUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: TeamDecisionCreateManyDepartmentInputEnvelope
    set?: TeamDecisionWhereUniqueInput | TeamDecisionWhereUniqueInput[]
    disconnect?: TeamDecisionWhereUniqueInput | TeamDecisionWhereUniqueInput[]
    delete?: TeamDecisionWhereUniqueInput | TeamDecisionWhereUniqueInput[]
    connect?: TeamDecisionWhereUniqueInput | TeamDecisionWhereUniqueInput[]
    update?: TeamDecisionUpdateWithWhereUniqueWithoutDepartmentInput | TeamDecisionUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: TeamDecisionUpdateManyWithWhereWithoutDepartmentInput | TeamDecisionUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: TeamDecisionScalarWhereInput | TeamDecisionScalarWhereInput[]
  }

  export type DepartmentDocumentUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<DepartmentDocumentCreateWithoutDepartmentInput, DepartmentDocumentUncheckedCreateWithoutDepartmentInput> | DepartmentDocumentCreateWithoutDepartmentInput[] | DepartmentDocumentUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DepartmentDocumentCreateOrConnectWithoutDepartmentInput | DepartmentDocumentCreateOrConnectWithoutDepartmentInput[]
    upsert?: DepartmentDocumentUpsertWithWhereUniqueWithoutDepartmentInput | DepartmentDocumentUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: DepartmentDocumentCreateManyDepartmentInputEnvelope
    set?: DepartmentDocumentWhereUniqueInput | DepartmentDocumentWhereUniqueInput[]
    disconnect?: DepartmentDocumentWhereUniqueInput | DepartmentDocumentWhereUniqueInput[]
    delete?: DepartmentDocumentWhereUniqueInput | DepartmentDocumentWhereUniqueInput[]
    connect?: DepartmentDocumentWhereUniqueInput | DepartmentDocumentWhereUniqueInput[]
    update?: DepartmentDocumentUpdateWithWhereUniqueWithoutDepartmentInput | DepartmentDocumentUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: DepartmentDocumentUpdateManyWithWhereWithoutDepartmentInput | DepartmentDocumentUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: DepartmentDocumentScalarWhereInput | DepartmentDocumentScalarWhereInput[]
  }

  export type DepartmentCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<DepartmentCreateWithoutDocumentsInput, DepartmentUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutDocumentsInput
    connect?: DepartmentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUploadedDepartmentDocumentsInput = {
    create?: XOR<UserCreateWithoutUploadedDepartmentDocumentsInput, UserUncheckedCreateWithoutUploadedDepartmentDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedDepartmentDocumentsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumFileTypeFieldUpdateOperationsInput = {
    set?: $Enums.FileType
  }

  export type DepartmentUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<DepartmentCreateWithoutDocumentsInput, DepartmentUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutDocumentsInput
    upsert?: DepartmentUpsertWithoutDocumentsInput
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutDocumentsInput, DepartmentUpdateWithoutDocumentsInput>, DepartmentUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserUpdateOneRequiredWithoutUploadedDepartmentDocumentsNestedInput = {
    create?: XOR<UserCreateWithoutUploadedDepartmentDocumentsInput, UserUncheckedCreateWithoutUploadedDepartmentDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedDepartmentDocumentsInput
    upsert?: UserUpsertWithoutUploadedDepartmentDocumentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUploadedDepartmentDocumentsInput, UserUpdateWithoutUploadedDepartmentDocumentsInput>, UserUncheckedUpdateWithoutUploadedDepartmentDocumentsInput>
  }

  export type DepartmentCreateNestedOneWithoutGoalsInput = {
    create?: XOR<DepartmentCreateWithoutGoalsInput, DepartmentUncheckedCreateWithoutGoalsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutGoalsInput
    connect?: DepartmentWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DepartmentUpdateOneRequiredWithoutGoalsNestedInput = {
    create?: XOR<DepartmentCreateWithoutGoalsInput, DepartmentUncheckedCreateWithoutGoalsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutGoalsInput
    upsert?: DepartmentUpsertWithoutGoalsInput
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutGoalsInput, DepartmentUpdateWithoutGoalsInput>, DepartmentUncheckedUpdateWithoutGoalsInput>
  }

  export type DepartmentCreateNestedOneWithoutMeetingsInput = {
    create?: XOR<DepartmentCreateWithoutMeetingsInput, DepartmentUncheckedCreateWithoutMeetingsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutMeetingsInput
    connect?: DepartmentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedMeetingsInput = {
    create?: XOR<UserCreateWithoutCreatedMeetingsInput, UserUncheckedCreateWithoutCreatedMeetingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedMeetingsInput
    connect?: UserWhereUniqueInput
  }

  export type DepartmentUpdateOneRequiredWithoutMeetingsNestedInput = {
    create?: XOR<DepartmentCreateWithoutMeetingsInput, DepartmentUncheckedCreateWithoutMeetingsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutMeetingsInput
    upsert?: DepartmentUpsertWithoutMeetingsInput
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutMeetingsInput, DepartmentUpdateWithoutMeetingsInput>, DepartmentUncheckedUpdateWithoutMeetingsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedMeetingsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedMeetingsInput, UserUncheckedCreateWithoutCreatedMeetingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedMeetingsInput
    upsert?: UserUpsertWithoutCreatedMeetingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedMeetingsInput, UserUpdateWithoutCreatedMeetingsInput>, UserUncheckedUpdateWithoutCreatedMeetingsInput>
  }

  export type DepartmentCreateNestedOneWithoutPollsInput = {
    create?: XOR<DepartmentCreateWithoutPollsInput, DepartmentUncheckedCreateWithoutPollsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutPollsInput
    connect?: DepartmentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedPollsInput = {
    create?: XOR<UserCreateWithoutCreatedPollsInput, UserUncheckedCreateWithoutCreatedPollsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedPollsInput
    connect?: UserWhereUniqueInput
  }

  export type PollVoteCreateNestedManyWithoutPollInput = {
    create?: XOR<PollVoteCreateWithoutPollInput, PollVoteUncheckedCreateWithoutPollInput> | PollVoteCreateWithoutPollInput[] | PollVoteUncheckedCreateWithoutPollInput[]
    connectOrCreate?: PollVoteCreateOrConnectWithoutPollInput | PollVoteCreateOrConnectWithoutPollInput[]
    createMany?: PollVoteCreateManyPollInputEnvelope
    connect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
  }

  export type PollVoteUncheckedCreateNestedManyWithoutPollInput = {
    create?: XOR<PollVoteCreateWithoutPollInput, PollVoteUncheckedCreateWithoutPollInput> | PollVoteCreateWithoutPollInput[] | PollVoteUncheckedCreateWithoutPollInput[]
    connectOrCreate?: PollVoteCreateOrConnectWithoutPollInput | PollVoteCreateOrConnectWithoutPollInput[]
    createMany?: PollVoteCreateManyPollInputEnvelope
    connect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
  }

  export type DepartmentUpdateOneRequiredWithoutPollsNestedInput = {
    create?: XOR<DepartmentCreateWithoutPollsInput, DepartmentUncheckedCreateWithoutPollsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutPollsInput
    upsert?: DepartmentUpsertWithoutPollsInput
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutPollsInput, DepartmentUpdateWithoutPollsInput>, DepartmentUncheckedUpdateWithoutPollsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedPollsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedPollsInput, UserUncheckedCreateWithoutCreatedPollsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedPollsInput
    upsert?: UserUpsertWithoutCreatedPollsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedPollsInput, UserUpdateWithoutCreatedPollsInput>, UserUncheckedUpdateWithoutCreatedPollsInput>
  }

  export type PollVoteUpdateManyWithoutPollNestedInput = {
    create?: XOR<PollVoteCreateWithoutPollInput, PollVoteUncheckedCreateWithoutPollInput> | PollVoteCreateWithoutPollInput[] | PollVoteUncheckedCreateWithoutPollInput[]
    connectOrCreate?: PollVoteCreateOrConnectWithoutPollInput | PollVoteCreateOrConnectWithoutPollInput[]
    upsert?: PollVoteUpsertWithWhereUniqueWithoutPollInput | PollVoteUpsertWithWhereUniqueWithoutPollInput[]
    createMany?: PollVoteCreateManyPollInputEnvelope
    set?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    disconnect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    delete?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    connect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    update?: PollVoteUpdateWithWhereUniqueWithoutPollInput | PollVoteUpdateWithWhereUniqueWithoutPollInput[]
    updateMany?: PollVoteUpdateManyWithWhereWithoutPollInput | PollVoteUpdateManyWithWhereWithoutPollInput[]
    deleteMany?: PollVoteScalarWhereInput | PollVoteScalarWhereInput[]
  }

  export type PollVoteUncheckedUpdateManyWithoutPollNestedInput = {
    create?: XOR<PollVoteCreateWithoutPollInput, PollVoteUncheckedCreateWithoutPollInput> | PollVoteCreateWithoutPollInput[] | PollVoteUncheckedCreateWithoutPollInput[]
    connectOrCreate?: PollVoteCreateOrConnectWithoutPollInput | PollVoteCreateOrConnectWithoutPollInput[]
    upsert?: PollVoteUpsertWithWhereUniqueWithoutPollInput | PollVoteUpsertWithWhereUniqueWithoutPollInput[]
    createMany?: PollVoteCreateManyPollInputEnvelope
    set?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    disconnect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    delete?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    connect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    update?: PollVoteUpdateWithWhereUniqueWithoutPollInput | PollVoteUpdateWithWhereUniqueWithoutPollInput[]
    updateMany?: PollVoteUpdateManyWithWhereWithoutPollInput | PollVoteUpdateManyWithWhereWithoutPollInput[]
    deleteMany?: PollVoteScalarWhereInput | PollVoteScalarWhereInput[]
  }

  export type DepartmentPollCreateNestedOneWithoutVotesInput = {
    create?: XOR<DepartmentPollCreateWithoutVotesInput, DepartmentPollUncheckedCreateWithoutVotesInput>
    connectOrCreate?: DepartmentPollCreateOrConnectWithoutVotesInput
    connect?: DepartmentPollWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPollVotesInput = {
    create?: XOR<UserCreateWithoutPollVotesInput, UserUncheckedCreateWithoutPollVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPollVotesInput
    connect?: UserWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DepartmentPollUpdateOneRequiredWithoutVotesNestedInput = {
    create?: XOR<DepartmentPollCreateWithoutVotesInput, DepartmentPollUncheckedCreateWithoutVotesInput>
    connectOrCreate?: DepartmentPollCreateOrConnectWithoutVotesInput
    upsert?: DepartmentPollUpsertWithoutVotesInput
    connect?: DepartmentPollWhereUniqueInput
    update?: XOR<XOR<DepartmentPollUpdateToOneWithWhereWithoutVotesInput, DepartmentPollUpdateWithoutVotesInput>, DepartmentPollUncheckedUpdateWithoutVotesInput>
  }

  export type UserUpdateOneRequiredWithoutPollVotesNestedInput = {
    create?: XOR<UserCreateWithoutPollVotesInput, UserUncheckedCreateWithoutPollVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPollVotesInput
    upsert?: UserUpsertWithoutPollVotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPollVotesInput, UserUpdateWithoutPollVotesInput>, UserUncheckedUpdateWithoutPollVotesInput>
  }

  export type DepartmentCreateNestedOneWithoutTeamDecisionsInput = {
    create?: XOR<DepartmentCreateWithoutTeamDecisionsInput, DepartmentUncheckedCreateWithoutTeamDecisionsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutTeamDecisionsInput
    connect?: DepartmentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedDecisionsInput = {
    create?: XOR<UserCreateWithoutCreatedDecisionsInput, UserUncheckedCreateWithoutCreatedDecisionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedDecisionsInput
    connect?: UserWhereUniqueInput
  }

  export type DecisionVoteCreateNestedManyWithoutDecisionInput = {
    create?: XOR<DecisionVoteCreateWithoutDecisionInput, DecisionVoteUncheckedCreateWithoutDecisionInput> | DecisionVoteCreateWithoutDecisionInput[] | DecisionVoteUncheckedCreateWithoutDecisionInput[]
    connectOrCreate?: DecisionVoteCreateOrConnectWithoutDecisionInput | DecisionVoteCreateOrConnectWithoutDecisionInput[]
    createMany?: DecisionVoteCreateManyDecisionInputEnvelope
    connect?: DecisionVoteWhereUniqueInput | DecisionVoteWhereUniqueInput[]
  }

  export type DecisionVoteUncheckedCreateNestedManyWithoutDecisionInput = {
    create?: XOR<DecisionVoteCreateWithoutDecisionInput, DecisionVoteUncheckedCreateWithoutDecisionInput> | DecisionVoteCreateWithoutDecisionInput[] | DecisionVoteUncheckedCreateWithoutDecisionInput[]
    connectOrCreate?: DecisionVoteCreateOrConnectWithoutDecisionInput | DecisionVoteCreateOrConnectWithoutDecisionInput[]
    createMany?: DecisionVoteCreateManyDecisionInputEnvelope
    connect?: DecisionVoteWhereUniqueInput | DecisionVoteWhereUniqueInput[]
  }

  export type DepartmentUpdateOneRequiredWithoutTeamDecisionsNestedInput = {
    create?: XOR<DepartmentCreateWithoutTeamDecisionsInput, DepartmentUncheckedCreateWithoutTeamDecisionsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutTeamDecisionsInput
    upsert?: DepartmentUpsertWithoutTeamDecisionsInput
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutTeamDecisionsInput, DepartmentUpdateWithoutTeamDecisionsInput>, DepartmentUncheckedUpdateWithoutTeamDecisionsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedDecisionsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedDecisionsInput, UserUncheckedCreateWithoutCreatedDecisionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedDecisionsInput
    upsert?: UserUpsertWithoutCreatedDecisionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedDecisionsInput, UserUpdateWithoutCreatedDecisionsInput>, UserUncheckedUpdateWithoutCreatedDecisionsInput>
  }

  export type DecisionVoteUpdateManyWithoutDecisionNestedInput = {
    create?: XOR<DecisionVoteCreateWithoutDecisionInput, DecisionVoteUncheckedCreateWithoutDecisionInput> | DecisionVoteCreateWithoutDecisionInput[] | DecisionVoteUncheckedCreateWithoutDecisionInput[]
    connectOrCreate?: DecisionVoteCreateOrConnectWithoutDecisionInput | DecisionVoteCreateOrConnectWithoutDecisionInput[]
    upsert?: DecisionVoteUpsertWithWhereUniqueWithoutDecisionInput | DecisionVoteUpsertWithWhereUniqueWithoutDecisionInput[]
    createMany?: DecisionVoteCreateManyDecisionInputEnvelope
    set?: DecisionVoteWhereUniqueInput | DecisionVoteWhereUniqueInput[]
    disconnect?: DecisionVoteWhereUniqueInput | DecisionVoteWhereUniqueInput[]
    delete?: DecisionVoteWhereUniqueInput | DecisionVoteWhereUniqueInput[]
    connect?: DecisionVoteWhereUniqueInput | DecisionVoteWhereUniqueInput[]
    update?: DecisionVoteUpdateWithWhereUniqueWithoutDecisionInput | DecisionVoteUpdateWithWhereUniqueWithoutDecisionInput[]
    updateMany?: DecisionVoteUpdateManyWithWhereWithoutDecisionInput | DecisionVoteUpdateManyWithWhereWithoutDecisionInput[]
    deleteMany?: DecisionVoteScalarWhereInput | DecisionVoteScalarWhereInput[]
  }

  export type DecisionVoteUncheckedUpdateManyWithoutDecisionNestedInput = {
    create?: XOR<DecisionVoteCreateWithoutDecisionInput, DecisionVoteUncheckedCreateWithoutDecisionInput> | DecisionVoteCreateWithoutDecisionInput[] | DecisionVoteUncheckedCreateWithoutDecisionInput[]
    connectOrCreate?: DecisionVoteCreateOrConnectWithoutDecisionInput | DecisionVoteCreateOrConnectWithoutDecisionInput[]
    upsert?: DecisionVoteUpsertWithWhereUniqueWithoutDecisionInput | DecisionVoteUpsertWithWhereUniqueWithoutDecisionInput[]
    createMany?: DecisionVoteCreateManyDecisionInputEnvelope
    set?: DecisionVoteWhereUniqueInput | DecisionVoteWhereUniqueInput[]
    disconnect?: DecisionVoteWhereUniqueInput | DecisionVoteWhereUniqueInput[]
    delete?: DecisionVoteWhereUniqueInput | DecisionVoteWhereUniqueInput[]
    connect?: DecisionVoteWhereUniqueInput | DecisionVoteWhereUniqueInput[]
    update?: DecisionVoteUpdateWithWhereUniqueWithoutDecisionInput | DecisionVoteUpdateWithWhereUniqueWithoutDecisionInput[]
    updateMany?: DecisionVoteUpdateManyWithWhereWithoutDecisionInput | DecisionVoteUpdateManyWithWhereWithoutDecisionInput[]
    deleteMany?: DecisionVoteScalarWhereInput | DecisionVoteScalarWhereInput[]
  }

  export type TeamDecisionCreateNestedOneWithoutVotesInput = {
    create?: XOR<TeamDecisionCreateWithoutVotesInput, TeamDecisionUncheckedCreateWithoutVotesInput>
    connectOrCreate?: TeamDecisionCreateOrConnectWithoutVotesInput
    connect?: TeamDecisionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDecisionVotesInput = {
    create?: XOR<UserCreateWithoutDecisionVotesInput, UserUncheckedCreateWithoutDecisionVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDecisionVotesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumDecisionVoteTypeFieldUpdateOperationsInput = {
    set?: $Enums.DecisionVoteType
  }

  export type TeamDecisionUpdateOneRequiredWithoutVotesNestedInput = {
    create?: XOR<TeamDecisionCreateWithoutVotesInput, TeamDecisionUncheckedCreateWithoutVotesInput>
    connectOrCreate?: TeamDecisionCreateOrConnectWithoutVotesInput
    upsert?: TeamDecisionUpsertWithoutVotesInput
    connect?: TeamDecisionWhereUniqueInput
    update?: XOR<XOR<TeamDecisionUpdateToOneWithWhereWithoutVotesInput, TeamDecisionUpdateWithoutVotesInput>, TeamDecisionUncheckedUpdateWithoutVotesInput>
  }

  export type UserUpdateOneRequiredWithoutDecisionVotesNestedInput = {
    create?: XOR<UserCreateWithoutDecisionVotesInput, UserUncheckedCreateWithoutDecisionVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDecisionVotesInput
    upsert?: UserUpsertWithoutDecisionVotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDecisionVotesInput, UserUpdateWithoutDecisionVotesInput>, UserUncheckedUpdateWithoutDecisionVotesInput>
  }

  export type DepartmentCreateNestedOneWithoutMembersInput = {
    create?: XOR<DepartmentCreateWithoutMembersInput, DepartmentUncheckedCreateWithoutMembersInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutMembersInput
    connect?: DepartmentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDeptMembershipsInput = {
    create?: XOR<UserCreateWithoutDeptMembershipsInput, UserUncheckedCreateWithoutDeptMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeptMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type DepartmentUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<DepartmentCreateWithoutMembersInput, DepartmentUncheckedCreateWithoutMembersInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutMembersInput
    upsert?: DepartmentUpsertWithoutMembersInput
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutMembersInput, DepartmentUpdateWithoutMembersInput>, DepartmentUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutDeptMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutDeptMembershipsInput, UserUncheckedCreateWithoutDeptMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeptMembershipsInput
    upsert?: UserUpsertWithoutDeptMembershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDeptMembershipsInput, UserUpdateWithoutDeptMembershipsInput>, UserUncheckedUpdateWithoutDeptMembershipsInput>
  }

  export type DepartmentCreateNestedOneWithoutConversationsInput = {
    create?: XOR<DepartmentCreateWithoutConversationsInput, DepartmentUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutConversationsInput
    connect?: DepartmentWhereUniqueInput
  }

  export type GroupMemberCreateNestedManyWithoutGroupInput = {
    create?: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput> | GroupMemberCreateWithoutGroupInput[] | GroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutGroupInput | GroupMemberCreateOrConnectWithoutGroupInput[]
    createMany?: GroupMemberCreateManyGroupInputEnvelope
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutGroupInput = {
    create?: XOR<MessageCreateWithoutGroupInput, MessageUncheckedCreateWithoutGroupInput> | MessageCreateWithoutGroupInput[] | MessageUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutGroupInput | MessageCreateOrConnectWithoutGroupInput[]
    createMany?: MessageCreateManyGroupInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type GroupDocumentCreateNestedManyWithoutGroupInput = {
    create?: XOR<GroupDocumentCreateWithoutGroupInput, GroupDocumentUncheckedCreateWithoutGroupInput> | GroupDocumentCreateWithoutGroupInput[] | GroupDocumentUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupDocumentCreateOrConnectWithoutGroupInput | GroupDocumentCreateOrConnectWithoutGroupInput[]
    createMany?: GroupDocumentCreateManyGroupInputEnvelope
    connect?: GroupDocumentWhereUniqueInput | GroupDocumentWhereUniqueInput[]
  }

  export type GroupMemberUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput> | GroupMemberCreateWithoutGroupInput[] | GroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutGroupInput | GroupMemberCreateOrConnectWithoutGroupInput[]
    createMany?: GroupMemberCreateManyGroupInputEnvelope
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<MessageCreateWithoutGroupInput, MessageUncheckedCreateWithoutGroupInput> | MessageCreateWithoutGroupInput[] | MessageUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutGroupInput | MessageCreateOrConnectWithoutGroupInput[]
    createMany?: MessageCreateManyGroupInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type GroupDocumentUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<GroupDocumentCreateWithoutGroupInput, GroupDocumentUncheckedCreateWithoutGroupInput> | GroupDocumentCreateWithoutGroupInput[] | GroupDocumentUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupDocumentCreateOrConnectWithoutGroupInput | GroupDocumentCreateOrConnectWithoutGroupInput[]
    createMany?: GroupDocumentCreateManyGroupInputEnvelope
    connect?: GroupDocumentWhereUniqueInput | GroupDocumentWhereUniqueInput[]
  }

  export type DepartmentUpdateOneWithoutConversationsNestedInput = {
    create?: XOR<DepartmentCreateWithoutConversationsInput, DepartmentUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutConversationsInput
    upsert?: DepartmentUpsertWithoutConversationsInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutConversationsInput, DepartmentUpdateWithoutConversationsInput>, DepartmentUncheckedUpdateWithoutConversationsInput>
  }

  export type GroupMemberUpdateManyWithoutGroupNestedInput = {
    create?: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput> | GroupMemberCreateWithoutGroupInput[] | GroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutGroupInput | GroupMemberCreateOrConnectWithoutGroupInput[]
    upsert?: GroupMemberUpsertWithWhereUniqueWithoutGroupInput | GroupMemberUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: GroupMemberCreateManyGroupInputEnvelope
    set?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    disconnect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    delete?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    update?: GroupMemberUpdateWithWhereUniqueWithoutGroupInput | GroupMemberUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: GroupMemberUpdateManyWithWhereWithoutGroupInput | GroupMemberUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutGroupNestedInput = {
    create?: XOR<MessageCreateWithoutGroupInput, MessageUncheckedCreateWithoutGroupInput> | MessageCreateWithoutGroupInput[] | MessageUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutGroupInput | MessageCreateOrConnectWithoutGroupInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutGroupInput | MessageUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: MessageCreateManyGroupInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutGroupInput | MessageUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutGroupInput | MessageUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type GroupDocumentUpdateManyWithoutGroupNestedInput = {
    create?: XOR<GroupDocumentCreateWithoutGroupInput, GroupDocumentUncheckedCreateWithoutGroupInput> | GroupDocumentCreateWithoutGroupInput[] | GroupDocumentUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupDocumentCreateOrConnectWithoutGroupInput | GroupDocumentCreateOrConnectWithoutGroupInput[]
    upsert?: GroupDocumentUpsertWithWhereUniqueWithoutGroupInput | GroupDocumentUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: GroupDocumentCreateManyGroupInputEnvelope
    set?: GroupDocumentWhereUniqueInput | GroupDocumentWhereUniqueInput[]
    disconnect?: GroupDocumentWhereUniqueInput | GroupDocumentWhereUniqueInput[]
    delete?: GroupDocumentWhereUniqueInput | GroupDocumentWhereUniqueInput[]
    connect?: GroupDocumentWhereUniqueInput | GroupDocumentWhereUniqueInput[]
    update?: GroupDocumentUpdateWithWhereUniqueWithoutGroupInput | GroupDocumentUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: GroupDocumentUpdateManyWithWhereWithoutGroupInput | GroupDocumentUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: GroupDocumentScalarWhereInput | GroupDocumentScalarWhereInput[]
  }

  export type GroupMemberUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput> | GroupMemberCreateWithoutGroupInput[] | GroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutGroupInput | GroupMemberCreateOrConnectWithoutGroupInput[]
    upsert?: GroupMemberUpsertWithWhereUniqueWithoutGroupInput | GroupMemberUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: GroupMemberCreateManyGroupInputEnvelope
    set?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    disconnect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    delete?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    update?: GroupMemberUpdateWithWhereUniqueWithoutGroupInput | GroupMemberUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: GroupMemberUpdateManyWithWhereWithoutGroupInput | GroupMemberUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<MessageCreateWithoutGroupInput, MessageUncheckedCreateWithoutGroupInput> | MessageCreateWithoutGroupInput[] | MessageUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutGroupInput | MessageCreateOrConnectWithoutGroupInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutGroupInput | MessageUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: MessageCreateManyGroupInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutGroupInput | MessageUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutGroupInput | MessageUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type GroupDocumentUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<GroupDocumentCreateWithoutGroupInput, GroupDocumentUncheckedCreateWithoutGroupInput> | GroupDocumentCreateWithoutGroupInput[] | GroupDocumentUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupDocumentCreateOrConnectWithoutGroupInput | GroupDocumentCreateOrConnectWithoutGroupInput[]
    upsert?: GroupDocumentUpsertWithWhereUniqueWithoutGroupInput | GroupDocumentUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: GroupDocumentCreateManyGroupInputEnvelope
    set?: GroupDocumentWhereUniqueInput | GroupDocumentWhereUniqueInput[]
    disconnect?: GroupDocumentWhereUniqueInput | GroupDocumentWhereUniqueInput[]
    delete?: GroupDocumentWhereUniqueInput | GroupDocumentWhereUniqueInput[]
    connect?: GroupDocumentWhereUniqueInput | GroupDocumentWhereUniqueInput[]
    update?: GroupDocumentUpdateWithWhereUniqueWithoutGroupInput | GroupDocumentUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: GroupDocumentUpdateManyWithWhereWithoutGroupInput | GroupDocumentUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: GroupDocumentScalarWhereInput | GroupDocumentScalarWhereInput[]
  }

  export type GroupCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<GroupCreateWithoutDocumentsInput, GroupUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutDocumentsInput
    connect?: GroupWhereUniqueInput
  }

  export type GroupNoteCreateNestedManyWithoutDocumentInput = {
    create?: XOR<GroupNoteCreateWithoutDocumentInput, GroupNoteUncheckedCreateWithoutDocumentInput> | GroupNoteCreateWithoutDocumentInput[] | GroupNoteUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: GroupNoteCreateOrConnectWithoutDocumentInput | GroupNoteCreateOrConnectWithoutDocumentInput[]
    createMany?: GroupNoteCreateManyDocumentInputEnvelope
    connect?: GroupNoteWhereUniqueInput | GroupNoteWhereUniqueInput[]
  }

  export type GroupNoteUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<GroupNoteCreateWithoutDocumentInput, GroupNoteUncheckedCreateWithoutDocumentInput> | GroupNoteCreateWithoutDocumentInput[] | GroupNoteUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: GroupNoteCreateOrConnectWithoutDocumentInput | GroupNoteCreateOrConnectWithoutDocumentInput[]
    createMany?: GroupNoteCreateManyDocumentInputEnvelope
    connect?: GroupNoteWhereUniqueInput | GroupNoteWhereUniqueInput[]
  }

  export type GroupUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<GroupCreateWithoutDocumentsInput, GroupUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutDocumentsInput
    upsert?: GroupUpsertWithoutDocumentsInput
    connect?: GroupWhereUniqueInput
    update?: XOR<XOR<GroupUpdateToOneWithWhereWithoutDocumentsInput, GroupUpdateWithoutDocumentsInput>, GroupUncheckedUpdateWithoutDocumentsInput>
  }

  export type GroupNoteUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<GroupNoteCreateWithoutDocumentInput, GroupNoteUncheckedCreateWithoutDocumentInput> | GroupNoteCreateWithoutDocumentInput[] | GroupNoteUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: GroupNoteCreateOrConnectWithoutDocumentInput | GroupNoteCreateOrConnectWithoutDocumentInput[]
    upsert?: GroupNoteUpsertWithWhereUniqueWithoutDocumentInput | GroupNoteUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: GroupNoteCreateManyDocumentInputEnvelope
    set?: GroupNoteWhereUniqueInput | GroupNoteWhereUniqueInput[]
    disconnect?: GroupNoteWhereUniqueInput | GroupNoteWhereUniqueInput[]
    delete?: GroupNoteWhereUniqueInput | GroupNoteWhereUniqueInput[]
    connect?: GroupNoteWhereUniqueInput | GroupNoteWhereUniqueInput[]
    update?: GroupNoteUpdateWithWhereUniqueWithoutDocumentInput | GroupNoteUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: GroupNoteUpdateManyWithWhereWithoutDocumentInput | GroupNoteUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: GroupNoteScalarWhereInput | GroupNoteScalarWhereInput[]
  }

  export type GroupNoteUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<GroupNoteCreateWithoutDocumentInput, GroupNoteUncheckedCreateWithoutDocumentInput> | GroupNoteCreateWithoutDocumentInput[] | GroupNoteUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: GroupNoteCreateOrConnectWithoutDocumentInput | GroupNoteCreateOrConnectWithoutDocumentInput[]
    upsert?: GroupNoteUpsertWithWhereUniqueWithoutDocumentInput | GroupNoteUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: GroupNoteCreateManyDocumentInputEnvelope
    set?: GroupNoteWhereUniqueInput | GroupNoteWhereUniqueInput[]
    disconnect?: GroupNoteWhereUniqueInput | GroupNoteWhereUniqueInput[]
    delete?: GroupNoteWhereUniqueInput | GroupNoteWhereUniqueInput[]
    connect?: GroupNoteWhereUniqueInput | GroupNoteWhereUniqueInput[]
    update?: GroupNoteUpdateWithWhereUniqueWithoutDocumentInput | GroupNoteUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: GroupNoteUpdateManyWithWhereWithoutDocumentInput | GroupNoteUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: GroupNoteScalarWhereInput | GroupNoteScalarWhereInput[]
  }

  export type GroupDocumentCreateNestedOneWithoutNotesInput = {
    create?: XOR<GroupDocumentCreateWithoutNotesInput, GroupDocumentUncheckedCreateWithoutNotesInput>
    connectOrCreate?: GroupDocumentCreateOrConnectWithoutNotesInput
    connect?: GroupDocumentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutGroupNotesInput = {
    create?: XOR<UserCreateWithoutGroupNotesInput, UserUncheckedCreateWithoutGroupNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutGroupNotesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNoteTextSizeFieldUpdateOperationsInput = {
    set?: $Enums.NoteTextSize
  }

  export type GroupDocumentUpdateOneRequiredWithoutNotesNestedInput = {
    create?: XOR<GroupDocumentCreateWithoutNotesInput, GroupDocumentUncheckedCreateWithoutNotesInput>
    connectOrCreate?: GroupDocumentCreateOrConnectWithoutNotesInput
    upsert?: GroupDocumentUpsertWithoutNotesInput
    connect?: GroupDocumentWhereUniqueInput
    update?: XOR<XOR<GroupDocumentUpdateToOneWithWhereWithoutNotesInput, GroupDocumentUpdateWithoutNotesInput>, GroupDocumentUncheckedUpdateWithoutNotesInput>
  }

  export type UserUpdateOneRequiredWithoutGroupNotesNestedInput = {
    create?: XOR<UserCreateWithoutGroupNotesInput, UserUncheckedCreateWithoutGroupNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutGroupNotesInput
    upsert?: UserUpsertWithoutGroupNotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGroupNotesInput, UserUpdateWithoutGroupNotesInput>, UserUncheckedUpdateWithoutGroupNotesInput>
  }

  export type GroupCreateNestedOneWithoutMembersInput = {
    create?: XOR<GroupCreateWithoutMembersInput, GroupUncheckedCreateWithoutMembersInput>
    connectOrCreate?: GroupCreateOrConnectWithoutMembersInput
    connect?: GroupWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutGroupMembershipsInput = {
    create?: XOR<UserCreateWithoutGroupMembershipsInput, UserUncheckedCreateWithoutGroupMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGroupMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type GroupUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<GroupCreateWithoutMembersInput, GroupUncheckedCreateWithoutMembersInput>
    connectOrCreate?: GroupCreateOrConnectWithoutMembersInput
    upsert?: GroupUpsertWithoutMembersInput
    connect?: GroupWhereUniqueInput
    update?: XOR<XOR<GroupUpdateToOneWithWhereWithoutMembersInput, GroupUpdateWithoutMembersInput>, GroupUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutGroupMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutGroupMembershipsInput, UserUncheckedCreateWithoutGroupMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGroupMembershipsInput
    upsert?: UserUpsertWithoutGroupMembershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGroupMembershipsInput, UserUpdateWithoutGroupMembershipsInput>, UserUncheckedUpdateWithoutGroupMembershipsInput>
  }

  export type AttachmentCreateNestedManyWithoutMessageInput = {
    create?: XOR<AttachmentCreateWithoutMessageInput, AttachmentUncheckedCreateWithoutMessageInput> | AttachmentCreateWithoutMessageInput[] | AttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutMessageInput | AttachmentCreateOrConnectWithoutMessageInput[]
    createMany?: AttachmentCreateManyMessageInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type GroupCreateNestedOneWithoutMessagesInput = {
    create?: XOR<GroupCreateWithoutMessagesInput, GroupUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: GroupCreateOrConnectWithoutMessagesInput
    connect?: GroupWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type AttachmentUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<AttachmentCreateWithoutMessageInput, AttachmentUncheckedCreateWithoutMessageInput> | AttachmentCreateWithoutMessageInput[] | AttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutMessageInput | AttachmentCreateOrConnectWithoutMessageInput[]
    createMany?: AttachmentCreateManyMessageInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type AttachmentUpdateManyWithoutMessageNestedInput = {
    create?: XOR<AttachmentCreateWithoutMessageInput, AttachmentUncheckedCreateWithoutMessageInput> | AttachmentCreateWithoutMessageInput[] | AttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutMessageInput | AttachmentCreateOrConnectWithoutMessageInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutMessageInput | AttachmentUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: AttachmentCreateManyMessageInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutMessageInput | AttachmentUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutMessageInput | AttachmentUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type GroupUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<GroupCreateWithoutMessagesInput, GroupUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: GroupCreateOrConnectWithoutMessagesInput
    upsert?: GroupUpsertWithoutMessagesInput
    connect?: GroupWhereUniqueInput
    update?: XOR<XOR<GroupUpdateToOneWithWhereWithoutMessagesInput, GroupUpdateWithoutMessagesInput>, GroupUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutSentMessagesNestedInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    upsert?: UserUpsertWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentMessagesInput, UserUpdateWithoutSentMessagesInput>, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type AttachmentUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<AttachmentCreateWithoutMessageInput, AttachmentUncheckedCreateWithoutMessageInput> | AttachmentCreateWithoutMessageInput[] | AttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutMessageInput | AttachmentCreateOrConnectWithoutMessageInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutMessageInput | AttachmentUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: AttachmentCreateManyMessageInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutMessageInput | AttachmentUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutMessageInput | AttachmentUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type MessageCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<MessageCreateWithoutAttachmentsInput, MessageUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutAttachmentsInput
    connect?: MessageWhereUniqueInput
  }

  export type MessageUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<MessageCreateWithoutAttachmentsInput, MessageUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutAttachmentsInput
    upsert?: MessageUpsertWithoutAttachmentsInput
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutAttachmentsInput, MessageUpdateWithoutAttachmentsInput>, MessageUncheckedUpdateWithoutAttachmentsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutPublishedAnnouncementsInput = {
    create?: XOR<UserCreateWithoutPublishedAnnouncementsInput, UserUncheckedCreateWithoutPublishedAnnouncementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPublishedAnnouncementsInput
    connect?: UserWhereUniqueInput
  }

  export type AnnouncementReadCreateNestedManyWithoutAnnouncementInput = {
    create?: XOR<AnnouncementReadCreateWithoutAnnouncementInput, AnnouncementReadUncheckedCreateWithoutAnnouncementInput> | AnnouncementReadCreateWithoutAnnouncementInput[] | AnnouncementReadUncheckedCreateWithoutAnnouncementInput[]
    connectOrCreate?: AnnouncementReadCreateOrConnectWithoutAnnouncementInput | AnnouncementReadCreateOrConnectWithoutAnnouncementInput[]
    createMany?: AnnouncementReadCreateManyAnnouncementInputEnvelope
    connect?: AnnouncementReadWhereUniqueInput | AnnouncementReadWhereUniqueInput[]
  }

  export type AnnouncementReadUncheckedCreateNestedManyWithoutAnnouncementInput = {
    create?: XOR<AnnouncementReadCreateWithoutAnnouncementInput, AnnouncementReadUncheckedCreateWithoutAnnouncementInput> | AnnouncementReadCreateWithoutAnnouncementInput[] | AnnouncementReadUncheckedCreateWithoutAnnouncementInput[]
    connectOrCreate?: AnnouncementReadCreateOrConnectWithoutAnnouncementInput | AnnouncementReadCreateOrConnectWithoutAnnouncementInput[]
    createMany?: AnnouncementReadCreateManyAnnouncementInputEnvelope
    connect?: AnnouncementReadWhereUniqueInput | AnnouncementReadWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutPublishedAnnouncementsNestedInput = {
    create?: XOR<UserCreateWithoutPublishedAnnouncementsInput, UserUncheckedCreateWithoutPublishedAnnouncementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPublishedAnnouncementsInput
    upsert?: UserUpsertWithoutPublishedAnnouncementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPublishedAnnouncementsInput, UserUpdateWithoutPublishedAnnouncementsInput>, UserUncheckedUpdateWithoutPublishedAnnouncementsInput>
  }

  export type AnnouncementReadUpdateManyWithoutAnnouncementNestedInput = {
    create?: XOR<AnnouncementReadCreateWithoutAnnouncementInput, AnnouncementReadUncheckedCreateWithoutAnnouncementInput> | AnnouncementReadCreateWithoutAnnouncementInput[] | AnnouncementReadUncheckedCreateWithoutAnnouncementInput[]
    connectOrCreate?: AnnouncementReadCreateOrConnectWithoutAnnouncementInput | AnnouncementReadCreateOrConnectWithoutAnnouncementInput[]
    upsert?: AnnouncementReadUpsertWithWhereUniqueWithoutAnnouncementInput | AnnouncementReadUpsertWithWhereUniqueWithoutAnnouncementInput[]
    createMany?: AnnouncementReadCreateManyAnnouncementInputEnvelope
    set?: AnnouncementReadWhereUniqueInput | AnnouncementReadWhereUniqueInput[]
    disconnect?: AnnouncementReadWhereUniqueInput | AnnouncementReadWhereUniqueInput[]
    delete?: AnnouncementReadWhereUniqueInput | AnnouncementReadWhereUniqueInput[]
    connect?: AnnouncementReadWhereUniqueInput | AnnouncementReadWhereUniqueInput[]
    update?: AnnouncementReadUpdateWithWhereUniqueWithoutAnnouncementInput | AnnouncementReadUpdateWithWhereUniqueWithoutAnnouncementInput[]
    updateMany?: AnnouncementReadUpdateManyWithWhereWithoutAnnouncementInput | AnnouncementReadUpdateManyWithWhereWithoutAnnouncementInput[]
    deleteMany?: AnnouncementReadScalarWhereInput | AnnouncementReadScalarWhereInput[]
  }

  export type AnnouncementReadUncheckedUpdateManyWithoutAnnouncementNestedInput = {
    create?: XOR<AnnouncementReadCreateWithoutAnnouncementInput, AnnouncementReadUncheckedCreateWithoutAnnouncementInput> | AnnouncementReadCreateWithoutAnnouncementInput[] | AnnouncementReadUncheckedCreateWithoutAnnouncementInput[]
    connectOrCreate?: AnnouncementReadCreateOrConnectWithoutAnnouncementInput | AnnouncementReadCreateOrConnectWithoutAnnouncementInput[]
    upsert?: AnnouncementReadUpsertWithWhereUniqueWithoutAnnouncementInput | AnnouncementReadUpsertWithWhereUniqueWithoutAnnouncementInput[]
    createMany?: AnnouncementReadCreateManyAnnouncementInputEnvelope
    set?: AnnouncementReadWhereUniqueInput | AnnouncementReadWhereUniqueInput[]
    disconnect?: AnnouncementReadWhereUniqueInput | AnnouncementReadWhereUniqueInput[]
    delete?: AnnouncementReadWhereUniqueInput | AnnouncementReadWhereUniqueInput[]
    connect?: AnnouncementReadWhereUniqueInput | AnnouncementReadWhereUniqueInput[]
    update?: AnnouncementReadUpdateWithWhereUniqueWithoutAnnouncementInput | AnnouncementReadUpdateWithWhereUniqueWithoutAnnouncementInput[]
    updateMany?: AnnouncementReadUpdateManyWithWhereWithoutAnnouncementInput | AnnouncementReadUpdateManyWithWhereWithoutAnnouncementInput[]
    deleteMany?: AnnouncementReadScalarWhereInput | AnnouncementReadScalarWhereInput[]
  }

  export type AnnouncementCreateNestedOneWithoutReadsInput = {
    create?: XOR<AnnouncementCreateWithoutReadsInput, AnnouncementUncheckedCreateWithoutReadsInput>
    connectOrCreate?: AnnouncementCreateOrConnectWithoutReadsInput
    connect?: AnnouncementWhereUniqueInput
  }

  export type AnnouncementUpdateOneRequiredWithoutReadsNestedInput = {
    create?: XOR<AnnouncementCreateWithoutReadsInput, AnnouncementUncheckedCreateWithoutReadsInput>
    connectOrCreate?: AnnouncementCreateOrConnectWithoutReadsInput
    upsert?: AnnouncementUpsertWithoutReadsInput
    connect?: AnnouncementWhereUniqueInput
    update?: XOR<XOR<AnnouncementUpdateToOneWithWhereWithoutReadsInput, AnnouncementUpdateWithoutReadsInput>, AnnouncementUncheckedUpdateWithoutReadsInput>
  }

  export type EnumRequestStatusFieldUpdateOperationsInput = {
    set?: $Enums.RequestStatus
  }

  export type EnumPaymentOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentOrderStatus
  }

  export type OrganizationCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<OrganizationCreateWithoutSubscriptionInput, OrganizationUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutSubscriptionInput
    connect?: OrganizationWhereUniqueInput
  }

  export type EnumSubscriptionPlanFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionPlan
  }

  export type OrganizationUpdateOneRequiredWithoutSubscriptionNestedInput = {
    create?: XOR<OrganizationCreateWithoutSubscriptionInput, OrganizationUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutSubscriptionInput
    upsert?: OrganizationUpsertWithoutSubscriptionInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutSubscriptionInput, OrganizationUpdateWithoutSubscriptionInput>, OrganizationUncheckedUpdateWithoutSubscriptionInput>
  }

  export type OrganizationCreateNestedOneWithoutEventsInput = {
    create?: XOR<OrganizationCreateWithoutEventsInput, OrganizationUncheckedCreateWithoutEventsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutEventsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type InvitationRSVPCreateNestedManyWithoutEventInput = {
    create?: XOR<InvitationRSVPCreateWithoutEventInput, InvitationRSVPUncheckedCreateWithoutEventInput> | InvitationRSVPCreateWithoutEventInput[] | InvitationRSVPUncheckedCreateWithoutEventInput[]
    connectOrCreate?: InvitationRSVPCreateOrConnectWithoutEventInput | InvitationRSVPCreateOrConnectWithoutEventInput[]
    createMany?: InvitationRSVPCreateManyEventInputEnvelope
    connect?: InvitationRSVPWhereUniqueInput | InvitationRSVPWhereUniqueInput[]
  }

  export type EventDepartmentBroadcastCreateNestedManyWithoutEventInput = {
    create?: XOR<EventDepartmentBroadcastCreateWithoutEventInput, EventDepartmentBroadcastUncheckedCreateWithoutEventInput> | EventDepartmentBroadcastCreateWithoutEventInput[] | EventDepartmentBroadcastUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventDepartmentBroadcastCreateOrConnectWithoutEventInput | EventDepartmentBroadcastCreateOrConnectWithoutEventInput[]
    createMany?: EventDepartmentBroadcastCreateManyEventInputEnvelope
    connect?: EventDepartmentBroadcastWhereUniqueInput | EventDepartmentBroadcastWhereUniqueInput[]
  }

  export type InvitationRSVPUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<InvitationRSVPCreateWithoutEventInput, InvitationRSVPUncheckedCreateWithoutEventInput> | InvitationRSVPCreateWithoutEventInput[] | InvitationRSVPUncheckedCreateWithoutEventInput[]
    connectOrCreate?: InvitationRSVPCreateOrConnectWithoutEventInput | InvitationRSVPCreateOrConnectWithoutEventInput[]
    createMany?: InvitationRSVPCreateManyEventInputEnvelope
    connect?: InvitationRSVPWhereUniqueInput | InvitationRSVPWhereUniqueInput[]
  }

  export type EventDepartmentBroadcastUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<EventDepartmentBroadcastCreateWithoutEventInput, EventDepartmentBroadcastUncheckedCreateWithoutEventInput> | EventDepartmentBroadcastCreateWithoutEventInput[] | EventDepartmentBroadcastUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventDepartmentBroadcastCreateOrConnectWithoutEventInput | EventDepartmentBroadcastCreateOrConnectWithoutEventInput[]
    createMany?: EventDepartmentBroadcastCreateManyEventInputEnvelope
    connect?: EventDepartmentBroadcastWhereUniqueInput | EventDepartmentBroadcastWhereUniqueInput[]
  }

  export type EnumEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.EventType
  }

  export type OrganizationUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<OrganizationCreateWithoutEventsInput, OrganizationUncheckedCreateWithoutEventsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutEventsInput
    upsert?: OrganizationUpsertWithoutEventsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutEventsInput, OrganizationUpdateWithoutEventsInput>, OrganizationUncheckedUpdateWithoutEventsInput>
  }

  export type InvitationRSVPUpdateManyWithoutEventNestedInput = {
    create?: XOR<InvitationRSVPCreateWithoutEventInput, InvitationRSVPUncheckedCreateWithoutEventInput> | InvitationRSVPCreateWithoutEventInput[] | InvitationRSVPUncheckedCreateWithoutEventInput[]
    connectOrCreate?: InvitationRSVPCreateOrConnectWithoutEventInput | InvitationRSVPCreateOrConnectWithoutEventInput[]
    upsert?: InvitationRSVPUpsertWithWhereUniqueWithoutEventInput | InvitationRSVPUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: InvitationRSVPCreateManyEventInputEnvelope
    set?: InvitationRSVPWhereUniqueInput | InvitationRSVPWhereUniqueInput[]
    disconnect?: InvitationRSVPWhereUniqueInput | InvitationRSVPWhereUniqueInput[]
    delete?: InvitationRSVPWhereUniqueInput | InvitationRSVPWhereUniqueInput[]
    connect?: InvitationRSVPWhereUniqueInput | InvitationRSVPWhereUniqueInput[]
    update?: InvitationRSVPUpdateWithWhereUniqueWithoutEventInput | InvitationRSVPUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: InvitationRSVPUpdateManyWithWhereWithoutEventInput | InvitationRSVPUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: InvitationRSVPScalarWhereInput | InvitationRSVPScalarWhereInput[]
  }

  export type EventDepartmentBroadcastUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventDepartmentBroadcastCreateWithoutEventInput, EventDepartmentBroadcastUncheckedCreateWithoutEventInput> | EventDepartmentBroadcastCreateWithoutEventInput[] | EventDepartmentBroadcastUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventDepartmentBroadcastCreateOrConnectWithoutEventInput | EventDepartmentBroadcastCreateOrConnectWithoutEventInput[]
    upsert?: EventDepartmentBroadcastUpsertWithWhereUniqueWithoutEventInput | EventDepartmentBroadcastUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventDepartmentBroadcastCreateManyEventInputEnvelope
    set?: EventDepartmentBroadcastWhereUniqueInput | EventDepartmentBroadcastWhereUniqueInput[]
    disconnect?: EventDepartmentBroadcastWhereUniqueInput | EventDepartmentBroadcastWhereUniqueInput[]
    delete?: EventDepartmentBroadcastWhereUniqueInput | EventDepartmentBroadcastWhereUniqueInput[]
    connect?: EventDepartmentBroadcastWhereUniqueInput | EventDepartmentBroadcastWhereUniqueInput[]
    update?: EventDepartmentBroadcastUpdateWithWhereUniqueWithoutEventInput | EventDepartmentBroadcastUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventDepartmentBroadcastUpdateManyWithWhereWithoutEventInput | EventDepartmentBroadcastUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventDepartmentBroadcastScalarWhereInput | EventDepartmentBroadcastScalarWhereInput[]
  }

  export type InvitationRSVPUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<InvitationRSVPCreateWithoutEventInput, InvitationRSVPUncheckedCreateWithoutEventInput> | InvitationRSVPCreateWithoutEventInput[] | InvitationRSVPUncheckedCreateWithoutEventInput[]
    connectOrCreate?: InvitationRSVPCreateOrConnectWithoutEventInput | InvitationRSVPCreateOrConnectWithoutEventInput[]
    upsert?: InvitationRSVPUpsertWithWhereUniqueWithoutEventInput | InvitationRSVPUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: InvitationRSVPCreateManyEventInputEnvelope
    set?: InvitationRSVPWhereUniqueInput | InvitationRSVPWhereUniqueInput[]
    disconnect?: InvitationRSVPWhereUniqueInput | InvitationRSVPWhereUniqueInput[]
    delete?: InvitationRSVPWhereUniqueInput | InvitationRSVPWhereUniqueInput[]
    connect?: InvitationRSVPWhereUniqueInput | InvitationRSVPWhereUniqueInput[]
    update?: InvitationRSVPUpdateWithWhereUniqueWithoutEventInput | InvitationRSVPUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: InvitationRSVPUpdateManyWithWhereWithoutEventInput | InvitationRSVPUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: InvitationRSVPScalarWhereInput | InvitationRSVPScalarWhereInput[]
  }

  export type EventDepartmentBroadcastUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventDepartmentBroadcastCreateWithoutEventInput, EventDepartmentBroadcastUncheckedCreateWithoutEventInput> | EventDepartmentBroadcastCreateWithoutEventInput[] | EventDepartmentBroadcastUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventDepartmentBroadcastCreateOrConnectWithoutEventInput | EventDepartmentBroadcastCreateOrConnectWithoutEventInput[]
    upsert?: EventDepartmentBroadcastUpsertWithWhereUniqueWithoutEventInput | EventDepartmentBroadcastUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventDepartmentBroadcastCreateManyEventInputEnvelope
    set?: EventDepartmentBroadcastWhereUniqueInput | EventDepartmentBroadcastWhereUniqueInput[]
    disconnect?: EventDepartmentBroadcastWhereUniqueInput | EventDepartmentBroadcastWhereUniqueInput[]
    delete?: EventDepartmentBroadcastWhereUniqueInput | EventDepartmentBroadcastWhereUniqueInput[]
    connect?: EventDepartmentBroadcastWhereUniqueInput | EventDepartmentBroadcastWhereUniqueInput[]
    update?: EventDepartmentBroadcastUpdateWithWhereUniqueWithoutEventInput | EventDepartmentBroadcastUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventDepartmentBroadcastUpdateManyWithWhereWithoutEventInput | EventDepartmentBroadcastUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventDepartmentBroadcastScalarWhereInput | EventDepartmentBroadcastScalarWhereInput[]
  }

  export type EventInvitationCreateNestedOneWithoutDepartmentBroadcastsInput = {
    create?: XOR<EventInvitationCreateWithoutDepartmentBroadcastsInput, EventInvitationUncheckedCreateWithoutDepartmentBroadcastsInput>
    connectOrCreate?: EventInvitationCreateOrConnectWithoutDepartmentBroadcastsInput
    connect?: EventInvitationWhereUniqueInput
  }

  export type DepartmentCreateNestedOneWithoutEventBroadcastsInput = {
    create?: XOR<DepartmentCreateWithoutEventBroadcastsInput, DepartmentUncheckedCreateWithoutEventBroadcastsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutEventBroadcastsInput
    connect?: DepartmentWhereUniqueInput
  }

  export type EventInvitationUpdateOneRequiredWithoutDepartmentBroadcastsNestedInput = {
    create?: XOR<EventInvitationCreateWithoutDepartmentBroadcastsInput, EventInvitationUncheckedCreateWithoutDepartmentBroadcastsInput>
    connectOrCreate?: EventInvitationCreateOrConnectWithoutDepartmentBroadcastsInput
    upsert?: EventInvitationUpsertWithoutDepartmentBroadcastsInput
    connect?: EventInvitationWhereUniqueInput
    update?: XOR<XOR<EventInvitationUpdateToOneWithWhereWithoutDepartmentBroadcastsInput, EventInvitationUpdateWithoutDepartmentBroadcastsInput>, EventInvitationUncheckedUpdateWithoutDepartmentBroadcastsInput>
  }

  export type DepartmentUpdateOneRequiredWithoutEventBroadcastsNestedInput = {
    create?: XOR<DepartmentCreateWithoutEventBroadcastsInput, DepartmentUncheckedCreateWithoutEventBroadcastsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutEventBroadcastsInput
    upsert?: DepartmentUpsertWithoutEventBroadcastsInput
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutEventBroadcastsInput, DepartmentUpdateWithoutEventBroadcastsInput>, DepartmentUncheckedUpdateWithoutEventBroadcastsInput>
  }

  export type EventInvitationCreateNestedOneWithoutRsvpsInput = {
    create?: XOR<EventInvitationCreateWithoutRsvpsInput, EventInvitationUncheckedCreateWithoutRsvpsInput>
    connectOrCreate?: EventInvitationCreateOrConnectWithoutRsvpsInput
    connect?: EventInvitationWhereUniqueInput
  }

  export type EventInvitationUpdateOneRequiredWithoutRsvpsNestedInput = {
    create?: XOR<EventInvitationCreateWithoutRsvpsInput, EventInvitationUncheckedCreateWithoutRsvpsInput>
    connectOrCreate?: EventInvitationCreateOrConnectWithoutRsvpsInput
    upsert?: EventInvitationUpsertWithoutRsvpsInput
    connect?: EventInvitationWhereUniqueInput
    update?: XOR<XOR<EventInvitationUpdateToOneWithWhereWithoutRsvpsInput, EventInvitationUpdateWithoutRsvpsInput>, EventInvitationUncheckedUpdateWithoutRsvpsInput>
  }

  export type UserCreateNestedOneWithoutUserPageInput = {
    create?: XOR<UserCreateWithoutUserPageInput, UserUncheckedCreateWithoutUserPageInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserPageInput
    connect?: UserWhereUniqueInput
  }

  export type PostCreateNestedManyWithoutPageInput = {
    create?: XOR<PostCreateWithoutPageInput, PostUncheckedCreateWithoutPageInput> | PostCreateWithoutPageInput[] | PostUncheckedCreateWithoutPageInput[]
    connectOrCreate?: PostCreateOrConnectWithoutPageInput | PostCreateOrConnectWithoutPageInput[]
    createMany?: PostCreateManyPageInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutPageInput = {
    create?: XOR<PostCreateWithoutPageInput, PostUncheckedCreateWithoutPageInput> | PostCreateWithoutPageInput[] | PostUncheckedCreateWithoutPageInput[]
    connectOrCreate?: PostCreateOrConnectWithoutPageInput | PostCreateOrConnectWithoutPageInput[]
    createMany?: PostCreateManyPageInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutUserPageNestedInput = {
    create?: XOR<UserCreateWithoutUserPageInput, UserUncheckedCreateWithoutUserPageInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserPageInput
    upsert?: UserUpsertWithoutUserPageInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserPageInput, UserUpdateWithoutUserPageInput>, UserUncheckedUpdateWithoutUserPageInput>
  }

  export type PostUpdateManyWithoutPageNestedInput = {
    create?: XOR<PostCreateWithoutPageInput, PostUncheckedCreateWithoutPageInput> | PostCreateWithoutPageInput[] | PostUncheckedCreateWithoutPageInput[]
    connectOrCreate?: PostCreateOrConnectWithoutPageInput | PostCreateOrConnectWithoutPageInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutPageInput | PostUpsertWithWhereUniqueWithoutPageInput[]
    createMany?: PostCreateManyPageInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutPageInput | PostUpdateWithWhereUniqueWithoutPageInput[]
    updateMany?: PostUpdateManyWithWhereWithoutPageInput | PostUpdateManyWithWhereWithoutPageInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutPageNestedInput = {
    create?: XOR<PostCreateWithoutPageInput, PostUncheckedCreateWithoutPageInput> | PostCreateWithoutPageInput[] | PostUncheckedCreateWithoutPageInput[]
    connectOrCreate?: PostCreateOrConnectWithoutPageInput | PostCreateOrConnectWithoutPageInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutPageInput | PostUpsertWithWhereUniqueWithoutPageInput[]
    createMany?: PostCreateManyPageInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutPageInput | PostUpdateWithWhereUniqueWithoutPageInput[]
    updateMany?: PostUpdateManyWithWhereWithoutPageInput | PostUpdateManyWithWhereWithoutPageInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type UserPageCreateNestedOneWithoutPostsInput = {
    create?: XOR<UserPageCreateWithoutPostsInput, UserPageUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserPageCreateOrConnectWithoutPostsInput
    connect?: UserPageWhereUniqueInput
  }

  export type LikeCreateNestedManyWithoutPostInput = {
    create?: XOR<LikeCreateWithoutPostInput, LikeUncheckedCreateWithoutPostInput> | LikeCreateWithoutPostInput[] | LikeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutPostInput | LikeCreateOrConnectWithoutPostInput[]
    createMany?: LikeCreateManyPostInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type PostReadCreateNestedManyWithoutPostInput = {
    create?: XOR<PostReadCreateWithoutPostInput, PostReadUncheckedCreateWithoutPostInput> | PostReadCreateWithoutPostInput[] | PostReadUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostReadCreateOrConnectWithoutPostInput | PostReadCreateOrConnectWithoutPostInput[]
    createMany?: PostReadCreateManyPostInputEnvelope
    connect?: PostReadWhereUniqueInput | PostReadWhereUniqueInput[]
  }

  export type LikeUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<LikeCreateWithoutPostInput, LikeUncheckedCreateWithoutPostInput> | LikeCreateWithoutPostInput[] | LikeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutPostInput | LikeCreateOrConnectWithoutPostInput[]
    createMany?: LikeCreateManyPostInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type PostReadUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<PostReadCreateWithoutPostInput, PostReadUncheckedCreateWithoutPostInput> | PostReadCreateWithoutPostInput[] | PostReadUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostReadCreateOrConnectWithoutPostInput | PostReadCreateOrConnectWithoutPostInput[]
    createMany?: PostReadCreateManyPostInputEnvelope
    connect?: PostReadWhereUniqueInput | PostReadWhereUniqueInput[]
  }

  export type EnumPostTypeFieldUpdateOperationsInput = {
    set?: $Enums.PostType
  }

  export type UserPageUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<UserPageCreateWithoutPostsInput, UserPageUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserPageCreateOrConnectWithoutPostsInput
    upsert?: UserPageUpsertWithoutPostsInput
    connect?: UserPageWhereUniqueInput
    update?: XOR<XOR<UserPageUpdateToOneWithWhereWithoutPostsInput, UserPageUpdateWithoutPostsInput>, UserPageUncheckedUpdateWithoutPostsInput>
  }

  export type LikeUpdateManyWithoutPostNestedInput = {
    create?: XOR<LikeCreateWithoutPostInput, LikeUncheckedCreateWithoutPostInput> | LikeCreateWithoutPostInput[] | LikeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutPostInput | LikeCreateOrConnectWithoutPostInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutPostInput | LikeUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: LikeCreateManyPostInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutPostInput | LikeUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutPostInput | LikeUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type PostReadUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostReadCreateWithoutPostInput, PostReadUncheckedCreateWithoutPostInput> | PostReadCreateWithoutPostInput[] | PostReadUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostReadCreateOrConnectWithoutPostInput | PostReadCreateOrConnectWithoutPostInput[]
    upsert?: PostReadUpsertWithWhereUniqueWithoutPostInput | PostReadUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostReadCreateManyPostInputEnvelope
    set?: PostReadWhereUniqueInput | PostReadWhereUniqueInput[]
    disconnect?: PostReadWhereUniqueInput | PostReadWhereUniqueInput[]
    delete?: PostReadWhereUniqueInput | PostReadWhereUniqueInput[]
    connect?: PostReadWhereUniqueInput | PostReadWhereUniqueInput[]
    update?: PostReadUpdateWithWhereUniqueWithoutPostInput | PostReadUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostReadUpdateManyWithWhereWithoutPostInput | PostReadUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostReadScalarWhereInput | PostReadScalarWhereInput[]
  }

  export type LikeUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<LikeCreateWithoutPostInput, LikeUncheckedCreateWithoutPostInput> | LikeCreateWithoutPostInput[] | LikeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutPostInput | LikeCreateOrConnectWithoutPostInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutPostInput | LikeUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: LikeCreateManyPostInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutPostInput | LikeUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutPostInput | LikeUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type PostReadUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostReadCreateWithoutPostInput, PostReadUncheckedCreateWithoutPostInput> | PostReadCreateWithoutPostInput[] | PostReadUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostReadCreateOrConnectWithoutPostInput | PostReadCreateOrConnectWithoutPostInput[]
    upsert?: PostReadUpsertWithWhereUniqueWithoutPostInput | PostReadUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostReadCreateManyPostInputEnvelope
    set?: PostReadWhereUniqueInput | PostReadWhereUniqueInput[]
    disconnect?: PostReadWhereUniqueInput | PostReadWhereUniqueInput[]
    delete?: PostReadWhereUniqueInput | PostReadWhereUniqueInput[]
    connect?: PostReadWhereUniqueInput | PostReadWhereUniqueInput[]
    update?: PostReadUpdateWithWhereUniqueWithoutPostInput | PostReadUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostReadUpdateManyWithWhereWithoutPostInput | PostReadUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostReadScalarWhereInput | PostReadScalarWhereInput[]
  }

  export type PostCreateNestedOneWithoutLikesInput = {
    create?: XOR<PostCreateWithoutLikesInput, PostUncheckedCreateWithoutLikesInput>
    connectOrCreate?: PostCreateOrConnectWithoutLikesInput
    connect?: PostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLikesInput = {
    create?: XOR<UserCreateWithoutLikesInput, UserUncheckedCreateWithoutLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikesInput
    connect?: UserWhereUniqueInput
  }

  export type PostUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<PostCreateWithoutLikesInput, PostUncheckedCreateWithoutLikesInput>
    connectOrCreate?: PostCreateOrConnectWithoutLikesInput
    upsert?: PostUpsertWithoutLikesInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutLikesInput, PostUpdateWithoutLikesInput>, PostUncheckedUpdateWithoutLikesInput>
  }

  export type UserUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<UserCreateWithoutLikesInput, UserUncheckedCreateWithoutLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikesInput
    upsert?: UserUpsertWithoutLikesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLikesInput, UserUpdateWithoutLikesInput>, UserUncheckedUpdateWithoutLikesInput>
  }

  export type PostCreateNestedOneWithoutCommentsInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    connect?: PostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutRepliesInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    connect?: CommentWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutParentInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type PostUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    upsert?: PostUpsertWithoutCommentsInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutCommentsInput, PostUpdateWithoutCommentsInput>, PostUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type CommentUpdateOneWithoutRepliesNestedInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    upsert?: CommentUpsertWithoutRepliesInput
    disconnect?: CommentWhereInput | boolean
    delete?: CommentWhereInput | boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutRepliesInput, CommentUpdateWithoutRepliesInput>, CommentUncheckedUpdateWithoutRepliesInput>
  }

  export type CommentUpdateManyWithoutParentNestedInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutParentInput | CommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutParentInput | CommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutParentInput | CommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutParentInput | CommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutParentInput | CommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutParentInput | CommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPostReadsInput = {
    create?: XOR<UserCreateWithoutPostReadsInput, UserUncheckedCreateWithoutPostReadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostReadsInput
    connect?: UserWhereUniqueInput
  }

  export type PostCreateNestedOneWithoutPostReadsInput = {
    create?: XOR<PostCreateWithoutPostReadsInput, PostUncheckedCreateWithoutPostReadsInput>
    connectOrCreate?: PostCreateOrConnectWithoutPostReadsInput
    connect?: PostWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPostReadsNestedInput = {
    create?: XOR<UserCreateWithoutPostReadsInput, UserUncheckedCreateWithoutPostReadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostReadsInput
    upsert?: UserUpsertWithoutPostReadsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPostReadsInput, UserUpdateWithoutPostReadsInput>, UserUncheckedUpdateWithoutPostReadsInput>
  }

  export type PostUpdateOneRequiredWithoutPostReadsNestedInput = {
    create?: XOR<PostCreateWithoutPostReadsInput, PostUncheckedCreateWithoutPostReadsInput>
    connectOrCreate?: PostCreateOrConnectWithoutPostReadsInput
    upsert?: PostUpsertWithoutPostReadsInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutPostReadsInput, PostUpdateWithoutPostReadsInput>, PostUncheckedUpdateWithoutPostReadsInput>
  }

  export type DepartmentCreateNestedOneWithoutTasksInput = {
    create?: XOR<DepartmentCreateWithoutTasksInput, DepartmentUncheckedCreateWithoutTasksInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutTasksInput
    connect?: DepartmentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedTasksInput = {
    create?: XOR<UserCreateWithoutCreatedTasksInput, UserUncheckedCreateWithoutCreatedTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTasksInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssignedTasksInput = {
    create?: XOR<UserCreateWithoutAssignedTasksInput, UserUncheckedCreateWithoutAssignedTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedTasksInput
    connect?: UserWhereUniqueInput
  }

  export type TaskMessageCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskMessageCreateWithoutTaskInput, TaskMessageUncheckedCreateWithoutTaskInput> | TaskMessageCreateWithoutTaskInput[] | TaskMessageUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskMessageCreateOrConnectWithoutTaskInput | TaskMessageCreateOrConnectWithoutTaskInput[]
    createMany?: TaskMessageCreateManyTaskInputEnvelope
    connect?: TaskMessageWhereUniqueInput | TaskMessageWhereUniqueInput[]
  }

  export type TaskAttachmentCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskAttachmentCreateWithoutTaskInput, TaskAttachmentUncheckedCreateWithoutTaskInput> | TaskAttachmentCreateWithoutTaskInput[] | TaskAttachmentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskAttachmentCreateOrConnectWithoutTaskInput | TaskAttachmentCreateOrConnectWithoutTaskInput[]
    createMany?: TaskAttachmentCreateManyTaskInputEnvelope
    connect?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
  }

  export type TaskMessageUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskMessageCreateWithoutTaskInput, TaskMessageUncheckedCreateWithoutTaskInput> | TaskMessageCreateWithoutTaskInput[] | TaskMessageUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskMessageCreateOrConnectWithoutTaskInput | TaskMessageCreateOrConnectWithoutTaskInput[]
    createMany?: TaskMessageCreateManyTaskInputEnvelope
    connect?: TaskMessageWhereUniqueInput | TaskMessageWhereUniqueInput[]
  }

  export type TaskAttachmentUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskAttachmentCreateWithoutTaskInput, TaskAttachmentUncheckedCreateWithoutTaskInput> | TaskAttachmentCreateWithoutTaskInput[] | TaskAttachmentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskAttachmentCreateOrConnectWithoutTaskInput | TaskAttachmentCreateOrConnectWithoutTaskInput[]
    createMany?: TaskAttachmentCreateManyTaskInputEnvelope
    connect?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
  }

  export type EnumTaskStatusFieldUpdateOperationsInput = {
    set?: $Enums.TaskStatus
  }

  export type EnumTaskPriorityFieldUpdateOperationsInput = {
    set?: $Enums.TaskPriority
  }

  export type DepartmentUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<DepartmentCreateWithoutTasksInput, DepartmentUncheckedCreateWithoutTasksInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutTasksInput
    upsert?: DepartmentUpsertWithoutTasksInput
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutTasksInput, DepartmentUpdateWithoutTasksInput>, DepartmentUncheckedUpdateWithoutTasksInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedTasksNestedInput = {
    create?: XOR<UserCreateWithoutCreatedTasksInput, UserUncheckedCreateWithoutCreatedTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTasksInput
    upsert?: UserUpsertWithoutCreatedTasksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedTasksInput, UserUpdateWithoutCreatedTasksInput>, UserUncheckedUpdateWithoutCreatedTasksInput>
  }

  export type UserUpdateOneRequiredWithoutAssignedTasksNestedInput = {
    create?: XOR<UserCreateWithoutAssignedTasksInput, UserUncheckedCreateWithoutAssignedTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedTasksInput
    upsert?: UserUpsertWithoutAssignedTasksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedTasksInput, UserUpdateWithoutAssignedTasksInput>, UserUncheckedUpdateWithoutAssignedTasksInput>
  }

  export type TaskMessageUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskMessageCreateWithoutTaskInput, TaskMessageUncheckedCreateWithoutTaskInput> | TaskMessageCreateWithoutTaskInput[] | TaskMessageUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskMessageCreateOrConnectWithoutTaskInput | TaskMessageCreateOrConnectWithoutTaskInput[]
    upsert?: TaskMessageUpsertWithWhereUniqueWithoutTaskInput | TaskMessageUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskMessageCreateManyTaskInputEnvelope
    set?: TaskMessageWhereUniqueInput | TaskMessageWhereUniqueInput[]
    disconnect?: TaskMessageWhereUniqueInput | TaskMessageWhereUniqueInput[]
    delete?: TaskMessageWhereUniqueInput | TaskMessageWhereUniqueInput[]
    connect?: TaskMessageWhereUniqueInput | TaskMessageWhereUniqueInput[]
    update?: TaskMessageUpdateWithWhereUniqueWithoutTaskInput | TaskMessageUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskMessageUpdateManyWithWhereWithoutTaskInput | TaskMessageUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskMessageScalarWhereInput | TaskMessageScalarWhereInput[]
  }

  export type TaskAttachmentUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskAttachmentCreateWithoutTaskInput, TaskAttachmentUncheckedCreateWithoutTaskInput> | TaskAttachmentCreateWithoutTaskInput[] | TaskAttachmentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskAttachmentCreateOrConnectWithoutTaskInput | TaskAttachmentCreateOrConnectWithoutTaskInput[]
    upsert?: TaskAttachmentUpsertWithWhereUniqueWithoutTaskInput | TaskAttachmentUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskAttachmentCreateManyTaskInputEnvelope
    set?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
    disconnect?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
    delete?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
    connect?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
    update?: TaskAttachmentUpdateWithWhereUniqueWithoutTaskInput | TaskAttachmentUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskAttachmentUpdateManyWithWhereWithoutTaskInput | TaskAttachmentUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskAttachmentScalarWhereInput | TaskAttachmentScalarWhereInput[]
  }

  export type TaskMessageUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskMessageCreateWithoutTaskInput, TaskMessageUncheckedCreateWithoutTaskInput> | TaskMessageCreateWithoutTaskInput[] | TaskMessageUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskMessageCreateOrConnectWithoutTaskInput | TaskMessageCreateOrConnectWithoutTaskInput[]
    upsert?: TaskMessageUpsertWithWhereUniqueWithoutTaskInput | TaskMessageUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskMessageCreateManyTaskInputEnvelope
    set?: TaskMessageWhereUniqueInput | TaskMessageWhereUniqueInput[]
    disconnect?: TaskMessageWhereUniqueInput | TaskMessageWhereUniqueInput[]
    delete?: TaskMessageWhereUniqueInput | TaskMessageWhereUniqueInput[]
    connect?: TaskMessageWhereUniqueInput | TaskMessageWhereUniqueInput[]
    update?: TaskMessageUpdateWithWhereUniqueWithoutTaskInput | TaskMessageUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskMessageUpdateManyWithWhereWithoutTaskInput | TaskMessageUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskMessageScalarWhereInput | TaskMessageScalarWhereInput[]
  }

  export type TaskAttachmentUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskAttachmentCreateWithoutTaskInput, TaskAttachmentUncheckedCreateWithoutTaskInput> | TaskAttachmentCreateWithoutTaskInput[] | TaskAttachmentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskAttachmentCreateOrConnectWithoutTaskInput | TaskAttachmentCreateOrConnectWithoutTaskInput[]
    upsert?: TaskAttachmentUpsertWithWhereUniqueWithoutTaskInput | TaskAttachmentUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskAttachmentCreateManyTaskInputEnvelope
    set?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
    disconnect?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
    delete?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
    connect?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
    update?: TaskAttachmentUpdateWithWhereUniqueWithoutTaskInput | TaskAttachmentUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskAttachmentUpdateManyWithWhereWithoutTaskInput | TaskAttachmentUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskAttachmentScalarWhereInput | TaskAttachmentScalarWhereInput[]
  }

  export type TaskCreateNestedOneWithoutMessagesInput = {
    create?: XOR<TaskCreateWithoutMessagesInput, TaskUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: TaskCreateOrConnectWithoutMessagesInput
    connect?: TaskWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTaskMessagesInput = {
    create?: XOR<UserCreateWithoutTaskMessagesInput, UserUncheckedCreateWithoutTaskMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaskMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type TaskAttachmentCreateNestedManyWithoutMessageInput = {
    create?: XOR<TaskAttachmentCreateWithoutMessageInput, TaskAttachmentUncheckedCreateWithoutMessageInput> | TaskAttachmentCreateWithoutMessageInput[] | TaskAttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: TaskAttachmentCreateOrConnectWithoutMessageInput | TaskAttachmentCreateOrConnectWithoutMessageInput[]
    createMany?: TaskAttachmentCreateManyMessageInputEnvelope
    connect?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
  }

  export type TaskAttachmentUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<TaskAttachmentCreateWithoutMessageInput, TaskAttachmentUncheckedCreateWithoutMessageInput> | TaskAttachmentCreateWithoutMessageInput[] | TaskAttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: TaskAttachmentCreateOrConnectWithoutMessageInput | TaskAttachmentCreateOrConnectWithoutMessageInput[]
    createMany?: TaskAttachmentCreateManyMessageInputEnvelope
    connect?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
  }

  export type TaskUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<TaskCreateWithoutMessagesInput, TaskUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: TaskCreateOrConnectWithoutMessagesInput
    upsert?: TaskUpsertWithoutMessagesInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutMessagesInput, TaskUpdateWithoutMessagesInput>, TaskUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutTaskMessagesNestedInput = {
    create?: XOR<UserCreateWithoutTaskMessagesInput, UserUncheckedCreateWithoutTaskMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaskMessagesInput
    upsert?: UserUpsertWithoutTaskMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTaskMessagesInput, UserUpdateWithoutTaskMessagesInput>, UserUncheckedUpdateWithoutTaskMessagesInput>
  }

  export type TaskAttachmentUpdateManyWithoutMessageNestedInput = {
    create?: XOR<TaskAttachmentCreateWithoutMessageInput, TaskAttachmentUncheckedCreateWithoutMessageInput> | TaskAttachmentCreateWithoutMessageInput[] | TaskAttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: TaskAttachmentCreateOrConnectWithoutMessageInput | TaskAttachmentCreateOrConnectWithoutMessageInput[]
    upsert?: TaskAttachmentUpsertWithWhereUniqueWithoutMessageInput | TaskAttachmentUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: TaskAttachmentCreateManyMessageInputEnvelope
    set?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
    disconnect?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
    delete?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
    connect?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
    update?: TaskAttachmentUpdateWithWhereUniqueWithoutMessageInput | TaskAttachmentUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: TaskAttachmentUpdateManyWithWhereWithoutMessageInput | TaskAttachmentUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: TaskAttachmentScalarWhereInput | TaskAttachmentScalarWhereInput[]
  }

  export type TaskAttachmentUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<TaskAttachmentCreateWithoutMessageInput, TaskAttachmentUncheckedCreateWithoutMessageInput> | TaskAttachmentCreateWithoutMessageInput[] | TaskAttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: TaskAttachmentCreateOrConnectWithoutMessageInput | TaskAttachmentCreateOrConnectWithoutMessageInput[]
    upsert?: TaskAttachmentUpsertWithWhereUniqueWithoutMessageInput | TaskAttachmentUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: TaskAttachmentCreateManyMessageInputEnvelope
    set?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
    disconnect?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
    delete?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
    connect?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
    update?: TaskAttachmentUpdateWithWhereUniqueWithoutMessageInput | TaskAttachmentUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: TaskAttachmentUpdateManyWithWhereWithoutMessageInput | TaskAttachmentUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: TaskAttachmentScalarWhereInput | TaskAttachmentScalarWhereInput[]
  }

  export type TaskCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<TaskCreateWithoutAttachmentsInput, TaskUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutAttachmentsInput
    connect?: TaskWhereUniqueInput
  }

  export type TaskMessageCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<TaskMessageCreateWithoutAttachmentsInput, TaskMessageUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: TaskMessageCreateOrConnectWithoutAttachmentsInput
    connect?: TaskMessageWhereUniqueInput
  }

  export type TaskUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<TaskCreateWithoutAttachmentsInput, TaskUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutAttachmentsInput
    upsert?: TaskUpsertWithoutAttachmentsInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutAttachmentsInput, TaskUpdateWithoutAttachmentsInput>, TaskUncheckedUpdateWithoutAttachmentsInput>
  }

  export type TaskMessageUpdateOneWithoutAttachmentsNestedInput = {
    create?: XOR<TaskMessageCreateWithoutAttachmentsInput, TaskMessageUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: TaskMessageCreateOrConnectWithoutAttachmentsInput
    upsert?: TaskMessageUpsertWithoutAttachmentsInput
    disconnect?: TaskMessageWhereInput | boolean
    delete?: TaskMessageWhereInput | boolean
    connect?: TaskMessageWhereUniqueInput
    update?: XOR<XOR<TaskMessageUpdateToOneWithWhereWithoutAttachmentsInput, TaskMessageUpdateWithoutAttachmentsInput>, TaskMessageUncheckedUpdateWithoutAttachmentsInput>
  }

  export type DepartmentCreateNestedOneWithoutMonthlyReportsInput = {
    create?: XOR<DepartmentCreateWithoutMonthlyReportsInput, DepartmentUncheckedCreateWithoutMonthlyReportsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutMonthlyReportsInput
    connect?: DepartmentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDepartmentMonthlyReportsInput = {
    create?: XOR<UserCreateWithoutDepartmentMonthlyReportsInput, UserUncheckedCreateWithoutDepartmentMonthlyReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDepartmentMonthlyReportsInput
    connect?: UserWhereUniqueInput
  }

  export type DepartmentUpdateOneRequiredWithoutMonthlyReportsNestedInput = {
    create?: XOR<DepartmentCreateWithoutMonthlyReportsInput, DepartmentUncheckedCreateWithoutMonthlyReportsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutMonthlyReportsInput
    upsert?: DepartmentUpsertWithoutMonthlyReportsInput
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutMonthlyReportsInput, DepartmentUpdateWithoutMonthlyReportsInput>, DepartmentUncheckedUpdateWithoutMonthlyReportsInput>
  }

  export type UserUpdateOneRequiredWithoutDepartmentMonthlyReportsNestedInput = {
    create?: XOR<UserCreateWithoutDepartmentMonthlyReportsInput, UserUncheckedCreateWithoutDepartmentMonthlyReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDepartmentMonthlyReportsInput
    upsert?: UserUpsertWithoutDepartmentMonthlyReportsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDepartmentMonthlyReportsInput, UserUpdateWithoutDepartmentMonthlyReportsInput>, UserUncheckedUpdateWithoutDepartmentMonthlyReportsInput>
  }

  export type UserCreateNestedOneWithoutPushSubscriptionsInput = {
    create?: XOR<UserCreateWithoutPushSubscriptionsInput, UserUncheckedCreateWithoutPushSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPushSubscriptionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPushSubscriptionsNestedInput = {
    create?: XOR<UserCreateWithoutPushSubscriptionsInput, UserUncheckedCreateWithoutPushSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPushSubscriptionsInput
    upsert?: UserUpsertWithoutPushSubscriptionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPushSubscriptionsInput, UserUpdateWithoutPushSubscriptionsInput>, UserUncheckedUpdateWithoutPushSubscriptionsInput>
  }

  export type UserCreateNestedOneWithoutPersonalTasksInput = {
    create?: XOR<UserCreateWithoutPersonalTasksInput, UserUncheckedCreateWithoutPersonalTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutPersonalTasksInput
    connect?: UserWhereUniqueInput
  }

  export type EnumPersonalTaskStatusFieldUpdateOperationsInput = {
    set?: $Enums.PersonalTaskStatus
  }

  export type EnumPersonalTaskPriorityFieldUpdateOperationsInput = {
    set?: $Enums.PersonalTaskPriority
  }

  export type UserUpdateOneRequiredWithoutPersonalTasksNestedInput = {
    create?: XOR<UserCreateWithoutPersonalTasksInput, UserUncheckedCreateWithoutPersonalTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutPersonalTasksInput
    upsert?: UserUpsertWithoutPersonalTasksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPersonalTasksInput, UserUpdateWithoutPersonalTasksInput>, UserUncheckedUpdateWithoutPersonalTasksInput>
  }

  export type UserCreateNestedOneWithoutFinancialGoalsInput = {
    create?: XOR<UserCreateWithoutFinancialGoalsInput, UserUncheckedCreateWithoutFinancialGoalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFinancialGoalsInput
    connect?: UserWhereUniqueInput
  }

  export type UserMonthlyProgressCreateNestedManyWithoutGoalInput = {
    create?: XOR<UserMonthlyProgressCreateWithoutGoalInput, UserMonthlyProgressUncheckedCreateWithoutGoalInput> | UserMonthlyProgressCreateWithoutGoalInput[] | UserMonthlyProgressUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: UserMonthlyProgressCreateOrConnectWithoutGoalInput | UserMonthlyProgressCreateOrConnectWithoutGoalInput[]
    createMany?: UserMonthlyProgressCreateManyGoalInputEnvelope
    connect?: UserMonthlyProgressWhereUniqueInput | UserMonthlyProgressWhereUniqueInput[]
  }

  export type UserMonthlyProgressUncheckedCreateNestedManyWithoutGoalInput = {
    create?: XOR<UserMonthlyProgressCreateWithoutGoalInput, UserMonthlyProgressUncheckedCreateWithoutGoalInput> | UserMonthlyProgressCreateWithoutGoalInput[] | UserMonthlyProgressUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: UserMonthlyProgressCreateOrConnectWithoutGoalInput | UserMonthlyProgressCreateOrConnectWithoutGoalInput[]
    createMany?: UserMonthlyProgressCreateManyGoalInputEnvelope
    connect?: UserMonthlyProgressWhereUniqueInput | UserMonthlyProgressWhereUniqueInput[]
  }

  export type EnumFinancialGoalTypeFieldUpdateOperationsInput = {
    set?: $Enums.FinancialGoalType
  }

  export type UserUpdateOneRequiredWithoutFinancialGoalsNestedInput = {
    create?: XOR<UserCreateWithoutFinancialGoalsInput, UserUncheckedCreateWithoutFinancialGoalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFinancialGoalsInput
    upsert?: UserUpsertWithoutFinancialGoalsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFinancialGoalsInput, UserUpdateWithoutFinancialGoalsInput>, UserUncheckedUpdateWithoutFinancialGoalsInput>
  }

  export type UserMonthlyProgressUpdateManyWithoutGoalNestedInput = {
    create?: XOR<UserMonthlyProgressCreateWithoutGoalInput, UserMonthlyProgressUncheckedCreateWithoutGoalInput> | UserMonthlyProgressCreateWithoutGoalInput[] | UserMonthlyProgressUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: UserMonthlyProgressCreateOrConnectWithoutGoalInput | UserMonthlyProgressCreateOrConnectWithoutGoalInput[]
    upsert?: UserMonthlyProgressUpsertWithWhereUniqueWithoutGoalInput | UserMonthlyProgressUpsertWithWhereUniqueWithoutGoalInput[]
    createMany?: UserMonthlyProgressCreateManyGoalInputEnvelope
    set?: UserMonthlyProgressWhereUniqueInput | UserMonthlyProgressWhereUniqueInput[]
    disconnect?: UserMonthlyProgressWhereUniqueInput | UserMonthlyProgressWhereUniqueInput[]
    delete?: UserMonthlyProgressWhereUniqueInput | UserMonthlyProgressWhereUniqueInput[]
    connect?: UserMonthlyProgressWhereUniqueInput | UserMonthlyProgressWhereUniqueInput[]
    update?: UserMonthlyProgressUpdateWithWhereUniqueWithoutGoalInput | UserMonthlyProgressUpdateWithWhereUniqueWithoutGoalInput[]
    updateMany?: UserMonthlyProgressUpdateManyWithWhereWithoutGoalInput | UserMonthlyProgressUpdateManyWithWhereWithoutGoalInput[]
    deleteMany?: UserMonthlyProgressScalarWhereInput | UserMonthlyProgressScalarWhereInput[]
  }

  export type UserMonthlyProgressUncheckedUpdateManyWithoutGoalNestedInput = {
    create?: XOR<UserMonthlyProgressCreateWithoutGoalInput, UserMonthlyProgressUncheckedCreateWithoutGoalInput> | UserMonthlyProgressCreateWithoutGoalInput[] | UserMonthlyProgressUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: UserMonthlyProgressCreateOrConnectWithoutGoalInput | UserMonthlyProgressCreateOrConnectWithoutGoalInput[]
    upsert?: UserMonthlyProgressUpsertWithWhereUniqueWithoutGoalInput | UserMonthlyProgressUpsertWithWhereUniqueWithoutGoalInput[]
    createMany?: UserMonthlyProgressCreateManyGoalInputEnvelope
    set?: UserMonthlyProgressWhereUniqueInput | UserMonthlyProgressWhereUniqueInput[]
    disconnect?: UserMonthlyProgressWhereUniqueInput | UserMonthlyProgressWhereUniqueInput[]
    delete?: UserMonthlyProgressWhereUniqueInput | UserMonthlyProgressWhereUniqueInput[]
    connect?: UserMonthlyProgressWhereUniqueInput | UserMonthlyProgressWhereUniqueInput[]
    update?: UserMonthlyProgressUpdateWithWhereUniqueWithoutGoalInput | UserMonthlyProgressUpdateWithWhereUniqueWithoutGoalInput[]
    updateMany?: UserMonthlyProgressUpdateManyWithWhereWithoutGoalInput | UserMonthlyProgressUpdateManyWithWhereWithoutGoalInput[]
    deleteMany?: UserMonthlyProgressScalarWhereInput | UserMonthlyProgressScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutFinancialProfileInput = {
    create?: XOR<UserCreateWithoutFinancialProfileInput, UserUncheckedCreateWithoutFinancialProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutFinancialProfileInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFinancialProfileNestedInput = {
    create?: XOR<UserCreateWithoutFinancialProfileInput, UserUncheckedCreateWithoutFinancialProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutFinancialProfileInput
    upsert?: UserUpsertWithoutFinancialProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFinancialProfileInput, UserUpdateWithoutFinancialProfileInput>, UserUncheckedUpdateWithoutFinancialProfileInput>
  }

  export type UserCreateNestedOneWithoutMonthlyStatementsInput = {
    create?: XOR<UserCreateWithoutMonthlyStatementsInput, UserUncheckedCreateWithoutMonthlyStatementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMonthlyStatementsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMonthlyStatementsNestedInput = {
    create?: XOR<UserCreateWithoutMonthlyStatementsInput, UserUncheckedCreateWithoutMonthlyStatementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMonthlyStatementsInput
    upsert?: UserUpsertWithoutMonthlyStatementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMonthlyStatementsInput, UserUpdateWithoutMonthlyStatementsInput>, UserUncheckedUpdateWithoutMonthlyStatementsInput>
  }

  export type UserCreateNestedOneWithoutFinancialEntriesInput = {
    create?: XOR<UserCreateWithoutFinancialEntriesInput, UserUncheckedCreateWithoutFinancialEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFinancialEntriesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumFinancialEntryTypeFieldUpdateOperationsInput = {
    set?: $Enums.FinancialEntryType
  }

  export type UserUpdateOneRequiredWithoutFinancialEntriesNestedInput = {
    create?: XOR<UserCreateWithoutFinancialEntriesInput, UserUncheckedCreateWithoutFinancialEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFinancialEntriesInput
    upsert?: UserUpsertWithoutFinancialEntriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFinancialEntriesInput, UserUpdateWithoutFinancialEntriesInput>, UserUncheckedUpdateWithoutFinancialEntriesInput>
  }

  export type UserFinancialGoalCreateNestedOneWithoutProgressInput = {
    create?: XOR<UserFinancialGoalCreateWithoutProgressInput, UserFinancialGoalUncheckedCreateWithoutProgressInput>
    connectOrCreate?: UserFinancialGoalCreateOrConnectWithoutProgressInput
    connect?: UserFinancialGoalWhereUniqueInput
  }

  export type UserFinancialGoalUpdateOneRequiredWithoutProgressNestedInput = {
    create?: XOR<UserFinancialGoalCreateWithoutProgressInput, UserFinancialGoalUncheckedCreateWithoutProgressInput>
    connectOrCreate?: UserFinancialGoalCreateOrConnectWithoutProgressInput
    upsert?: UserFinancialGoalUpsertWithoutProgressInput
    connect?: UserFinancialGoalWhereUniqueInput
    update?: XOR<XOR<UserFinancialGoalUpdateToOneWithWhereWithoutProgressInput, UserFinancialGoalUpdateWithoutProgressInput>, UserFinancialGoalUncheckedUpdateWithoutProgressInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumInvitationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusFilter<$PrismaModel> | $Enums.InvitationStatus
  }

  export type NestedEnumInvitationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationType | EnumInvitationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationType[] | ListEnumInvitationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationType[] | ListEnumInvitationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationTypeFilter<$PrismaModel> | $Enums.InvitationType
  }

  export type NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvitationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvitationStatusFilter<$PrismaModel>
    _max?: NestedEnumInvitationStatusFilter<$PrismaModel>
  }

  export type NestedEnumInvitationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationType | EnumInvitationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationType[] | ListEnumInvitationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationType[] | ListEnumInvitationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationTypeWithAggregatesFilter<$PrismaModel> | $Enums.InvitationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvitationTypeFilter<$PrismaModel>
    _max?: NestedEnumInvitationTypeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumOrgRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.OrgRole | EnumOrgRoleFieldRefInput<$PrismaModel>
    in?: $Enums.OrgRole[] | ListEnumOrgRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrgRole[] | ListEnumOrgRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumOrgRoleFilter<$PrismaModel> | $Enums.OrgRole
  }

  export type NestedEnumOrgRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrgRole | EnumOrgRoleFieldRefInput<$PrismaModel>
    in?: $Enums.OrgRole[] | ListEnumOrgRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrgRole[] | ListEnumOrgRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumOrgRoleWithAggregatesFilter<$PrismaModel> | $Enums.OrgRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrgRoleFilter<$PrismaModel>
    _max?: NestedEnumOrgRoleFilter<$PrismaModel>
  }

  export type NestedEnumFileTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeFilter<$PrismaModel> | $Enums.FileType
  }

  export type NestedEnumFileTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeWithAggregatesFilter<$PrismaModel> | $Enums.FileType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFileTypeFilter<$PrismaModel>
    _max?: NestedEnumFileTypeFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumDecisionVoteTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DecisionVoteType | EnumDecisionVoteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DecisionVoteType[] | ListEnumDecisionVoteTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DecisionVoteType[] | ListEnumDecisionVoteTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDecisionVoteTypeFilter<$PrismaModel> | $Enums.DecisionVoteType
  }

  export type NestedEnumDecisionVoteTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DecisionVoteType | EnumDecisionVoteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DecisionVoteType[] | ListEnumDecisionVoteTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DecisionVoteType[] | ListEnumDecisionVoteTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDecisionVoteTypeWithAggregatesFilter<$PrismaModel> | $Enums.DecisionVoteType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDecisionVoteTypeFilter<$PrismaModel>
    _max?: NestedEnumDecisionVoteTypeFilter<$PrismaModel>
  }

  export type NestedEnumNoteTextSizeFilter<$PrismaModel = never> = {
    equals?: $Enums.NoteTextSize | EnumNoteTextSizeFieldRefInput<$PrismaModel>
    in?: $Enums.NoteTextSize[] | ListEnumNoteTextSizeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NoteTextSize[] | ListEnumNoteTextSizeFieldRefInput<$PrismaModel>
    not?: NestedEnumNoteTextSizeFilter<$PrismaModel> | $Enums.NoteTextSize
  }

  export type NestedEnumNoteTextSizeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NoteTextSize | EnumNoteTextSizeFieldRefInput<$PrismaModel>
    in?: $Enums.NoteTextSize[] | ListEnumNoteTextSizeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NoteTextSize[] | ListEnumNoteTextSizeFieldRefInput<$PrismaModel>
    not?: NestedEnumNoteTextSizeWithAggregatesFilter<$PrismaModel> | $Enums.NoteTextSize
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNoteTextSizeFilter<$PrismaModel>
    _max?: NestedEnumNoteTextSizeFilter<$PrismaModel>
  }

  export type NestedEnumRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestStatus | EnumRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestStatusFilter<$PrismaModel> | $Enums.RequestStatus
  }

  export type NestedEnumRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestStatus | EnumRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.RequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumRequestStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentOrderStatus | EnumPaymentOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentOrderStatus[] | ListEnumPaymentOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentOrderStatus[] | ListEnumPaymentOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentOrderStatusFilter<$PrismaModel> | $Enums.PaymentOrderStatus
  }

  export type NestedEnumPaymentOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentOrderStatus | EnumPaymentOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentOrderStatus[] | ListEnumPaymentOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentOrderStatus[] | ListEnumPaymentOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentOrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentOrderStatusFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionPlanFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionPlanFilter<$PrismaModel> | $Enums.SubscriptionPlan
  }

  export type NestedEnumSubscriptionPlanWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionPlanWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionPlan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
  }

  export type NestedEnumEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeFilter<$PrismaModel> | $Enums.EventType
  }

  export type NestedEnumEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.EventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventTypeFilter<$PrismaModel>
    _max?: NestedEnumEventTypeFilter<$PrismaModel>
  }

  export type NestedEnumPostTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PostType | EnumPostTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPostTypeFilter<$PrismaModel> | $Enums.PostType
  }

  export type NestedEnumPostTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostType | EnumPostTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPostTypeWithAggregatesFilter<$PrismaModel> | $Enums.PostType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostTypeFilter<$PrismaModel>
    _max?: NestedEnumPostTypeFilter<$PrismaModel>
  }

  export type NestedEnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type NestedEnumTaskPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskPriority | EnumTaskPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TaskPriority[] | ListEnumTaskPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskPriority[] | ListEnumTaskPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskPriorityFilter<$PrismaModel> | $Enums.TaskPriority
  }

  export type NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type NestedEnumTaskPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskPriority | EnumTaskPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TaskPriority[] | ListEnumTaskPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskPriority[] | ListEnumTaskPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskPriorityWithAggregatesFilter<$PrismaModel> | $Enums.TaskPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskPriorityFilter<$PrismaModel>
    _max?: NestedEnumTaskPriorityFilter<$PrismaModel>
  }

  export type NestedEnumPersonalTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PersonalTaskStatus | EnumPersonalTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PersonalTaskStatus[] | ListEnumPersonalTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PersonalTaskStatus[] | ListEnumPersonalTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPersonalTaskStatusFilter<$PrismaModel> | $Enums.PersonalTaskStatus
  }

  export type NestedEnumPersonalTaskPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.PersonalTaskPriority | EnumPersonalTaskPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.PersonalTaskPriority[] | ListEnumPersonalTaskPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.PersonalTaskPriority[] | ListEnumPersonalTaskPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPersonalTaskPriorityFilter<$PrismaModel> | $Enums.PersonalTaskPriority
  }

  export type NestedEnumPersonalTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PersonalTaskStatus | EnumPersonalTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PersonalTaskStatus[] | ListEnumPersonalTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PersonalTaskStatus[] | ListEnumPersonalTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPersonalTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.PersonalTaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPersonalTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumPersonalTaskStatusFilter<$PrismaModel>
  }

  export type NestedEnumPersonalTaskPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PersonalTaskPriority | EnumPersonalTaskPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.PersonalTaskPriority[] | ListEnumPersonalTaskPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.PersonalTaskPriority[] | ListEnumPersonalTaskPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPersonalTaskPriorityWithAggregatesFilter<$PrismaModel> | $Enums.PersonalTaskPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPersonalTaskPriorityFilter<$PrismaModel>
    _max?: NestedEnumPersonalTaskPriorityFilter<$PrismaModel>
  }

  export type NestedEnumFinancialGoalTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FinancialGoalType | EnumFinancialGoalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FinancialGoalType[] | ListEnumFinancialGoalTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FinancialGoalType[] | ListEnumFinancialGoalTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFinancialGoalTypeFilter<$PrismaModel> | $Enums.FinancialGoalType
  }

  export type NestedEnumFinancialGoalTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FinancialGoalType | EnumFinancialGoalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FinancialGoalType[] | ListEnumFinancialGoalTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FinancialGoalType[] | ListEnumFinancialGoalTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFinancialGoalTypeWithAggregatesFilter<$PrismaModel> | $Enums.FinancialGoalType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFinancialGoalTypeFilter<$PrismaModel>
    _max?: NestedEnumFinancialGoalTypeFilter<$PrismaModel>
  }

  export type NestedEnumFinancialEntryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FinancialEntryType | EnumFinancialEntryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FinancialEntryType[] | ListEnumFinancialEntryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FinancialEntryType[] | ListEnumFinancialEntryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFinancialEntryTypeFilter<$PrismaModel> | $Enums.FinancialEntryType
  }

  export type NestedEnumFinancialEntryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FinancialEntryType | EnumFinancialEntryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FinancialEntryType[] | ListEnumFinancialEntryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FinancialEntryType[] | ListEnumFinancialEntryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFinancialEntryTypeWithAggregatesFilter<$PrismaModel> | $Enums.FinancialEntryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFinancialEntryTypeFilter<$PrismaModel>
    _max?: NestedEnumFinancialEntryTypeFilter<$PrismaModel>
  }

  export type AnnouncementCreateWithoutPublisherInput = {
    id?: string
    title: string
    content: string
    expiresAt: Date | string
    createdAt?: Date | string
    isActive?: boolean
    reads?: AnnouncementReadCreateNestedManyWithoutAnnouncementInput
  }

  export type AnnouncementUncheckedCreateWithoutPublisherInput = {
    id?: string
    title: string
    content: string
    expiresAt: Date | string
    createdAt?: Date | string
    isActive?: boolean
    reads?: AnnouncementReadUncheckedCreateNestedManyWithoutAnnouncementInput
  }

  export type AnnouncementCreateOrConnectWithoutPublisherInput = {
    where: AnnouncementWhereUniqueInput
    create: XOR<AnnouncementCreateWithoutPublisherInput, AnnouncementUncheckedCreateWithoutPublisherInput>
  }

  export type AnnouncementCreateManyPublisherInputEnvelope = {
    data: AnnouncementCreateManyPublisherInput | AnnouncementCreateManyPublisherInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentMemberCreateWithoutUserInput = {
    id?: string
    encryptedDeptKey: string
    department: DepartmentCreateNestedOneWithoutMembersInput
  }

  export type DepartmentMemberUncheckedCreateWithoutUserInput = {
    id?: string
    deptId: string
    encryptedDeptKey: string
  }

  export type DepartmentMemberCreateOrConnectWithoutUserInput = {
    where: DepartmentMemberWhereUniqueInput
    create: XOR<DepartmentMemberCreateWithoutUserInput, DepartmentMemberUncheckedCreateWithoutUserInput>
  }

  export type DepartmentMemberCreateManyUserInputEnvelope = {
    data: DepartmentMemberCreateManyUserInput | DepartmentMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GroupMemberCreateWithoutUserInput = {
    id?: string
    joinedAt?: Date | string
    lastReadAt?: Date | string
    group: GroupCreateNestedOneWithoutMembersInput
  }

  export type GroupMemberUncheckedCreateWithoutUserInput = {
    id?: string
    groupId: string
    joinedAt?: Date | string
    lastReadAt?: Date | string
  }

  export type GroupMemberCreateOrConnectWithoutUserInput = {
    where: GroupMemberWhereUniqueInput
    create: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput>
  }

  export type GroupMemberCreateManyUserInputEnvelope = {
    data: GroupMemberCreateManyUserInput | GroupMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutSenderInput = {
    id?: string
    content: string
    isEdited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: AttachmentCreateNestedManyWithoutMessageInput
    group: GroupCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: string
    content: string
    groupId: string
    isEdited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: AttachmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    content: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    isRead?: boolean
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    content: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    isRead?: boolean
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationMemberCreateWithoutUserInput = {
    id?: string
    role?: $Enums.OrgRole
    joinedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutMembersInput
  }

  export type OrganizationMemberUncheckedCreateWithoutUserInput = {
    id?: string
    orgId: string
    role?: $Enums.OrgRole
    joinedAt?: Date | string
  }

  export type OrganizationMemberCreateOrConnectWithoutUserInput = {
    where: OrganizationMemberWhereUniqueInput
    create: XOR<OrganizationMemberCreateWithoutUserInput, OrganizationMemberUncheckedCreateWithoutUserInput>
  }

  export type OrganizationMemberCreateManyUserInputEnvelope = {
    data: OrganizationMemberCreateManyUserInput | OrganizationMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserPageCreateWithoutUserInput = {
    id?: string
    handle: string
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostCreateNestedManyWithoutPageInput
  }

  export type UserPageUncheckedCreateWithoutUserInput = {
    id?: string
    handle: string
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostUncheckedCreateNestedManyWithoutPageInput
  }

  export type UserPageCreateOrConnectWithoutUserInput = {
    where: UserPageWhereUniqueInput
    create: XOR<UserPageCreateWithoutUserInput, UserPageUncheckedCreateWithoutUserInput>
  }

  export type LikeCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    post: PostCreateNestedOneWithoutLikesInput
  }

  export type LikeUncheckedCreateWithoutUserInput = {
    id?: string
    postId: string
    createdAt?: Date | string
  }

  export type LikeCreateOrConnectWithoutUserInput = {
    where: LikeWhereUniqueInput
    create: XOR<LikeCreateWithoutUserInput, LikeUncheckedCreateWithoutUserInput>
  }

  export type LikeCreateManyUserInputEnvelope = {
    data: LikeCreateManyUserInput | LikeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutUserInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    post: PostCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentInput
  }

  export type CommentUncheckedCreateWithoutUserInput = {
    id?: string
    postId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentCreateOrConnectWithoutUserInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentCreateManyUserInputEnvelope = {
    data: CommentCreateManyUserInput | CommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PostReadCreateWithoutUserInput = {
    id?: string
    readAt?: Date | string
    post: PostCreateNestedOneWithoutPostReadsInput
  }

  export type PostReadUncheckedCreateWithoutUserInput = {
    id?: string
    postId: string
    readAt?: Date | string
  }

  export type PostReadCreateOrConnectWithoutUserInput = {
    where: PostReadWhereUniqueInput
    create: XOR<PostReadCreateWithoutUserInput, PostReadUncheckedCreateWithoutUserInput>
  }

  export type PostReadCreateManyUserInputEnvelope = {
    data: PostReadCreateManyUserInput | PostReadCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutAssigneeInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.TaskPriority
    startDate?: Date | string | null
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department: DepartmentCreateNestedOneWithoutTasksInput
    creator: UserCreateNestedOneWithoutCreatedTasksInput
    messages?: TaskMessageCreateNestedManyWithoutTaskInput
    attachments?: TaskAttachmentCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutAssigneeInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.TaskPriority
    startDate?: Date | string | null
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deptId: string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: TaskMessageUncheckedCreateNestedManyWithoutTaskInput
    attachments?: TaskAttachmentUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutAssigneeInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutAssigneeInput, TaskUncheckedCreateWithoutAssigneeInput>
  }

  export type TaskCreateManyAssigneeInputEnvelope = {
    data: TaskCreateManyAssigneeInput | TaskCreateManyAssigneeInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutCreatorInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.TaskPriority
    startDate?: Date | string | null
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department: DepartmentCreateNestedOneWithoutTasksInput
    assignee: UserCreateNestedOneWithoutAssignedTasksInput
    messages?: TaskMessageCreateNestedManyWithoutTaskInput
    attachments?: TaskAttachmentCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutCreatorInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.TaskPriority
    startDate?: Date | string | null
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deptId: string
    assigneeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: TaskMessageUncheckedCreateNestedManyWithoutTaskInput
    attachments?: TaskAttachmentUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutCreatorInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutCreatorInput, TaskUncheckedCreateWithoutCreatorInput>
  }

  export type TaskCreateManyCreatorInputEnvelope = {
    data: TaskCreateManyCreatorInput | TaskCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentCreateWithoutHeadInput = {
    id?: string
    name: string
    publicKey: string
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutDepartmentsInput
    members?: DepartmentMemberCreateNestedManyWithoutDepartmentInput
    conversations?: GroupCreateNestedManyWithoutDepartmentInput
    tasks?: TaskCreateNestedManyWithoutDepartmentInput
    eventBroadcasts?: EventDepartmentBroadcastCreateNestedManyWithoutDepartmentInput
    monthlyReports?: DepartmentMonthlyReportCreateNestedManyWithoutDepartmentInput
    goals?: DepartmentGoalCreateNestedManyWithoutDepartmentInput
    meetings?: DepartmentMeetingCreateNestedManyWithoutDepartmentInput
    polls?: DepartmentPollCreateNestedManyWithoutDepartmentInput
    teamDecisions?: TeamDecisionCreateNestedManyWithoutDepartmentInput
    documents?: DepartmentDocumentCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutHeadInput = {
    id?: string
    name: string
    orgId: string
    publicKey: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: DepartmentMemberUncheckedCreateNestedManyWithoutDepartmentInput
    conversations?: GroupUncheckedCreateNestedManyWithoutDepartmentInput
    tasks?: TaskUncheckedCreateNestedManyWithoutDepartmentInput
    eventBroadcasts?: EventDepartmentBroadcastUncheckedCreateNestedManyWithoutDepartmentInput
    monthlyReports?: DepartmentMonthlyReportUncheckedCreateNestedManyWithoutDepartmentInput
    goals?: DepartmentGoalUncheckedCreateNestedManyWithoutDepartmentInput
    meetings?: DepartmentMeetingUncheckedCreateNestedManyWithoutDepartmentInput
    polls?: DepartmentPollUncheckedCreateNestedManyWithoutDepartmentInput
    teamDecisions?: TeamDecisionUncheckedCreateNestedManyWithoutDepartmentInput
    documents?: DepartmentDocumentUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutHeadInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutHeadInput, DepartmentUncheckedCreateWithoutHeadInput>
  }

  export type DepartmentCreateManyHeadInputEnvelope = {
    data: DepartmentCreateManyHeadInput | DepartmentCreateManyHeadInput[]
    skipDuplicates?: boolean
  }

  export type TaskMessageCreateWithoutSenderInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    task: TaskCreateNestedOneWithoutMessagesInput
    attachments?: TaskAttachmentCreateNestedManyWithoutMessageInput
  }

  export type TaskMessageUncheckedCreateWithoutSenderInput = {
    id?: string
    taskId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: TaskAttachmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type TaskMessageCreateOrConnectWithoutSenderInput = {
    where: TaskMessageWhereUniqueInput
    create: XOR<TaskMessageCreateWithoutSenderInput, TaskMessageUncheckedCreateWithoutSenderInput>
  }

  export type TaskMessageCreateManySenderInputEnvelope = {
    data: TaskMessageCreateManySenderInput | TaskMessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentMonthlyReportCreateWithoutUserInput = {
    id?: string
    month: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    department: DepartmentCreateNestedOneWithoutMonthlyReportsInput
  }

  export type DepartmentMonthlyReportUncheckedCreateWithoutUserInput = {
    id?: string
    deptId: string
    month: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentMonthlyReportCreateOrConnectWithoutUserInput = {
    where: DepartmentMonthlyReportWhereUniqueInput
    create: XOR<DepartmentMonthlyReportCreateWithoutUserInput, DepartmentMonthlyReportUncheckedCreateWithoutUserInput>
  }

  export type DepartmentMonthlyReportCreateManyUserInputEnvelope = {
    data: DepartmentMonthlyReportCreateManyUserInput | DepartmentMonthlyReportCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentMeetingCreateWithoutCreatorInput = {
    id?: string
    title: string
    description?: string | null
    agenda?: string | null
    meetingDate: Date | string
    location?: string | null
    minutes?: string | null
    minutesAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department: DepartmentCreateNestedOneWithoutMeetingsInput
  }

  export type DepartmentMeetingUncheckedCreateWithoutCreatorInput = {
    id?: string
    deptId: string
    title: string
    description?: string | null
    agenda?: string | null
    meetingDate: Date | string
    location?: string | null
    minutes?: string | null
    minutesAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentMeetingCreateOrConnectWithoutCreatorInput = {
    where: DepartmentMeetingWhereUniqueInput
    create: XOR<DepartmentMeetingCreateWithoutCreatorInput, DepartmentMeetingUncheckedCreateWithoutCreatorInput>
  }

  export type DepartmentMeetingCreateManyCreatorInputEnvelope = {
    data: DepartmentMeetingCreateManyCreatorInput | DepartmentMeetingCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentPollCreateWithoutCreatorInput = {
    id?: string
    question: string
    options: JsonNullValueInput | InputJsonValue
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department: DepartmentCreateNestedOneWithoutPollsInput
    votes?: PollVoteCreateNestedManyWithoutPollInput
  }

  export type DepartmentPollUncheckedCreateWithoutCreatorInput = {
    id?: string
    deptId: string
    question: string
    options: JsonNullValueInput | InputJsonValue
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: PollVoteUncheckedCreateNestedManyWithoutPollInput
  }

  export type DepartmentPollCreateOrConnectWithoutCreatorInput = {
    where: DepartmentPollWhereUniqueInput
    create: XOR<DepartmentPollCreateWithoutCreatorInput, DepartmentPollUncheckedCreateWithoutCreatorInput>
  }

  export type DepartmentPollCreateManyCreatorInputEnvelope = {
    data: DepartmentPollCreateManyCreatorInput | DepartmentPollCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type TeamDecisionCreateWithoutCreatorInput = {
    id?: string
    title: string
    description?: string | null
    voteDeadline?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    department: DepartmentCreateNestedOneWithoutTeamDecisionsInput
    votes?: DecisionVoteCreateNestedManyWithoutDecisionInput
  }

  export type TeamDecisionUncheckedCreateWithoutCreatorInput = {
    id?: string
    deptId: string
    title: string
    description?: string | null
    voteDeadline?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: DecisionVoteUncheckedCreateNestedManyWithoutDecisionInput
  }

  export type TeamDecisionCreateOrConnectWithoutCreatorInput = {
    where: TeamDecisionWhereUniqueInput
    create: XOR<TeamDecisionCreateWithoutCreatorInput, TeamDecisionUncheckedCreateWithoutCreatorInput>
  }

  export type TeamDecisionCreateManyCreatorInputEnvelope = {
    data: TeamDecisionCreateManyCreatorInput | TeamDecisionCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type PollVoteCreateWithoutUserInput = {
    id?: string
    optionIndex: number
    createdAt?: Date | string
    poll: DepartmentPollCreateNestedOneWithoutVotesInput
  }

  export type PollVoteUncheckedCreateWithoutUserInput = {
    id?: string
    pollId: string
    optionIndex: number
    createdAt?: Date | string
  }

  export type PollVoteCreateOrConnectWithoutUserInput = {
    where: PollVoteWhereUniqueInput
    create: XOR<PollVoteCreateWithoutUserInput, PollVoteUncheckedCreateWithoutUserInput>
  }

  export type PollVoteCreateManyUserInputEnvelope = {
    data: PollVoteCreateManyUserInput | PollVoteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DecisionVoteCreateWithoutUserInput = {
    id?: string
    vote: $Enums.DecisionVoteType
    createdAt?: Date | string
    decision: TeamDecisionCreateNestedOneWithoutVotesInput
  }

  export type DecisionVoteUncheckedCreateWithoutUserInput = {
    id?: string
    decisionId: string
    vote: $Enums.DecisionVoteType
    createdAt?: Date | string
  }

  export type DecisionVoteCreateOrConnectWithoutUserInput = {
    where: DecisionVoteWhereUniqueInput
    create: XOR<DecisionVoteCreateWithoutUserInput, DecisionVoteUncheckedCreateWithoutUserInput>
  }

  export type DecisionVoteCreateManyUserInputEnvelope = {
    data: DecisionVoteCreateManyUserInput | DecisionVoteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PushSubscriptionCreateWithoutUserInput = {
    id?: string
    endpoint: string
    p256dh: string
    auth: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PushSubscriptionUncheckedCreateWithoutUserInput = {
    id?: string
    endpoint: string
    p256dh: string
    auth: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PushSubscriptionCreateOrConnectWithoutUserInput = {
    where: PushSubscriptionWhereUniqueInput
    create: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput>
  }

  export type PushSubscriptionCreateManyUserInputEnvelope = {
    data: PushSubscriptionCreateManyUserInput | PushSubscriptionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserInvitationCreateWithoutUserInput = {
    id?: string
    token: string
    status?: $Enums.InvitationStatus
    title: string
    description?: string | null
    imageBase64?: string | null
    type?: $Enums.InvitationType
    date: Date | string
    location: string
    maxGuests?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    guests?: InvitationGuestCreateNestedManyWithoutInvitationInput
  }

  export type UserInvitationUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    status?: $Enums.InvitationStatus
    title: string
    description?: string | null
    imageBase64?: string | null
    type?: $Enums.InvitationType
    date: Date | string
    location: string
    maxGuests?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    guests?: InvitationGuestUncheckedCreateNestedManyWithoutInvitationInput
  }

  export type UserInvitationCreateOrConnectWithoutUserInput = {
    where: UserInvitationWhereUniqueInput
    create: XOR<UserInvitationCreateWithoutUserInput, UserInvitationUncheckedCreateWithoutUserInput>
  }

  export type UserInvitationCreateManyUserInputEnvelope = {
    data: UserInvitationCreateManyUserInput | UserInvitationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserPersonalTaskCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.PersonalTaskStatus
    priority?: $Enums.PersonalTaskPriority
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPersonalTaskUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.PersonalTaskStatus
    priority?: $Enums.PersonalTaskPriority
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPersonalTaskCreateOrConnectWithoutUserInput = {
    where: UserPersonalTaskWhereUniqueInput
    create: XOR<UserPersonalTaskCreateWithoutUserInput, UserPersonalTaskUncheckedCreateWithoutUserInput>
  }

  export type UserPersonalTaskCreateManyUserInputEnvelope = {
    data: UserPersonalTaskCreateManyUserInput | UserPersonalTaskCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserFinancialGoalCreateWithoutUserInput = {
    id?: string
    type?: $Enums.FinancialGoalType
    year?: number | null
    targetItem?: string | null
    targetAmount: number
    targetDate?: Date | string | null
    label?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: UserMonthlyProgressCreateNestedManyWithoutGoalInput
  }

  export type UserFinancialGoalUncheckedCreateWithoutUserInput = {
    id?: string
    type?: $Enums.FinancialGoalType
    year?: number | null
    targetItem?: string | null
    targetAmount: number
    targetDate?: Date | string | null
    label?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: UserMonthlyProgressUncheckedCreateNestedManyWithoutGoalInput
  }

  export type UserFinancialGoalCreateOrConnectWithoutUserInput = {
    where: UserFinancialGoalWhereUniqueInput
    create: XOR<UserFinancialGoalCreateWithoutUserInput, UserFinancialGoalUncheckedCreateWithoutUserInput>
  }

  export type UserFinancialGoalCreateManyUserInputEnvelope = {
    data: UserFinancialGoalCreateManyUserInput | UserFinancialGoalCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserFinancialProfileCreateWithoutUserInput = {
    id?: string
    monthlySalary?: number
    supplementaryIncome?: number
    currency?: string
    preferredSavingsRate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserFinancialProfileUncheckedCreateWithoutUserInput = {
    id?: string
    monthlySalary?: number
    supplementaryIncome?: number
    currency?: string
    preferredSavingsRate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserFinancialProfileCreateOrConnectWithoutUserInput = {
    where: UserFinancialProfileWhereUniqueInput
    create: XOR<UserFinancialProfileCreateWithoutUserInput, UserFinancialProfileUncheckedCreateWithoutUserInput>
  }

  export type UserMonthlyStatementCreateWithoutUserInput = {
    id?: string
    year: number
    month: number
    salaryReceived?: number
    supplementaryIncome?: number
    totalExpenses?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserMonthlyStatementUncheckedCreateWithoutUserInput = {
    id?: string
    year: number
    month: number
    salaryReceived?: number
    supplementaryIncome?: number
    totalExpenses?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserMonthlyStatementCreateOrConnectWithoutUserInput = {
    where: UserMonthlyStatementWhereUniqueInput
    create: XOR<UserMonthlyStatementCreateWithoutUserInput, UserMonthlyStatementUncheckedCreateWithoutUserInput>
  }

  export type UserMonthlyStatementCreateManyUserInputEnvelope = {
    data: UserMonthlyStatementCreateManyUserInput | UserMonthlyStatementCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserFinancialEntryCreateWithoutUserInput = {
    id?: string
    year: number
    month: number
    type: $Enums.FinancialEntryType
    amount: number
    note?: string | null
    isConfirmed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserFinancialEntryUncheckedCreateWithoutUserInput = {
    id?: string
    year: number
    month: number
    type: $Enums.FinancialEntryType
    amount: number
    note?: string | null
    isConfirmed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserFinancialEntryCreateOrConnectWithoutUserInput = {
    where: UserFinancialEntryWhereUniqueInput
    create: XOR<UserFinancialEntryCreateWithoutUserInput, UserFinancialEntryUncheckedCreateWithoutUserInput>
  }

  export type UserFinancialEntryCreateManyUserInputEnvelope = {
    data: UserFinancialEntryCreateManyUserInput | UserFinancialEntryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FollowCreateWithoutFollowingInput = {
    id?: string
    createdAt?: Date | string
    follower: UserCreateNestedOneWithoutFollowingInput
  }

  export type FollowUncheckedCreateWithoutFollowingInput = {
    id?: string
    followerId: string
    createdAt?: Date | string
  }

  export type FollowCreateOrConnectWithoutFollowingInput = {
    where: FollowWhereUniqueInput
    create: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput>
  }

  export type FollowCreateManyFollowingInputEnvelope = {
    data: FollowCreateManyFollowingInput | FollowCreateManyFollowingInput[]
    skipDuplicates?: boolean
  }

  export type FollowCreateWithoutFollowerInput = {
    id?: string
    createdAt?: Date | string
    following: UserCreateNestedOneWithoutFollowersInput
  }

  export type FollowUncheckedCreateWithoutFollowerInput = {
    id?: string
    followingId: string
    createdAt?: Date | string
  }

  export type FollowCreateOrConnectWithoutFollowerInput = {
    where: FollowWhereUniqueInput
    create: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput>
  }

  export type FollowCreateManyFollowerInputEnvelope = {
    data: FollowCreateManyFollowerInput | FollowCreateManyFollowerInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentDocumentCreateWithoutUploaderInput = {
    id?: string
    filename: string
    type: $Enums.FileType
    data: string
    createdAt?: Date | string
    department: DepartmentCreateNestedOneWithoutDocumentsInput
  }

  export type DepartmentDocumentUncheckedCreateWithoutUploaderInput = {
    id?: string
    deptId: string
    filename: string
    type: $Enums.FileType
    data: string
    createdAt?: Date | string
  }

  export type DepartmentDocumentCreateOrConnectWithoutUploaderInput = {
    where: DepartmentDocumentWhereUniqueInput
    create: XOR<DepartmentDocumentCreateWithoutUploaderInput, DepartmentDocumentUncheckedCreateWithoutUploaderInput>
  }

  export type DepartmentDocumentCreateManyUploaderInputEnvelope = {
    data: DepartmentDocumentCreateManyUploaderInput | DepartmentDocumentCreateManyUploaderInput[]
    skipDuplicates?: boolean
  }

  export type GroupNoteCreateWithoutCreatorInput = {
    id?: string
    title: string
    content: string
    textSize?: $Enums.NoteTextSize
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    document: GroupDocumentCreateNestedOneWithoutNotesInput
  }

  export type GroupNoteUncheckedCreateWithoutCreatorInput = {
    id?: string
    documentId: string
    title: string
    content: string
    textSize?: $Enums.NoteTextSize
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupNoteCreateOrConnectWithoutCreatorInput = {
    where: GroupNoteWhereUniqueInput
    create: XOR<GroupNoteCreateWithoutCreatorInput, GroupNoteUncheckedCreateWithoutCreatorInput>
  }

  export type GroupNoteCreateManyCreatorInputEnvelope = {
    data: GroupNoteCreateManyCreatorInput | GroupNoteCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type AnnouncementUpsertWithWhereUniqueWithoutPublisherInput = {
    where: AnnouncementWhereUniqueInput
    update: XOR<AnnouncementUpdateWithoutPublisherInput, AnnouncementUncheckedUpdateWithoutPublisherInput>
    create: XOR<AnnouncementCreateWithoutPublisherInput, AnnouncementUncheckedCreateWithoutPublisherInput>
  }

  export type AnnouncementUpdateWithWhereUniqueWithoutPublisherInput = {
    where: AnnouncementWhereUniqueInput
    data: XOR<AnnouncementUpdateWithoutPublisherInput, AnnouncementUncheckedUpdateWithoutPublisherInput>
  }

  export type AnnouncementUpdateManyWithWhereWithoutPublisherInput = {
    where: AnnouncementScalarWhereInput
    data: XOR<AnnouncementUpdateManyMutationInput, AnnouncementUncheckedUpdateManyWithoutPublisherInput>
  }

  export type AnnouncementScalarWhereInput = {
    AND?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
    OR?: AnnouncementScalarWhereInput[]
    NOT?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
    id?: StringFilter<"Announcement"> | string
    title?: StringFilter<"Announcement"> | string
    content?: StringFilter<"Announcement"> | string
    publisherId?: StringFilter<"Announcement"> | string
    expiresAt?: DateTimeFilter<"Announcement"> | Date | string
    createdAt?: DateTimeFilter<"Announcement"> | Date | string
    isActive?: BoolFilter<"Announcement"> | boolean
  }

  export type DepartmentMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: DepartmentMemberWhereUniqueInput
    update: XOR<DepartmentMemberUpdateWithoutUserInput, DepartmentMemberUncheckedUpdateWithoutUserInput>
    create: XOR<DepartmentMemberCreateWithoutUserInput, DepartmentMemberUncheckedCreateWithoutUserInput>
  }

  export type DepartmentMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: DepartmentMemberWhereUniqueInput
    data: XOR<DepartmentMemberUpdateWithoutUserInput, DepartmentMemberUncheckedUpdateWithoutUserInput>
  }

  export type DepartmentMemberUpdateManyWithWhereWithoutUserInput = {
    where: DepartmentMemberScalarWhereInput
    data: XOR<DepartmentMemberUpdateManyMutationInput, DepartmentMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type DepartmentMemberScalarWhereInput = {
    AND?: DepartmentMemberScalarWhereInput | DepartmentMemberScalarWhereInput[]
    OR?: DepartmentMemberScalarWhereInput[]
    NOT?: DepartmentMemberScalarWhereInput | DepartmentMemberScalarWhereInput[]
    id?: StringFilter<"DepartmentMember"> | string
    deptId?: StringFilter<"DepartmentMember"> | string
    userId?: StringFilter<"DepartmentMember"> | string
    encryptedDeptKey?: StringFilter<"DepartmentMember"> | string
  }

  export type GroupMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: GroupMemberWhereUniqueInput
    update: XOR<GroupMemberUpdateWithoutUserInput, GroupMemberUncheckedUpdateWithoutUserInput>
    create: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput>
  }

  export type GroupMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: GroupMemberWhereUniqueInput
    data: XOR<GroupMemberUpdateWithoutUserInput, GroupMemberUncheckedUpdateWithoutUserInput>
  }

  export type GroupMemberUpdateManyWithWhereWithoutUserInput = {
    where: GroupMemberScalarWhereInput
    data: XOR<GroupMemberUpdateManyMutationInput, GroupMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type GroupMemberScalarWhereInput = {
    AND?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
    OR?: GroupMemberScalarWhereInput[]
    NOT?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
    id?: StringFilter<"GroupMember"> | string
    groupId?: StringFilter<"GroupMember"> | string
    userId?: StringFilter<"GroupMember"> | string
    joinedAt?: DateTimeFilter<"GroupMember"> | Date | string
    lastReadAt?: DateTimeFilter<"GroupMember"> | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    groupId?: StringFilter<"Message"> | string
    isEdited?: BoolFilter<"Message"> | boolean
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    content?: StringFilter<"Notification"> | string
    userId?: StringNullableFilter<"Notification"> | string | null
    expiresAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    isRead?: BoolFilter<"Notification"> | boolean
  }

  export type OrganizationMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: OrganizationMemberWhereUniqueInput
    update: XOR<OrganizationMemberUpdateWithoutUserInput, OrganizationMemberUncheckedUpdateWithoutUserInput>
    create: XOR<OrganizationMemberCreateWithoutUserInput, OrganizationMemberUncheckedCreateWithoutUserInput>
  }

  export type OrganizationMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: OrganizationMemberWhereUniqueInput
    data: XOR<OrganizationMemberUpdateWithoutUserInput, OrganizationMemberUncheckedUpdateWithoutUserInput>
  }

  export type OrganizationMemberUpdateManyWithWhereWithoutUserInput = {
    where: OrganizationMemberScalarWhereInput
    data: XOR<OrganizationMemberUpdateManyMutationInput, OrganizationMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type OrganizationMemberScalarWhereInput = {
    AND?: OrganizationMemberScalarWhereInput | OrganizationMemberScalarWhereInput[]
    OR?: OrganizationMemberScalarWhereInput[]
    NOT?: OrganizationMemberScalarWhereInput | OrganizationMemberScalarWhereInput[]
    id?: StringFilter<"OrganizationMember"> | string
    userId?: StringFilter<"OrganizationMember"> | string
    orgId?: StringFilter<"OrganizationMember"> | string
    role?: EnumOrgRoleFilter<"OrganizationMember"> | $Enums.OrgRole
    joinedAt?: DateTimeFilter<"OrganizationMember"> | Date | string
  }

  export type UserPageUpsertWithoutUserInput = {
    update: XOR<UserPageUpdateWithoutUserInput, UserPageUncheckedUpdateWithoutUserInput>
    create: XOR<UserPageCreateWithoutUserInput, UserPageUncheckedCreateWithoutUserInput>
    where?: UserPageWhereInput
  }

  export type UserPageUpdateToOneWithWhereWithoutUserInput = {
    where?: UserPageWhereInput
    data: XOR<UserPageUpdateWithoutUserInput, UserPageUncheckedUpdateWithoutUserInput>
  }

  export type UserPageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    handle?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostUpdateManyWithoutPageNestedInput
  }

  export type UserPageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    handle?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostUncheckedUpdateManyWithoutPageNestedInput
  }

  export type LikeUpsertWithWhereUniqueWithoutUserInput = {
    where: LikeWhereUniqueInput
    update: XOR<LikeUpdateWithoutUserInput, LikeUncheckedUpdateWithoutUserInput>
    create: XOR<LikeCreateWithoutUserInput, LikeUncheckedCreateWithoutUserInput>
  }

  export type LikeUpdateWithWhereUniqueWithoutUserInput = {
    where: LikeWhereUniqueInput
    data: XOR<LikeUpdateWithoutUserInput, LikeUncheckedUpdateWithoutUserInput>
  }

  export type LikeUpdateManyWithWhereWithoutUserInput = {
    where: LikeScalarWhereInput
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyWithoutUserInput>
  }

  export type LikeScalarWhereInput = {
    AND?: LikeScalarWhereInput | LikeScalarWhereInput[]
    OR?: LikeScalarWhereInput[]
    NOT?: LikeScalarWhereInput | LikeScalarWhereInput[]
    id?: StringFilter<"Like"> | string
    postId?: StringFilter<"Like"> | string
    userId?: StringFilter<"Like"> | string
    createdAt?: DateTimeFilter<"Like"> | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
  }

  export type CommentUpdateManyWithWhereWithoutUserInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutUserInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    postId?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    parentId?: StringNullableFilter<"Comment"> | string | null
  }

  export type PostReadUpsertWithWhereUniqueWithoutUserInput = {
    where: PostReadWhereUniqueInput
    update: XOR<PostReadUpdateWithoutUserInput, PostReadUncheckedUpdateWithoutUserInput>
    create: XOR<PostReadCreateWithoutUserInput, PostReadUncheckedCreateWithoutUserInput>
  }

  export type PostReadUpdateWithWhereUniqueWithoutUserInput = {
    where: PostReadWhereUniqueInput
    data: XOR<PostReadUpdateWithoutUserInput, PostReadUncheckedUpdateWithoutUserInput>
  }

  export type PostReadUpdateManyWithWhereWithoutUserInput = {
    where: PostReadScalarWhereInput
    data: XOR<PostReadUpdateManyMutationInput, PostReadUncheckedUpdateManyWithoutUserInput>
  }

  export type PostReadScalarWhereInput = {
    AND?: PostReadScalarWhereInput | PostReadScalarWhereInput[]
    OR?: PostReadScalarWhereInput[]
    NOT?: PostReadScalarWhereInput | PostReadScalarWhereInput[]
    id?: StringFilter<"PostRead"> | string
    userId?: StringFilter<"PostRead"> | string
    postId?: StringFilter<"PostRead"> | string
    readAt?: DateTimeFilter<"PostRead"> | Date | string
  }

  export type TaskUpsertWithWhereUniqueWithoutAssigneeInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutAssigneeInput, TaskUncheckedUpdateWithoutAssigneeInput>
    create: XOR<TaskCreateWithoutAssigneeInput, TaskUncheckedCreateWithoutAssigneeInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutAssigneeInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutAssigneeInput, TaskUncheckedUpdateWithoutAssigneeInput>
  }

  export type TaskUpdateManyWithWhereWithoutAssigneeInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutAssigneeInput>
  }

  export type TaskScalarWhereInput = {
    AND?: TaskScalarWhereInput | TaskScalarWhereInput[]
    OR?: TaskScalarWhereInput[]
    NOT?: TaskScalarWhereInput | TaskScalarWhereInput[]
    id?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    status?: EnumTaskStatusFilter<"Task"> | $Enums.TaskStatus
    priority?: EnumTaskPriorityFilter<"Task"> | $Enums.TaskPriority
    startDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    deptId?: StringFilter<"Task"> | string
    creatorId?: StringFilter<"Task"> | string
    assigneeId?: StringFilter<"Task"> | string
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
  }

  export type TaskUpsertWithWhereUniqueWithoutCreatorInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutCreatorInput, TaskUncheckedUpdateWithoutCreatorInput>
    create: XOR<TaskCreateWithoutCreatorInput, TaskUncheckedCreateWithoutCreatorInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutCreatorInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutCreatorInput, TaskUncheckedUpdateWithoutCreatorInput>
  }

  export type TaskUpdateManyWithWhereWithoutCreatorInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutCreatorInput>
  }

  export type DepartmentUpsertWithWhereUniqueWithoutHeadInput = {
    where: DepartmentWhereUniqueInput
    update: XOR<DepartmentUpdateWithoutHeadInput, DepartmentUncheckedUpdateWithoutHeadInput>
    create: XOR<DepartmentCreateWithoutHeadInput, DepartmentUncheckedCreateWithoutHeadInput>
  }

  export type DepartmentUpdateWithWhereUniqueWithoutHeadInput = {
    where: DepartmentWhereUniqueInput
    data: XOR<DepartmentUpdateWithoutHeadInput, DepartmentUncheckedUpdateWithoutHeadInput>
  }

  export type DepartmentUpdateManyWithWhereWithoutHeadInput = {
    where: DepartmentScalarWhereInput
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyWithoutHeadInput>
  }

  export type DepartmentScalarWhereInput = {
    AND?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    OR?: DepartmentScalarWhereInput[]
    NOT?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    id?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    orgId?: StringFilter<"Department"> | string
    publicKey?: StringFilter<"Department"> | string
    headId?: StringNullableFilter<"Department"> | string | null
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
  }

  export type TaskMessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: TaskMessageWhereUniqueInput
    update: XOR<TaskMessageUpdateWithoutSenderInput, TaskMessageUncheckedUpdateWithoutSenderInput>
    create: XOR<TaskMessageCreateWithoutSenderInput, TaskMessageUncheckedCreateWithoutSenderInput>
  }

  export type TaskMessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: TaskMessageWhereUniqueInput
    data: XOR<TaskMessageUpdateWithoutSenderInput, TaskMessageUncheckedUpdateWithoutSenderInput>
  }

  export type TaskMessageUpdateManyWithWhereWithoutSenderInput = {
    where: TaskMessageScalarWhereInput
    data: XOR<TaskMessageUpdateManyMutationInput, TaskMessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type TaskMessageScalarWhereInput = {
    AND?: TaskMessageScalarWhereInput | TaskMessageScalarWhereInput[]
    OR?: TaskMessageScalarWhereInput[]
    NOT?: TaskMessageScalarWhereInput | TaskMessageScalarWhereInput[]
    id?: StringFilter<"TaskMessage"> | string
    taskId?: StringFilter<"TaskMessage"> | string
    senderId?: StringFilter<"TaskMessage"> | string
    content?: StringFilter<"TaskMessage"> | string
    createdAt?: DateTimeFilter<"TaskMessage"> | Date | string
    updatedAt?: DateTimeFilter<"TaskMessage"> | Date | string
  }

  export type DepartmentMonthlyReportUpsertWithWhereUniqueWithoutUserInput = {
    where: DepartmentMonthlyReportWhereUniqueInput
    update: XOR<DepartmentMonthlyReportUpdateWithoutUserInput, DepartmentMonthlyReportUncheckedUpdateWithoutUserInput>
    create: XOR<DepartmentMonthlyReportCreateWithoutUserInput, DepartmentMonthlyReportUncheckedCreateWithoutUserInput>
  }

  export type DepartmentMonthlyReportUpdateWithWhereUniqueWithoutUserInput = {
    where: DepartmentMonthlyReportWhereUniqueInput
    data: XOR<DepartmentMonthlyReportUpdateWithoutUserInput, DepartmentMonthlyReportUncheckedUpdateWithoutUserInput>
  }

  export type DepartmentMonthlyReportUpdateManyWithWhereWithoutUserInput = {
    where: DepartmentMonthlyReportScalarWhereInput
    data: XOR<DepartmentMonthlyReportUpdateManyMutationInput, DepartmentMonthlyReportUncheckedUpdateManyWithoutUserInput>
  }

  export type DepartmentMonthlyReportScalarWhereInput = {
    AND?: DepartmentMonthlyReportScalarWhereInput | DepartmentMonthlyReportScalarWhereInput[]
    OR?: DepartmentMonthlyReportScalarWhereInput[]
    NOT?: DepartmentMonthlyReportScalarWhereInput | DepartmentMonthlyReportScalarWhereInput[]
    id?: StringFilter<"DepartmentMonthlyReport"> | string
    deptId?: StringFilter<"DepartmentMonthlyReport"> | string
    userId?: StringFilter<"DepartmentMonthlyReport"> | string
    month?: StringFilter<"DepartmentMonthlyReport"> | string
    content?: StringFilter<"DepartmentMonthlyReport"> | string
    createdAt?: DateTimeFilter<"DepartmentMonthlyReport"> | Date | string
    updatedAt?: DateTimeFilter<"DepartmentMonthlyReport"> | Date | string
  }

  export type DepartmentMeetingUpsertWithWhereUniqueWithoutCreatorInput = {
    where: DepartmentMeetingWhereUniqueInput
    update: XOR<DepartmentMeetingUpdateWithoutCreatorInput, DepartmentMeetingUncheckedUpdateWithoutCreatorInput>
    create: XOR<DepartmentMeetingCreateWithoutCreatorInput, DepartmentMeetingUncheckedCreateWithoutCreatorInput>
  }

  export type DepartmentMeetingUpdateWithWhereUniqueWithoutCreatorInput = {
    where: DepartmentMeetingWhereUniqueInput
    data: XOR<DepartmentMeetingUpdateWithoutCreatorInput, DepartmentMeetingUncheckedUpdateWithoutCreatorInput>
  }

  export type DepartmentMeetingUpdateManyWithWhereWithoutCreatorInput = {
    where: DepartmentMeetingScalarWhereInput
    data: XOR<DepartmentMeetingUpdateManyMutationInput, DepartmentMeetingUncheckedUpdateManyWithoutCreatorInput>
  }

  export type DepartmentMeetingScalarWhereInput = {
    AND?: DepartmentMeetingScalarWhereInput | DepartmentMeetingScalarWhereInput[]
    OR?: DepartmentMeetingScalarWhereInput[]
    NOT?: DepartmentMeetingScalarWhereInput | DepartmentMeetingScalarWhereInput[]
    id?: StringFilter<"DepartmentMeeting"> | string
    deptId?: StringFilter<"DepartmentMeeting"> | string
    title?: StringFilter<"DepartmentMeeting"> | string
    description?: StringNullableFilter<"DepartmentMeeting"> | string | null
    agenda?: StringNullableFilter<"DepartmentMeeting"> | string | null
    meetingDate?: DateTimeFilter<"DepartmentMeeting"> | Date | string
    location?: StringNullableFilter<"DepartmentMeeting"> | string | null
    createdBy?: StringFilter<"DepartmentMeeting"> | string
    minutes?: StringNullableFilter<"DepartmentMeeting"> | string | null
    minutesAt?: DateTimeNullableFilter<"DepartmentMeeting"> | Date | string | null
    createdAt?: DateTimeFilter<"DepartmentMeeting"> | Date | string
    updatedAt?: DateTimeFilter<"DepartmentMeeting"> | Date | string
  }

  export type DepartmentPollUpsertWithWhereUniqueWithoutCreatorInput = {
    where: DepartmentPollWhereUniqueInput
    update: XOR<DepartmentPollUpdateWithoutCreatorInput, DepartmentPollUncheckedUpdateWithoutCreatorInput>
    create: XOR<DepartmentPollCreateWithoutCreatorInput, DepartmentPollUncheckedCreateWithoutCreatorInput>
  }

  export type DepartmentPollUpdateWithWhereUniqueWithoutCreatorInput = {
    where: DepartmentPollWhereUniqueInput
    data: XOR<DepartmentPollUpdateWithoutCreatorInput, DepartmentPollUncheckedUpdateWithoutCreatorInput>
  }

  export type DepartmentPollUpdateManyWithWhereWithoutCreatorInput = {
    where: DepartmentPollScalarWhereInput
    data: XOR<DepartmentPollUpdateManyMutationInput, DepartmentPollUncheckedUpdateManyWithoutCreatorInput>
  }

  export type DepartmentPollScalarWhereInput = {
    AND?: DepartmentPollScalarWhereInput | DepartmentPollScalarWhereInput[]
    OR?: DepartmentPollScalarWhereInput[]
    NOT?: DepartmentPollScalarWhereInput | DepartmentPollScalarWhereInput[]
    id?: StringFilter<"DepartmentPoll"> | string
    deptId?: StringFilter<"DepartmentPoll"> | string
    question?: StringFilter<"DepartmentPoll"> | string
    options?: JsonFilter<"DepartmentPoll">
    endDate?: DateTimeNullableFilter<"DepartmentPoll"> | Date | string | null
    createdBy?: StringFilter<"DepartmentPoll"> | string
    createdAt?: DateTimeFilter<"DepartmentPoll"> | Date | string
    updatedAt?: DateTimeFilter<"DepartmentPoll"> | Date | string
  }

  export type TeamDecisionUpsertWithWhereUniqueWithoutCreatorInput = {
    where: TeamDecisionWhereUniqueInput
    update: XOR<TeamDecisionUpdateWithoutCreatorInput, TeamDecisionUncheckedUpdateWithoutCreatorInput>
    create: XOR<TeamDecisionCreateWithoutCreatorInput, TeamDecisionUncheckedCreateWithoutCreatorInput>
  }

  export type TeamDecisionUpdateWithWhereUniqueWithoutCreatorInput = {
    where: TeamDecisionWhereUniqueInput
    data: XOR<TeamDecisionUpdateWithoutCreatorInput, TeamDecisionUncheckedUpdateWithoutCreatorInput>
  }

  export type TeamDecisionUpdateManyWithWhereWithoutCreatorInput = {
    where: TeamDecisionScalarWhereInput
    data: XOR<TeamDecisionUpdateManyMutationInput, TeamDecisionUncheckedUpdateManyWithoutCreatorInput>
  }

  export type TeamDecisionScalarWhereInput = {
    AND?: TeamDecisionScalarWhereInput | TeamDecisionScalarWhereInput[]
    OR?: TeamDecisionScalarWhereInput[]
    NOT?: TeamDecisionScalarWhereInput | TeamDecisionScalarWhereInput[]
    id?: StringFilter<"TeamDecision"> | string
    deptId?: StringFilter<"TeamDecision"> | string
    title?: StringFilter<"TeamDecision"> | string
    description?: StringNullableFilter<"TeamDecision"> | string | null
    voteDeadline?: DateTimeNullableFilter<"TeamDecision"> | Date | string | null
    status?: StringFilter<"TeamDecision"> | string
    createdBy?: StringFilter<"TeamDecision"> | string
    createdAt?: DateTimeFilter<"TeamDecision"> | Date | string
    updatedAt?: DateTimeFilter<"TeamDecision"> | Date | string
  }

  export type PollVoteUpsertWithWhereUniqueWithoutUserInput = {
    where: PollVoteWhereUniqueInput
    update: XOR<PollVoteUpdateWithoutUserInput, PollVoteUncheckedUpdateWithoutUserInput>
    create: XOR<PollVoteCreateWithoutUserInput, PollVoteUncheckedCreateWithoutUserInput>
  }

  export type PollVoteUpdateWithWhereUniqueWithoutUserInput = {
    where: PollVoteWhereUniqueInput
    data: XOR<PollVoteUpdateWithoutUserInput, PollVoteUncheckedUpdateWithoutUserInput>
  }

  export type PollVoteUpdateManyWithWhereWithoutUserInput = {
    where: PollVoteScalarWhereInput
    data: XOR<PollVoteUpdateManyMutationInput, PollVoteUncheckedUpdateManyWithoutUserInput>
  }

  export type PollVoteScalarWhereInput = {
    AND?: PollVoteScalarWhereInput | PollVoteScalarWhereInput[]
    OR?: PollVoteScalarWhereInput[]
    NOT?: PollVoteScalarWhereInput | PollVoteScalarWhereInput[]
    id?: StringFilter<"PollVote"> | string
    pollId?: StringFilter<"PollVote"> | string
    userId?: StringFilter<"PollVote"> | string
    optionIndex?: IntFilter<"PollVote"> | number
    createdAt?: DateTimeFilter<"PollVote"> | Date | string
  }

  export type DecisionVoteUpsertWithWhereUniqueWithoutUserInput = {
    where: DecisionVoteWhereUniqueInput
    update: XOR<DecisionVoteUpdateWithoutUserInput, DecisionVoteUncheckedUpdateWithoutUserInput>
    create: XOR<DecisionVoteCreateWithoutUserInput, DecisionVoteUncheckedCreateWithoutUserInput>
  }

  export type DecisionVoteUpdateWithWhereUniqueWithoutUserInput = {
    where: DecisionVoteWhereUniqueInput
    data: XOR<DecisionVoteUpdateWithoutUserInput, DecisionVoteUncheckedUpdateWithoutUserInput>
  }

  export type DecisionVoteUpdateManyWithWhereWithoutUserInput = {
    where: DecisionVoteScalarWhereInput
    data: XOR<DecisionVoteUpdateManyMutationInput, DecisionVoteUncheckedUpdateManyWithoutUserInput>
  }

  export type DecisionVoteScalarWhereInput = {
    AND?: DecisionVoteScalarWhereInput | DecisionVoteScalarWhereInput[]
    OR?: DecisionVoteScalarWhereInput[]
    NOT?: DecisionVoteScalarWhereInput | DecisionVoteScalarWhereInput[]
    id?: StringFilter<"DecisionVote"> | string
    decisionId?: StringFilter<"DecisionVote"> | string
    userId?: StringFilter<"DecisionVote"> | string
    vote?: EnumDecisionVoteTypeFilter<"DecisionVote"> | $Enums.DecisionVoteType
    createdAt?: DateTimeFilter<"DecisionVote"> | Date | string
  }

  export type PushSubscriptionUpsertWithWhereUniqueWithoutUserInput = {
    where: PushSubscriptionWhereUniqueInput
    update: XOR<PushSubscriptionUpdateWithoutUserInput, PushSubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput>
  }

  export type PushSubscriptionUpdateWithWhereUniqueWithoutUserInput = {
    where: PushSubscriptionWhereUniqueInput
    data: XOR<PushSubscriptionUpdateWithoutUserInput, PushSubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type PushSubscriptionUpdateManyWithWhereWithoutUserInput = {
    where: PushSubscriptionScalarWhereInput
    data: XOR<PushSubscriptionUpdateManyMutationInput, PushSubscriptionUncheckedUpdateManyWithoutUserInput>
  }

  export type PushSubscriptionScalarWhereInput = {
    AND?: PushSubscriptionScalarWhereInput | PushSubscriptionScalarWhereInput[]
    OR?: PushSubscriptionScalarWhereInput[]
    NOT?: PushSubscriptionScalarWhereInput | PushSubscriptionScalarWhereInput[]
    id?: StringFilter<"PushSubscription"> | string
    userId?: StringFilter<"PushSubscription"> | string
    endpoint?: StringFilter<"PushSubscription"> | string
    p256dh?: StringFilter<"PushSubscription"> | string
    auth?: StringFilter<"PushSubscription"> | string
    createdAt?: DateTimeFilter<"PushSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"PushSubscription"> | Date | string
  }

  export type UserInvitationUpsertWithWhereUniqueWithoutUserInput = {
    where: UserInvitationWhereUniqueInput
    update: XOR<UserInvitationUpdateWithoutUserInput, UserInvitationUncheckedUpdateWithoutUserInput>
    create: XOR<UserInvitationCreateWithoutUserInput, UserInvitationUncheckedCreateWithoutUserInput>
  }

  export type UserInvitationUpdateWithWhereUniqueWithoutUserInput = {
    where: UserInvitationWhereUniqueInput
    data: XOR<UserInvitationUpdateWithoutUserInput, UserInvitationUncheckedUpdateWithoutUserInput>
  }

  export type UserInvitationUpdateManyWithWhereWithoutUserInput = {
    where: UserInvitationScalarWhereInput
    data: XOR<UserInvitationUpdateManyMutationInput, UserInvitationUncheckedUpdateManyWithoutUserInput>
  }

  export type UserInvitationScalarWhereInput = {
    AND?: UserInvitationScalarWhereInput | UserInvitationScalarWhereInput[]
    OR?: UserInvitationScalarWhereInput[]
    NOT?: UserInvitationScalarWhereInput | UserInvitationScalarWhereInput[]
    id?: StringFilter<"UserInvitation"> | string
    userId?: StringFilter<"UserInvitation"> | string
    token?: StringFilter<"UserInvitation"> | string
    status?: EnumInvitationStatusFilter<"UserInvitation"> | $Enums.InvitationStatus
    title?: StringFilter<"UserInvitation"> | string
    description?: StringNullableFilter<"UserInvitation"> | string | null
    imageBase64?: StringNullableFilter<"UserInvitation"> | string | null
    type?: EnumInvitationTypeFilter<"UserInvitation"> | $Enums.InvitationType
    date?: DateTimeFilter<"UserInvitation"> | Date | string
    location?: StringFilter<"UserInvitation"> | string
    maxGuests?: IntNullableFilter<"UserInvitation"> | number | null
    createdAt?: DateTimeFilter<"UserInvitation"> | Date | string
    updatedAt?: DateTimeFilter<"UserInvitation"> | Date | string
  }

  export type UserPersonalTaskUpsertWithWhereUniqueWithoutUserInput = {
    where: UserPersonalTaskWhereUniqueInput
    update: XOR<UserPersonalTaskUpdateWithoutUserInput, UserPersonalTaskUncheckedUpdateWithoutUserInput>
    create: XOR<UserPersonalTaskCreateWithoutUserInput, UserPersonalTaskUncheckedCreateWithoutUserInput>
  }

  export type UserPersonalTaskUpdateWithWhereUniqueWithoutUserInput = {
    where: UserPersonalTaskWhereUniqueInput
    data: XOR<UserPersonalTaskUpdateWithoutUserInput, UserPersonalTaskUncheckedUpdateWithoutUserInput>
  }

  export type UserPersonalTaskUpdateManyWithWhereWithoutUserInput = {
    where: UserPersonalTaskScalarWhereInput
    data: XOR<UserPersonalTaskUpdateManyMutationInput, UserPersonalTaskUncheckedUpdateManyWithoutUserInput>
  }

  export type UserPersonalTaskScalarWhereInput = {
    AND?: UserPersonalTaskScalarWhereInput | UserPersonalTaskScalarWhereInput[]
    OR?: UserPersonalTaskScalarWhereInput[]
    NOT?: UserPersonalTaskScalarWhereInput | UserPersonalTaskScalarWhereInput[]
    id?: StringFilter<"UserPersonalTask"> | string
    userId?: StringFilter<"UserPersonalTask"> | string
    title?: StringFilter<"UserPersonalTask"> | string
    description?: StringNullableFilter<"UserPersonalTask"> | string | null
    status?: EnumPersonalTaskStatusFilter<"UserPersonalTask"> | $Enums.PersonalTaskStatus
    priority?: EnumPersonalTaskPriorityFilter<"UserPersonalTask"> | $Enums.PersonalTaskPriority
    dueDate?: DateTimeNullableFilter<"UserPersonalTask"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"UserPersonalTask"> | Date | string | null
    createdAt?: DateTimeFilter<"UserPersonalTask"> | Date | string
    updatedAt?: DateTimeFilter<"UserPersonalTask"> | Date | string
  }

  export type UserFinancialGoalUpsertWithWhereUniqueWithoutUserInput = {
    where: UserFinancialGoalWhereUniqueInput
    update: XOR<UserFinancialGoalUpdateWithoutUserInput, UserFinancialGoalUncheckedUpdateWithoutUserInput>
    create: XOR<UserFinancialGoalCreateWithoutUserInput, UserFinancialGoalUncheckedCreateWithoutUserInput>
  }

  export type UserFinancialGoalUpdateWithWhereUniqueWithoutUserInput = {
    where: UserFinancialGoalWhereUniqueInput
    data: XOR<UserFinancialGoalUpdateWithoutUserInput, UserFinancialGoalUncheckedUpdateWithoutUserInput>
  }

  export type UserFinancialGoalUpdateManyWithWhereWithoutUserInput = {
    where: UserFinancialGoalScalarWhereInput
    data: XOR<UserFinancialGoalUpdateManyMutationInput, UserFinancialGoalUncheckedUpdateManyWithoutUserInput>
  }

  export type UserFinancialGoalScalarWhereInput = {
    AND?: UserFinancialGoalScalarWhereInput | UserFinancialGoalScalarWhereInput[]
    OR?: UserFinancialGoalScalarWhereInput[]
    NOT?: UserFinancialGoalScalarWhereInput | UserFinancialGoalScalarWhereInput[]
    id?: StringFilter<"UserFinancialGoal"> | string
    userId?: StringFilter<"UserFinancialGoal"> | string
    type?: EnumFinancialGoalTypeFilter<"UserFinancialGoal"> | $Enums.FinancialGoalType
    year?: IntNullableFilter<"UserFinancialGoal"> | number | null
    targetItem?: StringNullableFilter<"UserFinancialGoal"> | string | null
    targetAmount?: FloatFilter<"UserFinancialGoal"> | number
    targetDate?: DateTimeNullableFilter<"UserFinancialGoal"> | Date | string | null
    label?: StringNullableFilter<"UserFinancialGoal"> | string | null
    createdAt?: DateTimeFilter<"UserFinancialGoal"> | Date | string
    updatedAt?: DateTimeFilter<"UserFinancialGoal"> | Date | string
  }

  export type UserFinancialProfileUpsertWithoutUserInput = {
    update: XOR<UserFinancialProfileUpdateWithoutUserInput, UserFinancialProfileUncheckedUpdateWithoutUserInput>
    create: XOR<UserFinancialProfileCreateWithoutUserInput, UserFinancialProfileUncheckedCreateWithoutUserInput>
    where?: UserFinancialProfileWhereInput
  }

  export type UserFinancialProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: UserFinancialProfileWhereInput
    data: XOR<UserFinancialProfileUpdateWithoutUserInput, UserFinancialProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserFinancialProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    monthlySalary?: FloatFieldUpdateOperationsInput | number
    supplementaryIncome?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    preferredSavingsRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFinancialProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    monthlySalary?: FloatFieldUpdateOperationsInput | number
    supplementaryIncome?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    preferredSavingsRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserMonthlyStatementUpsertWithWhereUniqueWithoutUserInput = {
    where: UserMonthlyStatementWhereUniqueInput
    update: XOR<UserMonthlyStatementUpdateWithoutUserInput, UserMonthlyStatementUncheckedUpdateWithoutUserInput>
    create: XOR<UserMonthlyStatementCreateWithoutUserInput, UserMonthlyStatementUncheckedCreateWithoutUserInput>
  }

  export type UserMonthlyStatementUpdateWithWhereUniqueWithoutUserInput = {
    where: UserMonthlyStatementWhereUniqueInput
    data: XOR<UserMonthlyStatementUpdateWithoutUserInput, UserMonthlyStatementUncheckedUpdateWithoutUserInput>
  }

  export type UserMonthlyStatementUpdateManyWithWhereWithoutUserInput = {
    where: UserMonthlyStatementScalarWhereInput
    data: XOR<UserMonthlyStatementUpdateManyMutationInput, UserMonthlyStatementUncheckedUpdateManyWithoutUserInput>
  }

  export type UserMonthlyStatementScalarWhereInput = {
    AND?: UserMonthlyStatementScalarWhereInput | UserMonthlyStatementScalarWhereInput[]
    OR?: UserMonthlyStatementScalarWhereInput[]
    NOT?: UserMonthlyStatementScalarWhereInput | UserMonthlyStatementScalarWhereInput[]
    id?: StringFilter<"UserMonthlyStatement"> | string
    userId?: StringFilter<"UserMonthlyStatement"> | string
    year?: IntFilter<"UserMonthlyStatement"> | number
    month?: IntFilter<"UserMonthlyStatement"> | number
    salaryReceived?: FloatFilter<"UserMonthlyStatement"> | number
    supplementaryIncome?: FloatFilter<"UserMonthlyStatement"> | number
    totalExpenses?: FloatFilter<"UserMonthlyStatement"> | number
    notes?: StringNullableFilter<"UserMonthlyStatement"> | string | null
    createdAt?: DateTimeFilter<"UserMonthlyStatement"> | Date | string
    updatedAt?: DateTimeFilter<"UserMonthlyStatement"> | Date | string
  }

  export type UserFinancialEntryUpsertWithWhereUniqueWithoutUserInput = {
    where: UserFinancialEntryWhereUniqueInput
    update: XOR<UserFinancialEntryUpdateWithoutUserInput, UserFinancialEntryUncheckedUpdateWithoutUserInput>
    create: XOR<UserFinancialEntryCreateWithoutUserInput, UserFinancialEntryUncheckedCreateWithoutUserInput>
  }

  export type UserFinancialEntryUpdateWithWhereUniqueWithoutUserInput = {
    where: UserFinancialEntryWhereUniqueInput
    data: XOR<UserFinancialEntryUpdateWithoutUserInput, UserFinancialEntryUncheckedUpdateWithoutUserInput>
  }

  export type UserFinancialEntryUpdateManyWithWhereWithoutUserInput = {
    where: UserFinancialEntryScalarWhereInput
    data: XOR<UserFinancialEntryUpdateManyMutationInput, UserFinancialEntryUncheckedUpdateManyWithoutUserInput>
  }

  export type UserFinancialEntryScalarWhereInput = {
    AND?: UserFinancialEntryScalarWhereInput | UserFinancialEntryScalarWhereInput[]
    OR?: UserFinancialEntryScalarWhereInput[]
    NOT?: UserFinancialEntryScalarWhereInput | UserFinancialEntryScalarWhereInput[]
    id?: StringFilter<"UserFinancialEntry"> | string
    userId?: StringFilter<"UserFinancialEntry"> | string
    year?: IntFilter<"UserFinancialEntry"> | number
    month?: IntFilter<"UserFinancialEntry"> | number
    type?: EnumFinancialEntryTypeFilter<"UserFinancialEntry"> | $Enums.FinancialEntryType
    amount?: FloatFilter<"UserFinancialEntry"> | number
    note?: StringNullableFilter<"UserFinancialEntry"> | string | null
    isConfirmed?: BoolFilter<"UserFinancialEntry"> | boolean
    createdAt?: DateTimeFilter<"UserFinancialEntry"> | Date | string
    updatedAt?: DateTimeFilter<"UserFinancialEntry"> | Date | string
  }

  export type FollowUpsertWithWhereUniqueWithoutFollowingInput = {
    where: FollowWhereUniqueInput
    update: XOR<FollowUpdateWithoutFollowingInput, FollowUncheckedUpdateWithoutFollowingInput>
    create: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput>
  }

  export type FollowUpdateWithWhereUniqueWithoutFollowingInput = {
    where: FollowWhereUniqueInput
    data: XOR<FollowUpdateWithoutFollowingInput, FollowUncheckedUpdateWithoutFollowingInput>
  }

  export type FollowUpdateManyWithWhereWithoutFollowingInput = {
    where: FollowScalarWhereInput
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyWithoutFollowingInput>
  }

  export type FollowScalarWhereInput = {
    AND?: FollowScalarWhereInput | FollowScalarWhereInput[]
    OR?: FollowScalarWhereInput[]
    NOT?: FollowScalarWhereInput | FollowScalarWhereInput[]
    id?: StringFilter<"Follow"> | string
    followerId?: StringFilter<"Follow"> | string
    followingId?: StringFilter<"Follow"> | string
    createdAt?: DateTimeFilter<"Follow"> | Date | string
  }

  export type FollowUpsertWithWhereUniqueWithoutFollowerInput = {
    where: FollowWhereUniqueInput
    update: XOR<FollowUpdateWithoutFollowerInput, FollowUncheckedUpdateWithoutFollowerInput>
    create: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput>
  }

  export type FollowUpdateWithWhereUniqueWithoutFollowerInput = {
    where: FollowWhereUniqueInput
    data: XOR<FollowUpdateWithoutFollowerInput, FollowUncheckedUpdateWithoutFollowerInput>
  }

  export type FollowUpdateManyWithWhereWithoutFollowerInput = {
    where: FollowScalarWhereInput
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyWithoutFollowerInput>
  }

  export type DepartmentDocumentUpsertWithWhereUniqueWithoutUploaderInput = {
    where: DepartmentDocumentWhereUniqueInput
    update: XOR<DepartmentDocumentUpdateWithoutUploaderInput, DepartmentDocumentUncheckedUpdateWithoutUploaderInput>
    create: XOR<DepartmentDocumentCreateWithoutUploaderInput, DepartmentDocumentUncheckedCreateWithoutUploaderInput>
  }

  export type DepartmentDocumentUpdateWithWhereUniqueWithoutUploaderInput = {
    where: DepartmentDocumentWhereUniqueInput
    data: XOR<DepartmentDocumentUpdateWithoutUploaderInput, DepartmentDocumentUncheckedUpdateWithoutUploaderInput>
  }

  export type DepartmentDocumentUpdateManyWithWhereWithoutUploaderInput = {
    where: DepartmentDocumentScalarWhereInput
    data: XOR<DepartmentDocumentUpdateManyMutationInput, DepartmentDocumentUncheckedUpdateManyWithoutUploaderInput>
  }

  export type DepartmentDocumentScalarWhereInput = {
    AND?: DepartmentDocumentScalarWhereInput | DepartmentDocumentScalarWhereInput[]
    OR?: DepartmentDocumentScalarWhereInput[]
    NOT?: DepartmentDocumentScalarWhereInput | DepartmentDocumentScalarWhereInput[]
    id?: StringFilter<"DepartmentDocument"> | string
    deptId?: StringFilter<"DepartmentDocument"> | string
    filename?: StringFilter<"DepartmentDocument"> | string
    type?: EnumFileTypeFilter<"DepartmentDocument"> | $Enums.FileType
    data?: StringFilter<"DepartmentDocument"> | string
    uploadedBy?: StringFilter<"DepartmentDocument"> | string
    createdAt?: DateTimeFilter<"DepartmentDocument"> | Date | string
  }

  export type GroupNoteUpsertWithWhereUniqueWithoutCreatorInput = {
    where: GroupNoteWhereUniqueInput
    update: XOR<GroupNoteUpdateWithoutCreatorInput, GroupNoteUncheckedUpdateWithoutCreatorInput>
    create: XOR<GroupNoteCreateWithoutCreatorInput, GroupNoteUncheckedCreateWithoutCreatorInput>
  }

  export type GroupNoteUpdateWithWhereUniqueWithoutCreatorInput = {
    where: GroupNoteWhereUniqueInput
    data: XOR<GroupNoteUpdateWithoutCreatorInput, GroupNoteUncheckedUpdateWithoutCreatorInput>
  }

  export type GroupNoteUpdateManyWithWhereWithoutCreatorInput = {
    where: GroupNoteScalarWhereInput
    data: XOR<GroupNoteUpdateManyMutationInput, GroupNoteUncheckedUpdateManyWithoutCreatorInput>
  }

  export type GroupNoteScalarWhereInput = {
    AND?: GroupNoteScalarWhereInput | GroupNoteScalarWhereInput[]
    OR?: GroupNoteScalarWhereInput[]
    NOT?: GroupNoteScalarWhereInput | GroupNoteScalarWhereInput[]
    id?: StringFilter<"GroupNote"> | string
    documentId?: StringFilter<"GroupNote"> | string
    title?: StringFilter<"GroupNote"> | string
    content?: StringFilter<"GroupNote"> | string
    textSize?: EnumNoteTextSizeFilter<"GroupNote"> | $Enums.NoteTextSize
    order?: IntFilter<"GroupNote"> | number
    createdBy?: StringFilter<"GroupNote"> | string
    createdAt?: DateTimeFilter<"GroupNote"> | Date | string
    updatedAt?: DateTimeFilter<"GroupNote"> | Date | string
  }

  export type UserCreateWithoutInvitationsInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberCreateNestedManyWithoutUserInput
    userPage?: UserPageCreateNestedOneWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    postReads?: PostReadCreateNestedManyWithoutUserInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutInvitationsInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementUncheckedCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberUncheckedCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    userPage?: UserPageUncheckedCreateNestedOneWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    postReads?: PostReadUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageUncheckedCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingUncheckedCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollUncheckedCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionUncheckedCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskUncheckedCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalUncheckedCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileUncheckedCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementUncheckedCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutInvitationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvitationsInput, UserUncheckedCreateWithoutInvitationsInput>
  }

  export type InvitationGuestCreateWithoutInvitationInput = {
    id?: string
    name: string
    phone: string
    confirmedAt?: Date | string
  }

  export type InvitationGuestUncheckedCreateWithoutInvitationInput = {
    id?: string
    name: string
    phone: string
    confirmedAt?: Date | string
  }

  export type InvitationGuestCreateOrConnectWithoutInvitationInput = {
    where: InvitationGuestWhereUniqueInput
    create: XOR<InvitationGuestCreateWithoutInvitationInput, InvitationGuestUncheckedCreateWithoutInvitationInput>
  }

  export type InvitationGuestCreateManyInvitationInputEnvelope = {
    data: InvitationGuestCreateManyInvitationInput | InvitationGuestCreateManyInvitationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutInvitationsInput = {
    update: XOR<UserUpdateWithoutInvitationsInput, UserUncheckedUpdateWithoutInvitationsInput>
    create: XOR<UserCreateWithoutInvitationsInput, UserUncheckedCreateWithoutInvitationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvitationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvitationsInput, UserUncheckedUpdateWithoutInvitationsInput>
  }

  export type UserUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUpdateManyWithoutUserNestedInput
    userPage?: UserPageUpdateOneWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    postReads?: PostReadUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUncheckedUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    userPage?: UserPageUncheckedUpdateOneWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    postReads?: PostReadUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUncheckedUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUncheckedUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUncheckedUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUncheckedUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUncheckedUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUncheckedUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUncheckedUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUncheckedUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type InvitationGuestUpsertWithWhereUniqueWithoutInvitationInput = {
    where: InvitationGuestWhereUniqueInput
    update: XOR<InvitationGuestUpdateWithoutInvitationInput, InvitationGuestUncheckedUpdateWithoutInvitationInput>
    create: XOR<InvitationGuestCreateWithoutInvitationInput, InvitationGuestUncheckedCreateWithoutInvitationInput>
  }

  export type InvitationGuestUpdateWithWhereUniqueWithoutInvitationInput = {
    where: InvitationGuestWhereUniqueInput
    data: XOR<InvitationGuestUpdateWithoutInvitationInput, InvitationGuestUncheckedUpdateWithoutInvitationInput>
  }

  export type InvitationGuestUpdateManyWithWhereWithoutInvitationInput = {
    where: InvitationGuestScalarWhereInput
    data: XOR<InvitationGuestUpdateManyMutationInput, InvitationGuestUncheckedUpdateManyWithoutInvitationInput>
  }

  export type InvitationGuestScalarWhereInput = {
    AND?: InvitationGuestScalarWhereInput | InvitationGuestScalarWhereInput[]
    OR?: InvitationGuestScalarWhereInput[]
    NOT?: InvitationGuestScalarWhereInput | InvitationGuestScalarWhereInput[]
    id?: StringFilter<"InvitationGuest"> | string
    invitationId?: StringFilter<"InvitationGuest"> | string
    name?: StringFilter<"InvitationGuest"> | string
    phone?: StringFilter<"InvitationGuest"> | string
    confirmedAt?: DateTimeFilter<"InvitationGuest"> | Date | string
  }

  export type UserInvitationCreateWithoutGuestsInput = {
    id?: string
    token: string
    status?: $Enums.InvitationStatus
    title: string
    description?: string | null
    imageBase64?: string | null
    type?: $Enums.InvitationType
    date: Date | string
    location: string
    maxGuests?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInvitationsInput
  }

  export type UserInvitationUncheckedCreateWithoutGuestsInput = {
    id?: string
    userId: string
    token: string
    status?: $Enums.InvitationStatus
    title: string
    description?: string | null
    imageBase64?: string | null
    type?: $Enums.InvitationType
    date: Date | string
    location: string
    maxGuests?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserInvitationCreateOrConnectWithoutGuestsInput = {
    where: UserInvitationWhereUniqueInput
    create: XOR<UserInvitationCreateWithoutGuestsInput, UserInvitationUncheckedCreateWithoutGuestsInput>
  }

  export type UserInvitationUpsertWithoutGuestsInput = {
    update: XOR<UserInvitationUpdateWithoutGuestsInput, UserInvitationUncheckedUpdateWithoutGuestsInput>
    create: XOR<UserInvitationCreateWithoutGuestsInput, UserInvitationUncheckedCreateWithoutGuestsInput>
    where?: UserInvitationWhereInput
  }

  export type UserInvitationUpdateToOneWithWhereWithoutGuestsInput = {
    where?: UserInvitationWhereInput
    data: XOR<UserInvitationUpdateWithoutGuestsInput, UserInvitationUncheckedUpdateWithoutGuestsInput>
  }

  export type UserInvitationUpdateWithoutGuestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageBase64?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInvitationTypeFieldUpdateOperationsInput | $Enums.InvitationType
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInvitationsNestedInput
  }

  export type UserInvitationUncheckedUpdateWithoutGuestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageBase64?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInvitationTypeFieldUpdateOperationsInput | $Enums.InvitationType
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutFollowingInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberCreateNestedManyWithoutUserInput
    userPage?: UserPageCreateNestedOneWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    postReads?: PostReadCreateNestedManyWithoutUserInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    invitations?: UserInvitationCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    uploadedDepartmentDocuments?: DepartmentDocumentCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutFollowingInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementUncheckedCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberUncheckedCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    userPage?: UserPageUncheckedCreateNestedOneWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    postReads?: PostReadUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageUncheckedCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingUncheckedCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollUncheckedCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionUncheckedCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitations?: UserInvitationUncheckedCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskUncheckedCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalUncheckedCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileUncheckedCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementUncheckedCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutFollowingInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
  }

  export type UserCreateWithoutFollowersInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberCreateNestedManyWithoutUserInput
    userPage?: UserPageCreateNestedOneWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    postReads?: PostReadCreateNestedManyWithoutUserInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    invitations?: UserInvitationCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryCreateNestedManyWithoutUserInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutFollowersInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementUncheckedCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberUncheckedCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    userPage?: UserPageUncheckedCreateNestedOneWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    postReads?: PostReadUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageUncheckedCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingUncheckedCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollUncheckedCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionUncheckedCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitations?: UserInvitationUncheckedCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskUncheckedCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalUncheckedCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileUncheckedCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementUncheckedCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryUncheckedCreateNestedManyWithoutUserInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutFollowersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
  }

  export type UserUpsertWithoutFollowingInput = {
    update: XOR<UserUpdateWithoutFollowingInput, UserUncheckedUpdateWithoutFollowingInput>
    create: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFollowingInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFollowingInput, UserUncheckedUpdateWithoutFollowingInput>
  }

  export type UserUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUpdateManyWithoutUserNestedInput
    userPage?: UserPageUpdateOneWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    postReads?: PostReadUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUncheckedUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    userPage?: UserPageUncheckedUpdateOneWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    postReads?: PostReadUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUncheckedUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUncheckedUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUncheckedUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUncheckedUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUncheckedUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUncheckedUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUncheckedUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUncheckedUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUncheckedUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserUpsertWithoutFollowersInput = {
    update: XOR<UserUpdateWithoutFollowersInput, UserUncheckedUpdateWithoutFollowersInput>
    create: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFollowersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFollowersInput, UserUncheckedUpdateWithoutFollowersInput>
  }

  export type UserUpdateWithoutFollowersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUpdateManyWithoutUserNestedInput
    userPage?: UserPageUpdateOneWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    postReads?: PostReadUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUpdateManyWithoutUserNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutFollowersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUncheckedUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    userPage?: UserPageUncheckedUpdateOneWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    postReads?: PostReadUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUncheckedUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUncheckedUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUncheckedUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUncheckedUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUncheckedUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUncheckedUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUncheckedUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUncheckedUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUncheckedUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUncheckedUpdateManyWithoutUserNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type DepartmentCreateWithoutOrganizationInput = {
    id?: string
    name: string
    publicKey: string
    createdAt?: Date | string
    updatedAt?: Date | string
    head?: UserCreateNestedOneWithoutHeadedDepartmentsInput
    members?: DepartmentMemberCreateNestedManyWithoutDepartmentInput
    conversations?: GroupCreateNestedManyWithoutDepartmentInput
    tasks?: TaskCreateNestedManyWithoutDepartmentInput
    eventBroadcasts?: EventDepartmentBroadcastCreateNestedManyWithoutDepartmentInput
    monthlyReports?: DepartmentMonthlyReportCreateNestedManyWithoutDepartmentInput
    goals?: DepartmentGoalCreateNestedManyWithoutDepartmentInput
    meetings?: DepartmentMeetingCreateNestedManyWithoutDepartmentInput
    polls?: DepartmentPollCreateNestedManyWithoutDepartmentInput
    teamDecisions?: TeamDecisionCreateNestedManyWithoutDepartmentInput
    documents?: DepartmentDocumentCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutOrganizationInput = {
    id?: string
    name: string
    publicKey: string
    headId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: DepartmentMemberUncheckedCreateNestedManyWithoutDepartmentInput
    conversations?: GroupUncheckedCreateNestedManyWithoutDepartmentInput
    tasks?: TaskUncheckedCreateNestedManyWithoutDepartmentInput
    eventBroadcasts?: EventDepartmentBroadcastUncheckedCreateNestedManyWithoutDepartmentInput
    monthlyReports?: DepartmentMonthlyReportUncheckedCreateNestedManyWithoutDepartmentInput
    goals?: DepartmentGoalUncheckedCreateNestedManyWithoutDepartmentInput
    meetings?: DepartmentMeetingUncheckedCreateNestedManyWithoutDepartmentInput
    polls?: DepartmentPollUncheckedCreateNestedManyWithoutDepartmentInput
    teamDecisions?: TeamDecisionUncheckedCreateNestedManyWithoutDepartmentInput
    documents?: DepartmentDocumentUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutOrganizationInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutOrganizationInput, DepartmentUncheckedCreateWithoutOrganizationInput>
  }

  export type DepartmentCreateManyOrganizationInputEnvelope = {
    data: DepartmentCreateManyOrganizationInput | DepartmentCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationMemberCreateWithoutOrganizationInput = {
    id?: string
    role?: $Enums.OrgRole
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutOrgMembershipsInput
  }

  export type OrganizationMemberUncheckedCreateWithoutOrganizationInput = {
    id?: string
    userId: string
    role?: $Enums.OrgRole
    joinedAt?: Date | string
  }

  export type OrganizationMemberCreateOrConnectWithoutOrganizationInput = {
    where: OrganizationMemberWhereUniqueInput
    create: XOR<OrganizationMemberCreateWithoutOrganizationInput, OrganizationMemberUncheckedCreateWithoutOrganizationInput>
  }

  export type OrganizationMemberCreateManyOrganizationInputEnvelope = {
    data: OrganizationMemberCreateManyOrganizationInput | OrganizationMemberCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutOrganizationInput = {
    id?: string
    plan?: $Enums.SubscriptionPlan
    startDate?: Date | string
    endDate?: Date | string | null
    maxDepartments?: number
    maxMembersPerDept?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUncheckedCreateWithoutOrganizationInput = {
    id?: string
    plan?: $Enums.SubscriptionPlan
    startDate?: Date | string
    endDate?: Date | string | null
    maxDepartments?: number
    maxMembersPerDept?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateOrConnectWithoutOrganizationInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutOrganizationInput, SubscriptionUncheckedCreateWithoutOrganizationInput>
  }

  export type EventInvitationCreateWithoutOrganizationInput = {
    id?: string
    title: string
    description?: string | null
    eventType?: $Enums.EventType
    eventDate: Date | string
    maxAttendees: number
    imageUrl?: string | null
    token: string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rsvps?: InvitationRSVPCreateNestedManyWithoutEventInput
    departmentBroadcasts?: EventDepartmentBroadcastCreateNestedManyWithoutEventInput
  }

  export type EventInvitationUncheckedCreateWithoutOrganizationInput = {
    id?: string
    title: string
    description?: string | null
    eventType?: $Enums.EventType
    eventDate: Date | string
    maxAttendees: number
    imageUrl?: string | null
    token: string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rsvps?: InvitationRSVPUncheckedCreateNestedManyWithoutEventInput
    departmentBroadcasts?: EventDepartmentBroadcastUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventInvitationCreateOrConnectWithoutOrganizationInput = {
    where: EventInvitationWhereUniqueInput
    create: XOR<EventInvitationCreateWithoutOrganizationInput, EventInvitationUncheckedCreateWithoutOrganizationInput>
  }

  export type EventInvitationCreateManyOrganizationInputEnvelope = {
    data: EventInvitationCreateManyOrganizationInput | EventInvitationCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: DepartmentWhereUniqueInput
    update: XOR<DepartmentUpdateWithoutOrganizationInput, DepartmentUncheckedUpdateWithoutOrganizationInput>
    create: XOR<DepartmentCreateWithoutOrganizationInput, DepartmentUncheckedCreateWithoutOrganizationInput>
  }

  export type DepartmentUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: DepartmentWhereUniqueInput
    data: XOR<DepartmentUpdateWithoutOrganizationInput, DepartmentUncheckedUpdateWithoutOrganizationInput>
  }

  export type DepartmentUpdateManyWithWhereWithoutOrganizationInput = {
    where: DepartmentScalarWhereInput
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type OrganizationMemberUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: OrganizationMemberWhereUniqueInput
    update: XOR<OrganizationMemberUpdateWithoutOrganizationInput, OrganizationMemberUncheckedUpdateWithoutOrganizationInput>
    create: XOR<OrganizationMemberCreateWithoutOrganizationInput, OrganizationMemberUncheckedCreateWithoutOrganizationInput>
  }

  export type OrganizationMemberUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: OrganizationMemberWhereUniqueInput
    data: XOR<OrganizationMemberUpdateWithoutOrganizationInput, OrganizationMemberUncheckedUpdateWithoutOrganizationInput>
  }

  export type OrganizationMemberUpdateManyWithWhereWithoutOrganizationInput = {
    where: OrganizationMemberScalarWhereInput
    data: XOR<OrganizationMemberUpdateManyMutationInput, OrganizationMemberUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type SubscriptionUpsertWithoutOrganizationInput = {
    update: XOR<SubscriptionUpdateWithoutOrganizationInput, SubscriptionUncheckedUpdateWithoutOrganizationInput>
    create: XOR<SubscriptionCreateWithoutOrganizationInput, SubscriptionUncheckedCreateWithoutOrganizationInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutOrganizationInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutOrganizationInput, SubscriptionUncheckedUpdateWithoutOrganizationInput>
  }

  export type SubscriptionUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxDepartments?: IntFieldUpdateOperationsInput | number
    maxMembersPerDept?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxDepartments?: IntFieldUpdateOperationsInput | number
    maxMembersPerDept?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventInvitationUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: EventInvitationWhereUniqueInput
    update: XOR<EventInvitationUpdateWithoutOrganizationInput, EventInvitationUncheckedUpdateWithoutOrganizationInput>
    create: XOR<EventInvitationCreateWithoutOrganizationInput, EventInvitationUncheckedCreateWithoutOrganizationInput>
  }

  export type EventInvitationUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: EventInvitationWhereUniqueInput
    data: XOR<EventInvitationUpdateWithoutOrganizationInput, EventInvitationUncheckedUpdateWithoutOrganizationInput>
  }

  export type EventInvitationUpdateManyWithWhereWithoutOrganizationInput = {
    where: EventInvitationScalarWhereInput
    data: XOR<EventInvitationUpdateManyMutationInput, EventInvitationUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type EventInvitationScalarWhereInput = {
    AND?: EventInvitationScalarWhereInput | EventInvitationScalarWhereInput[]
    OR?: EventInvitationScalarWhereInput[]
    NOT?: EventInvitationScalarWhereInput | EventInvitationScalarWhereInput[]
    id?: StringFilter<"EventInvitation"> | string
    orgId?: StringFilter<"EventInvitation"> | string
    title?: StringFilter<"EventInvitation"> | string
    description?: StringNullableFilter<"EventInvitation"> | string | null
    eventType?: EnumEventTypeFilter<"EventInvitation"> | $Enums.EventType
    eventDate?: DateTimeFilter<"EventInvitation"> | Date | string
    maxAttendees?: IntFilter<"EventInvitation"> | number
    imageUrl?: StringNullableFilter<"EventInvitation"> | string | null
    token?: StringFilter<"EventInvitation"> | string
    createdBy?: StringFilter<"EventInvitation"> | string
    createdAt?: DateTimeFilter<"EventInvitation"> | Date | string
    updatedAt?: DateTimeFilter<"EventInvitation"> | Date | string
  }

  export type OrganizationCreateWithoutMembersInput = {
    id?: string
    name: string
    code: string
    logo?: string | null
    address?: string | null
    isSuspended?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    departments?: DepartmentCreateNestedManyWithoutOrganizationInput
    subscription?: SubscriptionCreateNestedOneWithoutOrganizationInput
    events?: EventInvitationCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    code: string
    logo?: string | null
    address?: string | null
    isSuspended?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    departments?: DepartmentUncheckedCreateNestedManyWithoutOrganizationInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutOrganizationInput
    events?: EventInvitationUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutMembersInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutOrgMembershipsInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    userPage?: UserPageCreateNestedOneWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    postReads?: PostReadCreateNestedManyWithoutUserInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    invitations?: UserInvitationCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutOrgMembershipsInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementUncheckedCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberUncheckedCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    userPage?: UserPageUncheckedCreateNestedOneWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    postReads?: PostReadUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageUncheckedCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingUncheckedCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollUncheckedCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionUncheckedCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitations?: UserInvitationUncheckedCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskUncheckedCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalUncheckedCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileUncheckedCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementUncheckedCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutOrgMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrgMembershipsInput, UserUncheckedCreateWithoutOrgMembershipsInput>
  }

  export type OrganizationUpsertWithoutMembersInput = {
    update: XOR<OrganizationUpdateWithoutMembersInput, OrganizationUncheckedUpdateWithoutMembersInput>
    create: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutMembersInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutMembersInput, OrganizationUncheckedUpdateWithoutMembersInput>
  }

  export type OrganizationUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    departments?: DepartmentUpdateManyWithoutOrganizationNestedInput
    subscription?: SubscriptionUpdateOneWithoutOrganizationNestedInput
    events?: EventInvitationUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    departments?: DepartmentUncheckedUpdateManyWithoutOrganizationNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutOrganizationNestedInput
    events?: EventInvitationUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UserUpsertWithoutOrgMembershipsInput = {
    update: XOR<UserUpdateWithoutOrgMembershipsInput, UserUncheckedUpdateWithoutOrgMembershipsInput>
    create: XOR<UserCreateWithoutOrgMembershipsInput, UserUncheckedCreateWithoutOrgMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrgMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrgMembershipsInput, UserUncheckedUpdateWithoutOrgMembershipsInput>
  }

  export type UserUpdateWithoutOrgMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    userPage?: UserPageUpdateOneWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    postReads?: PostReadUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutOrgMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUncheckedUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    userPage?: UserPageUncheckedUpdateOneWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    postReads?: PostReadUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUncheckedUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUncheckedUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUncheckedUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUncheckedUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUncheckedUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUncheckedUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUncheckedUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUncheckedUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUncheckedUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type OrganizationCreateWithoutDepartmentsInput = {
    id?: string
    name: string
    code: string
    logo?: string | null
    address?: string | null
    isSuspended?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    members?: OrganizationMemberCreateNestedManyWithoutOrganizationInput
    subscription?: SubscriptionCreateNestedOneWithoutOrganizationInput
    events?: EventInvitationCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutDepartmentsInput = {
    id?: string
    name: string
    code: string
    logo?: string | null
    address?: string | null
    isSuspended?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    members?: OrganizationMemberUncheckedCreateNestedManyWithoutOrganizationInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutOrganizationInput
    events?: EventInvitationUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutDepartmentsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutDepartmentsInput, OrganizationUncheckedCreateWithoutDepartmentsInput>
  }

  export type UserCreateWithoutHeadedDepartmentsInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberCreateNestedManyWithoutUserInput
    userPage?: UserPageCreateNestedOneWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    postReads?: PostReadCreateNestedManyWithoutUserInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    taskMessages?: TaskMessageCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    invitations?: UserInvitationCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutHeadedDepartmentsInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementUncheckedCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberUncheckedCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    userPage?: UserPageUncheckedCreateNestedOneWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    postReads?: PostReadUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    taskMessages?: TaskMessageUncheckedCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingUncheckedCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollUncheckedCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionUncheckedCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitations?: UserInvitationUncheckedCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskUncheckedCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalUncheckedCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileUncheckedCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementUncheckedCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutHeadedDepartmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHeadedDepartmentsInput, UserUncheckedCreateWithoutHeadedDepartmentsInput>
  }

  export type DepartmentMemberCreateWithoutDepartmentInput = {
    id?: string
    encryptedDeptKey: string
    user: UserCreateNestedOneWithoutDeptMembershipsInput
  }

  export type DepartmentMemberUncheckedCreateWithoutDepartmentInput = {
    id?: string
    userId: string
    encryptedDeptKey: string
  }

  export type DepartmentMemberCreateOrConnectWithoutDepartmentInput = {
    where: DepartmentMemberWhereUniqueInput
    create: XOR<DepartmentMemberCreateWithoutDepartmentInput, DepartmentMemberUncheckedCreateWithoutDepartmentInput>
  }

  export type DepartmentMemberCreateManyDepartmentInputEnvelope = {
    data: DepartmentMemberCreateManyDepartmentInput | DepartmentMemberCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type GroupCreateWithoutDepartmentInput = {
    id?: string
    name?: string | null
    isDirect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: GroupMemberCreateNestedManyWithoutGroupInput
    messages?: MessageCreateNestedManyWithoutGroupInput
    documents?: GroupDocumentCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateWithoutDepartmentInput = {
    id?: string
    name?: string | null
    isDirect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: GroupMemberUncheckedCreateNestedManyWithoutGroupInput
    messages?: MessageUncheckedCreateNestedManyWithoutGroupInput
    documents?: GroupDocumentUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutDepartmentInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutDepartmentInput, GroupUncheckedCreateWithoutDepartmentInput>
  }

  export type GroupCreateManyDepartmentInputEnvelope = {
    data: GroupCreateManyDepartmentInput | GroupCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutDepartmentInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.TaskPriority
    startDate?: Date | string | null
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedTasksInput
    assignee: UserCreateNestedOneWithoutAssignedTasksInput
    messages?: TaskMessageCreateNestedManyWithoutTaskInput
    attachments?: TaskAttachmentCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutDepartmentInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.TaskPriority
    startDate?: Date | string | null
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    creatorId: string
    assigneeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: TaskMessageUncheckedCreateNestedManyWithoutTaskInput
    attachments?: TaskAttachmentUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutDepartmentInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutDepartmentInput, TaskUncheckedCreateWithoutDepartmentInput>
  }

  export type TaskCreateManyDepartmentInputEnvelope = {
    data: TaskCreateManyDepartmentInput | TaskCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type EventDepartmentBroadcastCreateWithoutDepartmentInput = {
    id?: string
    createdAt?: Date | string
    event: EventInvitationCreateNestedOneWithoutDepartmentBroadcastsInput
  }

  export type EventDepartmentBroadcastUncheckedCreateWithoutDepartmentInput = {
    id?: string
    eventId: string
    createdAt?: Date | string
  }

  export type EventDepartmentBroadcastCreateOrConnectWithoutDepartmentInput = {
    where: EventDepartmentBroadcastWhereUniqueInput
    create: XOR<EventDepartmentBroadcastCreateWithoutDepartmentInput, EventDepartmentBroadcastUncheckedCreateWithoutDepartmentInput>
  }

  export type EventDepartmentBroadcastCreateManyDepartmentInputEnvelope = {
    data: EventDepartmentBroadcastCreateManyDepartmentInput | EventDepartmentBroadcastCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentMonthlyReportCreateWithoutDepartmentInput = {
    id?: string
    month: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDepartmentMonthlyReportsInput
  }

  export type DepartmentMonthlyReportUncheckedCreateWithoutDepartmentInput = {
    id?: string
    userId: string
    month: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentMonthlyReportCreateOrConnectWithoutDepartmentInput = {
    where: DepartmentMonthlyReportWhereUniqueInput
    create: XOR<DepartmentMonthlyReportCreateWithoutDepartmentInput, DepartmentMonthlyReportUncheckedCreateWithoutDepartmentInput>
  }

  export type DepartmentMonthlyReportCreateManyDepartmentInputEnvelope = {
    data: DepartmentMonthlyReportCreateManyDepartmentInput | DepartmentMonthlyReportCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentGoalCreateWithoutDepartmentInput = {
    id?: string
    title: string
    description?: string | null
    targetValue?: number | null
    currentValue?: number
    period: string
    periodKey: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentGoalUncheckedCreateWithoutDepartmentInput = {
    id?: string
    title: string
    description?: string | null
    targetValue?: number | null
    currentValue?: number
    period: string
    periodKey: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentGoalCreateOrConnectWithoutDepartmentInput = {
    where: DepartmentGoalWhereUniqueInput
    create: XOR<DepartmentGoalCreateWithoutDepartmentInput, DepartmentGoalUncheckedCreateWithoutDepartmentInput>
  }

  export type DepartmentGoalCreateManyDepartmentInputEnvelope = {
    data: DepartmentGoalCreateManyDepartmentInput | DepartmentGoalCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentMeetingCreateWithoutDepartmentInput = {
    id?: string
    title: string
    description?: string | null
    agenda?: string | null
    meetingDate: Date | string
    location?: string | null
    minutes?: string | null
    minutesAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedMeetingsInput
  }

  export type DepartmentMeetingUncheckedCreateWithoutDepartmentInput = {
    id?: string
    title: string
    description?: string | null
    agenda?: string | null
    meetingDate: Date | string
    location?: string | null
    createdBy: string
    minutes?: string | null
    minutesAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentMeetingCreateOrConnectWithoutDepartmentInput = {
    where: DepartmentMeetingWhereUniqueInput
    create: XOR<DepartmentMeetingCreateWithoutDepartmentInput, DepartmentMeetingUncheckedCreateWithoutDepartmentInput>
  }

  export type DepartmentMeetingCreateManyDepartmentInputEnvelope = {
    data: DepartmentMeetingCreateManyDepartmentInput | DepartmentMeetingCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentPollCreateWithoutDepartmentInput = {
    id?: string
    question: string
    options: JsonNullValueInput | InputJsonValue
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedPollsInput
    votes?: PollVoteCreateNestedManyWithoutPollInput
  }

  export type DepartmentPollUncheckedCreateWithoutDepartmentInput = {
    id?: string
    question: string
    options: JsonNullValueInput | InputJsonValue
    endDate?: Date | string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: PollVoteUncheckedCreateNestedManyWithoutPollInput
  }

  export type DepartmentPollCreateOrConnectWithoutDepartmentInput = {
    where: DepartmentPollWhereUniqueInput
    create: XOR<DepartmentPollCreateWithoutDepartmentInput, DepartmentPollUncheckedCreateWithoutDepartmentInput>
  }

  export type DepartmentPollCreateManyDepartmentInputEnvelope = {
    data: DepartmentPollCreateManyDepartmentInput | DepartmentPollCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type TeamDecisionCreateWithoutDepartmentInput = {
    id?: string
    title: string
    description?: string | null
    voteDeadline?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedDecisionsInput
    votes?: DecisionVoteCreateNestedManyWithoutDecisionInput
  }

  export type TeamDecisionUncheckedCreateWithoutDepartmentInput = {
    id?: string
    title: string
    description?: string | null
    voteDeadline?: Date | string | null
    status?: string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: DecisionVoteUncheckedCreateNestedManyWithoutDecisionInput
  }

  export type TeamDecisionCreateOrConnectWithoutDepartmentInput = {
    where: TeamDecisionWhereUniqueInput
    create: XOR<TeamDecisionCreateWithoutDepartmentInput, TeamDecisionUncheckedCreateWithoutDepartmentInput>
  }

  export type TeamDecisionCreateManyDepartmentInputEnvelope = {
    data: TeamDecisionCreateManyDepartmentInput | TeamDecisionCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentDocumentCreateWithoutDepartmentInput = {
    id?: string
    filename: string
    type: $Enums.FileType
    data: string
    createdAt?: Date | string
    uploader: UserCreateNestedOneWithoutUploadedDepartmentDocumentsInput
  }

  export type DepartmentDocumentUncheckedCreateWithoutDepartmentInput = {
    id?: string
    filename: string
    type: $Enums.FileType
    data: string
    uploadedBy: string
    createdAt?: Date | string
  }

  export type DepartmentDocumentCreateOrConnectWithoutDepartmentInput = {
    where: DepartmentDocumentWhereUniqueInput
    create: XOR<DepartmentDocumentCreateWithoutDepartmentInput, DepartmentDocumentUncheckedCreateWithoutDepartmentInput>
  }

  export type DepartmentDocumentCreateManyDepartmentInputEnvelope = {
    data: DepartmentDocumentCreateManyDepartmentInput | DepartmentDocumentCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutDepartmentsInput = {
    update: XOR<OrganizationUpdateWithoutDepartmentsInput, OrganizationUncheckedUpdateWithoutDepartmentsInput>
    create: XOR<OrganizationCreateWithoutDepartmentsInput, OrganizationUncheckedCreateWithoutDepartmentsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutDepartmentsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutDepartmentsInput, OrganizationUncheckedUpdateWithoutDepartmentsInput>
  }

  export type OrganizationUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    members?: OrganizationMemberUpdateManyWithoutOrganizationNestedInput
    subscription?: SubscriptionUpdateOneWithoutOrganizationNestedInput
    events?: EventInvitationUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    members?: OrganizationMemberUncheckedUpdateManyWithoutOrganizationNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutOrganizationNestedInput
    events?: EventInvitationUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UserUpsertWithoutHeadedDepartmentsInput = {
    update: XOR<UserUpdateWithoutHeadedDepartmentsInput, UserUncheckedUpdateWithoutHeadedDepartmentsInput>
    create: XOR<UserCreateWithoutHeadedDepartmentsInput, UserUncheckedCreateWithoutHeadedDepartmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutHeadedDepartmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutHeadedDepartmentsInput, UserUncheckedUpdateWithoutHeadedDepartmentsInput>
  }

  export type UserUpdateWithoutHeadedDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUpdateManyWithoutUserNestedInput
    userPage?: UserPageUpdateOneWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    postReads?: PostReadUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    taskMessages?: TaskMessageUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutHeadedDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUncheckedUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    userPage?: UserPageUncheckedUpdateOneWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    postReads?: PostReadUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    taskMessages?: TaskMessageUncheckedUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUncheckedUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUncheckedUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUncheckedUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUncheckedUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUncheckedUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUncheckedUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUncheckedUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUncheckedUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type DepartmentMemberUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: DepartmentMemberWhereUniqueInput
    update: XOR<DepartmentMemberUpdateWithoutDepartmentInput, DepartmentMemberUncheckedUpdateWithoutDepartmentInput>
    create: XOR<DepartmentMemberCreateWithoutDepartmentInput, DepartmentMemberUncheckedCreateWithoutDepartmentInput>
  }

  export type DepartmentMemberUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: DepartmentMemberWhereUniqueInput
    data: XOR<DepartmentMemberUpdateWithoutDepartmentInput, DepartmentMemberUncheckedUpdateWithoutDepartmentInput>
  }

  export type DepartmentMemberUpdateManyWithWhereWithoutDepartmentInput = {
    where: DepartmentMemberScalarWhereInput
    data: XOR<DepartmentMemberUpdateManyMutationInput, DepartmentMemberUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type GroupUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: GroupWhereUniqueInput
    update: XOR<GroupUpdateWithoutDepartmentInput, GroupUncheckedUpdateWithoutDepartmentInput>
    create: XOR<GroupCreateWithoutDepartmentInput, GroupUncheckedCreateWithoutDepartmentInput>
  }

  export type GroupUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: GroupWhereUniqueInput
    data: XOR<GroupUpdateWithoutDepartmentInput, GroupUncheckedUpdateWithoutDepartmentInput>
  }

  export type GroupUpdateManyWithWhereWithoutDepartmentInput = {
    where: GroupScalarWhereInput
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type GroupScalarWhereInput = {
    AND?: GroupScalarWhereInput | GroupScalarWhereInput[]
    OR?: GroupScalarWhereInput[]
    NOT?: GroupScalarWhereInput | GroupScalarWhereInput[]
    id?: StringFilter<"Group"> | string
    name?: StringNullableFilter<"Group"> | string | null
    isDirect?: BoolFilter<"Group"> | boolean
    deptId?: StringNullableFilter<"Group"> | string | null
    createdAt?: DateTimeFilter<"Group"> | Date | string
    updatedAt?: DateTimeFilter<"Group"> | Date | string
  }

  export type TaskUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutDepartmentInput, TaskUncheckedUpdateWithoutDepartmentInput>
    create: XOR<TaskCreateWithoutDepartmentInput, TaskUncheckedCreateWithoutDepartmentInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutDepartmentInput, TaskUncheckedUpdateWithoutDepartmentInput>
  }

  export type TaskUpdateManyWithWhereWithoutDepartmentInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type EventDepartmentBroadcastUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: EventDepartmentBroadcastWhereUniqueInput
    update: XOR<EventDepartmentBroadcastUpdateWithoutDepartmentInput, EventDepartmentBroadcastUncheckedUpdateWithoutDepartmentInput>
    create: XOR<EventDepartmentBroadcastCreateWithoutDepartmentInput, EventDepartmentBroadcastUncheckedCreateWithoutDepartmentInput>
  }

  export type EventDepartmentBroadcastUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: EventDepartmentBroadcastWhereUniqueInput
    data: XOR<EventDepartmentBroadcastUpdateWithoutDepartmentInput, EventDepartmentBroadcastUncheckedUpdateWithoutDepartmentInput>
  }

  export type EventDepartmentBroadcastUpdateManyWithWhereWithoutDepartmentInput = {
    where: EventDepartmentBroadcastScalarWhereInput
    data: XOR<EventDepartmentBroadcastUpdateManyMutationInput, EventDepartmentBroadcastUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type EventDepartmentBroadcastScalarWhereInput = {
    AND?: EventDepartmentBroadcastScalarWhereInput | EventDepartmentBroadcastScalarWhereInput[]
    OR?: EventDepartmentBroadcastScalarWhereInput[]
    NOT?: EventDepartmentBroadcastScalarWhereInput | EventDepartmentBroadcastScalarWhereInput[]
    id?: StringFilter<"EventDepartmentBroadcast"> | string
    eventId?: StringFilter<"EventDepartmentBroadcast"> | string
    deptId?: StringFilter<"EventDepartmentBroadcast"> | string
    createdAt?: DateTimeFilter<"EventDepartmentBroadcast"> | Date | string
  }

  export type DepartmentMonthlyReportUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: DepartmentMonthlyReportWhereUniqueInput
    update: XOR<DepartmentMonthlyReportUpdateWithoutDepartmentInput, DepartmentMonthlyReportUncheckedUpdateWithoutDepartmentInput>
    create: XOR<DepartmentMonthlyReportCreateWithoutDepartmentInput, DepartmentMonthlyReportUncheckedCreateWithoutDepartmentInput>
  }

  export type DepartmentMonthlyReportUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: DepartmentMonthlyReportWhereUniqueInput
    data: XOR<DepartmentMonthlyReportUpdateWithoutDepartmentInput, DepartmentMonthlyReportUncheckedUpdateWithoutDepartmentInput>
  }

  export type DepartmentMonthlyReportUpdateManyWithWhereWithoutDepartmentInput = {
    where: DepartmentMonthlyReportScalarWhereInput
    data: XOR<DepartmentMonthlyReportUpdateManyMutationInput, DepartmentMonthlyReportUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type DepartmentGoalUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: DepartmentGoalWhereUniqueInput
    update: XOR<DepartmentGoalUpdateWithoutDepartmentInput, DepartmentGoalUncheckedUpdateWithoutDepartmentInput>
    create: XOR<DepartmentGoalCreateWithoutDepartmentInput, DepartmentGoalUncheckedCreateWithoutDepartmentInput>
  }

  export type DepartmentGoalUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: DepartmentGoalWhereUniqueInput
    data: XOR<DepartmentGoalUpdateWithoutDepartmentInput, DepartmentGoalUncheckedUpdateWithoutDepartmentInput>
  }

  export type DepartmentGoalUpdateManyWithWhereWithoutDepartmentInput = {
    where: DepartmentGoalScalarWhereInput
    data: XOR<DepartmentGoalUpdateManyMutationInput, DepartmentGoalUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type DepartmentGoalScalarWhereInput = {
    AND?: DepartmentGoalScalarWhereInput | DepartmentGoalScalarWhereInput[]
    OR?: DepartmentGoalScalarWhereInput[]
    NOT?: DepartmentGoalScalarWhereInput | DepartmentGoalScalarWhereInput[]
    id?: StringFilter<"DepartmentGoal"> | string
    deptId?: StringFilter<"DepartmentGoal"> | string
    title?: StringFilter<"DepartmentGoal"> | string
    description?: StringNullableFilter<"DepartmentGoal"> | string | null
    targetValue?: FloatNullableFilter<"DepartmentGoal"> | number | null
    currentValue?: FloatFilter<"DepartmentGoal"> | number
    period?: StringFilter<"DepartmentGoal"> | string
    periodKey?: StringFilter<"DepartmentGoal"> | string
    createdAt?: DateTimeFilter<"DepartmentGoal"> | Date | string
    updatedAt?: DateTimeFilter<"DepartmentGoal"> | Date | string
  }

  export type DepartmentMeetingUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: DepartmentMeetingWhereUniqueInput
    update: XOR<DepartmentMeetingUpdateWithoutDepartmentInput, DepartmentMeetingUncheckedUpdateWithoutDepartmentInput>
    create: XOR<DepartmentMeetingCreateWithoutDepartmentInput, DepartmentMeetingUncheckedCreateWithoutDepartmentInput>
  }

  export type DepartmentMeetingUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: DepartmentMeetingWhereUniqueInput
    data: XOR<DepartmentMeetingUpdateWithoutDepartmentInput, DepartmentMeetingUncheckedUpdateWithoutDepartmentInput>
  }

  export type DepartmentMeetingUpdateManyWithWhereWithoutDepartmentInput = {
    where: DepartmentMeetingScalarWhereInput
    data: XOR<DepartmentMeetingUpdateManyMutationInput, DepartmentMeetingUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type DepartmentPollUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: DepartmentPollWhereUniqueInput
    update: XOR<DepartmentPollUpdateWithoutDepartmentInput, DepartmentPollUncheckedUpdateWithoutDepartmentInput>
    create: XOR<DepartmentPollCreateWithoutDepartmentInput, DepartmentPollUncheckedCreateWithoutDepartmentInput>
  }

  export type DepartmentPollUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: DepartmentPollWhereUniqueInput
    data: XOR<DepartmentPollUpdateWithoutDepartmentInput, DepartmentPollUncheckedUpdateWithoutDepartmentInput>
  }

  export type DepartmentPollUpdateManyWithWhereWithoutDepartmentInput = {
    where: DepartmentPollScalarWhereInput
    data: XOR<DepartmentPollUpdateManyMutationInput, DepartmentPollUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type TeamDecisionUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: TeamDecisionWhereUniqueInput
    update: XOR<TeamDecisionUpdateWithoutDepartmentInput, TeamDecisionUncheckedUpdateWithoutDepartmentInput>
    create: XOR<TeamDecisionCreateWithoutDepartmentInput, TeamDecisionUncheckedCreateWithoutDepartmentInput>
  }

  export type TeamDecisionUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: TeamDecisionWhereUniqueInput
    data: XOR<TeamDecisionUpdateWithoutDepartmentInput, TeamDecisionUncheckedUpdateWithoutDepartmentInput>
  }

  export type TeamDecisionUpdateManyWithWhereWithoutDepartmentInput = {
    where: TeamDecisionScalarWhereInput
    data: XOR<TeamDecisionUpdateManyMutationInput, TeamDecisionUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type DepartmentDocumentUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: DepartmentDocumentWhereUniqueInput
    update: XOR<DepartmentDocumentUpdateWithoutDepartmentInput, DepartmentDocumentUncheckedUpdateWithoutDepartmentInput>
    create: XOR<DepartmentDocumentCreateWithoutDepartmentInput, DepartmentDocumentUncheckedCreateWithoutDepartmentInput>
  }

  export type DepartmentDocumentUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: DepartmentDocumentWhereUniqueInput
    data: XOR<DepartmentDocumentUpdateWithoutDepartmentInput, DepartmentDocumentUncheckedUpdateWithoutDepartmentInput>
  }

  export type DepartmentDocumentUpdateManyWithWhereWithoutDepartmentInput = {
    where: DepartmentDocumentScalarWhereInput
    data: XOR<DepartmentDocumentUpdateManyMutationInput, DepartmentDocumentUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type DepartmentCreateWithoutDocumentsInput = {
    id?: string
    name: string
    publicKey: string
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutDepartmentsInput
    head?: UserCreateNestedOneWithoutHeadedDepartmentsInput
    members?: DepartmentMemberCreateNestedManyWithoutDepartmentInput
    conversations?: GroupCreateNestedManyWithoutDepartmentInput
    tasks?: TaskCreateNestedManyWithoutDepartmentInput
    eventBroadcasts?: EventDepartmentBroadcastCreateNestedManyWithoutDepartmentInput
    monthlyReports?: DepartmentMonthlyReportCreateNestedManyWithoutDepartmentInput
    goals?: DepartmentGoalCreateNestedManyWithoutDepartmentInput
    meetings?: DepartmentMeetingCreateNestedManyWithoutDepartmentInput
    polls?: DepartmentPollCreateNestedManyWithoutDepartmentInput
    teamDecisions?: TeamDecisionCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutDocumentsInput = {
    id?: string
    name: string
    orgId: string
    publicKey: string
    headId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: DepartmentMemberUncheckedCreateNestedManyWithoutDepartmentInput
    conversations?: GroupUncheckedCreateNestedManyWithoutDepartmentInput
    tasks?: TaskUncheckedCreateNestedManyWithoutDepartmentInput
    eventBroadcasts?: EventDepartmentBroadcastUncheckedCreateNestedManyWithoutDepartmentInput
    monthlyReports?: DepartmentMonthlyReportUncheckedCreateNestedManyWithoutDepartmentInput
    goals?: DepartmentGoalUncheckedCreateNestedManyWithoutDepartmentInput
    meetings?: DepartmentMeetingUncheckedCreateNestedManyWithoutDepartmentInput
    polls?: DepartmentPollUncheckedCreateNestedManyWithoutDepartmentInput
    teamDecisions?: TeamDecisionUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutDocumentsInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutDocumentsInput, DepartmentUncheckedCreateWithoutDocumentsInput>
  }

  export type UserCreateWithoutUploadedDepartmentDocumentsInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberCreateNestedManyWithoutUserInput
    userPage?: UserPageCreateNestedOneWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    postReads?: PostReadCreateNestedManyWithoutUserInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    invitations?: UserInvitationCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    groupNotes?: GroupNoteCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutUploadedDepartmentDocumentsInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementUncheckedCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberUncheckedCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    userPage?: UserPageUncheckedCreateNestedOneWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    postReads?: PostReadUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageUncheckedCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingUncheckedCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollUncheckedCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionUncheckedCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitations?: UserInvitationUncheckedCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskUncheckedCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalUncheckedCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileUncheckedCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementUncheckedCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    groupNotes?: GroupNoteUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutUploadedDepartmentDocumentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUploadedDepartmentDocumentsInput, UserUncheckedCreateWithoutUploadedDepartmentDocumentsInput>
  }

  export type DepartmentUpsertWithoutDocumentsInput = {
    update: XOR<DepartmentUpdateWithoutDocumentsInput, DepartmentUncheckedUpdateWithoutDocumentsInput>
    create: XOR<DepartmentCreateWithoutDocumentsInput, DepartmentUncheckedCreateWithoutDocumentsInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutDocumentsInput, DepartmentUncheckedUpdateWithoutDocumentsInput>
  }

  export type DepartmentUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutDepartmentsNestedInput
    head?: UserUpdateOneWithoutHeadedDepartmentsNestedInput
    members?: DepartmentMemberUpdateManyWithoutDepartmentNestedInput
    conversations?: GroupUpdateManyWithoutDepartmentNestedInput
    tasks?: TaskUpdateManyWithoutDepartmentNestedInput
    eventBroadcasts?: EventDepartmentBroadcastUpdateManyWithoutDepartmentNestedInput
    monthlyReports?: DepartmentMonthlyReportUpdateManyWithoutDepartmentNestedInput
    goals?: DepartmentGoalUpdateManyWithoutDepartmentNestedInput
    meetings?: DepartmentMeetingUpdateManyWithoutDepartmentNestedInput
    polls?: DepartmentPollUpdateManyWithoutDepartmentNestedInput
    teamDecisions?: TeamDecisionUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    headId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: DepartmentMemberUncheckedUpdateManyWithoutDepartmentNestedInput
    conversations?: GroupUncheckedUpdateManyWithoutDepartmentNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutDepartmentNestedInput
    eventBroadcasts?: EventDepartmentBroadcastUncheckedUpdateManyWithoutDepartmentNestedInput
    monthlyReports?: DepartmentMonthlyReportUncheckedUpdateManyWithoutDepartmentNestedInput
    goals?: DepartmentGoalUncheckedUpdateManyWithoutDepartmentNestedInput
    meetings?: DepartmentMeetingUncheckedUpdateManyWithoutDepartmentNestedInput
    polls?: DepartmentPollUncheckedUpdateManyWithoutDepartmentNestedInput
    teamDecisions?: TeamDecisionUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type UserUpsertWithoutUploadedDepartmentDocumentsInput = {
    update: XOR<UserUpdateWithoutUploadedDepartmentDocumentsInput, UserUncheckedUpdateWithoutUploadedDepartmentDocumentsInput>
    create: XOR<UserCreateWithoutUploadedDepartmentDocumentsInput, UserUncheckedCreateWithoutUploadedDepartmentDocumentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUploadedDepartmentDocumentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUploadedDepartmentDocumentsInput, UserUncheckedUpdateWithoutUploadedDepartmentDocumentsInput>
  }

  export type UserUpdateWithoutUploadedDepartmentDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUpdateManyWithoutUserNestedInput
    userPage?: UserPageUpdateOneWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    postReads?: PostReadUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    groupNotes?: GroupNoteUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutUploadedDepartmentDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUncheckedUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    userPage?: UserPageUncheckedUpdateOneWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    postReads?: PostReadUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUncheckedUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUncheckedUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUncheckedUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUncheckedUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUncheckedUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUncheckedUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUncheckedUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUncheckedUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUncheckedUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    groupNotes?: GroupNoteUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type DepartmentCreateWithoutGoalsInput = {
    id?: string
    name: string
    publicKey: string
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutDepartmentsInput
    head?: UserCreateNestedOneWithoutHeadedDepartmentsInput
    members?: DepartmentMemberCreateNestedManyWithoutDepartmentInput
    conversations?: GroupCreateNestedManyWithoutDepartmentInput
    tasks?: TaskCreateNestedManyWithoutDepartmentInput
    eventBroadcasts?: EventDepartmentBroadcastCreateNestedManyWithoutDepartmentInput
    monthlyReports?: DepartmentMonthlyReportCreateNestedManyWithoutDepartmentInput
    meetings?: DepartmentMeetingCreateNestedManyWithoutDepartmentInput
    polls?: DepartmentPollCreateNestedManyWithoutDepartmentInput
    teamDecisions?: TeamDecisionCreateNestedManyWithoutDepartmentInput
    documents?: DepartmentDocumentCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutGoalsInput = {
    id?: string
    name: string
    orgId: string
    publicKey: string
    headId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: DepartmentMemberUncheckedCreateNestedManyWithoutDepartmentInput
    conversations?: GroupUncheckedCreateNestedManyWithoutDepartmentInput
    tasks?: TaskUncheckedCreateNestedManyWithoutDepartmentInput
    eventBroadcasts?: EventDepartmentBroadcastUncheckedCreateNestedManyWithoutDepartmentInput
    monthlyReports?: DepartmentMonthlyReportUncheckedCreateNestedManyWithoutDepartmentInput
    meetings?: DepartmentMeetingUncheckedCreateNestedManyWithoutDepartmentInput
    polls?: DepartmentPollUncheckedCreateNestedManyWithoutDepartmentInput
    teamDecisions?: TeamDecisionUncheckedCreateNestedManyWithoutDepartmentInput
    documents?: DepartmentDocumentUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutGoalsInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutGoalsInput, DepartmentUncheckedCreateWithoutGoalsInput>
  }

  export type DepartmentUpsertWithoutGoalsInput = {
    update: XOR<DepartmentUpdateWithoutGoalsInput, DepartmentUncheckedUpdateWithoutGoalsInput>
    create: XOR<DepartmentCreateWithoutGoalsInput, DepartmentUncheckedCreateWithoutGoalsInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutGoalsInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutGoalsInput, DepartmentUncheckedUpdateWithoutGoalsInput>
  }

  export type DepartmentUpdateWithoutGoalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutDepartmentsNestedInput
    head?: UserUpdateOneWithoutHeadedDepartmentsNestedInput
    members?: DepartmentMemberUpdateManyWithoutDepartmentNestedInput
    conversations?: GroupUpdateManyWithoutDepartmentNestedInput
    tasks?: TaskUpdateManyWithoutDepartmentNestedInput
    eventBroadcasts?: EventDepartmentBroadcastUpdateManyWithoutDepartmentNestedInput
    monthlyReports?: DepartmentMonthlyReportUpdateManyWithoutDepartmentNestedInput
    meetings?: DepartmentMeetingUpdateManyWithoutDepartmentNestedInput
    polls?: DepartmentPollUpdateManyWithoutDepartmentNestedInput
    teamDecisions?: TeamDecisionUpdateManyWithoutDepartmentNestedInput
    documents?: DepartmentDocumentUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutGoalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    headId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: DepartmentMemberUncheckedUpdateManyWithoutDepartmentNestedInput
    conversations?: GroupUncheckedUpdateManyWithoutDepartmentNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutDepartmentNestedInput
    eventBroadcasts?: EventDepartmentBroadcastUncheckedUpdateManyWithoutDepartmentNestedInput
    monthlyReports?: DepartmentMonthlyReportUncheckedUpdateManyWithoutDepartmentNestedInput
    meetings?: DepartmentMeetingUncheckedUpdateManyWithoutDepartmentNestedInput
    polls?: DepartmentPollUncheckedUpdateManyWithoutDepartmentNestedInput
    teamDecisions?: TeamDecisionUncheckedUpdateManyWithoutDepartmentNestedInput
    documents?: DepartmentDocumentUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentCreateWithoutMeetingsInput = {
    id?: string
    name: string
    publicKey: string
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutDepartmentsInput
    head?: UserCreateNestedOneWithoutHeadedDepartmentsInput
    members?: DepartmentMemberCreateNestedManyWithoutDepartmentInput
    conversations?: GroupCreateNestedManyWithoutDepartmentInput
    tasks?: TaskCreateNestedManyWithoutDepartmentInput
    eventBroadcasts?: EventDepartmentBroadcastCreateNestedManyWithoutDepartmentInput
    monthlyReports?: DepartmentMonthlyReportCreateNestedManyWithoutDepartmentInput
    goals?: DepartmentGoalCreateNestedManyWithoutDepartmentInput
    polls?: DepartmentPollCreateNestedManyWithoutDepartmentInput
    teamDecisions?: TeamDecisionCreateNestedManyWithoutDepartmentInput
    documents?: DepartmentDocumentCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutMeetingsInput = {
    id?: string
    name: string
    orgId: string
    publicKey: string
    headId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: DepartmentMemberUncheckedCreateNestedManyWithoutDepartmentInput
    conversations?: GroupUncheckedCreateNestedManyWithoutDepartmentInput
    tasks?: TaskUncheckedCreateNestedManyWithoutDepartmentInput
    eventBroadcasts?: EventDepartmentBroadcastUncheckedCreateNestedManyWithoutDepartmentInput
    monthlyReports?: DepartmentMonthlyReportUncheckedCreateNestedManyWithoutDepartmentInput
    goals?: DepartmentGoalUncheckedCreateNestedManyWithoutDepartmentInput
    polls?: DepartmentPollUncheckedCreateNestedManyWithoutDepartmentInput
    teamDecisions?: TeamDecisionUncheckedCreateNestedManyWithoutDepartmentInput
    documents?: DepartmentDocumentUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutMeetingsInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutMeetingsInput, DepartmentUncheckedCreateWithoutMeetingsInput>
  }

  export type UserCreateWithoutCreatedMeetingsInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberCreateNestedManyWithoutUserInput
    userPage?: UserPageCreateNestedOneWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    postReads?: PostReadCreateNestedManyWithoutUserInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportCreateNestedManyWithoutUserInput
    createdPolls?: DepartmentPollCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    invitations?: UserInvitationCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutCreatedMeetingsInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementUncheckedCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberUncheckedCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    userPage?: UserPageUncheckedCreateNestedOneWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    postReads?: PostReadUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageUncheckedCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedCreateNestedManyWithoutUserInput
    createdPolls?: DepartmentPollUncheckedCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionUncheckedCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitations?: UserInvitationUncheckedCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskUncheckedCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalUncheckedCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileUncheckedCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementUncheckedCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutCreatedMeetingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedMeetingsInput, UserUncheckedCreateWithoutCreatedMeetingsInput>
  }

  export type DepartmentUpsertWithoutMeetingsInput = {
    update: XOR<DepartmentUpdateWithoutMeetingsInput, DepartmentUncheckedUpdateWithoutMeetingsInput>
    create: XOR<DepartmentCreateWithoutMeetingsInput, DepartmentUncheckedCreateWithoutMeetingsInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutMeetingsInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutMeetingsInput, DepartmentUncheckedUpdateWithoutMeetingsInput>
  }

  export type DepartmentUpdateWithoutMeetingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutDepartmentsNestedInput
    head?: UserUpdateOneWithoutHeadedDepartmentsNestedInput
    members?: DepartmentMemberUpdateManyWithoutDepartmentNestedInput
    conversations?: GroupUpdateManyWithoutDepartmentNestedInput
    tasks?: TaskUpdateManyWithoutDepartmentNestedInput
    eventBroadcasts?: EventDepartmentBroadcastUpdateManyWithoutDepartmentNestedInput
    monthlyReports?: DepartmentMonthlyReportUpdateManyWithoutDepartmentNestedInput
    goals?: DepartmentGoalUpdateManyWithoutDepartmentNestedInput
    polls?: DepartmentPollUpdateManyWithoutDepartmentNestedInput
    teamDecisions?: TeamDecisionUpdateManyWithoutDepartmentNestedInput
    documents?: DepartmentDocumentUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutMeetingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    headId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: DepartmentMemberUncheckedUpdateManyWithoutDepartmentNestedInput
    conversations?: GroupUncheckedUpdateManyWithoutDepartmentNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutDepartmentNestedInput
    eventBroadcasts?: EventDepartmentBroadcastUncheckedUpdateManyWithoutDepartmentNestedInput
    monthlyReports?: DepartmentMonthlyReportUncheckedUpdateManyWithoutDepartmentNestedInput
    goals?: DepartmentGoalUncheckedUpdateManyWithoutDepartmentNestedInput
    polls?: DepartmentPollUncheckedUpdateManyWithoutDepartmentNestedInput
    teamDecisions?: TeamDecisionUncheckedUpdateManyWithoutDepartmentNestedInput
    documents?: DepartmentDocumentUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type UserUpsertWithoutCreatedMeetingsInput = {
    update: XOR<UserUpdateWithoutCreatedMeetingsInput, UserUncheckedUpdateWithoutCreatedMeetingsInput>
    create: XOR<UserCreateWithoutCreatedMeetingsInput, UserUncheckedCreateWithoutCreatedMeetingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedMeetingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedMeetingsInput, UserUncheckedUpdateWithoutCreatedMeetingsInput>
  }

  export type UserUpdateWithoutCreatedMeetingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUpdateManyWithoutUserNestedInput
    userPage?: UserPageUpdateOneWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    postReads?: PostReadUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUpdateManyWithoutUserNestedInput
    createdPolls?: DepartmentPollUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedMeetingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUncheckedUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    userPage?: UserPageUncheckedUpdateOneWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    postReads?: PostReadUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUncheckedUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedUpdateManyWithoutUserNestedInput
    createdPolls?: DepartmentPollUncheckedUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUncheckedUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUncheckedUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUncheckedUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUncheckedUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUncheckedUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUncheckedUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type DepartmentCreateWithoutPollsInput = {
    id?: string
    name: string
    publicKey: string
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutDepartmentsInput
    head?: UserCreateNestedOneWithoutHeadedDepartmentsInput
    members?: DepartmentMemberCreateNestedManyWithoutDepartmentInput
    conversations?: GroupCreateNestedManyWithoutDepartmentInput
    tasks?: TaskCreateNestedManyWithoutDepartmentInput
    eventBroadcasts?: EventDepartmentBroadcastCreateNestedManyWithoutDepartmentInput
    monthlyReports?: DepartmentMonthlyReportCreateNestedManyWithoutDepartmentInput
    goals?: DepartmentGoalCreateNestedManyWithoutDepartmentInput
    meetings?: DepartmentMeetingCreateNestedManyWithoutDepartmentInput
    teamDecisions?: TeamDecisionCreateNestedManyWithoutDepartmentInput
    documents?: DepartmentDocumentCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutPollsInput = {
    id?: string
    name: string
    orgId: string
    publicKey: string
    headId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: DepartmentMemberUncheckedCreateNestedManyWithoutDepartmentInput
    conversations?: GroupUncheckedCreateNestedManyWithoutDepartmentInput
    tasks?: TaskUncheckedCreateNestedManyWithoutDepartmentInput
    eventBroadcasts?: EventDepartmentBroadcastUncheckedCreateNestedManyWithoutDepartmentInput
    monthlyReports?: DepartmentMonthlyReportUncheckedCreateNestedManyWithoutDepartmentInput
    goals?: DepartmentGoalUncheckedCreateNestedManyWithoutDepartmentInput
    meetings?: DepartmentMeetingUncheckedCreateNestedManyWithoutDepartmentInput
    teamDecisions?: TeamDecisionUncheckedCreateNestedManyWithoutDepartmentInput
    documents?: DepartmentDocumentUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutPollsInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutPollsInput, DepartmentUncheckedCreateWithoutPollsInput>
  }

  export type UserCreateWithoutCreatedPollsInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberCreateNestedManyWithoutUserInput
    userPage?: UserPageCreateNestedOneWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    postReads?: PostReadCreateNestedManyWithoutUserInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    invitations?: UserInvitationCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutCreatedPollsInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementUncheckedCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberUncheckedCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    userPage?: UserPageUncheckedCreateNestedOneWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    postReads?: PostReadUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageUncheckedCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingUncheckedCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionUncheckedCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitations?: UserInvitationUncheckedCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskUncheckedCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalUncheckedCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileUncheckedCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementUncheckedCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutCreatedPollsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedPollsInput, UserUncheckedCreateWithoutCreatedPollsInput>
  }

  export type PollVoteCreateWithoutPollInput = {
    id?: string
    optionIndex: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPollVotesInput
  }

  export type PollVoteUncheckedCreateWithoutPollInput = {
    id?: string
    userId: string
    optionIndex: number
    createdAt?: Date | string
  }

  export type PollVoteCreateOrConnectWithoutPollInput = {
    where: PollVoteWhereUniqueInput
    create: XOR<PollVoteCreateWithoutPollInput, PollVoteUncheckedCreateWithoutPollInput>
  }

  export type PollVoteCreateManyPollInputEnvelope = {
    data: PollVoteCreateManyPollInput | PollVoteCreateManyPollInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentUpsertWithoutPollsInput = {
    update: XOR<DepartmentUpdateWithoutPollsInput, DepartmentUncheckedUpdateWithoutPollsInput>
    create: XOR<DepartmentCreateWithoutPollsInput, DepartmentUncheckedCreateWithoutPollsInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutPollsInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutPollsInput, DepartmentUncheckedUpdateWithoutPollsInput>
  }

  export type DepartmentUpdateWithoutPollsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutDepartmentsNestedInput
    head?: UserUpdateOneWithoutHeadedDepartmentsNestedInput
    members?: DepartmentMemberUpdateManyWithoutDepartmentNestedInput
    conversations?: GroupUpdateManyWithoutDepartmentNestedInput
    tasks?: TaskUpdateManyWithoutDepartmentNestedInput
    eventBroadcasts?: EventDepartmentBroadcastUpdateManyWithoutDepartmentNestedInput
    monthlyReports?: DepartmentMonthlyReportUpdateManyWithoutDepartmentNestedInput
    goals?: DepartmentGoalUpdateManyWithoutDepartmentNestedInput
    meetings?: DepartmentMeetingUpdateManyWithoutDepartmentNestedInput
    teamDecisions?: TeamDecisionUpdateManyWithoutDepartmentNestedInput
    documents?: DepartmentDocumentUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutPollsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    headId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: DepartmentMemberUncheckedUpdateManyWithoutDepartmentNestedInput
    conversations?: GroupUncheckedUpdateManyWithoutDepartmentNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutDepartmentNestedInput
    eventBroadcasts?: EventDepartmentBroadcastUncheckedUpdateManyWithoutDepartmentNestedInput
    monthlyReports?: DepartmentMonthlyReportUncheckedUpdateManyWithoutDepartmentNestedInput
    goals?: DepartmentGoalUncheckedUpdateManyWithoutDepartmentNestedInput
    meetings?: DepartmentMeetingUncheckedUpdateManyWithoutDepartmentNestedInput
    teamDecisions?: TeamDecisionUncheckedUpdateManyWithoutDepartmentNestedInput
    documents?: DepartmentDocumentUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type UserUpsertWithoutCreatedPollsInput = {
    update: XOR<UserUpdateWithoutCreatedPollsInput, UserUncheckedUpdateWithoutCreatedPollsInput>
    create: XOR<UserCreateWithoutCreatedPollsInput, UserUncheckedCreateWithoutCreatedPollsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedPollsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedPollsInput, UserUncheckedUpdateWithoutCreatedPollsInput>
  }

  export type UserUpdateWithoutCreatedPollsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUpdateManyWithoutUserNestedInput
    userPage?: UserPageUpdateOneWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    postReads?: PostReadUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedPollsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUncheckedUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    userPage?: UserPageUncheckedUpdateOneWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    postReads?: PostReadUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUncheckedUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUncheckedUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUncheckedUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUncheckedUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUncheckedUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUncheckedUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUncheckedUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUncheckedUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type PollVoteUpsertWithWhereUniqueWithoutPollInput = {
    where: PollVoteWhereUniqueInput
    update: XOR<PollVoteUpdateWithoutPollInput, PollVoteUncheckedUpdateWithoutPollInput>
    create: XOR<PollVoteCreateWithoutPollInput, PollVoteUncheckedCreateWithoutPollInput>
  }

  export type PollVoteUpdateWithWhereUniqueWithoutPollInput = {
    where: PollVoteWhereUniqueInput
    data: XOR<PollVoteUpdateWithoutPollInput, PollVoteUncheckedUpdateWithoutPollInput>
  }

  export type PollVoteUpdateManyWithWhereWithoutPollInput = {
    where: PollVoteScalarWhereInput
    data: XOR<PollVoteUpdateManyMutationInput, PollVoteUncheckedUpdateManyWithoutPollInput>
  }

  export type DepartmentPollCreateWithoutVotesInput = {
    id?: string
    question: string
    options: JsonNullValueInput | InputJsonValue
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department: DepartmentCreateNestedOneWithoutPollsInput
    creator: UserCreateNestedOneWithoutCreatedPollsInput
  }

  export type DepartmentPollUncheckedCreateWithoutVotesInput = {
    id?: string
    deptId: string
    question: string
    options: JsonNullValueInput | InputJsonValue
    endDate?: Date | string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentPollCreateOrConnectWithoutVotesInput = {
    where: DepartmentPollWhereUniqueInput
    create: XOR<DepartmentPollCreateWithoutVotesInput, DepartmentPollUncheckedCreateWithoutVotesInput>
  }

  export type UserCreateWithoutPollVotesInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberCreateNestedManyWithoutUserInput
    userPage?: UserPageCreateNestedOneWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    postReads?: PostReadCreateNestedManyWithoutUserInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionCreateNestedManyWithoutCreatorInput
    decisionVotes?: DecisionVoteCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    invitations?: UserInvitationCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutPollVotesInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementUncheckedCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberUncheckedCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    userPage?: UserPageUncheckedCreateNestedOneWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    postReads?: PostReadUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageUncheckedCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingUncheckedCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollUncheckedCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionUncheckedCreateNestedManyWithoutCreatorInput
    decisionVotes?: DecisionVoteUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitations?: UserInvitationUncheckedCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskUncheckedCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalUncheckedCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileUncheckedCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementUncheckedCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutPollVotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPollVotesInput, UserUncheckedCreateWithoutPollVotesInput>
  }

  export type DepartmentPollUpsertWithoutVotesInput = {
    update: XOR<DepartmentPollUpdateWithoutVotesInput, DepartmentPollUncheckedUpdateWithoutVotesInput>
    create: XOR<DepartmentPollCreateWithoutVotesInput, DepartmentPollUncheckedCreateWithoutVotesInput>
    where?: DepartmentPollWhereInput
  }

  export type DepartmentPollUpdateToOneWithWhereWithoutVotesInput = {
    where?: DepartmentPollWhereInput
    data: XOR<DepartmentPollUpdateWithoutVotesInput, DepartmentPollUncheckedUpdateWithoutVotesInput>
  }

  export type DepartmentPollUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneRequiredWithoutPollsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedPollsNestedInput
  }

  export type DepartmentPollUncheckedUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    deptId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutPollVotesInput = {
    update: XOR<UserUpdateWithoutPollVotesInput, UserUncheckedUpdateWithoutPollVotesInput>
    create: XOR<UserCreateWithoutPollVotesInput, UserUncheckedCreateWithoutPollVotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPollVotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPollVotesInput, UserUncheckedUpdateWithoutPollVotesInput>
  }

  export type UserUpdateWithoutPollVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUpdateManyWithoutUserNestedInput
    userPage?: UserPageUpdateOneWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    postReads?: PostReadUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUpdateManyWithoutCreatorNestedInput
    decisionVotes?: DecisionVoteUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutPollVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUncheckedUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    userPage?: UserPageUncheckedUpdateOneWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    postReads?: PostReadUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUncheckedUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUncheckedUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUncheckedUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUncheckedUpdateManyWithoutCreatorNestedInput
    decisionVotes?: DecisionVoteUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUncheckedUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUncheckedUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUncheckedUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUncheckedUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUncheckedUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type DepartmentCreateWithoutTeamDecisionsInput = {
    id?: string
    name: string
    publicKey: string
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutDepartmentsInput
    head?: UserCreateNestedOneWithoutHeadedDepartmentsInput
    members?: DepartmentMemberCreateNestedManyWithoutDepartmentInput
    conversations?: GroupCreateNestedManyWithoutDepartmentInput
    tasks?: TaskCreateNestedManyWithoutDepartmentInput
    eventBroadcasts?: EventDepartmentBroadcastCreateNestedManyWithoutDepartmentInput
    monthlyReports?: DepartmentMonthlyReportCreateNestedManyWithoutDepartmentInput
    goals?: DepartmentGoalCreateNestedManyWithoutDepartmentInput
    meetings?: DepartmentMeetingCreateNestedManyWithoutDepartmentInput
    polls?: DepartmentPollCreateNestedManyWithoutDepartmentInput
    documents?: DepartmentDocumentCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutTeamDecisionsInput = {
    id?: string
    name: string
    orgId: string
    publicKey: string
    headId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: DepartmentMemberUncheckedCreateNestedManyWithoutDepartmentInput
    conversations?: GroupUncheckedCreateNestedManyWithoutDepartmentInput
    tasks?: TaskUncheckedCreateNestedManyWithoutDepartmentInput
    eventBroadcasts?: EventDepartmentBroadcastUncheckedCreateNestedManyWithoutDepartmentInput
    monthlyReports?: DepartmentMonthlyReportUncheckedCreateNestedManyWithoutDepartmentInput
    goals?: DepartmentGoalUncheckedCreateNestedManyWithoutDepartmentInput
    meetings?: DepartmentMeetingUncheckedCreateNestedManyWithoutDepartmentInput
    polls?: DepartmentPollUncheckedCreateNestedManyWithoutDepartmentInput
    documents?: DepartmentDocumentUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutTeamDecisionsInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutTeamDecisionsInput, DepartmentUncheckedCreateWithoutTeamDecisionsInput>
  }

  export type UserCreateWithoutCreatedDecisionsInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberCreateNestedManyWithoutUserInput
    userPage?: UserPageCreateNestedOneWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    postReads?: PostReadCreateNestedManyWithoutUserInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    invitations?: UserInvitationCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutCreatedDecisionsInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementUncheckedCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberUncheckedCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    userPage?: UserPageUncheckedCreateNestedOneWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    postReads?: PostReadUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageUncheckedCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingUncheckedCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollUncheckedCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitations?: UserInvitationUncheckedCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskUncheckedCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalUncheckedCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileUncheckedCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementUncheckedCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutCreatedDecisionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedDecisionsInput, UserUncheckedCreateWithoutCreatedDecisionsInput>
  }

  export type DecisionVoteCreateWithoutDecisionInput = {
    id?: string
    vote: $Enums.DecisionVoteType
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutDecisionVotesInput
  }

  export type DecisionVoteUncheckedCreateWithoutDecisionInput = {
    id?: string
    userId: string
    vote: $Enums.DecisionVoteType
    createdAt?: Date | string
  }

  export type DecisionVoteCreateOrConnectWithoutDecisionInput = {
    where: DecisionVoteWhereUniqueInput
    create: XOR<DecisionVoteCreateWithoutDecisionInput, DecisionVoteUncheckedCreateWithoutDecisionInput>
  }

  export type DecisionVoteCreateManyDecisionInputEnvelope = {
    data: DecisionVoteCreateManyDecisionInput | DecisionVoteCreateManyDecisionInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentUpsertWithoutTeamDecisionsInput = {
    update: XOR<DepartmentUpdateWithoutTeamDecisionsInput, DepartmentUncheckedUpdateWithoutTeamDecisionsInput>
    create: XOR<DepartmentCreateWithoutTeamDecisionsInput, DepartmentUncheckedCreateWithoutTeamDecisionsInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutTeamDecisionsInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutTeamDecisionsInput, DepartmentUncheckedUpdateWithoutTeamDecisionsInput>
  }

  export type DepartmentUpdateWithoutTeamDecisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutDepartmentsNestedInput
    head?: UserUpdateOneWithoutHeadedDepartmentsNestedInput
    members?: DepartmentMemberUpdateManyWithoutDepartmentNestedInput
    conversations?: GroupUpdateManyWithoutDepartmentNestedInput
    tasks?: TaskUpdateManyWithoutDepartmentNestedInput
    eventBroadcasts?: EventDepartmentBroadcastUpdateManyWithoutDepartmentNestedInput
    monthlyReports?: DepartmentMonthlyReportUpdateManyWithoutDepartmentNestedInput
    goals?: DepartmentGoalUpdateManyWithoutDepartmentNestedInput
    meetings?: DepartmentMeetingUpdateManyWithoutDepartmentNestedInput
    polls?: DepartmentPollUpdateManyWithoutDepartmentNestedInput
    documents?: DepartmentDocumentUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutTeamDecisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    headId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: DepartmentMemberUncheckedUpdateManyWithoutDepartmentNestedInput
    conversations?: GroupUncheckedUpdateManyWithoutDepartmentNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutDepartmentNestedInput
    eventBroadcasts?: EventDepartmentBroadcastUncheckedUpdateManyWithoutDepartmentNestedInput
    monthlyReports?: DepartmentMonthlyReportUncheckedUpdateManyWithoutDepartmentNestedInput
    goals?: DepartmentGoalUncheckedUpdateManyWithoutDepartmentNestedInput
    meetings?: DepartmentMeetingUncheckedUpdateManyWithoutDepartmentNestedInput
    polls?: DepartmentPollUncheckedUpdateManyWithoutDepartmentNestedInput
    documents?: DepartmentDocumentUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type UserUpsertWithoutCreatedDecisionsInput = {
    update: XOR<UserUpdateWithoutCreatedDecisionsInput, UserUncheckedUpdateWithoutCreatedDecisionsInput>
    create: XOR<UserCreateWithoutCreatedDecisionsInput, UserUncheckedCreateWithoutCreatedDecisionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedDecisionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedDecisionsInput, UserUncheckedUpdateWithoutCreatedDecisionsInput>
  }

  export type UserUpdateWithoutCreatedDecisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUpdateManyWithoutUserNestedInput
    userPage?: UserPageUpdateOneWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    postReads?: PostReadUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedDecisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUncheckedUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    userPage?: UserPageUncheckedUpdateOneWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    postReads?: PostReadUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUncheckedUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUncheckedUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUncheckedUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUncheckedUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUncheckedUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUncheckedUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUncheckedUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUncheckedUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type DecisionVoteUpsertWithWhereUniqueWithoutDecisionInput = {
    where: DecisionVoteWhereUniqueInput
    update: XOR<DecisionVoteUpdateWithoutDecisionInput, DecisionVoteUncheckedUpdateWithoutDecisionInput>
    create: XOR<DecisionVoteCreateWithoutDecisionInput, DecisionVoteUncheckedCreateWithoutDecisionInput>
  }

  export type DecisionVoteUpdateWithWhereUniqueWithoutDecisionInput = {
    where: DecisionVoteWhereUniqueInput
    data: XOR<DecisionVoteUpdateWithoutDecisionInput, DecisionVoteUncheckedUpdateWithoutDecisionInput>
  }

  export type DecisionVoteUpdateManyWithWhereWithoutDecisionInput = {
    where: DecisionVoteScalarWhereInput
    data: XOR<DecisionVoteUpdateManyMutationInput, DecisionVoteUncheckedUpdateManyWithoutDecisionInput>
  }

  export type TeamDecisionCreateWithoutVotesInput = {
    id?: string
    title: string
    description?: string | null
    voteDeadline?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    department: DepartmentCreateNestedOneWithoutTeamDecisionsInput
    creator: UserCreateNestedOneWithoutCreatedDecisionsInput
  }

  export type TeamDecisionUncheckedCreateWithoutVotesInput = {
    id?: string
    deptId: string
    title: string
    description?: string | null
    voteDeadline?: Date | string | null
    status?: string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamDecisionCreateOrConnectWithoutVotesInput = {
    where: TeamDecisionWhereUniqueInput
    create: XOR<TeamDecisionCreateWithoutVotesInput, TeamDecisionUncheckedCreateWithoutVotesInput>
  }

  export type UserCreateWithoutDecisionVotesInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberCreateNestedManyWithoutUserInput
    userPage?: UserPageCreateNestedOneWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    postReads?: PostReadCreateNestedManyWithoutUserInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    invitations?: UserInvitationCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutDecisionVotesInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementUncheckedCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberUncheckedCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    userPage?: UserPageUncheckedCreateNestedOneWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    postReads?: PostReadUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageUncheckedCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingUncheckedCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollUncheckedCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionUncheckedCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitations?: UserInvitationUncheckedCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskUncheckedCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalUncheckedCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileUncheckedCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementUncheckedCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutDecisionVotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDecisionVotesInput, UserUncheckedCreateWithoutDecisionVotesInput>
  }

  export type TeamDecisionUpsertWithoutVotesInput = {
    update: XOR<TeamDecisionUpdateWithoutVotesInput, TeamDecisionUncheckedUpdateWithoutVotesInput>
    create: XOR<TeamDecisionCreateWithoutVotesInput, TeamDecisionUncheckedCreateWithoutVotesInput>
    where?: TeamDecisionWhereInput
  }

  export type TeamDecisionUpdateToOneWithWhereWithoutVotesInput = {
    where?: TeamDecisionWhereInput
    data: XOR<TeamDecisionUpdateWithoutVotesInput, TeamDecisionUncheckedUpdateWithoutVotesInput>
  }

  export type TeamDecisionUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    voteDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneRequiredWithoutTeamDecisionsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedDecisionsNestedInput
  }

  export type TeamDecisionUncheckedUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    deptId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    voteDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutDecisionVotesInput = {
    update: XOR<UserUpdateWithoutDecisionVotesInput, UserUncheckedUpdateWithoutDecisionVotesInput>
    create: XOR<UserCreateWithoutDecisionVotesInput, UserUncheckedCreateWithoutDecisionVotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDecisionVotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDecisionVotesInput, UserUncheckedUpdateWithoutDecisionVotesInput>
  }

  export type UserUpdateWithoutDecisionVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUpdateManyWithoutUserNestedInput
    userPage?: UserPageUpdateOneWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    postReads?: PostReadUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutDecisionVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUncheckedUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    userPage?: UserPageUncheckedUpdateOneWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    postReads?: PostReadUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUncheckedUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUncheckedUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUncheckedUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUncheckedUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUncheckedUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUncheckedUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUncheckedUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUncheckedUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUncheckedUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type DepartmentCreateWithoutMembersInput = {
    id?: string
    name: string
    publicKey: string
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutDepartmentsInput
    head?: UserCreateNestedOneWithoutHeadedDepartmentsInput
    conversations?: GroupCreateNestedManyWithoutDepartmentInput
    tasks?: TaskCreateNestedManyWithoutDepartmentInput
    eventBroadcasts?: EventDepartmentBroadcastCreateNestedManyWithoutDepartmentInput
    monthlyReports?: DepartmentMonthlyReportCreateNestedManyWithoutDepartmentInput
    goals?: DepartmentGoalCreateNestedManyWithoutDepartmentInput
    meetings?: DepartmentMeetingCreateNestedManyWithoutDepartmentInput
    polls?: DepartmentPollCreateNestedManyWithoutDepartmentInput
    teamDecisions?: TeamDecisionCreateNestedManyWithoutDepartmentInput
    documents?: DepartmentDocumentCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    orgId: string
    publicKey: string
    headId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: GroupUncheckedCreateNestedManyWithoutDepartmentInput
    tasks?: TaskUncheckedCreateNestedManyWithoutDepartmentInput
    eventBroadcasts?: EventDepartmentBroadcastUncheckedCreateNestedManyWithoutDepartmentInput
    monthlyReports?: DepartmentMonthlyReportUncheckedCreateNestedManyWithoutDepartmentInput
    goals?: DepartmentGoalUncheckedCreateNestedManyWithoutDepartmentInput
    meetings?: DepartmentMeetingUncheckedCreateNestedManyWithoutDepartmentInput
    polls?: DepartmentPollUncheckedCreateNestedManyWithoutDepartmentInput
    teamDecisions?: TeamDecisionUncheckedCreateNestedManyWithoutDepartmentInput
    documents?: DepartmentDocumentUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutMembersInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutMembersInput, DepartmentUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutDeptMembershipsInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementCreateNestedManyWithoutPublisherInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberCreateNestedManyWithoutUserInput
    userPage?: UserPageCreateNestedOneWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    postReads?: PostReadCreateNestedManyWithoutUserInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    invitations?: UserInvitationCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutDeptMembershipsInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementUncheckedCreateNestedManyWithoutPublisherInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    userPage?: UserPageUncheckedCreateNestedOneWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    postReads?: PostReadUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageUncheckedCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingUncheckedCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollUncheckedCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionUncheckedCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitations?: UserInvitationUncheckedCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskUncheckedCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalUncheckedCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileUncheckedCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementUncheckedCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutDeptMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDeptMembershipsInput, UserUncheckedCreateWithoutDeptMembershipsInput>
  }

  export type DepartmentUpsertWithoutMembersInput = {
    update: XOR<DepartmentUpdateWithoutMembersInput, DepartmentUncheckedUpdateWithoutMembersInput>
    create: XOR<DepartmentCreateWithoutMembersInput, DepartmentUncheckedCreateWithoutMembersInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutMembersInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutMembersInput, DepartmentUncheckedUpdateWithoutMembersInput>
  }

  export type DepartmentUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutDepartmentsNestedInput
    head?: UserUpdateOneWithoutHeadedDepartmentsNestedInput
    conversations?: GroupUpdateManyWithoutDepartmentNestedInput
    tasks?: TaskUpdateManyWithoutDepartmentNestedInput
    eventBroadcasts?: EventDepartmentBroadcastUpdateManyWithoutDepartmentNestedInput
    monthlyReports?: DepartmentMonthlyReportUpdateManyWithoutDepartmentNestedInput
    goals?: DepartmentGoalUpdateManyWithoutDepartmentNestedInput
    meetings?: DepartmentMeetingUpdateManyWithoutDepartmentNestedInput
    polls?: DepartmentPollUpdateManyWithoutDepartmentNestedInput
    teamDecisions?: TeamDecisionUpdateManyWithoutDepartmentNestedInput
    documents?: DepartmentDocumentUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    headId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: GroupUncheckedUpdateManyWithoutDepartmentNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutDepartmentNestedInput
    eventBroadcasts?: EventDepartmentBroadcastUncheckedUpdateManyWithoutDepartmentNestedInput
    monthlyReports?: DepartmentMonthlyReportUncheckedUpdateManyWithoutDepartmentNestedInput
    goals?: DepartmentGoalUncheckedUpdateManyWithoutDepartmentNestedInput
    meetings?: DepartmentMeetingUncheckedUpdateManyWithoutDepartmentNestedInput
    polls?: DepartmentPollUncheckedUpdateManyWithoutDepartmentNestedInput
    teamDecisions?: TeamDecisionUncheckedUpdateManyWithoutDepartmentNestedInput
    documents?: DepartmentDocumentUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type UserUpsertWithoutDeptMembershipsInput = {
    update: XOR<UserUpdateWithoutDeptMembershipsInput, UserUncheckedUpdateWithoutDeptMembershipsInput>
    create: XOR<UserCreateWithoutDeptMembershipsInput, UserUncheckedCreateWithoutDeptMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDeptMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDeptMembershipsInput, UserUncheckedUpdateWithoutDeptMembershipsInput>
  }

  export type UserUpdateWithoutDeptMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUpdateManyWithoutPublisherNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUpdateManyWithoutUserNestedInput
    userPage?: UserPageUpdateOneWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    postReads?: PostReadUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutDeptMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUncheckedUpdateManyWithoutPublisherNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    userPage?: UserPageUncheckedUpdateOneWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    postReads?: PostReadUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUncheckedUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUncheckedUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUncheckedUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUncheckedUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUncheckedUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUncheckedUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUncheckedUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUncheckedUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUncheckedUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type DepartmentCreateWithoutConversationsInput = {
    id?: string
    name: string
    publicKey: string
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutDepartmentsInput
    head?: UserCreateNestedOneWithoutHeadedDepartmentsInput
    members?: DepartmentMemberCreateNestedManyWithoutDepartmentInput
    tasks?: TaskCreateNestedManyWithoutDepartmentInput
    eventBroadcasts?: EventDepartmentBroadcastCreateNestedManyWithoutDepartmentInput
    monthlyReports?: DepartmentMonthlyReportCreateNestedManyWithoutDepartmentInput
    goals?: DepartmentGoalCreateNestedManyWithoutDepartmentInput
    meetings?: DepartmentMeetingCreateNestedManyWithoutDepartmentInput
    polls?: DepartmentPollCreateNestedManyWithoutDepartmentInput
    teamDecisions?: TeamDecisionCreateNestedManyWithoutDepartmentInput
    documents?: DepartmentDocumentCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutConversationsInput = {
    id?: string
    name: string
    orgId: string
    publicKey: string
    headId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: DepartmentMemberUncheckedCreateNestedManyWithoutDepartmentInput
    tasks?: TaskUncheckedCreateNestedManyWithoutDepartmentInput
    eventBroadcasts?: EventDepartmentBroadcastUncheckedCreateNestedManyWithoutDepartmentInput
    monthlyReports?: DepartmentMonthlyReportUncheckedCreateNestedManyWithoutDepartmentInput
    goals?: DepartmentGoalUncheckedCreateNestedManyWithoutDepartmentInput
    meetings?: DepartmentMeetingUncheckedCreateNestedManyWithoutDepartmentInput
    polls?: DepartmentPollUncheckedCreateNestedManyWithoutDepartmentInput
    teamDecisions?: TeamDecisionUncheckedCreateNestedManyWithoutDepartmentInput
    documents?: DepartmentDocumentUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutConversationsInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutConversationsInput, DepartmentUncheckedCreateWithoutConversationsInput>
  }

  export type GroupMemberCreateWithoutGroupInput = {
    id?: string
    joinedAt?: Date | string
    lastReadAt?: Date | string
    user: UserCreateNestedOneWithoutGroupMembershipsInput
  }

  export type GroupMemberUncheckedCreateWithoutGroupInput = {
    id?: string
    userId: string
    joinedAt?: Date | string
    lastReadAt?: Date | string
  }

  export type GroupMemberCreateOrConnectWithoutGroupInput = {
    where: GroupMemberWhereUniqueInput
    create: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput>
  }

  export type GroupMemberCreateManyGroupInputEnvelope = {
    data: GroupMemberCreateManyGroupInput | GroupMemberCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutGroupInput = {
    id?: string
    content: string
    isEdited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: AttachmentCreateNestedManyWithoutMessageInput
    sender: UserCreateNestedOneWithoutSentMessagesInput
  }

  export type MessageUncheckedCreateWithoutGroupInput = {
    id?: string
    content: string
    senderId: string
    isEdited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: AttachmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutGroupInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutGroupInput, MessageUncheckedCreateWithoutGroupInput>
  }

  export type MessageCreateManyGroupInputEnvelope = {
    data: MessageCreateManyGroupInput | MessageCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type GroupDocumentCreateWithoutGroupInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: GroupNoteCreateNestedManyWithoutDocumentInput
  }

  export type GroupDocumentUncheckedCreateWithoutGroupInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: GroupNoteUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type GroupDocumentCreateOrConnectWithoutGroupInput = {
    where: GroupDocumentWhereUniqueInput
    create: XOR<GroupDocumentCreateWithoutGroupInput, GroupDocumentUncheckedCreateWithoutGroupInput>
  }

  export type GroupDocumentCreateManyGroupInputEnvelope = {
    data: GroupDocumentCreateManyGroupInput | GroupDocumentCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentUpsertWithoutConversationsInput = {
    update: XOR<DepartmentUpdateWithoutConversationsInput, DepartmentUncheckedUpdateWithoutConversationsInput>
    create: XOR<DepartmentCreateWithoutConversationsInput, DepartmentUncheckedCreateWithoutConversationsInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutConversationsInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutConversationsInput, DepartmentUncheckedUpdateWithoutConversationsInput>
  }

  export type DepartmentUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutDepartmentsNestedInput
    head?: UserUpdateOneWithoutHeadedDepartmentsNestedInput
    members?: DepartmentMemberUpdateManyWithoutDepartmentNestedInput
    tasks?: TaskUpdateManyWithoutDepartmentNestedInput
    eventBroadcasts?: EventDepartmentBroadcastUpdateManyWithoutDepartmentNestedInput
    monthlyReports?: DepartmentMonthlyReportUpdateManyWithoutDepartmentNestedInput
    goals?: DepartmentGoalUpdateManyWithoutDepartmentNestedInput
    meetings?: DepartmentMeetingUpdateManyWithoutDepartmentNestedInput
    polls?: DepartmentPollUpdateManyWithoutDepartmentNestedInput
    teamDecisions?: TeamDecisionUpdateManyWithoutDepartmentNestedInput
    documents?: DepartmentDocumentUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    headId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: DepartmentMemberUncheckedUpdateManyWithoutDepartmentNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutDepartmentNestedInput
    eventBroadcasts?: EventDepartmentBroadcastUncheckedUpdateManyWithoutDepartmentNestedInput
    monthlyReports?: DepartmentMonthlyReportUncheckedUpdateManyWithoutDepartmentNestedInput
    goals?: DepartmentGoalUncheckedUpdateManyWithoutDepartmentNestedInput
    meetings?: DepartmentMeetingUncheckedUpdateManyWithoutDepartmentNestedInput
    polls?: DepartmentPollUncheckedUpdateManyWithoutDepartmentNestedInput
    teamDecisions?: TeamDecisionUncheckedUpdateManyWithoutDepartmentNestedInput
    documents?: DepartmentDocumentUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type GroupMemberUpsertWithWhereUniqueWithoutGroupInput = {
    where: GroupMemberWhereUniqueInput
    update: XOR<GroupMemberUpdateWithoutGroupInput, GroupMemberUncheckedUpdateWithoutGroupInput>
    create: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput>
  }

  export type GroupMemberUpdateWithWhereUniqueWithoutGroupInput = {
    where: GroupMemberWhereUniqueInput
    data: XOR<GroupMemberUpdateWithoutGroupInput, GroupMemberUncheckedUpdateWithoutGroupInput>
  }

  export type GroupMemberUpdateManyWithWhereWithoutGroupInput = {
    where: GroupMemberScalarWhereInput
    data: XOR<GroupMemberUpdateManyMutationInput, GroupMemberUncheckedUpdateManyWithoutGroupInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutGroupInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutGroupInput, MessageUncheckedUpdateWithoutGroupInput>
    create: XOR<MessageCreateWithoutGroupInput, MessageUncheckedCreateWithoutGroupInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutGroupInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutGroupInput, MessageUncheckedUpdateWithoutGroupInput>
  }

  export type MessageUpdateManyWithWhereWithoutGroupInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutGroupInput>
  }

  export type GroupDocumentUpsertWithWhereUniqueWithoutGroupInput = {
    where: GroupDocumentWhereUniqueInput
    update: XOR<GroupDocumentUpdateWithoutGroupInput, GroupDocumentUncheckedUpdateWithoutGroupInput>
    create: XOR<GroupDocumentCreateWithoutGroupInput, GroupDocumentUncheckedCreateWithoutGroupInput>
  }

  export type GroupDocumentUpdateWithWhereUniqueWithoutGroupInput = {
    where: GroupDocumentWhereUniqueInput
    data: XOR<GroupDocumentUpdateWithoutGroupInput, GroupDocumentUncheckedUpdateWithoutGroupInput>
  }

  export type GroupDocumentUpdateManyWithWhereWithoutGroupInput = {
    where: GroupDocumentScalarWhereInput
    data: XOR<GroupDocumentUpdateManyMutationInput, GroupDocumentUncheckedUpdateManyWithoutGroupInput>
  }

  export type GroupDocumentScalarWhereInput = {
    AND?: GroupDocumentScalarWhereInput | GroupDocumentScalarWhereInput[]
    OR?: GroupDocumentScalarWhereInput[]
    NOT?: GroupDocumentScalarWhereInput | GroupDocumentScalarWhereInput[]
    id?: StringFilter<"GroupDocument"> | string
    groupId?: StringFilter<"GroupDocument"> | string
    title?: StringFilter<"GroupDocument"> | string
    createdAt?: DateTimeFilter<"GroupDocument"> | Date | string
    updatedAt?: DateTimeFilter<"GroupDocument"> | Date | string
  }

  export type GroupCreateWithoutDocumentsInput = {
    id?: string
    name?: string | null
    isDirect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutConversationsInput
    members?: GroupMemberCreateNestedManyWithoutGroupInput
    messages?: MessageCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateWithoutDocumentsInput = {
    id?: string
    name?: string | null
    isDirect?: boolean
    deptId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: GroupMemberUncheckedCreateNestedManyWithoutGroupInput
    messages?: MessageUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutDocumentsInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutDocumentsInput, GroupUncheckedCreateWithoutDocumentsInput>
  }

  export type GroupNoteCreateWithoutDocumentInput = {
    id?: string
    title: string
    content: string
    textSize?: $Enums.NoteTextSize
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutGroupNotesInput
  }

  export type GroupNoteUncheckedCreateWithoutDocumentInput = {
    id?: string
    title: string
    content: string
    textSize?: $Enums.NoteTextSize
    order?: number
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupNoteCreateOrConnectWithoutDocumentInput = {
    where: GroupNoteWhereUniqueInput
    create: XOR<GroupNoteCreateWithoutDocumentInput, GroupNoteUncheckedCreateWithoutDocumentInput>
  }

  export type GroupNoteCreateManyDocumentInputEnvelope = {
    data: GroupNoteCreateManyDocumentInput | GroupNoteCreateManyDocumentInput[]
    skipDuplicates?: boolean
  }

  export type GroupUpsertWithoutDocumentsInput = {
    update: XOR<GroupUpdateWithoutDocumentsInput, GroupUncheckedUpdateWithoutDocumentsInput>
    create: XOR<GroupCreateWithoutDocumentsInput, GroupUncheckedCreateWithoutDocumentsInput>
    where?: GroupWhereInput
  }

  export type GroupUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: GroupWhereInput
    data: XOR<GroupUpdateWithoutDocumentsInput, GroupUncheckedUpdateWithoutDocumentsInput>
  }

  export type GroupUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isDirect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutConversationsNestedInput
    members?: GroupMemberUpdateManyWithoutGroupNestedInput
    messages?: MessageUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isDirect?: BoolFieldUpdateOperationsInput | boolean
    deptId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: GroupMemberUncheckedUpdateManyWithoutGroupNestedInput
    messages?: MessageUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type GroupNoteUpsertWithWhereUniqueWithoutDocumentInput = {
    where: GroupNoteWhereUniqueInput
    update: XOR<GroupNoteUpdateWithoutDocumentInput, GroupNoteUncheckedUpdateWithoutDocumentInput>
    create: XOR<GroupNoteCreateWithoutDocumentInput, GroupNoteUncheckedCreateWithoutDocumentInput>
  }

  export type GroupNoteUpdateWithWhereUniqueWithoutDocumentInput = {
    where: GroupNoteWhereUniqueInput
    data: XOR<GroupNoteUpdateWithoutDocumentInput, GroupNoteUncheckedUpdateWithoutDocumentInput>
  }

  export type GroupNoteUpdateManyWithWhereWithoutDocumentInput = {
    where: GroupNoteScalarWhereInput
    data: XOR<GroupNoteUpdateManyMutationInput, GroupNoteUncheckedUpdateManyWithoutDocumentInput>
  }

  export type GroupDocumentCreateWithoutNotesInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    group: GroupCreateNestedOneWithoutDocumentsInput
  }

  export type GroupDocumentUncheckedCreateWithoutNotesInput = {
    id?: string
    groupId: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupDocumentCreateOrConnectWithoutNotesInput = {
    where: GroupDocumentWhereUniqueInput
    create: XOR<GroupDocumentCreateWithoutNotesInput, GroupDocumentUncheckedCreateWithoutNotesInput>
  }

  export type UserCreateWithoutGroupNotesInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberCreateNestedManyWithoutUserInput
    userPage?: UserPageCreateNestedOneWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    postReads?: PostReadCreateNestedManyWithoutUserInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    invitations?: UserInvitationCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentCreateNestedManyWithoutUploaderInput
  }

  export type UserUncheckedCreateWithoutGroupNotesInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementUncheckedCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberUncheckedCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    userPage?: UserPageUncheckedCreateNestedOneWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    postReads?: PostReadUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageUncheckedCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingUncheckedCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollUncheckedCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionUncheckedCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitations?: UserInvitationUncheckedCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskUncheckedCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalUncheckedCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileUncheckedCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementUncheckedCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedCreateNestedManyWithoutUploaderInput
  }

  export type UserCreateOrConnectWithoutGroupNotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGroupNotesInput, UserUncheckedCreateWithoutGroupNotesInput>
  }

  export type GroupDocumentUpsertWithoutNotesInput = {
    update: XOR<GroupDocumentUpdateWithoutNotesInput, GroupDocumentUncheckedUpdateWithoutNotesInput>
    create: XOR<GroupDocumentCreateWithoutNotesInput, GroupDocumentUncheckedCreateWithoutNotesInput>
    where?: GroupDocumentWhereInput
  }

  export type GroupDocumentUpdateToOneWithWhereWithoutNotesInput = {
    where?: GroupDocumentWhereInput
    data: XOR<GroupDocumentUpdateWithoutNotesInput, GroupDocumentUncheckedUpdateWithoutNotesInput>
  }

  export type GroupDocumentUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: GroupUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type GroupDocumentUncheckedUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutGroupNotesInput = {
    update: XOR<UserUpdateWithoutGroupNotesInput, UserUncheckedUpdateWithoutGroupNotesInput>
    create: XOR<UserCreateWithoutGroupNotesInput, UserUncheckedCreateWithoutGroupNotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGroupNotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGroupNotesInput, UserUncheckedUpdateWithoutGroupNotesInput>
  }

  export type UserUpdateWithoutGroupNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUpdateManyWithoutUserNestedInput
    userPage?: UserPageUpdateOneWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    postReads?: PostReadUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUpdateManyWithoutUploaderNestedInput
  }

  export type UserUncheckedUpdateWithoutGroupNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUncheckedUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    userPage?: UserPageUncheckedUpdateOneWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    postReads?: PostReadUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUncheckedUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUncheckedUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUncheckedUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUncheckedUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUncheckedUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUncheckedUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUncheckedUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUncheckedUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUncheckedUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedUpdateManyWithoutUploaderNestedInput
  }

  export type GroupCreateWithoutMembersInput = {
    id?: string
    name?: string | null
    isDirect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutConversationsInput
    messages?: MessageCreateNestedManyWithoutGroupInput
    documents?: GroupDocumentCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateWithoutMembersInput = {
    id?: string
    name?: string | null
    isDirect?: boolean
    deptId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutGroupInput
    documents?: GroupDocumentUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutMembersInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutMembersInput, GroupUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutGroupMembershipsInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberCreateNestedManyWithoutUserInput
    userPage?: UserPageCreateNestedOneWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    postReads?: PostReadCreateNestedManyWithoutUserInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    invitations?: UserInvitationCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutGroupMembershipsInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementUncheckedCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    userPage?: UserPageUncheckedCreateNestedOneWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    postReads?: PostReadUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageUncheckedCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingUncheckedCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollUncheckedCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionUncheckedCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitations?: UserInvitationUncheckedCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskUncheckedCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalUncheckedCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileUncheckedCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementUncheckedCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutGroupMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGroupMembershipsInput, UserUncheckedCreateWithoutGroupMembershipsInput>
  }

  export type GroupUpsertWithoutMembersInput = {
    update: XOR<GroupUpdateWithoutMembersInput, GroupUncheckedUpdateWithoutMembersInput>
    create: XOR<GroupCreateWithoutMembersInput, GroupUncheckedCreateWithoutMembersInput>
    where?: GroupWhereInput
  }

  export type GroupUpdateToOneWithWhereWithoutMembersInput = {
    where?: GroupWhereInput
    data: XOR<GroupUpdateWithoutMembersInput, GroupUncheckedUpdateWithoutMembersInput>
  }

  export type GroupUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isDirect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutConversationsNestedInput
    messages?: MessageUpdateManyWithoutGroupNestedInput
    documents?: GroupDocumentUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isDirect?: BoolFieldUpdateOperationsInput | boolean
    deptId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutGroupNestedInput
    documents?: GroupDocumentUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type UserUpsertWithoutGroupMembershipsInput = {
    update: XOR<UserUpdateWithoutGroupMembershipsInput, UserUncheckedUpdateWithoutGroupMembershipsInput>
    create: XOR<UserCreateWithoutGroupMembershipsInput, UserUncheckedCreateWithoutGroupMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGroupMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGroupMembershipsInput, UserUncheckedUpdateWithoutGroupMembershipsInput>
  }

  export type UserUpdateWithoutGroupMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUpdateManyWithoutUserNestedInput
    userPage?: UserPageUpdateOneWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    postReads?: PostReadUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutGroupMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUncheckedUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    userPage?: UserPageUncheckedUpdateOneWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    postReads?: PostReadUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUncheckedUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUncheckedUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUncheckedUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUncheckedUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUncheckedUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUncheckedUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUncheckedUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUncheckedUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUncheckedUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type AttachmentCreateWithoutMessageInput = {
    id?: string
    type: $Enums.FileType
    filename: string
    data: string
    createdAt?: Date | string
  }

  export type AttachmentUncheckedCreateWithoutMessageInput = {
    id?: string
    type: $Enums.FileType
    filename: string
    data: string
    createdAt?: Date | string
  }

  export type AttachmentCreateOrConnectWithoutMessageInput = {
    where: AttachmentWhereUniqueInput
    create: XOR<AttachmentCreateWithoutMessageInput, AttachmentUncheckedCreateWithoutMessageInput>
  }

  export type AttachmentCreateManyMessageInputEnvelope = {
    data: AttachmentCreateManyMessageInput | AttachmentCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type GroupCreateWithoutMessagesInput = {
    id?: string
    name?: string | null
    isDirect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutConversationsInput
    members?: GroupMemberCreateNestedManyWithoutGroupInput
    documents?: GroupDocumentCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateWithoutMessagesInput = {
    id?: string
    name?: string | null
    isDirect?: boolean
    deptId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: GroupMemberUncheckedCreateNestedManyWithoutGroupInput
    documents?: GroupDocumentUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutMessagesInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutMessagesInput, GroupUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutSentMessagesInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberCreateNestedManyWithoutUserInput
    userPage?: UserPageCreateNestedOneWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    postReads?: PostReadCreateNestedManyWithoutUserInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    invitations?: UserInvitationCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutSentMessagesInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementUncheckedCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberUncheckedCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    userPage?: UserPageUncheckedCreateNestedOneWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    postReads?: PostReadUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageUncheckedCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingUncheckedCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollUncheckedCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionUncheckedCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitations?: UserInvitationUncheckedCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskUncheckedCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalUncheckedCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileUncheckedCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementUncheckedCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutSentMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
  }

  export type AttachmentUpsertWithWhereUniqueWithoutMessageInput = {
    where: AttachmentWhereUniqueInput
    update: XOR<AttachmentUpdateWithoutMessageInput, AttachmentUncheckedUpdateWithoutMessageInput>
    create: XOR<AttachmentCreateWithoutMessageInput, AttachmentUncheckedCreateWithoutMessageInput>
  }

  export type AttachmentUpdateWithWhereUniqueWithoutMessageInput = {
    where: AttachmentWhereUniqueInput
    data: XOR<AttachmentUpdateWithoutMessageInput, AttachmentUncheckedUpdateWithoutMessageInput>
  }

  export type AttachmentUpdateManyWithWhereWithoutMessageInput = {
    where: AttachmentScalarWhereInput
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyWithoutMessageInput>
  }

  export type AttachmentScalarWhereInput = {
    AND?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
    OR?: AttachmentScalarWhereInput[]
    NOT?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
    id?: StringFilter<"Attachment"> | string
    messageId?: StringFilter<"Attachment"> | string
    type?: EnumFileTypeFilter<"Attachment"> | $Enums.FileType
    filename?: StringFilter<"Attachment"> | string
    data?: StringFilter<"Attachment"> | string
    createdAt?: DateTimeFilter<"Attachment"> | Date | string
  }

  export type GroupUpsertWithoutMessagesInput = {
    update: XOR<GroupUpdateWithoutMessagesInput, GroupUncheckedUpdateWithoutMessagesInput>
    create: XOR<GroupCreateWithoutMessagesInput, GroupUncheckedCreateWithoutMessagesInput>
    where?: GroupWhereInput
  }

  export type GroupUpdateToOneWithWhereWithoutMessagesInput = {
    where?: GroupWhereInput
    data: XOR<GroupUpdateWithoutMessagesInput, GroupUncheckedUpdateWithoutMessagesInput>
  }

  export type GroupUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isDirect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutConversationsNestedInput
    members?: GroupMemberUpdateManyWithoutGroupNestedInput
    documents?: GroupDocumentUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isDirect?: BoolFieldUpdateOperationsInput | boolean
    deptId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: GroupMemberUncheckedUpdateManyWithoutGroupNestedInput
    documents?: GroupDocumentUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type UserUpsertWithoutSentMessagesInput = {
    update: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUpdateManyWithoutUserNestedInput
    userPage?: UserPageUpdateOneWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    postReads?: PostReadUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUncheckedUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    userPage?: UserPageUncheckedUpdateOneWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    postReads?: PostReadUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUncheckedUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUncheckedUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUncheckedUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUncheckedUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUncheckedUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUncheckedUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUncheckedUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUncheckedUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUncheckedUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type MessageCreateWithoutAttachmentsInput = {
    id?: string
    content: string
    isEdited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    group: GroupCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutSentMessagesInput
  }

  export type MessageUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    content: string
    senderId: string
    groupId: string
    isEdited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutAttachmentsInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutAttachmentsInput, MessageUncheckedCreateWithoutAttachmentsInput>
  }

  export type MessageUpsertWithoutAttachmentsInput = {
    update: XOR<MessageUpdateWithoutAttachmentsInput, MessageUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<MessageCreateWithoutAttachmentsInput, MessageUncheckedCreateWithoutAttachmentsInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutAttachmentsInput, MessageUncheckedUpdateWithoutAttachmentsInput>
  }

  export type MessageUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: GroupUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    orgMemberships?: OrganizationMemberCreateNestedManyWithoutUserInput
    userPage?: UserPageCreateNestedOneWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    postReads?: PostReadCreateNestedManyWithoutUserInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    invitations?: UserInvitationCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementUncheckedCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberUncheckedCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    orgMemberships?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    userPage?: UserPageUncheckedCreateNestedOneWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    postReads?: PostReadUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageUncheckedCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingUncheckedCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollUncheckedCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionUncheckedCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitations?: UserInvitationUncheckedCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskUncheckedCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalUncheckedCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileUncheckedCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementUncheckedCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    orgMemberships?: OrganizationMemberUpdateManyWithoutUserNestedInput
    userPage?: UserPageUpdateOneWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    postReads?: PostReadUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUncheckedUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    orgMemberships?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    userPage?: UserPageUncheckedUpdateOneWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    postReads?: PostReadUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUncheckedUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUncheckedUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUncheckedUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUncheckedUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUncheckedUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUncheckedUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUncheckedUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUncheckedUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUncheckedUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutPublishedAnnouncementsInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deptMemberships?: DepartmentMemberCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberCreateNestedManyWithoutUserInput
    userPage?: UserPageCreateNestedOneWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    postReads?: PostReadCreateNestedManyWithoutUserInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    invitations?: UserInvitationCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutPublishedAnnouncementsInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deptMemberships?: DepartmentMemberUncheckedCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    userPage?: UserPageUncheckedCreateNestedOneWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    postReads?: PostReadUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageUncheckedCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingUncheckedCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollUncheckedCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionUncheckedCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitations?: UserInvitationUncheckedCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskUncheckedCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalUncheckedCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileUncheckedCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementUncheckedCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutPublishedAnnouncementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPublishedAnnouncementsInput, UserUncheckedCreateWithoutPublishedAnnouncementsInput>
  }

  export type AnnouncementReadCreateWithoutAnnouncementInput = {
    id?: string
    userId: string
    readAt?: Date | string
  }

  export type AnnouncementReadUncheckedCreateWithoutAnnouncementInput = {
    id?: string
    userId: string
    readAt?: Date | string
  }

  export type AnnouncementReadCreateOrConnectWithoutAnnouncementInput = {
    where: AnnouncementReadWhereUniqueInput
    create: XOR<AnnouncementReadCreateWithoutAnnouncementInput, AnnouncementReadUncheckedCreateWithoutAnnouncementInput>
  }

  export type AnnouncementReadCreateManyAnnouncementInputEnvelope = {
    data: AnnouncementReadCreateManyAnnouncementInput | AnnouncementReadCreateManyAnnouncementInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPublishedAnnouncementsInput = {
    update: XOR<UserUpdateWithoutPublishedAnnouncementsInput, UserUncheckedUpdateWithoutPublishedAnnouncementsInput>
    create: XOR<UserCreateWithoutPublishedAnnouncementsInput, UserUncheckedCreateWithoutPublishedAnnouncementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPublishedAnnouncementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPublishedAnnouncementsInput, UserUncheckedUpdateWithoutPublishedAnnouncementsInput>
  }

  export type UserUpdateWithoutPublishedAnnouncementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deptMemberships?: DepartmentMemberUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUpdateManyWithoutUserNestedInput
    userPage?: UserPageUpdateOneWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    postReads?: PostReadUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutPublishedAnnouncementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deptMemberships?: DepartmentMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    userPage?: UserPageUncheckedUpdateOneWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    postReads?: PostReadUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUncheckedUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUncheckedUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUncheckedUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUncheckedUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUncheckedUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUncheckedUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUncheckedUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUncheckedUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUncheckedUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type AnnouncementReadUpsertWithWhereUniqueWithoutAnnouncementInput = {
    where: AnnouncementReadWhereUniqueInput
    update: XOR<AnnouncementReadUpdateWithoutAnnouncementInput, AnnouncementReadUncheckedUpdateWithoutAnnouncementInput>
    create: XOR<AnnouncementReadCreateWithoutAnnouncementInput, AnnouncementReadUncheckedCreateWithoutAnnouncementInput>
  }

  export type AnnouncementReadUpdateWithWhereUniqueWithoutAnnouncementInput = {
    where: AnnouncementReadWhereUniqueInput
    data: XOR<AnnouncementReadUpdateWithoutAnnouncementInput, AnnouncementReadUncheckedUpdateWithoutAnnouncementInput>
  }

  export type AnnouncementReadUpdateManyWithWhereWithoutAnnouncementInput = {
    where: AnnouncementReadScalarWhereInput
    data: XOR<AnnouncementReadUpdateManyMutationInput, AnnouncementReadUncheckedUpdateManyWithoutAnnouncementInput>
  }

  export type AnnouncementReadScalarWhereInput = {
    AND?: AnnouncementReadScalarWhereInput | AnnouncementReadScalarWhereInput[]
    OR?: AnnouncementReadScalarWhereInput[]
    NOT?: AnnouncementReadScalarWhereInput | AnnouncementReadScalarWhereInput[]
    id?: StringFilter<"AnnouncementRead"> | string
    announcementId?: StringFilter<"AnnouncementRead"> | string
    userId?: StringFilter<"AnnouncementRead"> | string
    readAt?: DateTimeFilter<"AnnouncementRead"> | Date | string
  }

  export type AnnouncementCreateWithoutReadsInput = {
    id?: string
    title: string
    content: string
    expiresAt: Date | string
    createdAt?: Date | string
    isActive?: boolean
    publisher: UserCreateNestedOneWithoutPublishedAnnouncementsInput
  }

  export type AnnouncementUncheckedCreateWithoutReadsInput = {
    id?: string
    title: string
    content: string
    publisherId: string
    expiresAt: Date | string
    createdAt?: Date | string
    isActive?: boolean
  }

  export type AnnouncementCreateOrConnectWithoutReadsInput = {
    where: AnnouncementWhereUniqueInput
    create: XOR<AnnouncementCreateWithoutReadsInput, AnnouncementUncheckedCreateWithoutReadsInput>
  }

  export type AnnouncementUpsertWithoutReadsInput = {
    update: XOR<AnnouncementUpdateWithoutReadsInput, AnnouncementUncheckedUpdateWithoutReadsInput>
    create: XOR<AnnouncementCreateWithoutReadsInput, AnnouncementUncheckedCreateWithoutReadsInput>
    where?: AnnouncementWhereInput
  }

  export type AnnouncementUpdateToOneWithWhereWithoutReadsInput = {
    where?: AnnouncementWhereInput
    data: XOR<AnnouncementUpdateWithoutReadsInput, AnnouncementUncheckedUpdateWithoutReadsInput>
  }

  export type AnnouncementUpdateWithoutReadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    publisher?: UserUpdateOneRequiredWithoutPublishedAnnouncementsNestedInput
  }

  export type AnnouncementUncheckedUpdateWithoutReadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publisherId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OrganizationCreateWithoutSubscriptionInput = {
    id?: string
    name: string
    code: string
    logo?: string | null
    address?: string | null
    isSuspended?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    departments?: DepartmentCreateNestedManyWithoutOrganizationInput
    members?: OrganizationMemberCreateNestedManyWithoutOrganizationInput
    events?: EventInvitationCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    name: string
    code: string
    logo?: string | null
    address?: string | null
    isSuspended?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    departments?: DepartmentUncheckedCreateNestedManyWithoutOrganizationInput
    members?: OrganizationMemberUncheckedCreateNestedManyWithoutOrganizationInput
    events?: EventInvitationUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutSubscriptionInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutSubscriptionInput, OrganizationUncheckedCreateWithoutSubscriptionInput>
  }

  export type OrganizationUpsertWithoutSubscriptionInput = {
    update: XOR<OrganizationUpdateWithoutSubscriptionInput, OrganizationUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<OrganizationCreateWithoutSubscriptionInput, OrganizationUncheckedCreateWithoutSubscriptionInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutSubscriptionInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutSubscriptionInput, OrganizationUncheckedUpdateWithoutSubscriptionInput>
  }

  export type OrganizationUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    departments?: DepartmentUpdateManyWithoutOrganizationNestedInput
    members?: OrganizationMemberUpdateManyWithoutOrganizationNestedInput
    events?: EventInvitationUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    departments?: DepartmentUncheckedUpdateManyWithoutOrganizationNestedInput
    members?: OrganizationMemberUncheckedUpdateManyWithoutOrganizationNestedInput
    events?: EventInvitationUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateWithoutEventsInput = {
    id?: string
    name: string
    code: string
    logo?: string | null
    address?: string | null
    isSuspended?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    departments?: DepartmentCreateNestedManyWithoutOrganizationInput
    members?: OrganizationMemberCreateNestedManyWithoutOrganizationInput
    subscription?: SubscriptionCreateNestedOneWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutEventsInput = {
    id?: string
    name: string
    code: string
    logo?: string | null
    address?: string | null
    isSuspended?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    departments?: DepartmentUncheckedCreateNestedManyWithoutOrganizationInput
    members?: OrganizationMemberUncheckedCreateNestedManyWithoutOrganizationInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutEventsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutEventsInput, OrganizationUncheckedCreateWithoutEventsInput>
  }

  export type InvitationRSVPCreateWithoutEventInput = {
    id?: string
    name: string
    phone: string
    createdAt?: Date | string
  }

  export type InvitationRSVPUncheckedCreateWithoutEventInput = {
    id?: string
    name: string
    phone: string
    createdAt?: Date | string
  }

  export type InvitationRSVPCreateOrConnectWithoutEventInput = {
    where: InvitationRSVPWhereUniqueInput
    create: XOR<InvitationRSVPCreateWithoutEventInput, InvitationRSVPUncheckedCreateWithoutEventInput>
  }

  export type InvitationRSVPCreateManyEventInputEnvelope = {
    data: InvitationRSVPCreateManyEventInput | InvitationRSVPCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type EventDepartmentBroadcastCreateWithoutEventInput = {
    id?: string
    createdAt?: Date | string
    department: DepartmentCreateNestedOneWithoutEventBroadcastsInput
  }

  export type EventDepartmentBroadcastUncheckedCreateWithoutEventInput = {
    id?: string
    deptId: string
    createdAt?: Date | string
  }

  export type EventDepartmentBroadcastCreateOrConnectWithoutEventInput = {
    where: EventDepartmentBroadcastWhereUniqueInput
    create: XOR<EventDepartmentBroadcastCreateWithoutEventInput, EventDepartmentBroadcastUncheckedCreateWithoutEventInput>
  }

  export type EventDepartmentBroadcastCreateManyEventInputEnvelope = {
    data: EventDepartmentBroadcastCreateManyEventInput | EventDepartmentBroadcastCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutEventsInput = {
    update: XOR<OrganizationUpdateWithoutEventsInput, OrganizationUncheckedUpdateWithoutEventsInput>
    create: XOR<OrganizationCreateWithoutEventsInput, OrganizationUncheckedCreateWithoutEventsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutEventsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutEventsInput, OrganizationUncheckedUpdateWithoutEventsInput>
  }

  export type OrganizationUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    departments?: DepartmentUpdateManyWithoutOrganizationNestedInput
    members?: OrganizationMemberUpdateManyWithoutOrganizationNestedInput
    subscription?: SubscriptionUpdateOneWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    departments?: DepartmentUncheckedUpdateManyWithoutOrganizationNestedInput
    members?: OrganizationMemberUncheckedUpdateManyWithoutOrganizationNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutOrganizationNestedInput
  }

  export type InvitationRSVPUpsertWithWhereUniqueWithoutEventInput = {
    where: InvitationRSVPWhereUniqueInput
    update: XOR<InvitationRSVPUpdateWithoutEventInput, InvitationRSVPUncheckedUpdateWithoutEventInput>
    create: XOR<InvitationRSVPCreateWithoutEventInput, InvitationRSVPUncheckedCreateWithoutEventInput>
  }

  export type InvitationRSVPUpdateWithWhereUniqueWithoutEventInput = {
    where: InvitationRSVPWhereUniqueInput
    data: XOR<InvitationRSVPUpdateWithoutEventInput, InvitationRSVPUncheckedUpdateWithoutEventInput>
  }

  export type InvitationRSVPUpdateManyWithWhereWithoutEventInput = {
    where: InvitationRSVPScalarWhereInput
    data: XOR<InvitationRSVPUpdateManyMutationInput, InvitationRSVPUncheckedUpdateManyWithoutEventInput>
  }

  export type InvitationRSVPScalarWhereInput = {
    AND?: InvitationRSVPScalarWhereInput | InvitationRSVPScalarWhereInput[]
    OR?: InvitationRSVPScalarWhereInput[]
    NOT?: InvitationRSVPScalarWhereInput | InvitationRSVPScalarWhereInput[]
    id?: StringFilter<"InvitationRSVP"> | string
    eventId?: StringFilter<"InvitationRSVP"> | string
    name?: StringFilter<"InvitationRSVP"> | string
    phone?: StringFilter<"InvitationRSVP"> | string
    createdAt?: DateTimeFilter<"InvitationRSVP"> | Date | string
  }

  export type EventDepartmentBroadcastUpsertWithWhereUniqueWithoutEventInput = {
    where: EventDepartmentBroadcastWhereUniqueInput
    update: XOR<EventDepartmentBroadcastUpdateWithoutEventInput, EventDepartmentBroadcastUncheckedUpdateWithoutEventInput>
    create: XOR<EventDepartmentBroadcastCreateWithoutEventInput, EventDepartmentBroadcastUncheckedCreateWithoutEventInput>
  }

  export type EventDepartmentBroadcastUpdateWithWhereUniqueWithoutEventInput = {
    where: EventDepartmentBroadcastWhereUniqueInput
    data: XOR<EventDepartmentBroadcastUpdateWithoutEventInput, EventDepartmentBroadcastUncheckedUpdateWithoutEventInput>
  }

  export type EventDepartmentBroadcastUpdateManyWithWhereWithoutEventInput = {
    where: EventDepartmentBroadcastScalarWhereInput
    data: XOR<EventDepartmentBroadcastUpdateManyMutationInput, EventDepartmentBroadcastUncheckedUpdateManyWithoutEventInput>
  }

  export type EventInvitationCreateWithoutDepartmentBroadcastsInput = {
    id?: string
    title: string
    description?: string | null
    eventType?: $Enums.EventType
    eventDate: Date | string
    maxAttendees: number
    imageUrl?: string | null
    token: string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutEventsInput
    rsvps?: InvitationRSVPCreateNestedManyWithoutEventInput
  }

  export type EventInvitationUncheckedCreateWithoutDepartmentBroadcastsInput = {
    id?: string
    orgId: string
    title: string
    description?: string | null
    eventType?: $Enums.EventType
    eventDate: Date | string
    maxAttendees: number
    imageUrl?: string | null
    token: string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rsvps?: InvitationRSVPUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventInvitationCreateOrConnectWithoutDepartmentBroadcastsInput = {
    where: EventInvitationWhereUniqueInput
    create: XOR<EventInvitationCreateWithoutDepartmentBroadcastsInput, EventInvitationUncheckedCreateWithoutDepartmentBroadcastsInput>
  }

  export type DepartmentCreateWithoutEventBroadcastsInput = {
    id?: string
    name: string
    publicKey: string
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutDepartmentsInput
    head?: UserCreateNestedOneWithoutHeadedDepartmentsInput
    members?: DepartmentMemberCreateNestedManyWithoutDepartmentInput
    conversations?: GroupCreateNestedManyWithoutDepartmentInput
    tasks?: TaskCreateNestedManyWithoutDepartmentInput
    monthlyReports?: DepartmentMonthlyReportCreateNestedManyWithoutDepartmentInput
    goals?: DepartmentGoalCreateNestedManyWithoutDepartmentInput
    meetings?: DepartmentMeetingCreateNestedManyWithoutDepartmentInput
    polls?: DepartmentPollCreateNestedManyWithoutDepartmentInput
    teamDecisions?: TeamDecisionCreateNestedManyWithoutDepartmentInput
    documents?: DepartmentDocumentCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutEventBroadcastsInput = {
    id?: string
    name: string
    orgId: string
    publicKey: string
    headId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: DepartmentMemberUncheckedCreateNestedManyWithoutDepartmentInput
    conversations?: GroupUncheckedCreateNestedManyWithoutDepartmentInput
    tasks?: TaskUncheckedCreateNestedManyWithoutDepartmentInput
    monthlyReports?: DepartmentMonthlyReportUncheckedCreateNestedManyWithoutDepartmentInput
    goals?: DepartmentGoalUncheckedCreateNestedManyWithoutDepartmentInput
    meetings?: DepartmentMeetingUncheckedCreateNestedManyWithoutDepartmentInput
    polls?: DepartmentPollUncheckedCreateNestedManyWithoutDepartmentInput
    teamDecisions?: TeamDecisionUncheckedCreateNestedManyWithoutDepartmentInput
    documents?: DepartmentDocumentUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutEventBroadcastsInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutEventBroadcastsInput, DepartmentUncheckedCreateWithoutEventBroadcastsInput>
  }

  export type EventInvitationUpsertWithoutDepartmentBroadcastsInput = {
    update: XOR<EventInvitationUpdateWithoutDepartmentBroadcastsInput, EventInvitationUncheckedUpdateWithoutDepartmentBroadcastsInput>
    create: XOR<EventInvitationCreateWithoutDepartmentBroadcastsInput, EventInvitationUncheckedCreateWithoutDepartmentBroadcastsInput>
    where?: EventInvitationWhereInput
  }

  export type EventInvitationUpdateToOneWithWhereWithoutDepartmentBroadcastsInput = {
    where?: EventInvitationWhereInput
    data: XOR<EventInvitationUpdateWithoutDepartmentBroadcastsInput, EventInvitationUncheckedUpdateWithoutDepartmentBroadcastsInput>
  }

  export type EventInvitationUpdateWithoutDepartmentBroadcastsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAttendees?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutEventsNestedInput
    rsvps?: InvitationRSVPUpdateManyWithoutEventNestedInput
  }

  export type EventInvitationUncheckedUpdateWithoutDepartmentBroadcastsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAttendees?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rsvps?: InvitationRSVPUncheckedUpdateManyWithoutEventNestedInput
  }

  export type DepartmentUpsertWithoutEventBroadcastsInput = {
    update: XOR<DepartmentUpdateWithoutEventBroadcastsInput, DepartmentUncheckedUpdateWithoutEventBroadcastsInput>
    create: XOR<DepartmentCreateWithoutEventBroadcastsInput, DepartmentUncheckedCreateWithoutEventBroadcastsInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutEventBroadcastsInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutEventBroadcastsInput, DepartmentUncheckedUpdateWithoutEventBroadcastsInput>
  }

  export type DepartmentUpdateWithoutEventBroadcastsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutDepartmentsNestedInput
    head?: UserUpdateOneWithoutHeadedDepartmentsNestedInput
    members?: DepartmentMemberUpdateManyWithoutDepartmentNestedInput
    conversations?: GroupUpdateManyWithoutDepartmentNestedInput
    tasks?: TaskUpdateManyWithoutDepartmentNestedInput
    monthlyReports?: DepartmentMonthlyReportUpdateManyWithoutDepartmentNestedInput
    goals?: DepartmentGoalUpdateManyWithoutDepartmentNestedInput
    meetings?: DepartmentMeetingUpdateManyWithoutDepartmentNestedInput
    polls?: DepartmentPollUpdateManyWithoutDepartmentNestedInput
    teamDecisions?: TeamDecisionUpdateManyWithoutDepartmentNestedInput
    documents?: DepartmentDocumentUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutEventBroadcastsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    headId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: DepartmentMemberUncheckedUpdateManyWithoutDepartmentNestedInput
    conversations?: GroupUncheckedUpdateManyWithoutDepartmentNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutDepartmentNestedInput
    monthlyReports?: DepartmentMonthlyReportUncheckedUpdateManyWithoutDepartmentNestedInput
    goals?: DepartmentGoalUncheckedUpdateManyWithoutDepartmentNestedInput
    meetings?: DepartmentMeetingUncheckedUpdateManyWithoutDepartmentNestedInput
    polls?: DepartmentPollUncheckedUpdateManyWithoutDepartmentNestedInput
    teamDecisions?: TeamDecisionUncheckedUpdateManyWithoutDepartmentNestedInput
    documents?: DepartmentDocumentUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type EventInvitationCreateWithoutRsvpsInput = {
    id?: string
    title: string
    description?: string | null
    eventType?: $Enums.EventType
    eventDate: Date | string
    maxAttendees: number
    imageUrl?: string | null
    token: string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutEventsInput
    departmentBroadcasts?: EventDepartmentBroadcastCreateNestedManyWithoutEventInput
  }

  export type EventInvitationUncheckedCreateWithoutRsvpsInput = {
    id?: string
    orgId: string
    title: string
    description?: string | null
    eventType?: $Enums.EventType
    eventDate: Date | string
    maxAttendees: number
    imageUrl?: string | null
    token: string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentBroadcasts?: EventDepartmentBroadcastUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventInvitationCreateOrConnectWithoutRsvpsInput = {
    where: EventInvitationWhereUniqueInput
    create: XOR<EventInvitationCreateWithoutRsvpsInput, EventInvitationUncheckedCreateWithoutRsvpsInput>
  }

  export type EventInvitationUpsertWithoutRsvpsInput = {
    update: XOR<EventInvitationUpdateWithoutRsvpsInput, EventInvitationUncheckedUpdateWithoutRsvpsInput>
    create: XOR<EventInvitationCreateWithoutRsvpsInput, EventInvitationUncheckedCreateWithoutRsvpsInput>
    where?: EventInvitationWhereInput
  }

  export type EventInvitationUpdateToOneWithWhereWithoutRsvpsInput = {
    where?: EventInvitationWhereInput
    data: XOR<EventInvitationUpdateWithoutRsvpsInput, EventInvitationUncheckedUpdateWithoutRsvpsInput>
  }

  export type EventInvitationUpdateWithoutRsvpsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAttendees?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutEventsNestedInput
    departmentBroadcasts?: EventDepartmentBroadcastUpdateManyWithoutEventNestedInput
  }

  export type EventInvitationUncheckedUpdateWithoutRsvpsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAttendees?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentBroadcasts?: EventDepartmentBroadcastUncheckedUpdateManyWithoutEventNestedInput
  }

  export type UserCreateWithoutUserPageInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    postReads?: PostReadCreateNestedManyWithoutUserInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    invitations?: UserInvitationCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutUserPageInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementUncheckedCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberUncheckedCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    postReads?: PostReadUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageUncheckedCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingUncheckedCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollUncheckedCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionUncheckedCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitations?: UserInvitationUncheckedCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskUncheckedCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalUncheckedCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileUncheckedCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementUncheckedCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutUserPageInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserPageInput, UserUncheckedCreateWithoutUserPageInput>
  }

  export type PostCreateWithoutPageInput = {
    id?: string
    type: $Enums.PostType
    content: string
    imageUrl?: string | null
    caption?: string | null
    reference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: LikeCreateNestedManyWithoutPostInput
    comments?: CommentCreateNestedManyWithoutPostInput
    postReads?: PostReadCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutPageInput = {
    id?: string
    type: $Enums.PostType
    content: string
    imageUrl?: string | null
    caption?: string | null
    reference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: LikeUncheckedCreateNestedManyWithoutPostInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    postReads?: PostReadUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutPageInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutPageInput, PostUncheckedCreateWithoutPageInput>
  }

  export type PostCreateManyPageInputEnvelope = {
    data: PostCreateManyPageInput | PostCreateManyPageInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutUserPageInput = {
    update: XOR<UserUpdateWithoutUserPageInput, UserUncheckedUpdateWithoutUserPageInput>
    create: XOR<UserCreateWithoutUserPageInput, UserUncheckedCreateWithoutUserPageInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserPageInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserPageInput, UserUncheckedUpdateWithoutUserPageInput>
  }

  export type UserUpdateWithoutUserPageInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    postReads?: PostReadUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutUserPageInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUncheckedUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    postReads?: PostReadUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUncheckedUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUncheckedUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUncheckedUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUncheckedUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUncheckedUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUncheckedUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUncheckedUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUncheckedUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUncheckedUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type PostUpsertWithWhereUniqueWithoutPageInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutPageInput, PostUncheckedUpdateWithoutPageInput>
    create: XOR<PostCreateWithoutPageInput, PostUncheckedCreateWithoutPageInput>
  }

  export type PostUpdateWithWhereUniqueWithoutPageInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutPageInput, PostUncheckedUpdateWithoutPageInput>
  }

  export type PostUpdateManyWithWhereWithoutPageInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutPageInput>
  }

  export type PostScalarWhereInput = {
    AND?: PostScalarWhereInput | PostScalarWhereInput[]
    OR?: PostScalarWhereInput[]
    NOT?: PostScalarWhereInput | PostScalarWhereInput[]
    id?: StringFilter<"Post"> | string
    pageId?: StringFilter<"Post"> | string
    type?: EnumPostTypeFilter<"Post"> | $Enums.PostType
    content?: StringFilter<"Post"> | string
    imageUrl?: StringNullableFilter<"Post"> | string | null
    caption?: StringNullableFilter<"Post"> | string | null
    reference?: StringNullableFilter<"Post"> | string | null
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
  }

  export type UserPageCreateWithoutPostsInput = {
    id?: string
    handle: string
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserPageInput
  }

  export type UserPageUncheckedCreateWithoutPostsInput = {
    id?: string
    userId: string
    handle: string
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPageCreateOrConnectWithoutPostsInput = {
    where: UserPageWhereUniqueInput
    create: XOR<UserPageCreateWithoutPostsInput, UserPageUncheckedCreateWithoutPostsInput>
  }

  export type LikeCreateWithoutPostInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutLikesInput
  }

  export type LikeUncheckedCreateWithoutPostInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type LikeCreateOrConnectWithoutPostInput = {
    where: LikeWhereUniqueInput
    create: XOR<LikeCreateWithoutPostInput, LikeUncheckedCreateWithoutPostInput>
  }

  export type LikeCreateManyPostInputEnvelope = {
    data: LikeCreateManyPostInput | LikeCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutPostInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentInput
  }

  export type CommentUncheckedCreateWithoutPostInput = {
    id?: string
    userId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentCreateOrConnectWithoutPostInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentCreateManyPostInputEnvelope = {
    data: CommentCreateManyPostInput | CommentCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type PostReadCreateWithoutPostInput = {
    id?: string
    readAt?: Date | string
    user: UserCreateNestedOneWithoutPostReadsInput
  }

  export type PostReadUncheckedCreateWithoutPostInput = {
    id?: string
    userId: string
    readAt?: Date | string
  }

  export type PostReadCreateOrConnectWithoutPostInput = {
    where: PostReadWhereUniqueInput
    create: XOR<PostReadCreateWithoutPostInput, PostReadUncheckedCreateWithoutPostInput>
  }

  export type PostReadCreateManyPostInputEnvelope = {
    data: PostReadCreateManyPostInput | PostReadCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type UserPageUpsertWithoutPostsInput = {
    update: XOR<UserPageUpdateWithoutPostsInput, UserPageUncheckedUpdateWithoutPostsInput>
    create: XOR<UserPageCreateWithoutPostsInput, UserPageUncheckedCreateWithoutPostsInput>
    where?: UserPageWhereInput
  }

  export type UserPageUpdateToOneWithWhereWithoutPostsInput = {
    where?: UserPageWhereInput
    data: XOR<UserPageUpdateWithoutPostsInput, UserPageUncheckedUpdateWithoutPostsInput>
  }

  export type UserPageUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    handle?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserPageNestedInput
  }

  export type UserPageUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    handle?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUpsertWithWhereUniqueWithoutPostInput = {
    where: LikeWhereUniqueInput
    update: XOR<LikeUpdateWithoutPostInput, LikeUncheckedUpdateWithoutPostInput>
    create: XOR<LikeCreateWithoutPostInput, LikeUncheckedCreateWithoutPostInput>
  }

  export type LikeUpdateWithWhereUniqueWithoutPostInput = {
    where: LikeWhereUniqueInput
    data: XOR<LikeUpdateWithoutPostInput, LikeUncheckedUpdateWithoutPostInput>
  }

  export type LikeUpdateManyWithWhereWithoutPostInput = {
    where: LikeScalarWhereInput
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyWithoutPostInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
  }

  export type CommentUpdateManyWithWhereWithoutPostInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutPostInput>
  }

  export type PostReadUpsertWithWhereUniqueWithoutPostInput = {
    where: PostReadWhereUniqueInput
    update: XOR<PostReadUpdateWithoutPostInput, PostReadUncheckedUpdateWithoutPostInput>
    create: XOR<PostReadCreateWithoutPostInput, PostReadUncheckedCreateWithoutPostInput>
  }

  export type PostReadUpdateWithWhereUniqueWithoutPostInput = {
    where: PostReadWhereUniqueInput
    data: XOR<PostReadUpdateWithoutPostInput, PostReadUncheckedUpdateWithoutPostInput>
  }

  export type PostReadUpdateManyWithWhereWithoutPostInput = {
    where: PostReadScalarWhereInput
    data: XOR<PostReadUpdateManyMutationInput, PostReadUncheckedUpdateManyWithoutPostInput>
  }

  export type PostCreateWithoutLikesInput = {
    id?: string
    type: $Enums.PostType
    content: string
    imageUrl?: string | null
    caption?: string | null
    reference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    page: UserPageCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    postReads?: PostReadCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutLikesInput = {
    id?: string
    pageId: string
    type: $Enums.PostType
    content: string
    imageUrl?: string | null
    caption?: string | null
    reference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    postReads?: PostReadUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutLikesInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutLikesInput, PostUncheckedCreateWithoutLikesInput>
  }

  export type UserCreateWithoutLikesInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberCreateNestedManyWithoutUserInput
    userPage?: UserPageCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    postReads?: PostReadCreateNestedManyWithoutUserInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    invitations?: UserInvitationCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutLikesInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementUncheckedCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberUncheckedCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    userPage?: UserPageUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    postReads?: PostReadUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageUncheckedCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingUncheckedCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollUncheckedCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionUncheckedCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitations?: UserInvitationUncheckedCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskUncheckedCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalUncheckedCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileUncheckedCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementUncheckedCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutLikesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLikesInput, UserUncheckedCreateWithoutLikesInput>
  }

  export type PostUpsertWithoutLikesInput = {
    update: XOR<PostUpdateWithoutLikesInput, PostUncheckedUpdateWithoutLikesInput>
    create: XOR<PostCreateWithoutLikesInput, PostUncheckedCreateWithoutLikesInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutLikesInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutLikesInput, PostUncheckedUpdateWithoutLikesInput>
  }

  export type PostUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    page?: UserPageUpdateOneRequiredWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    postReads?: PostReadUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageId?: StringFieldUpdateOperationsInput | string
    type?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    postReads?: PostReadUncheckedUpdateManyWithoutPostNestedInput
  }

  export type UserUpsertWithoutLikesInput = {
    update: XOR<UserUpdateWithoutLikesInput, UserUncheckedUpdateWithoutLikesInput>
    create: XOR<UserCreateWithoutLikesInput, UserUncheckedCreateWithoutLikesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLikesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLikesInput, UserUncheckedUpdateWithoutLikesInput>
  }

  export type UserUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUpdateManyWithoutUserNestedInput
    userPage?: UserPageUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    postReads?: PostReadUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUncheckedUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    userPage?: UserPageUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    postReads?: PostReadUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUncheckedUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUncheckedUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUncheckedUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUncheckedUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUncheckedUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUncheckedUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUncheckedUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUncheckedUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUncheckedUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type PostCreateWithoutCommentsInput = {
    id?: string
    type: $Enums.PostType
    content: string
    imageUrl?: string | null
    caption?: string | null
    reference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    page: UserPageCreateNestedOneWithoutPostsInput
    likes?: LikeCreateNestedManyWithoutPostInput
    postReads?: PostReadCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutCommentsInput = {
    id?: string
    pageId: string
    type: $Enums.PostType
    content: string
    imageUrl?: string | null
    caption?: string | null
    reference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: LikeUncheckedCreateNestedManyWithoutPostInput
    postReads?: PostReadUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutCommentsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutCommentsInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberCreateNestedManyWithoutUserInput
    userPage?: UserPageCreateNestedOneWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    postReads?: PostReadCreateNestedManyWithoutUserInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    invitations?: UserInvitationCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementUncheckedCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberUncheckedCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    userPage?: UserPageUncheckedCreateNestedOneWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    postReads?: PostReadUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageUncheckedCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingUncheckedCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollUncheckedCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionUncheckedCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitations?: UserInvitationUncheckedCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskUncheckedCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalUncheckedCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileUncheckedCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementUncheckedCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type CommentCreateWithoutRepliesInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    post: PostCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutRepliesInput
  }

  export type CommentUncheckedCreateWithoutRepliesInput = {
    id?: string
    postId: string
    userId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
  }

  export type CommentCreateOrConnectWithoutRepliesInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
  }

  export type CommentCreateWithoutParentInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    post: PostCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutCommentsInput
    replies?: CommentCreateNestedManyWithoutParentInput
  }

  export type CommentUncheckedCreateWithoutParentInput = {
    id?: string
    postId: string
    userId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentCreateOrConnectWithoutParentInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput>
  }

  export type CommentCreateManyParentInputEnvelope = {
    data: CommentCreateManyParentInput | CommentCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type PostUpsertWithoutCommentsInput = {
    update: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutCommentsInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
  }

  export type PostUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    page?: UserPageUpdateOneRequiredWithoutPostsNestedInput
    likes?: LikeUpdateManyWithoutPostNestedInput
    postReads?: PostReadUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageId?: StringFieldUpdateOperationsInput | string
    type?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: LikeUncheckedUpdateManyWithoutPostNestedInput
    postReads?: PostReadUncheckedUpdateManyWithoutPostNestedInput
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUpdateManyWithoutUserNestedInput
    userPage?: UserPageUpdateOneWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    postReads?: PostReadUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUncheckedUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    userPage?: UserPageUncheckedUpdateOneWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    postReads?: PostReadUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUncheckedUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUncheckedUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUncheckedUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUncheckedUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUncheckedUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUncheckedUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUncheckedUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUncheckedUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUncheckedUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type CommentUpsertWithoutRepliesInput = {
    update: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutRepliesInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
  }

  export type CommentUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutRepliesNestedInput
  }

  export type CommentUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentUpsertWithWhereUniqueWithoutParentInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutParentInput, CommentUncheckedUpdateWithoutParentInput>
    create: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutParentInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutParentInput, CommentUncheckedUpdateWithoutParentInput>
  }

  export type CommentUpdateManyWithWhereWithoutParentInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutParentInput>
  }

  export type UserCreateWithoutPostReadsInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberCreateNestedManyWithoutUserInput
    userPage?: UserPageCreateNestedOneWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    invitations?: UserInvitationCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutPostReadsInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementUncheckedCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberUncheckedCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    userPage?: UserPageUncheckedCreateNestedOneWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageUncheckedCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingUncheckedCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollUncheckedCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionUncheckedCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitations?: UserInvitationUncheckedCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskUncheckedCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalUncheckedCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileUncheckedCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementUncheckedCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutPostReadsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPostReadsInput, UserUncheckedCreateWithoutPostReadsInput>
  }

  export type PostCreateWithoutPostReadsInput = {
    id?: string
    type: $Enums.PostType
    content: string
    imageUrl?: string | null
    caption?: string | null
    reference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    page: UserPageCreateNestedOneWithoutPostsInput
    likes?: LikeCreateNestedManyWithoutPostInput
    comments?: CommentCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutPostReadsInput = {
    id?: string
    pageId: string
    type: $Enums.PostType
    content: string
    imageUrl?: string | null
    caption?: string | null
    reference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: LikeUncheckedCreateNestedManyWithoutPostInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutPostReadsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutPostReadsInput, PostUncheckedCreateWithoutPostReadsInput>
  }

  export type UserUpsertWithoutPostReadsInput = {
    update: XOR<UserUpdateWithoutPostReadsInput, UserUncheckedUpdateWithoutPostReadsInput>
    create: XOR<UserCreateWithoutPostReadsInput, UserUncheckedCreateWithoutPostReadsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPostReadsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPostReadsInput, UserUncheckedUpdateWithoutPostReadsInput>
  }

  export type UserUpdateWithoutPostReadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUpdateManyWithoutUserNestedInput
    userPage?: UserPageUpdateOneWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutPostReadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUncheckedUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    userPage?: UserPageUncheckedUpdateOneWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUncheckedUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUncheckedUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUncheckedUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUncheckedUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUncheckedUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUncheckedUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUncheckedUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUncheckedUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUncheckedUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type PostUpsertWithoutPostReadsInput = {
    update: XOR<PostUpdateWithoutPostReadsInput, PostUncheckedUpdateWithoutPostReadsInput>
    create: XOR<PostCreateWithoutPostReadsInput, PostUncheckedCreateWithoutPostReadsInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutPostReadsInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutPostReadsInput, PostUncheckedUpdateWithoutPostReadsInput>
  }

  export type PostUpdateWithoutPostReadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    page?: UserPageUpdateOneRequiredWithoutPostsNestedInput
    likes?: LikeUpdateManyWithoutPostNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutPostReadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageId?: StringFieldUpdateOperationsInput | string
    type?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: LikeUncheckedUpdateManyWithoutPostNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type DepartmentCreateWithoutTasksInput = {
    id?: string
    name: string
    publicKey: string
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutDepartmentsInput
    head?: UserCreateNestedOneWithoutHeadedDepartmentsInput
    members?: DepartmentMemberCreateNestedManyWithoutDepartmentInput
    conversations?: GroupCreateNestedManyWithoutDepartmentInput
    eventBroadcasts?: EventDepartmentBroadcastCreateNestedManyWithoutDepartmentInput
    monthlyReports?: DepartmentMonthlyReportCreateNestedManyWithoutDepartmentInput
    goals?: DepartmentGoalCreateNestedManyWithoutDepartmentInput
    meetings?: DepartmentMeetingCreateNestedManyWithoutDepartmentInput
    polls?: DepartmentPollCreateNestedManyWithoutDepartmentInput
    teamDecisions?: TeamDecisionCreateNestedManyWithoutDepartmentInput
    documents?: DepartmentDocumentCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutTasksInput = {
    id?: string
    name: string
    orgId: string
    publicKey: string
    headId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: DepartmentMemberUncheckedCreateNestedManyWithoutDepartmentInput
    conversations?: GroupUncheckedCreateNestedManyWithoutDepartmentInput
    eventBroadcasts?: EventDepartmentBroadcastUncheckedCreateNestedManyWithoutDepartmentInput
    monthlyReports?: DepartmentMonthlyReportUncheckedCreateNestedManyWithoutDepartmentInput
    goals?: DepartmentGoalUncheckedCreateNestedManyWithoutDepartmentInput
    meetings?: DepartmentMeetingUncheckedCreateNestedManyWithoutDepartmentInput
    polls?: DepartmentPollUncheckedCreateNestedManyWithoutDepartmentInput
    teamDecisions?: TeamDecisionUncheckedCreateNestedManyWithoutDepartmentInput
    documents?: DepartmentDocumentUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutTasksInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutTasksInput, DepartmentUncheckedCreateWithoutTasksInput>
  }

  export type UserCreateWithoutCreatedTasksInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberCreateNestedManyWithoutUserInput
    userPage?: UserPageCreateNestedOneWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    postReads?: PostReadCreateNestedManyWithoutUserInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    invitations?: UserInvitationCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutCreatedTasksInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementUncheckedCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberUncheckedCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    userPage?: UserPageUncheckedCreateNestedOneWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    postReads?: PostReadUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageUncheckedCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingUncheckedCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollUncheckedCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionUncheckedCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitations?: UserInvitationUncheckedCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskUncheckedCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalUncheckedCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileUncheckedCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementUncheckedCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutCreatedTasksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedTasksInput, UserUncheckedCreateWithoutCreatedTasksInput>
  }

  export type UserCreateWithoutAssignedTasksInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberCreateNestedManyWithoutUserInput
    userPage?: UserPageCreateNestedOneWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    postReads?: PostReadCreateNestedManyWithoutUserInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    invitations?: UserInvitationCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutAssignedTasksInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementUncheckedCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberUncheckedCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    userPage?: UserPageUncheckedCreateNestedOneWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    postReads?: PostReadUncheckedCreateNestedManyWithoutUserInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageUncheckedCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingUncheckedCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollUncheckedCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionUncheckedCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitations?: UserInvitationUncheckedCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskUncheckedCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalUncheckedCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileUncheckedCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementUncheckedCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutAssignedTasksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedTasksInput, UserUncheckedCreateWithoutAssignedTasksInput>
  }

  export type TaskMessageCreateWithoutTaskInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sender: UserCreateNestedOneWithoutTaskMessagesInput
    attachments?: TaskAttachmentCreateNestedManyWithoutMessageInput
  }

  export type TaskMessageUncheckedCreateWithoutTaskInput = {
    id?: string
    senderId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: TaskAttachmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type TaskMessageCreateOrConnectWithoutTaskInput = {
    where: TaskMessageWhereUniqueInput
    create: XOR<TaskMessageCreateWithoutTaskInput, TaskMessageUncheckedCreateWithoutTaskInput>
  }

  export type TaskMessageCreateManyTaskInputEnvelope = {
    data: TaskMessageCreateManyTaskInput | TaskMessageCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type TaskAttachmentCreateWithoutTaskInput = {
    id?: string
    uploaderId: string
    filename: string
    url: string
    fileType?: string | null
    size?: number | null
    createdAt?: Date | string
    message?: TaskMessageCreateNestedOneWithoutAttachmentsInput
  }

  export type TaskAttachmentUncheckedCreateWithoutTaskInput = {
    id?: string
    messageId?: string | null
    uploaderId: string
    filename: string
    url: string
    fileType?: string | null
    size?: number | null
    createdAt?: Date | string
  }

  export type TaskAttachmentCreateOrConnectWithoutTaskInput = {
    where: TaskAttachmentWhereUniqueInput
    create: XOR<TaskAttachmentCreateWithoutTaskInput, TaskAttachmentUncheckedCreateWithoutTaskInput>
  }

  export type TaskAttachmentCreateManyTaskInputEnvelope = {
    data: TaskAttachmentCreateManyTaskInput | TaskAttachmentCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentUpsertWithoutTasksInput = {
    update: XOR<DepartmentUpdateWithoutTasksInput, DepartmentUncheckedUpdateWithoutTasksInput>
    create: XOR<DepartmentCreateWithoutTasksInput, DepartmentUncheckedCreateWithoutTasksInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutTasksInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutTasksInput, DepartmentUncheckedUpdateWithoutTasksInput>
  }

  export type DepartmentUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutDepartmentsNestedInput
    head?: UserUpdateOneWithoutHeadedDepartmentsNestedInput
    members?: DepartmentMemberUpdateManyWithoutDepartmentNestedInput
    conversations?: GroupUpdateManyWithoutDepartmentNestedInput
    eventBroadcasts?: EventDepartmentBroadcastUpdateManyWithoutDepartmentNestedInput
    monthlyReports?: DepartmentMonthlyReportUpdateManyWithoutDepartmentNestedInput
    goals?: DepartmentGoalUpdateManyWithoutDepartmentNestedInput
    meetings?: DepartmentMeetingUpdateManyWithoutDepartmentNestedInput
    polls?: DepartmentPollUpdateManyWithoutDepartmentNestedInput
    teamDecisions?: TeamDecisionUpdateManyWithoutDepartmentNestedInput
    documents?: DepartmentDocumentUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    headId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: DepartmentMemberUncheckedUpdateManyWithoutDepartmentNestedInput
    conversations?: GroupUncheckedUpdateManyWithoutDepartmentNestedInput
    eventBroadcasts?: EventDepartmentBroadcastUncheckedUpdateManyWithoutDepartmentNestedInput
    monthlyReports?: DepartmentMonthlyReportUncheckedUpdateManyWithoutDepartmentNestedInput
    goals?: DepartmentGoalUncheckedUpdateManyWithoutDepartmentNestedInput
    meetings?: DepartmentMeetingUncheckedUpdateManyWithoutDepartmentNestedInput
    polls?: DepartmentPollUncheckedUpdateManyWithoutDepartmentNestedInput
    teamDecisions?: TeamDecisionUncheckedUpdateManyWithoutDepartmentNestedInput
    documents?: DepartmentDocumentUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type UserUpsertWithoutCreatedTasksInput = {
    update: XOR<UserUpdateWithoutCreatedTasksInput, UserUncheckedUpdateWithoutCreatedTasksInput>
    create: XOR<UserCreateWithoutCreatedTasksInput, UserUncheckedCreateWithoutCreatedTasksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedTasksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedTasksInput, UserUncheckedUpdateWithoutCreatedTasksInput>
  }

  export type UserUpdateWithoutCreatedTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUpdateManyWithoutUserNestedInput
    userPage?: UserPageUpdateOneWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    postReads?: PostReadUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUncheckedUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    userPage?: UserPageUncheckedUpdateOneWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    postReads?: PostReadUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUncheckedUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUncheckedUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUncheckedUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUncheckedUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUncheckedUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUncheckedUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUncheckedUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUncheckedUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUncheckedUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserUpsertWithoutAssignedTasksInput = {
    update: XOR<UserUpdateWithoutAssignedTasksInput, UserUncheckedUpdateWithoutAssignedTasksInput>
    create: XOR<UserCreateWithoutAssignedTasksInput, UserUncheckedCreateWithoutAssignedTasksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedTasksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedTasksInput, UserUncheckedUpdateWithoutAssignedTasksInput>
  }

  export type UserUpdateWithoutAssignedTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUpdateManyWithoutUserNestedInput
    userPage?: UserPageUpdateOneWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    postReads?: PostReadUpdateManyWithoutUserNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUncheckedUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    userPage?: UserPageUncheckedUpdateOneWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    postReads?: PostReadUncheckedUpdateManyWithoutUserNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUncheckedUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUncheckedUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUncheckedUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUncheckedUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUncheckedUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUncheckedUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUncheckedUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUncheckedUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUncheckedUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type TaskMessageUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskMessageWhereUniqueInput
    update: XOR<TaskMessageUpdateWithoutTaskInput, TaskMessageUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskMessageCreateWithoutTaskInput, TaskMessageUncheckedCreateWithoutTaskInput>
  }

  export type TaskMessageUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskMessageWhereUniqueInput
    data: XOR<TaskMessageUpdateWithoutTaskInput, TaskMessageUncheckedUpdateWithoutTaskInput>
  }

  export type TaskMessageUpdateManyWithWhereWithoutTaskInput = {
    where: TaskMessageScalarWhereInput
    data: XOR<TaskMessageUpdateManyMutationInput, TaskMessageUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskAttachmentUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskAttachmentWhereUniqueInput
    update: XOR<TaskAttachmentUpdateWithoutTaskInput, TaskAttachmentUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskAttachmentCreateWithoutTaskInput, TaskAttachmentUncheckedCreateWithoutTaskInput>
  }

  export type TaskAttachmentUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskAttachmentWhereUniqueInput
    data: XOR<TaskAttachmentUpdateWithoutTaskInput, TaskAttachmentUncheckedUpdateWithoutTaskInput>
  }

  export type TaskAttachmentUpdateManyWithWhereWithoutTaskInput = {
    where: TaskAttachmentScalarWhereInput
    data: XOR<TaskAttachmentUpdateManyMutationInput, TaskAttachmentUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskAttachmentScalarWhereInput = {
    AND?: TaskAttachmentScalarWhereInput | TaskAttachmentScalarWhereInput[]
    OR?: TaskAttachmentScalarWhereInput[]
    NOT?: TaskAttachmentScalarWhereInput | TaskAttachmentScalarWhereInput[]
    id?: StringFilter<"TaskAttachment"> | string
    taskId?: StringFilter<"TaskAttachment"> | string
    messageId?: StringNullableFilter<"TaskAttachment"> | string | null
    uploaderId?: StringFilter<"TaskAttachment"> | string
    filename?: StringFilter<"TaskAttachment"> | string
    url?: StringFilter<"TaskAttachment"> | string
    fileType?: StringNullableFilter<"TaskAttachment"> | string | null
    size?: IntNullableFilter<"TaskAttachment"> | number | null
    createdAt?: DateTimeFilter<"TaskAttachment"> | Date | string
  }

  export type TaskCreateWithoutMessagesInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.TaskPriority
    startDate?: Date | string | null
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department: DepartmentCreateNestedOneWithoutTasksInput
    creator: UserCreateNestedOneWithoutCreatedTasksInput
    assignee: UserCreateNestedOneWithoutAssignedTasksInput
    attachments?: TaskAttachmentCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutMessagesInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.TaskPriority
    startDate?: Date | string | null
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deptId: string
    creatorId: string
    assigneeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: TaskAttachmentUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutMessagesInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutMessagesInput, TaskUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutTaskMessagesInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberCreateNestedManyWithoutUserInput
    userPage?: UserPageCreateNestedOneWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    postReads?: PostReadCreateNestedManyWithoutUserInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
    departmentMonthlyReports?: DepartmentMonthlyReportCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    invitations?: UserInvitationCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutTaskMessagesInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementUncheckedCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberUncheckedCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    userPage?: UserPageUncheckedCreateNestedOneWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    postReads?: PostReadUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingUncheckedCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollUncheckedCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionUncheckedCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitations?: UserInvitationUncheckedCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskUncheckedCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalUncheckedCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileUncheckedCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementUncheckedCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutTaskMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTaskMessagesInput, UserUncheckedCreateWithoutTaskMessagesInput>
  }

  export type TaskAttachmentCreateWithoutMessageInput = {
    id?: string
    uploaderId: string
    filename: string
    url: string
    fileType?: string | null
    size?: number | null
    createdAt?: Date | string
    task: TaskCreateNestedOneWithoutAttachmentsInput
  }

  export type TaskAttachmentUncheckedCreateWithoutMessageInput = {
    id?: string
    taskId: string
    uploaderId: string
    filename: string
    url: string
    fileType?: string | null
    size?: number | null
    createdAt?: Date | string
  }

  export type TaskAttachmentCreateOrConnectWithoutMessageInput = {
    where: TaskAttachmentWhereUniqueInput
    create: XOR<TaskAttachmentCreateWithoutMessageInput, TaskAttachmentUncheckedCreateWithoutMessageInput>
  }

  export type TaskAttachmentCreateManyMessageInputEnvelope = {
    data: TaskAttachmentCreateManyMessageInput | TaskAttachmentCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type TaskUpsertWithoutMessagesInput = {
    update: XOR<TaskUpdateWithoutMessagesInput, TaskUncheckedUpdateWithoutMessagesInput>
    create: XOR<TaskCreateWithoutMessagesInput, TaskUncheckedCreateWithoutMessagesInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutMessagesInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutMessagesInput, TaskUncheckedUpdateWithoutMessagesInput>
  }

  export type TaskUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneRequiredWithoutTasksNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedTasksNestedInput
    assignee?: UserUpdateOneRequiredWithoutAssignedTasksNestedInput
    attachments?: TaskAttachmentUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deptId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    assigneeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: TaskAttachmentUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type UserUpsertWithoutTaskMessagesInput = {
    update: XOR<UserUpdateWithoutTaskMessagesInput, UserUncheckedUpdateWithoutTaskMessagesInput>
    create: XOR<UserCreateWithoutTaskMessagesInput, UserUncheckedCreateWithoutTaskMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTaskMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTaskMessagesInput, UserUncheckedUpdateWithoutTaskMessagesInput>
  }

  export type UserUpdateWithoutTaskMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUpdateManyWithoutUserNestedInput
    userPage?: UserPageUpdateOneWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    postReads?: PostReadUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutTaskMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUncheckedUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    userPage?: UserPageUncheckedUpdateOneWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    postReads?: PostReadUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUncheckedUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUncheckedUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUncheckedUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUncheckedUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUncheckedUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUncheckedUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUncheckedUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUncheckedUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type TaskAttachmentUpsertWithWhereUniqueWithoutMessageInput = {
    where: TaskAttachmentWhereUniqueInput
    update: XOR<TaskAttachmentUpdateWithoutMessageInput, TaskAttachmentUncheckedUpdateWithoutMessageInput>
    create: XOR<TaskAttachmentCreateWithoutMessageInput, TaskAttachmentUncheckedCreateWithoutMessageInput>
  }

  export type TaskAttachmentUpdateWithWhereUniqueWithoutMessageInput = {
    where: TaskAttachmentWhereUniqueInput
    data: XOR<TaskAttachmentUpdateWithoutMessageInput, TaskAttachmentUncheckedUpdateWithoutMessageInput>
  }

  export type TaskAttachmentUpdateManyWithWhereWithoutMessageInput = {
    where: TaskAttachmentScalarWhereInput
    data: XOR<TaskAttachmentUpdateManyMutationInput, TaskAttachmentUncheckedUpdateManyWithoutMessageInput>
  }

  export type TaskCreateWithoutAttachmentsInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.TaskPriority
    startDate?: Date | string | null
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department: DepartmentCreateNestedOneWithoutTasksInput
    creator: UserCreateNestedOneWithoutCreatedTasksInput
    assignee: UserCreateNestedOneWithoutAssignedTasksInput
    messages?: TaskMessageCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.TaskPriority
    startDate?: Date | string | null
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deptId: string
    creatorId: string
    assigneeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: TaskMessageUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutAttachmentsInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutAttachmentsInput, TaskUncheckedCreateWithoutAttachmentsInput>
  }

  export type TaskMessageCreateWithoutAttachmentsInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    task: TaskCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutTaskMessagesInput
  }

  export type TaskMessageUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    taskId: string
    senderId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskMessageCreateOrConnectWithoutAttachmentsInput = {
    where: TaskMessageWhereUniqueInput
    create: XOR<TaskMessageCreateWithoutAttachmentsInput, TaskMessageUncheckedCreateWithoutAttachmentsInput>
  }

  export type TaskUpsertWithoutAttachmentsInput = {
    update: XOR<TaskUpdateWithoutAttachmentsInput, TaskUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<TaskCreateWithoutAttachmentsInput, TaskUncheckedCreateWithoutAttachmentsInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutAttachmentsInput, TaskUncheckedUpdateWithoutAttachmentsInput>
  }

  export type TaskUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneRequiredWithoutTasksNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedTasksNestedInput
    assignee?: UserUpdateOneRequiredWithoutAssignedTasksNestedInput
    messages?: TaskMessageUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deptId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    assigneeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: TaskMessageUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskMessageUpsertWithoutAttachmentsInput = {
    update: XOR<TaskMessageUpdateWithoutAttachmentsInput, TaskMessageUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<TaskMessageCreateWithoutAttachmentsInput, TaskMessageUncheckedCreateWithoutAttachmentsInput>
    where?: TaskMessageWhereInput
  }

  export type TaskMessageUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: TaskMessageWhereInput
    data: XOR<TaskMessageUpdateWithoutAttachmentsInput, TaskMessageUncheckedUpdateWithoutAttachmentsInput>
  }

  export type TaskMessageUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutTaskMessagesNestedInput
  }

  export type TaskMessageUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentCreateWithoutMonthlyReportsInput = {
    id?: string
    name: string
    publicKey: string
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutDepartmentsInput
    head?: UserCreateNestedOneWithoutHeadedDepartmentsInput
    members?: DepartmentMemberCreateNestedManyWithoutDepartmentInput
    conversations?: GroupCreateNestedManyWithoutDepartmentInput
    tasks?: TaskCreateNestedManyWithoutDepartmentInput
    eventBroadcasts?: EventDepartmentBroadcastCreateNestedManyWithoutDepartmentInput
    goals?: DepartmentGoalCreateNestedManyWithoutDepartmentInput
    meetings?: DepartmentMeetingCreateNestedManyWithoutDepartmentInput
    polls?: DepartmentPollCreateNestedManyWithoutDepartmentInput
    teamDecisions?: TeamDecisionCreateNestedManyWithoutDepartmentInput
    documents?: DepartmentDocumentCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutMonthlyReportsInput = {
    id?: string
    name: string
    orgId: string
    publicKey: string
    headId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: DepartmentMemberUncheckedCreateNestedManyWithoutDepartmentInput
    conversations?: GroupUncheckedCreateNestedManyWithoutDepartmentInput
    tasks?: TaskUncheckedCreateNestedManyWithoutDepartmentInput
    eventBroadcasts?: EventDepartmentBroadcastUncheckedCreateNestedManyWithoutDepartmentInput
    goals?: DepartmentGoalUncheckedCreateNestedManyWithoutDepartmentInput
    meetings?: DepartmentMeetingUncheckedCreateNestedManyWithoutDepartmentInput
    polls?: DepartmentPollUncheckedCreateNestedManyWithoutDepartmentInput
    teamDecisions?: TeamDecisionUncheckedCreateNestedManyWithoutDepartmentInput
    documents?: DepartmentDocumentUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutMonthlyReportsInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutMonthlyReportsInput, DepartmentUncheckedCreateWithoutMonthlyReportsInput>
  }

  export type UserCreateWithoutDepartmentMonthlyReportsInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberCreateNestedManyWithoutUserInput
    userPage?: UserPageCreateNestedOneWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    postReads?: PostReadCreateNestedManyWithoutUserInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageCreateNestedManyWithoutSenderInput
    createdMeetings?: DepartmentMeetingCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    invitations?: UserInvitationCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutDepartmentMonthlyReportsInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementUncheckedCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberUncheckedCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    userPage?: UserPageUncheckedCreateNestedOneWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    postReads?: PostReadUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageUncheckedCreateNestedManyWithoutSenderInput
    createdMeetings?: DepartmentMeetingUncheckedCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollUncheckedCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionUncheckedCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitations?: UserInvitationUncheckedCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskUncheckedCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalUncheckedCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileUncheckedCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementUncheckedCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutDepartmentMonthlyReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDepartmentMonthlyReportsInput, UserUncheckedCreateWithoutDepartmentMonthlyReportsInput>
  }

  export type DepartmentUpsertWithoutMonthlyReportsInput = {
    update: XOR<DepartmentUpdateWithoutMonthlyReportsInput, DepartmentUncheckedUpdateWithoutMonthlyReportsInput>
    create: XOR<DepartmentCreateWithoutMonthlyReportsInput, DepartmentUncheckedCreateWithoutMonthlyReportsInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutMonthlyReportsInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutMonthlyReportsInput, DepartmentUncheckedUpdateWithoutMonthlyReportsInput>
  }

  export type DepartmentUpdateWithoutMonthlyReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutDepartmentsNestedInput
    head?: UserUpdateOneWithoutHeadedDepartmentsNestedInput
    members?: DepartmentMemberUpdateManyWithoutDepartmentNestedInput
    conversations?: GroupUpdateManyWithoutDepartmentNestedInput
    tasks?: TaskUpdateManyWithoutDepartmentNestedInput
    eventBroadcasts?: EventDepartmentBroadcastUpdateManyWithoutDepartmentNestedInput
    goals?: DepartmentGoalUpdateManyWithoutDepartmentNestedInput
    meetings?: DepartmentMeetingUpdateManyWithoutDepartmentNestedInput
    polls?: DepartmentPollUpdateManyWithoutDepartmentNestedInput
    teamDecisions?: TeamDecisionUpdateManyWithoutDepartmentNestedInput
    documents?: DepartmentDocumentUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutMonthlyReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    headId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: DepartmentMemberUncheckedUpdateManyWithoutDepartmentNestedInput
    conversations?: GroupUncheckedUpdateManyWithoutDepartmentNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutDepartmentNestedInput
    eventBroadcasts?: EventDepartmentBroadcastUncheckedUpdateManyWithoutDepartmentNestedInput
    goals?: DepartmentGoalUncheckedUpdateManyWithoutDepartmentNestedInput
    meetings?: DepartmentMeetingUncheckedUpdateManyWithoutDepartmentNestedInput
    polls?: DepartmentPollUncheckedUpdateManyWithoutDepartmentNestedInput
    teamDecisions?: TeamDecisionUncheckedUpdateManyWithoutDepartmentNestedInput
    documents?: DepartmentDocumentUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type UserUpsertWithoutDepartmentMonthlyReportsInput = {
    update: XOR<UserUpdateWithoutDepartmentMonthlyReportsInput, UserUncheckedUpdateWithoutDepartmentMonthlyReportsInput>
    create: XOR<UserCreateWithoutDepartmentMonthlyReportsInput, UserUncheckedCreateWithoutDepartmentMonthlyReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDepartmentMonthlyReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDepartmentMonthlyReportsInput, UserUncheckedUpdateWithoutDepartmentMonthlyReportsInput>
  }

  export type UserUpdateWithoutDepartmentMonthlyReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUpdateManyWithoutUserNestedInput
    userPage?: UserPageUpdateOneWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    postReads?: PostReadUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUpdateManyWithoutSenderNestedInput
    createdMeetings?: DepartmentMeetingUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutDepartmentMonthlyReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUncheckedUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    userPage?: UserPageUncheckedUpdateOneWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    postReads?: PostReadUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUncheckedUpdateManyWithoutSenderNestedInput
    createdMeetings?: DepartmentMeetingUncheckedUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUncheckedUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUncheckedUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUncheckedUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUncheckedUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUncheckedUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUncheckedUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUncheckedUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutPushSubscriptionsInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberCreateNestedManyWithoutUserInput
    userPage?: UserPageCreateNestedOneWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    postReads?: PostReadCreateNestedManyWithoutUserInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteCreateNestedManyWithoutUserInput
    invitations?: UserInvitationCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutPushSubscriptionsInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementUncheckedCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberUncheckedCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    userPage?: UserPageUncheckedCreateNestedOneWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    postReads?: PostReadUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageUncheckedCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingUncheckedCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollUncheckedCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionUncheckedCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteUncheckedCreateNestedManyWithoutUserInput
    invitations?: UserInvitationUncheckedCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskUncheckedCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalUncheckedCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileUncheckedCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementUncheckedCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutPushSubscriptionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPushSubscriptionsInput, UserUncheckedCreateWithoutPushSubscriptionsInput>
  }

  export type UserUpsertWithoutPushSubscriptionsInput = {
    update: XOR<UserUpdateWithoutPushSubscriptionsInput, UserUncheckedUpdateWithoutPushSubscriptionsInput>
    create: XOR<UserCreateWithoutPushSubscriptionsInput, UserUncheckedCreateWithoutPushSubscriptionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPushSubscriptionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPushSubscriptionsInput, UserUncheckedUpdateWithoutPushSubscriptionsInput>
  }

  export type UserUpdateWithoutPushSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUpdateManyWithoutUserNestedInput
    userPage?: UserPageUpdateOneWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    postReads?: PostReadUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutPushSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUncheckedUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    userPage?: UserPageUncheckedUpdateOneWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    postReads?: PostReadUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUncheckedUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUncheckedUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUncheckedUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUncheckedUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUncheckedUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUncheckedUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUncheckedUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUncheckedUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUncheckedUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUncheckedUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutPersonalTasksInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberCreateNestedManyWithoutUserInput
    userPage?: UserPageCreateNestedOneWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    postReads?: PostReadCreateNestedManyWithoutUserInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    invitations?: UserInvitationCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutPersonalTasksInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementUncheckedCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberUncheckedCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    userPage?: UserPageUncheckedCreateNestedOneWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    postReads?: PostReadUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageUncheckedCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingUncheckedCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollUncheckedCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionUncheckedCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitations?: UserInvitationUncheckedCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalUncheckedCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileUncheckedCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementUncheckedCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutPersonalTasksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPersonalTasksInput, UserUncheckedCreateWithoutPersonalTasksInput>
  }

  export type UserUpsertWithoutPersonalTasksInput = {
    update: XOR<UserUpdateWithoutPersonalTasksInput, UserUncheckedUpdateWithoutPersonalTasksInput>
    create: XOR<UserCreateWithoutPersonalTasksInput, UserUncheckedCreateWithoutPersonalTasksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPersonalTasksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPersonalTasksInput, UserUncheckedUpdateWithoutPersonalTasksInput>
  }

  export type UserUpdateWithoutPersonalTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUpdateManyWithoutUserNestedInput
    userPage?: UserPageUpdateOneWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    postReads?: PostReadUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutPersonalTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUncheckedUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    userPage?: UserPageUncheckedUpdateOneWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    postReads?: PostReadUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUncheckedUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUncheckedUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUncheckedUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUncheckedUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUncheckedUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUncheckedUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUncheckedUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUncheckedUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutFinancialGoalsInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberCreateNestedManyWithoutUserInput
    userPage?: UserPageCreateNestedOneWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    postReads?: PostReadCreateNestedManyWithoutUserInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    invitations?: UserInvitationCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutFinancialGoalsInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementUncheckedCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberUncheckedCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    userPage?: UserPageUncheckedCreateNestedOneWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    postReads?: PostReadUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageUncheckedCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingUncheckedCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollUncheckedCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionUncheckedCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitations?: UserInvitationUncheckedCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskUncheckedCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileUncheckedCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementUncheckedCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutFinancialGoalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFinancialGoalsInput, UserUncheckedCreateWithoutFinancialGoalsInput>
  }

  export type UserMonthlyProgressCreateWithoutGoalInput = {
    id?: string
    year: number
    month: number
    amount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserMonthlyProgressUncheckedCreateWithoutGoalInput = {
    id?: string
    year: number
    month: number
    amount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserMonthlyProgressCreateOrConnectWithoutGoalInput = {
    where: UserMonthlyProgressWhereUniqueInput
    create: XOR<UserMonthlyProgressCreateWithoutGoalInput, UserMonthlyProgressUncheckedCreateWithoutGoalInput>
  }

  export type UserMonthlyProgressCreateManyGoalInputEnvelope = {
    data: UserMonthlyProgressCreateManyGoalInput | UserMonthlyProgressCreateManyGoalInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutFinancialGoalsInput = {
    update: XOR<UserUpdateWithoutFinancialGoalsInput, UserUncheckedUpdateWithoutFinancialGoalsInput>
    create: XOR<UserCreateWithoutFinancialGoalsInput, UserUncheckedCreateWithoutFinancialGoalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFinancialGoalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFinancialGoalsInput, UserUncheckedUpdateWithoutFinancialGoalsInput>
  }

  export type UserUpdateWithoutFinancialGoalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUpdateManyWithoutUserNestedInput
    userPage?: UserPageUpdateOneWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    postReads?: PostReadUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutFinancialGoalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUncheckedUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    userPage?: UserPageUncheckedUpdateOneWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    postReads?: PostReadUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUncheckedUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUncheckedUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUncheckedUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUncheckedUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUncheckedUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUncheckedUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUncheckedUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUncheckedUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserMonthlyProgressUpsertWithWhereUniqueWithoutGoalInput = {
    where: UserMonthlyProgressWhereUniqueInput
    update: XOR<UserMonthlyProgressUpdateWithoutGoalInput, UserMonthlyProgressUncheckedUpdateWithoutGoalInput>
    create: XOR<UserMonthlyProgressCreateWithoutGoalInput, UserMonthlyProgressUncheckedCreateWithoutGoalInput>
  }

  export type UserMonthlyProgressUpdateWithWhereUniqueWithoutGoalInput = {
    where: UserMonthlyProgressWhereUniqueInput
    data: XOR<UserMonthlyProgressUpdateWithoutGoalInput, UserMonthlyProgressUncheckedUpdateWithoutGoalInput>
  }

  export type UserMonthlyProgressUpdateManyWithWhereWithoutGoalInput = {
    where: UserMonthlyProgressScalarWhereInput
    data: XOR<UserMonthlyProgressUpdateManyMutationInput, UserMonthlyProgressUncheckedUpdateManyWithoutGoalInput>
  }

  export type UserMonthlyProgressScalarWhereInput = {
    AND?: UserMonthlyProgressScalarWhereInput | UserMonthlyProgressScalarWhereInput[]
    OR?: UserMonthlyProgressScalarWhereInput[]
    NOT?: UserMonthlyProgressScalarWhereInput | UserMonthlyProgressScalarWhereInput[]
    id?: StringFilter<"UserMonthlyProgress"> | string
    goalId?: StringFilter<"UserMonthlyProgress"> | string
    year?: IntFilter<"UserMonthlyProgress"> | number
    month?: IntFilter<"UserMonthlyProgress"> | number
    amount?: FloatFilter<"UserMonthlyProgress"> | number
    notes?: StringNullableFilter<"UserMonthlyProgress"> | string | null
    createdAt?: DateTimeFilter<"UserMonthlyProgress"> | Date | string
    updatedAt?: DateTimeFilter<"UserMonthlyProgress"> | Date | string
  }

  export type UserCreateWithoutFinancialProfileInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberCreateNestedManyWithoutUserInput
    userPage?: UserPageCreateNestedOneWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    postReads?: PostReadCreateNestedManyWithoutUserInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    invitations?: UserInvitationCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalCreateNestedManyWithoutUserInput
    monthlyStatements?: UserMonthlyStatementCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutFinancialProfileInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementUncheckedCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberUncheckedCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    userPage?: UserPageUncheckedCreateNestedOneWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    postReads?: PostReadUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageUncheckedCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingUncheckedCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollUncheckedCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionUncheckedCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitations?: UserInvitationUncheckedCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskUncheckedCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalUncheckedCreateNestedManyWithoutUserInput
    monthlyStatements?: UserMonthlyStatementUncheckedCreateNestedManyWithoutUserInput
    financialEntries?: UserFinancialEntryUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutFinancialProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFinancialProfileInput, UserUncheckedCreateWithoutFinancialProfileInput>
  }

  export type UserUpsertWithoutFinancialProfileInput = {
    update: XOR<UserUpdateWithoutFinancialProfileInput, UserUncheckedUpdateWithoutFinancialProfileInput>
    create: XOR<UserCreateWithoutFinancialProfileInput, UserUncheckedCreateWithoutFinancialProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFinancialProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFinancialProfileInput, UserUncheckedUpdateWithoutFinancialProfileInput>
  }

  export type UserUpdateWithoutFinancialProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUpdateManyWithoutUserNestedInput
    userPage?: UserPageUpdateOneWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    postReads?: PostReadUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUpdateManyWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutFinancialProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUncheckedUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    userPage?: UserPageUncheckedUpdateOneWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    postReads?: PostReadUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUncheckedUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUncheckedUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUncheckedUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUncheckedUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUncheckedUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUncheckedUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUncheckedUpdateManyWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUncheckedUpdateManyWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutMonthlyStatementsInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberCreateNestedManyWithoutUserInput
    userPage?: UserPageCreateNestedOneWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    postReads?: PostReadCreateNestedManyWithoutUserInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    invitations?: UserInvitationCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileCreateNestedOneWithoutUserInput
    financialEntries?: UserFinancialEntryCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutMonthlyStatementsInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementUncheckedCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberUncheckedCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    userPage?: UserPageUncheckedCreateNestedOneWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    postReads?: PostReadUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageUncheckedCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingUncheckedCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollUncheckedCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionUncheckedCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitations?: UserInvitationUncheckedCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskUncheckedCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalUncheckedCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileUncheckedCreateNestedOneWithoutUserInput
    financialEntries?: UserFinancialEntryUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutMonthlyStatementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMonthlyStatementsInput, UserUncheckedCreateWithoutMonthlyStatementsInput>
  }

  export type UserUpsertWithoutMonthlyStatementsInput = {
    update: XOR<UserUpdateWithoutMonthlyStatementsInput, UserUncheckedUpdateWithoutMonthlyStatementsInput>
    create: XOR<UserCreateWithoutMonthlyStatementsInput, UserUncheckedCreateWithoutMonthlyStatementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMonthlyStatementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMonthlyStatementsInput, UserUncheckedUpdateWithoutMonthlyStatementsInput>
  }

  export type UserUpdateWithoutMonthlyStatementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUpdateManyWithoutUserNestedInput
    userPage?: UserPageUpdateOneWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    postReads?: PostReadUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUpdateOneWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutMonthlyStatementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUncheckedUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    userPage?: UserPageUncheckedUpdateOneWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    postReads?: PostReadUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUncheckedUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUncheckedUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUncheckedUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUncheckedUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUncheckedUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUncheckedUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUncheckedUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUncheckedUpdateOneWithoutUserNestedInput
    financialEntries?: UserFinancialEntryUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutFinancialEntriesInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberCreateNestedManyWithoutUserInput
    userPage?: UserPageCreateNestedOneWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    postReads?: PostReadCreateNestedManyWithoutUserInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    invitations?: UserInvitationCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutFinancialEntriesInput = {
    id?: string
    email: string
    name?: string | null
    avatarUrl?: string | null
    password: string
    phone?: string | null
    publicKey: string
    encryptedPrivateKey: string
    otpCode?: string | null
    otpExpiry?: Date | string | null
    isVerified?: boolean
    deviceId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: string | null
    isBanned?: boolean
    isFirstLogin?: boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: Date | string | null
    isOnline?: boolean
    role?: $Enums.UserRole
    canPublishNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAnnouncements?: AnnouncementUncheckedCreateNestedManyWithoutPublisherInput
    deptMemberships?: DepartmentMemberUncheckedCreateNestedManyWithoutUserInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orgMemberships?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    userPage?: UserPageUncheckedCreateNestedOneWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    postReads?: PostReadUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadInput
    taskMessages?: TaskMessageUncheckedCreateNestedManyWithoutSenderInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedCreateNestedManyWithoutUserInput
    createdMeetings?: DepartmentMeetingUncheckedCreateNestedManyWithoutCreatorInput
    createdPolls?: DepartmentPollUncheckedCreateNestedManyWithoutCreatorInput
    createdDecisions?: TeamDecisionUncheckedCreateNestedManyWithoutCreatorInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    decisionVotes?: DecisionVoteUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    invitations?: UserInvitationUncheckedCreateNestedManyWithoutUserInput
    personalTasks?: UserPersonalTaskUncheckedCreateNestedManyWithoutUserInput
    financialGoals?: UserFinancialGoalUncheckedCreateNestedManyWithoutUserInput
    financialProfile?: UserFinancialProfileUncheckedCreateNestedOneWithoutUserInput
    monthlyStatements?: UserMonthlyStatementUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedCreateNestedManyWithoutUploaderInput
    groupNotes?: GroupNoteUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutFinancialEntriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFinancialEntriesInput, UserUncheckedCreateWithoutFinancialEntriesInput>
  }

  export type UserUpsertWithoutFinancialEntriesInput = {
    update: XOR<UserUpdateWithoutFinancialEntriesInput, UserUncheckedUpdateWithoutFinancialEntriesInput>
    create: XOR<UserCreateWithoutFinancialEntriesInput, UserUncheckedCreateWithoutFinancialEntriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFinancialEntriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFinancialEntriesInput, UserUncheckedUpdateWithoutFinancialEntriesInput>
  }

  export type UserUpdateWithoutFinancialEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUpdateManyWithoutUserNestedInput
    userPage?: UserPageUpdateOneWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    postReads?: PostReadUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutFinancialEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: StringFieldUpdateOperationsInput | string
    encryptedPrivateKey?: StringFieldUpdateOperationsInput | string
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    allowedCountry?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    canPublishNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAnnouncements?: AnnouncementUncheckedUpdateManyWithoutPublisherNestedInput
    deptMemberships?: DepartmentMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orgMemberships?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    userPage?: UserPageUncheckedUpdateOneWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    postReads?: PostReadUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadNestedInput
    taskMessages?: TaskMessageUncheckedUpdateManyWithoutSenderNestedInput
    departmentMonthlyReports?: DepartmentMonthlyReportUncheckedUpdateManyWithoutUserNestedInput
    createdMeetings?: DepartmentMeetingUncheckedUpdateManyWithoutCreatorNestedInput
    createdPolls?: DepartmentPollUncheckedUpdateManyWithoutCreatorNestedInput
    createdDecisions?: TeamDecisionUncheckedUpdateManyWithoutCreatorNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    decisionVotes?: DecisionVoteUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUncheckedUpdateManyWithoutUserNestedInput
    personalTasks?: UserPersonalTaskUncheckedUpdateManyWithoutUserNestedInput
    financialGoals?: UserFinancialGoalUncheckedUpdateManyWithoutUserNestedInput
    financialProfile?: UserFinancialProfileUncheckedUpdateOneWithoutUserNestedInput
    monthlyStatements?: UserMonthlyStatementUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    uploadedDepartmentDocuments?: DepartmentDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    groupNotes?: GroupNoteUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserFinancialGoalCreateWithoutProgressInput = {
    id?: string
    type?: $Enums.FinancialGoalType
    year?: number | null
    targetItem?: string | null
    targetAmount: number
    targetDate?: Date | string | null
    label?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutFinancialGoalsInput
  }

  export type UserFinancialGoalUncheckedCreateWithoutProgressInput = {
    id?: string
    userId: string
    type?: $Enums.FinancialGoalType
    year?: number | null
    targetItem?: string | null
    targetAmount: number
    targetDate?: Date | string | null
    label?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserFinancialGoalCreateOrConnectWithoutProgressInput = {
    where: UserFinancialGoalWhereUniqueInput
    create: XOR<UserFinancialGoalCreateWithoutProgressInput, UserFinancialGoalUncheckedCreateWithoutProgressInput>
  }

  export type UserFinancialGoalUpsertWithoutProgressInput = {
    update: XOR<UserFinancialGoalUpdateWithoutProgressInput, UserFinancialGoalUncheckedUpdateWithoutProgressInput>
    create: XOR<UserFinancialGoalCreateWithoutProgressInput, UserFinancialGoalUncheckedCreateWithoutProgressInput>
    where?: UserFinancialGoalWhereInput
  }

  export type UserFinancialGoalUpdateToOneWithWhereWithoutProgressInput = {
    where?: UserFinancialGoalWhereInput
    data: XOR<UserFinancialGoalUpdateWithoutProgressInput, UserFinancialGoalUncheckedUpdateWithoutProgressInput>
  }

  export type UserFinancialGoalUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFinancialGoalTypeFieldUpdateOperationsInput | $Enums.FinancialGoalType
    year?: NullableIntFieldUpdateOperationsInput | number | null
    targetItem?: NullableStringFieldUpdateOperationsInput | string | null
    targetAmount?: FloatFieldUpdateOperationsInput | number
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFinancialGoalsNestedInput
  }

  export type UserFinancialGoalUncheckedUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumFinancialGoalTypeFieldUpdateOperationsInput | $Enums.FinancialGoalType
    year?: NullableIntFieldUpdateOperationsInput | number | null
    targetItem?: NullableStringFieldUpdateOperationsInput | string | null
    targetAmount?: FloatFieldUpdateOperationsInput | number
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementCreateManyPublisherInput = {
    id?: string
    title: string
    content: string
    expiresAt: Date | string
    createdAt?: Date | string
    isActive?: boolean
  }

  export type DepartmentMemberCreateManyUserInput = {
    id?: string
    deptId: string
    encryptedDeptKey: string
  }

  export type GroupMemberCreateManyUserInput = {
    id?: string
    groupId: string
    joinedAt?: Date | string
    lastReadAt?: Date | string
  }

  export type MessageCreateManySenderInput = {
    id?: string
    content: string
    groupId: string
    isEdited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    content: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    isRead?: boolean
  }

  export type OrganizationMemberCreateManyUserInput = {
    id?: string
    orgId: string
    role?: $Enums.OrgRole
    joinedAt?: Date | string
  }

  export type LikeCreateManyUserInput = {
    id?: string
    postId: string
    createdAt?: Date | string
  }

  export type CommentCreateManyUserInput = {
    id?: string
    postId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
  }

  export type PostReadCreateManyUserInput = {
    id?: string
    postId: string
    readAt?: Date | string
  }

  export type TaskCreateManyAssigneeInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.TaskPriority
    startDate?: Date | string | null
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deptId: string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateManyCreatorInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.TaskPriority
    startDate?: Date | string | null
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deptId: string
    assigneeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentCreateManyHeadInput = {
    id?: string
    name: string
    orgId: string
    publicKey: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskMessageCreateManySenderInput = {
    id?: string
    taskId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentMonthlyReportCreateManyUserInput = {
    id?: string
    deptId: string
    month: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentMeetingCreateManyCreatorInput = {
    id?: string
    deptId: string
    title: string
    description?: string | null
    agenda?: string | null
    meetingDate: Date | string
    location?: string | null
    minutes?: string | null
    minutesAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentPollCreateManyCreatorInput = {
    id?: string
    deptId: string
    question: string
    options: JsonNullValueInput | InputJsonValue
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamDecisionCreateManyCreatorInput = {
    id?: string
    deptId: string
    title: string
    description?: string | null
    voteDeadline?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PollVoteCreateManyUserInput = {
    id?: string
    pollId: string
    optionIndex: number
    createdAt?: Date | string
  }

  export type DecisionVoteCreateManyUserInput = {
    id?: string
    decisionId: string
    vote: $Enums.DecisionVoteType
    createdAt?: Date | string
  }

  export type PushSubscriptionCreateManyUserInput = {
    id?: string
    endpoint: string
    p256dh: string
    auth: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserInvitationCreateManyUserInput = {
    id?: string
    token: string
    status?: $Enums.InvitationStatus
    title: string
    description?: string | null
    imageBase64?: string | null
    type?: $Enums.InvitationType
    date: Date | string
    location: string
    maxGuests?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPersonalTaskCreateManyUserInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.PersonalTaskStatus
    priority?: $Enums.PersonalTaskPriority
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserFinancialGoalCreateManyUserInput = {
    id?: string
    type?: $Enums.FinancialGoalType
    year?: number | null
    targetItem?: string | null
    targetAmount: number
    targetDate?: Date | string | null
    label?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserMonthlyStatementCreateManyUserInput = {
    id?: string
    year: number
    month: number
    salaryReceived?: number
    supplementaryIncome?: number
    totalExpenses?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserFinancialEntryCreateManyUserInput = {
    id?: string
    year: number
    month: number
    type: $Enums.FinancialEntryType
    amount: number
    note?: string | null
    isConfirmed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FollowCreateManyFollowingInput = {
    id?: string
    followerId: string
    createdAt?: Date | string
  }

  export type FollowCreateManyFollowerInput = {
    id?: string
    followingId: string
    createdAt?: Date | string
  }

  export type DepartmentDocumentCreateManyUploaderInput = {
    id?: string
    deptId: string
    filename: string
    type: $Enums.FileType
    data: string
    createdAt?: Date | string
  }

  export type GroupNoteCreateManyCreatorInput = {
    id?: string
    documentId: string
    title: string
    content: string
    textSize?: $Enums.NoteTextSize
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnouncementUpdateWithoutPublisherInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    reads?: AnnouncementReadUpdateManyWithoutAnnouncementNestedInput
  }

  export type AnnouncementUncheckedUpdateWithoutPublisherInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    reads?: AnnouncementReadUncheckedUpdateManyWithoutAnnouncementNestedInput
  }

  export type AnnouncementUncheckedUpdateManyWithoutPublisherInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DepartmentMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    encryptedDeptKey?: StringFieldUpdateOperationsInput | string
    department?: DepartmentUpdateOneRequiredWithoutMembersNestedInput
  }

  export type DepartmentMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    deptId?: StringFieldUpdateOperationsInput | string
    encryptedDeptKey?: StringFieldUpdateOperationsInput | string
  }

  export type DepartmentMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    deptId?: StringFieldUpdateOperationsInput | string
    encryptedDeptKey?: StringFieldUpdateOperationsInput | string
  }

  export type GroupMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReadAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: GroupUpdateOneRequiredWithoutMembersNestedInput
  }

  export type GroupMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReadAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReadAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: AttachmentUpdateManyWithoutMessageNestedInput
    group?: GroupUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: AttachmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OrganizationMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumOrgRoleFieldUpdateOperationsInput | $Enums.OrgRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutMembersNestedInput
  }

  export type OrganizationMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    role?: EnumOrgRoleFieldUpdateOperationsInput | $Enums.OrgRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    role?: EnumOrgRoleFieldUpdateOperationsInput | $Enums.OrgRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutLikesNestedInput
  }

  export type LikeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostReadUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutPostReadsNestedInput
  }

  export type PostReadUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostReadUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneRequiredWithoutTasksNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedTasksNestedInput
    messages?: TaskMessageUpdateManyWithoutTaskNestedInput
    attachments?: TaskAttachmentUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deptId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: TaskMessageUncheckedUpdateManyWithoutTaskNestedInput
    attachments?: TaskAttachmentUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deptId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneRequiredWithoutTasksNestedInput
    assignee?: UserUpdateOneRequiredWithoutAssignedTasksNestedInput
    messages?: TaskMessageUpdateManyWithoutTaskNestedInput
    attachments?: TaskAttachmentUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deptId?: StringFieldUpdateOperationsInput | string
    assigneeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: TaskMessageUncheckedUpdateManyWithoutTaskNestedInput
    attachments?: TaskAttachmentUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deptId?: StringFieldUpdateOperationsInput | string
    assigneeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUpdateWithoutHeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutDepartmentsNestedInput
    members?: DepartmentMemberUpdateManyWithoutDepartmentNestedInput
    conversations?: GroupUpdateManyWithoutDepartmentNestedInput
    tasks?: TaskUpdateManyWithoutDepartmentNestedInput
    eventBroadcasts?: EventDepartmentBroadcastUpdateManyWithoutDepartmentNestedInput
    monthlyReports?: DepartmentMonthlyReportUpdateManyWithoutDepartmentNestedInput
    goals?: DepartmentGoalUpdateManyWithoutDepartmentNestedInput
    meetings?: DepartmentMeetingUpdateManyWithoutDepartmentNestedInput
    polls?: DepartmentPollUpdateManyWithoutDepartmentNestedInput
    teamDecisions?: TeamDecisionUpdateManyWithoutDepartmentNestedInput
    documents?: DepartmentDocumentUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutHeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: DepartmentMemberUncheckedUpdateManyWithoutDepartmentNestedInput
    conversations?: GroupUncheckedUpdateManyWithoutDepartmentNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutDepartmentNestedInput
    eventBroadcasts?: EventDepartmentBroadcastUncheckedUpdateManyWithoutDepartmentNestedInput
    monthlyReports?: DepartmentMonthlyReportUncheckedUpdateManyWithoutDepartmentNestedInput
    goals?: DepartmentGoalUncheckedUpdateManyWithoutDepartmentNestedInput
    meetings?: DepartmentMeetingUncheckedUpdateManyWithoutDepartmentNestedInput
    polls?: DepartmentPollUncheckedUpdateManyWithoutDepartmentNestedInput
    teamDecisions?: TeamDecisionUncheckedUpdateManyWithoutDepartmentNestedInput
    documents?: DepartmentDocumentUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateManyWithoutHeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskMessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutMessagesNestedInput
    attachments?: TaskAttachmentUpdateManyWithoutMessageNestedInput
  }

  export type TaskMessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: TaskAttachmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type TaskMessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentMonthlyReportUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneRequiredWithoutMonthlyReportsNestedInput
  }

  export type DepartmentMonthlyReportUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    deptId?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentMonthlyReportUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    deptId?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentMeetingUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    meetingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    minutes?: NullableStringFieldUpdateOperationsInput | string | null
    minutesAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneRequiredWithoutMeetingsNestedInput
  }

  export type DepartmentMeetingUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    deptId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    meetingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    minutes?: NullableStringFieldUpdateOperationsInput | string | null
    minutesAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentMeetingUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    deptId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    meetingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    minutes?: NullableStringFieldUpdateOperationsInput | string | null
    minutesAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentPollUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneRequiredWithoutPollsNestedInput
    votes?: PollVoteUpdateManyWithoutPollNestedInput
  }

  export type DepartmentPollUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    deptId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: PollVoteUncheckedUpdateManyWithoutPollNestedInput
  }

  export type DepartmentPollUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    deptId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamDecisionUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    voteDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneRequiredWithoutTeamDecisionsNestedInput
    votes?: DecisionVoteUpdateManyWithoutDecisionNestedInput
  }

  export type TeamDecisionUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    deptId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    voteDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: DecisionVoteUncheckedUpdateManyWithoutDecisionNestedInput
  }

  export type TeamDecisionUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    deptId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    voteDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PollVoteUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    optionIndex?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    poll?: DepartmentPollUpdateOneRequiredWithoutVotesNestedInput
  }

  export type PollVoteUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    pollId?: StringFieldUpdateOperationsInput | string
    optionIndex?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PollVoteUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    pollId?: StringFieldUpdateOperationsInput | string
    optionIndex?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DecisionVoteUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    vote?: EnumDecisionVoteTypeFieldUpdateOperationsInput | $Enums.DecisionVoteType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    decision?: TeamDecisionUpdateOneRequiredWithoutVotesNestedInput
  }

  export type DecisionVoteUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    decisionId?: StringFieldUpdateOperationsInput | string
    vote?: EnumDecisionVoteTypeFieldUpdateOperationsInput | $Enums.DecisionVoteType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DecisionVoteUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    decisionId?: StringFieldUpdateOperationsInput | string
    vote?: EnumDecisionVoteTypeFieldUpdateOperationsInput | $Enums.DecisionVoteType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dh?: StringFieldUpdateOperationsInput | string
    auth?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dh?: StringFieldUpdateOperationsInput | string
    auth?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dh?: StringFieldUpdateOperationsInput | string
    auth?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInvitationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageBase64?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInvitationTypeFieldUpdateOperationsInput | $Enums.InvitationType
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guests?: InvitationGuestUpdateManyWithoutInvitationNestedInput
  }

  export type UserInvitationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageBase64?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInvitationTypeFieldUpdateOperationsInput | $Enums.InvitationType
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guests?: InvitationGuestUncheckedUpdateManyWithoutInvitationNestedInput
  }

  export type UserInvitationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageBase64?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInvitationTypeFieldUpdateOperationsInput | $Enums.InvitationType
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPersonalTaskUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPersonalTaskStatusFieldUpdateOperationsInput | $Enums.PersonalTaskStatus
    priority?: EnumPersonalTaskPriorityFieldUpdateOperationsInput | $Enums.PersonalTaskPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPersonalTaskUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPersonalTaskStatusFieldUpdateOperationsInput | $Enums.PersonalTaskStatus
    priority?: EnumPersonalTaskPriorityFieldUpdateOperationsInput | $Enums.PersonalTaskPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPersonalTaskUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPersonalTaskStatusFieldUpdateOperationsInput | $Enums.PersonalTaskStatus
    priority?: EnumPersonalTaskPriorityFieldUpdateOperationsInput | $Enums.PersonalTaskPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFinancialGoalUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFinancialGoalTypeFieldUpdateOperationsInput | $Enums.FinancialGoalType
    year?: NullableIntFieldUpdateOperationsInput | number | null
    targetItem?: NullableStringFieldUpdateOperationsInput | string | null
    targetAmount?: FloatFieldUpdateOperationsInput | number
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: UserMonthlyProgressUpdateManyWithoutGoalNestedInput
  }

  export type UserFinancialGoalUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFinancialGoalTypeFieldUpdateOperationsInput | $Enums.FinancialGoalType
    year?: NullableIntFieldUpdateOperationsInput | number | null
    targetItem?: NullableStringFieldUpdateOperationsInput | string | null
    targetAmount?: FloatFieldUpdateOperationsInput | number
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: UserMonthlyProgressUncheckedUpdateManyWithoutGoalNestedInput
  }

  export type UserFinancialGoalUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFinancialGoalTypeFieldUpdateOperationsInput | $Enums.FinancialGoalType
    year?: NullableIntFieldUpdateOperationsInput | number | null
    targetItem?: NullableStringFieldUpdateOperationsInput | string | null
    targetAmount?: FloatFieldUpdateOperationsInput | number
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserMonthlyStatementUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    salaryReceived?: FloatFieldUpdateOperationsInput | number
    supplementaryIncome?: FloatFieldUpdateOperationsInput | number
    totalExpenses?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserMonthlyStatementUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    salaryReceived?: FloatFieldUpdateOperationsInput | number
    supplementaryIncome?: FloatFieldUpdateOperationsInput | number
    totalExpenses?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserMonthlyStatementUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    salaryReceived?: FloatFieldUpdateOperationsInput | number
    supplementaryIncome?: FloatFieldUpdateOperationsInput | number
    totalExpenses?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFinancialEntryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    type?: EnumFinancialEntryTypeFieldUpdateOperationsInput | $Enums.FinancialEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFinancialEntryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    type?: EnumFinancialEntryTypeFieldUpdateOperationsInput | $Enums.FinancialEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFinancialEntryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    type?: EnumFinancialEntryTypeFieldUpdateOperationsInput | $Enums.FinancialEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isConfirmed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    follower?: UserUpdateOneRequiredWithoutFollowingNestedInput
  }

  export type FollowUncheckedUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUncheckedUpdateManyWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUpdateWithoutFollowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    following?: UserUpdateOneRequiredWithoutFollowersNestedInput
  }

  export type FollowUncheckedUpdateWithoutFollowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    followingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUncheckedUpdateManyWithoutFollowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    followingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentDocumentUpdateWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    data?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type DepartmentDocumentUncheckedUpdateWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    deptId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    data?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentDocumentUncheckedUpdateManyWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    deptId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    data?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupNoteUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    textSize?: EnumNoteTextSizeFieldUpdateOperationsInput | $Enums.NoteTextSize
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: GroupDocumentUpdateOneRequiredWithoutNotesNestedInput
  }

  export type GroupNoteUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    textSize?: EnumNoteTextSizeFieldUpdateOperationsInput | $Enums.NoteTextSize
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupNoteUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    textSize?: EnumNoteTextSizeFieldUpdateOperationsInput | $Enums.NoteTextSize
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationGuestCreateManyInvitationInput = {
    id?: string
    name: string
    phone: string
    confirmedAt?: Date | string
  }

  export type InvitationGuestUpdateWithoutInvitationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    confirmedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationGuestUncheckedUpdateWithoutInvitationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    confirmedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationGuestUncheckedUpdateManyWithoutInvitationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    confirmedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentCreateManyOrganizationInput = {
    id?: string
    name: string
    publicKey: string
    headId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationMemberCreateManyOrganizationInput = {
    id?: string
    userId: string
    role?: $Enums.OrgRole
    joinedAt?: Date | string
  }

  export type EventInvitationCreateManyOrganizationInput = {
    id?: string
    title: string
    description?: string | null
    eventType?: $Enums.EventType
    eventDate: Date | string
    maxAttendees: number
    imageUrl?: string | null
    token: string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    head?: UserUpdateOneWithoutHeadedDepartmentsNestedInput
    members?: DepartmentMemberUpdateManyWithoutDepartmentNestedInput
    conversations?: GroupUpdateManyWithoutDepartmentNestedInput
    tasks?: TaskUpdateManyWithoutDepartmentNestedInput
    eventBroadcasts?: EventDepartmentBroadcastUpdateManyWithoutDepartmentNestedInput
    monthlyReports?: DepartmentMonthlyReportUpdateManyWithoutDepartmentNestedInput
    goals?: DepartmentGoalUpdateManyWithoutDepartmentNestedInput
    meetings?: DepartmentMeetingUpdateManyWithoutDepartmentNestedInput
    polls?: DepartmentPollUpdateManyWithoutDepartmentNestedInput
    teamDecisions?: TeamDecisionUpdateManyWithoutDepartmentNestedInput
    documents?: DepartmentDocumentUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    headId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: DepartmentMemberUncheckedUpdateManyWithoutDepartmentNestedInput
    conversations?: GroupUncheckedUpdateManyWithoutDepartmentNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutDepartmentNestedInput
    eventBroadcasts?: EventDepartmentBroadcastUncheckedUpdateManyWithoutDepartmentNestedInput
    monthlyReports?: DepartmentMonthlyReportUncheckedUpdateManyWithoutDepartmentNestedInput
    goals?: DepartmentGoalUncheckedUpdateManyWithoutDepartmentNestedInput
    meetings?: DepartmentMeetingUncheckedUpdateManyWithoutDepartmentNestedInput
    polls?: DepartmentPollUncheckedUpdateManyWithoutDepartmentNestedInput
    teamDecisions?: TeamDecisionUncheckedUpdateManyWithoutDepartmentNestedInput
    documents?: DepartmentDocumentUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    headId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationMemberUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumOrgRoleFieldUpdateOperationsInput | $Enums.OrgRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrgMembershipsNestedInput
  }

  export type OrganizationMemberUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumOrgRoleFieldUpdateOperationsInput | $Enums.OrgRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationMemberUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumOrgRoleFieldUpdateOperationsInput | $Enums.OrgRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventInvitationUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAttendees?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rsvps?: InvitationRSVPUpdateManyWithoutEventNestedInput
    departmentBroadcasts?: EventDepartmentBroadcastUpdateManyWithoutEventNestedInput
  }

  export type EventInvitationUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAttendees?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rsvps?: InvitationRSVPUncheckedUpdateManyWithoutEventNestedInput
    departmentBroadcasts?: EventDepartmentBroadcastUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventInvitationUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxAttendees?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentMemberCreateManyDepartmentInput = {
    id?: string
    userId: string
    encryptedDeptKey: string
  }

  export type GroupCreateManyDepartmentInput = {
    id?: string
    name?: string | null
    isDirect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateManyDepartmentInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.TaskPriority
    startDate?: Date | string | null
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    creatorId: string
    assigneeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventDepartmentBroadcastCreateManyDepartmentInput = {
    id?: string
    eventId: string
    createdAt?: Date | string
  }

  export type DepartmentMonthlyReportCreateManyDepartmentInput = {
    id?: string
    userId: string
    month: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentGoalCreateManyDepartmentInput = {
    id?: string
    title: string
    description?: string | null
    targetValue?: number | null
    currentValue?: number
    period: string
    periodKey: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentMeetingCreateManyDepartmentInput = {
    id?: string
    title: string
    description?: string | null
    agenda?: string | null
    meetingDate: Date | string
    location?: string | null
    createdBy: string
    minutes?: string | null
    minutesAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentPollCreateManyDepartmentInput = {
    id?: string
    question: string
    options: JsonNullValueInput | InputJsonValue
    endDate?: Date | string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamDecisionCreateManyDepartmentInput = {
    id?: string
    title: string
    description?: string | null
    voteDeadline?: Date | string | null
    status?: string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentDocumentCreateManyDepartmentInput = {
    id?: string
    filename: string
    type: $Enums.FileType
    data: string
    uploadedBy: string
    createdAt?: Date | string
  }

  export type DepartmentMemberUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    encryptedDeptKey?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutDeptMembershipsNestedInput
  }

  export type DepartmentMemberUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    encryptedDeptKey?: StringFieldUpdateOperationsInput | string
  }

  export type DepartmentMemberUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    encryptedDeptKey?: StringFieldUpdateOperationsInput | string
  }

  export type GroupUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isDirect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: GroupMemberUpdateManyWithoutGroupNestedInput
    messages?: MessageUpdateManyWithoutGroupNestedInput
    documents?: GroupDocumentUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isDirect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: GroupMemberUncheckedUpdateManyWithoutGroupNestedInput
    messages?: MessageUncheckedUpdateManyWithoutGroupNestedInput
    documents?: GroupDocumentUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isDirect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedTasksNestedInput
    assignee?: UserUpdateOneRequiredWithoutAssignedTasksNestedInput
    messages?: TaskMessageUpdateManyWithoutTaskNestedInput
    attachments?: TaskAttachmentUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    assigneeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: TaskMessageUncheckedUpdateManyWithoutTaskNestedInput
    attachments?: TaskAttachmentUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    assigneeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventDepartmentBroadcastUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventInvitationUpdateOneRequiredWithoutDepartmentBroadcastsNestedInput
  }

  export type EventDepartmentBroadcastUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventDepartmentBroadcastUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentMonthlyReportUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDepartmentMonthlyReportsNestedInput
  }

  export type DepartmentMonthlyReportUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentMonthlyReportUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentGoalUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    period?: StringFieldUpdateOperationsInput | string
    periodKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentGoalUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    period?: StringFieldUpdateOperationsInput | string
    periodKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentGoalUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    period?: StringFieldUpdateOperationsInput | string
    periodKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentMeetingUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    meetingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    minutes?: NullableStringFieldUpdateOperationsInput | string | null
    minutesAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedMeetingsNestedInput
  }

  export type DepartmentMeetingUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    meetingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    minutes?: NullableStringFieldUpdateOperationsInput | string | null
    minutesAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentMeetingUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    meetingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    minutes?: NullableStringFieldUpdateOperationsInput | string | null
    minutesAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentPollUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedPollsNestedInput
    votes?: PollVoteUpdateManyWithoutPollNestedInput
  }

  export type DepartmentPollUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: PollVoteUncheckedUpdateManyWithoutPollNestedInput
  }

  export type DepartmentPollUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamDecisionUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    voteDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedDecisionsNestedInput
    votes?: DecisionVoteUpdateManyWithoutDecisionNestedInput
  }

  export type TeamDecisionUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    voteDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: DecisionVoteUncheckedUpdateManyWithoutDecisionNestedInput
  }

  export type TeamDecisionUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    voteDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentDocumentUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    data?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploader?: UserUpdateOneRequiredWithoutUploadedDepartmentDocumentsNestedInput
  }

  export type DepartmentDocumentUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    data?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentDocumentUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    data?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PollVoteCreateManyPollInput = {
    id?: string
    userId: string
    optionIndex: number
    createdAt?: Date | string
  }

  export type PollVoteUpdateWithoutPollInput = {
    id?: StringFieldUpdateOperationsInput | string
    optionIndex?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPollVotesNestedInput
  }

  export type PollVoteUncheckedUpdateWithoutPollInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    optionIndex?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PollVoteUncheckedUpdateManyWithoutPollInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    optionIndex?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DecisionVoteCreateManyDecisionInput = {
    id?: string
    userId: string
    vote: $Enums.DecisionVoteType
    createdAt?: Date | string
  }

  export type DecisionVoteUpdateWithoutDecisionInput = {
    id?: StringFieldUpdateOperationsInput | string
    vote?: EnumDecisionVoteTypeFieldUpdateOperationsInput | $Enums.DecisionVoteType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDecisionVotesNestedInput
  }

  export type DecisionVoteUncheckedUpdateWithoutDecisionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vote?: EnumDecisionVoteTypeFieldUpdateOperationsInput | $Enums.DecisionVoteType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DecisionVoteUncheckedUpdateManyWithoutDecisionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vote?: EnumDecisionVoteTypeFieldUpdateOperationsInput | $Enums.DecisionVoteType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberCreateManyGroupInput = {
    id?: string
    userId: string
    joinedAt?: Date | string
    lastReadAt?: Date | string
  }

  export type MessageCreateManyGroupInput = {
    id?: string
    content: string
    senderId: string
    isEdited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupDocumentCreateManyGroupInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupMemberUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReadAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGroupMembershipsNestedInput
  }

  export type GroupMemberUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReadAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReadAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: AttachmentUpdateManyWithoutMessageNestedInput
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: AttachmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupDocumentUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: GroupNoteUpdateManyWithoutDocumentNestedInput
  }

  export type GroupDocumentUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: GroupNoteUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type GroupDocumentUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupNoteCreateManyDocumentInput = {
    id?: string
    title: string
    content: string
    textSize?: $Enums.NoteTextSize
    order?: number
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupNoteUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    textSize?: EnumNoteTextSizeFieldUpdateOperationsInput | $Enums.NoteTextSize
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutGroupNotesNestedInput
  }

  export type GroupNoteUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    textSize?: EnumNoteTextSizeFieldUpdateOperationsInput | $Enums.NoteTextSize
    order?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupNoteUncheckedUpdateManyWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    textSize?: EnumNoteTextSizeFieldUpdateOperationsInput | $Enums.NoteTextSize
    order?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentCreateManyMessageInput = {
    id?: string
    type: $Enums.FileType
    filename: string
    data: string
    createdAt?: Date | string
  }

  export type AttachmentUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    filename?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    filename?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    filename?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementReadCreateManyAnnouncementInput = {
    id?: string
    userId: string
    readAt?: Date | string
  }

  export type AnnouncementReadUpdateWithoutAnnouncementInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementReadUncheckedUpdateWithoutAnnouncementInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementReadUncheckedUpdateManyWithoutAnnouncementInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationRSVPCreateManyEventInput = {
    id?: string
    name: string
    phone: string
    createdAt?: Date | string
  }

  export type EventDepartmentBroadcastCreateManyEventInput = {
    id?: string
    deptId: string
    createdAt?: Date | string
  }

  export type InvitationRSVPUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationRSVPUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationRSVPUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventDepartmentBroadcastUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneRequiredWithoutEventBroadcastsNestedInput
  }

  export type EventDepartmentBroadcastUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    deptId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventDepartmentBroadcastUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    deptId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCreateManyPageInput = {
    id?: string
    type: $Enums.PostType
    content: string
    imageUrl?: string | null
    caption?: string | null
    reference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostUpdateWithoutPageInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: LikeUpdateManyWithoutPostNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    postReads?: PostReadUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutPageInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: LikeUncheckedUpdateManyWithoutPostNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    postReads?: PostReadUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutPageInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeCreateManyPostInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type CommentCreateManyPostInput = {
    id?: string
    userId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
  }

  export type PostReadCreateManyPostInput = {
    id?: string
    userId: string
    readAt?: Date | string
  }

  export type LikeUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLikesNestedInput
  }

  export type LikeUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostReadUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPostReadsNestedInput
  }

  export type PostReadUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostReadUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyParentInput = {
    id?: string
    postId: string
    userId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    replies?: CommentUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskMessageCreateManyTaskInput = {
    id?: string
    senderId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskAttachmentCreateManyTaskInput = {
    id?: string
    messageId?: string | null
    uploaderId: string
    filename: string
    url: string
    fileType?: string | null
    size?: number | null
    createdAt?: Date | string
  }

  export type TaskMessageUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutTaskMessagesNestedInput
    attachments?: TaskAttachmentUpdateManyWithoutMessageNestedInput
  }

  export type TaskMessageUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: TaskAttachmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type TaskMessageUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAttachmentUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploaderId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: TaskMessageUpdateOneWithoutAttachmentsNestedInput
  }

  export type TaskAttachmentUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    uploaderId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAttachmentUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    uploaderId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAttachmentCreateManyMessageInput = {
    id?: string
    taskId: string
    uploaderId: string
    filename: string
    url: string
    fileType?: string | null
    size?: number | null
    createdAt?: Date | string
  }

  export type TaskAttachmentUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploaderId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type TaskAttachmentUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    uploaderId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAttachmentUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    uploaderId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserMonthlyProgressCreateManyGoalInput = {
    id?: string
    year: number
    month: number
    amount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserMonthlyProgressUpdateWithoutGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserMonthlyProgressUncheckedUpdateWithoutGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserMonthlyProgressUncheckedUpdateManyWithoutGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}